[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "ideas"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Boolean",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Boolean",
          "package": "ideas",
          "partial": "Boolean",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "And",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#And",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "And",
          "package": "ideas",
          "partial": "And",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#t:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "BoolValue",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#BoolValue",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "BoolValue",
          "package": "ideas",
          "partial": "Bool Value",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#t:BoolValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Boolean",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#Boolean",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Boolean",
          "package": "ideas",
          "partial": "Boolean",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#t:Boolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "CoBoolean",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#CoBoolean",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "CoBoolean",
          "package": "ideas",
          "partial": "Co Boolean",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#t:CoBoolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "DualMonoid",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#DualMonoid",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "DualMonoid",
          "package": "ideas",
          "partial": "Dual Monoid",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#t:DualMonoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Or",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#Or",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Or",
          "package": "ideas",
          "partial": "Or",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#t:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "(\u003c||\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#%3C%7C%7C%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "(\u003c||\u003e) \u003c||\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:-60--124--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "(\u003c&&\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#%3C%26%26%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "(\u003c&&\u003e) \u003c&&\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:-60--38--38--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "(\u003e\u003c)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#%3E%3C",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "(\u003e\u003c) \u003e\u003c",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:-62--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "And",
          "package": "ideas",
          "signature": "And",
          "source": "src/Ideas-Common-Algebra-Boolean.html#And",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "And",
          "package": "ideas",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Or",
          "package": "ideas",
          "signature": "Or",
          "source": "src/Ideas-Common-Algebra-Boolean.html#Or",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "Or",
          "package": "ideas",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Algebra.Boolean\",\"Ideas.Common.Predicate\"]",
          "name": "ands",
          "package": "ideas",
          "signature": "[a] -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#ands",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:ands\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:ands\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "ands",
          "normalized": "[a]-\u003ea",
          "package": "ideas",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:ands"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "complement",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#complement",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "complement",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "conjunctions",
          "package": "ideas",
          "signature": "a -\u003e [a]",
          "source": "src/Ideas-Common-Algebra-Boolean.html#conjunctions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "conjunctions",
          "normalized": "a-\u003e[a]",
          "package": "ideas",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:conjunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "disjunctions",
          "package": "ideas",
          "signature": "a -\u003e [a]",
          "source": "src/Ideas-Common-Algebra-Boolean.html#disjunctions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "disjunctions",
          "normalized": "a-\u003e[a]",
          "package": "ideas",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:disjunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "dualCompl",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#dualCompl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "dualCompl",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "partial": "Compl",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:dualCompl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Algebra.Boolean\",\"Ideas.Common.Predicate\"]",
          "name": "equivalent",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#equivalent",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:equivalent\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:equivalent\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "equivalent",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:equivalent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "false",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#false",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "false",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:false"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "fromAnd",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#And",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "fromAnd",
          "package": "ideas",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:fromAnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "fromBool",
          "package": "ideas",
          "signature": "Bool -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#fromBool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "fromBool",
          "normalized": "Bool-\u003ea",
          "package": "ideas",
          "partial": "Bool",
          "signature": "Bool-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:fromBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "fromOr",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#Or",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "fromOr",
          "package": "ideas",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:fromOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Algebra.Boolean\",\"Ideas.Common.Predicate\"]",
          "name": "implies",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#implies",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:implies\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:implies\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "implies",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:implies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isAnd",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Boolean.html#isAnd",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isAnd",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "And",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:isAnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isComplement",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#isComplement",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isComplement",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "partial": "Complement",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:isComplement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isFalse",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Boolean.html#isFalse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isFalse",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "False",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:isFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isOr",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Boolean.html#isOr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isOr",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Or",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:isOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isTrue",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Boolean.html#isTrue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "isTrue",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "True",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:isTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Algebra.Boolean\",\"Ideas.Common.Predicate\"]",
          "name": "ors",
          "package": "ideas",
          "signature": "[a] -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#ors",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:ors\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:ors\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "ors",
          "normalized": "[a]-\u003ea",
          "package": "ideas",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:ors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "true",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#true",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Boolean",
          "module": "Ideas.Common.Algebra.Boolean",
          "name": "true",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Boolean.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "BooleanLaws",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "BooleanLaws",
          "package": "ideas",
          "partial": "Boolean Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "absorptionAndLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#absorptionAndLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "absorptionAndLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "And Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:absorptionAndLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "absorptionOrLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#absorptionOrLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "absorptionOrLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Or Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:absorptionOrLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "andOverOrLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#andOverOrLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "andOverOrLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Over Or Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:andOverOrLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "booleanLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#booleanLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "booleanLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:booleanLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementAndLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#complementAndLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementAndLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "And Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:complementAndLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementFalse",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#complementFalse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementFalse",
          "package": "ideas",
          "partial": "False",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:complementFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementOrLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#complementOrLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementOrLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Or Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:complementOrLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementTrue",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#complementTrue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "complementTrue",
          "package": "ideas",
          "partial": "True",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:complementTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "deMorganAnd",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#deMorganAnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "deMorganAnd",
          "package": "ideas",
          "partial": "Morgan And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:deMorganAnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "deMorganOr",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#deMorganOr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "deMorganOr",
          "package": "ideas",
          "partial": "Morgan Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:deMorganOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "doubleComplement",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#doubleComplement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "doubleComplement",
          "package": "ideas",
          "partial": "Complement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:doubleComplement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "fromAndLaw",
          "package": "ideas",
          "signature": "Law (And a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#fromAndLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "fromAndLaw",
          "normalized": "Law(And a)-\u003eLaw a",
          "package": "ideas",
          "partial": "And Law",
          "signature": "Law(And a)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:fromAndLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "fromOrLaw",
          "package": "ideas",
          "signature": "Law (Or a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#fromOrLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "fromOrLaw",
          "normalized": "Law(Or a)-\u003eLaw a",
          "package": "ideas",
          "partial": "Or Law",
          "signature": "Law(Or a)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:fromOrLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "orOverAndLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#orOverAndLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "orOverAndLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Over And Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:orOverAndLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "propsBoolean",
          "package": "ideas",
          "signature": "[Property]",
          "source": "src/Ideas-Common-Algebra-BooleanLaws.html#propsBoolean",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra BooleanLaws",
          "module": "Ideas.Common.Algebra.BooleanLaws",
          "name": "propsBoolean",
          "normalized": "[Property]",
          "package": "ideas",
          "partial": "Boolean",
          "signature": "[Property]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-BooleanLaws.html#v:propsBoolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "Field",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "Field",
          "package": "ideas",
          "partial": "Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "Additive",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#Additive",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "Additive",
          "package": "ideas",
          "partial": "Additive",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:Additive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "CoField",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#CoField",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "CoField",
          "package": "ideas",
          "partial": "Co Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:CoField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "CoRing",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#CoRing",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "CoRing",
          "package": "ideas",
          "partial": "Co Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:CoRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "CoSemiRing",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#CoSemiRing",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "CoSemiRing",
          "package": "ideas",
          "partial": "Co Semi Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:CoSemiRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "Field",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#Field",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "Field",
          "package": "ideas",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "Multiplicative",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#Multiplicative",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "Multiplicative",
          "package": "ideas",
          "partial": "Multiplicative",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:Multiplicative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "Ring",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#Ring",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "Ring",
          "package": "ideas",
          "partial": "Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:Ring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "SafeNum",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#SafeNum",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "SafeNum",
          "package": "ideas",
          "partial": "Safe Num",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:SafeNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "SemiRing",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Field.html#SemiRing",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "SemiRing",
          "package": "ideas",
          "partial": "Semi Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#t:SemiRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c*\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#%3C%2A%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c+\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#%3C%2B%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c-\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#%3C-%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c-\u003e) \u003c-\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:-60--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c/\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#%3C%2F%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "(\u003c/\u003e) \u003c/\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:-60--47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "Additive",
          "package": "ideas",
          "signature": "Additive",
          "source": "src/Ideas-Common-Algebra-Field.html#Additive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "Additive",
          "package": "ideas",
          "partial": "Additive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:Additive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "Multiplicative",
          "package": "ideas",
          "signature": "Multiplicative",
          "source": "src/Ideas-Common-Algebra-Field.html#Multiplicative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "Multiplicative",
          "package": "ideas",
          "partial": "Multiplicative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:Multiplicative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "fromAdditive",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Field.html#Additive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "fromAdditive",
          "package": "ideas",
          "partial": "Additive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:fromAdditive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "fromMultiplicative",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Field.html#Multiplicative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "fromMultiplicative",
          "package": "ideas",
          "partial": "Multiplicative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:fromMultiplicative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isDivision",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Field.html#isDivision",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isDivision",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Division",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isDivision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isMinus",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Field.html#isMinus",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isMinus",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Minus",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isMinus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isNegate",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Algebra-Field.html#isNegate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isNegate",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "partial": "Negate",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isNegate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isOne",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Field.html#isOne",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isOne",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "One",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isPlus",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Field.html#isPlus",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isPlus",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Plus",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isRecip",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Algebra-Field.html#isRecip",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isRecip",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "partial": "Recip",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isTimes",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Field.html#isTimes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isTimes",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Times",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isTimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "isZero",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Field.html#isZero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "isZero",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Zero",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:isZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "one",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Field.html#one",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "one",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "plusInverse",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#plusInverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "plusInverse",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "partial": "Inverse",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:plusInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "product",
          "package": "ideas",
          "signature": "[a] -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#product",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "product",
          "normalized": "[a]-\u003ea",
          "package": "ideas",
          "signature": "[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "safeNum",
          "package": "ideas",
          "signature": "SafeNum a -\u003e Either String a",
          "source": "src/Ideas-Common-Algebra-Field.html#safeNum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "safeNum",
          "normalized": "SafeNum a-\u003eEither String a",
          "package": "ideas",
          "partial": "Num",
          "signature": "SafeNum a-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:safeNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "sum",
          "package": "ideas",
          "signature": "[a] -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#sum",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "sum",
          "normalized": "[a]-\u003ea",
          "package": "ideas",
          "signature": "[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "timesInverse",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Field.html#timesInverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "timesInverse",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "partial": "Inverse",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:timesInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Field",
          "name": "zero",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Field.html#zero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Field",
          "module": "Ideas.Common.Algebra.Field",
          "name": "zero",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Field.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "FieldLaws",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "FieldLaws",
          "package": "ideas",
          "partial": "Field Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "commutativeRingLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#commutativeRingLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "commutativeRingLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Ring Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:commutativeRingLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "distributiveLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#distributiveLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "distributiveLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:distributiveLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "distributiveSubtractionLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#distributiveSubtractionLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "distributiveSubtractionLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Subtraction Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:distributiveSubtractionLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "exchangeInverses",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#exchangeInverses",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "exchangeInverses",
          "package": "ideas",
          "partial": "Inverses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:exchangeInverses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "fieldLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#fieldLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "fieldLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:fieldLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "fromAdditiveLaw",
          "package": "ideas",
          "signature": "Law (Additive a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#fromAdditiveLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "fromAdditiveLaw",
          "normalized": "Law(Additive a)-\u003eLaw a",
          "package": "ideas",
          "partial": "Additive Law",
          "signature": "Law(Additive a)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:fromAdditiveLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "fromMultiplicativeLaw",
          "package": "ideas",
          "signature": "Law (Multiplicative a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#fromMultiplicativeLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "fromMultiplicativeLaw",
          "normalized": "Law(Multiplicative a)-\u003eLaw a",
          "package": "ideas",
          "partial": "Multiplicative Law",
          "signature": "Law(Multiplicative a)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:fromMultiplicativeLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "leftDistributive",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#leftDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "leftDistributive",
          "package": "ideas",
          "partial": "Distributive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:leftDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "leftNegateTimes",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#leftNegateTimes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "leftNegateTimes",
          "package": "ideas",
          "partial": "Negate Times",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:leftNegateTimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "negateTimesLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#negateTimesLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "negateTimesLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Times Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:negateTimesLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "propsField",
          "package": "ideas",
          "signature": "[Property]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#propsField",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "propsField",
          "normalized": "[Property]",
          "package": "ideas",
          "partial": "Field",
          "signature": "[Property]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:propsField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "rightDistributive",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#rightDistributive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "rightDistributive",
          "package": "ideas",
          "partial": "Distributive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:rightDistributive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "rightNegateTimes",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#rightNegateTimes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "rightNegateTimes",
          "package": "ideas",
          "partial": "Negate Times",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:rightNegateTimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "ringLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#ringLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "ringLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:ringLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "semiRingLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-FieldLaws.html#semiRingLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra FieldLaws",
          "module": "Ideas.Common.Algebra.FieldLaws",
          "name": "semiRingLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Ring Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-FieldLaws.html#v:semiRingLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "Group",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Group.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "Group",
          "package": "ideas",
          "partial": "Group",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "CoGroup",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Group.html#CoGroup",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "CoGroup",
          "package": "ideas",
          "partial": "Co Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#t:CoGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "CoMonoid",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Group.html#CoMonoid",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "CoMonoid",
          "package": "ideas",
          "partial": "Co Monoid",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#t:CoMonoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "CoMonoidZero",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Group.html#CoMonoidZero",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "CoMonoidZero",
          "package": "ideas",
          "partial": "Co Monoid Zero",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#t:CoMonoidZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal complete definition: inverse or appendInverse\n\u003c/p\u003e",
          "module": "Ideas.Common.Algebra.Group",
          "name": "Group",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Group.html#Group",
          "type": "class"
        },
        "index": {
          "description": "Minimal complete definition inverse or appendInverse",
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "Group",
          "package": "ideas",
          "partial": "Group",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#t:Group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of monoids (types with an associative binary operation that\n has an identity).  Instances should satisfy the following laws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003emappend mempty x = x\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003emappend x mempty = x\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003emappend x (mappend y z) = mappend (mappend x y) z\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003emconcat = \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e mappend mempty\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe method names refer to the monoid of lists under concatenation,\n but there are many other instances.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSome types can be viewed as a monoid in more than one way,\n e.g. both addition and multiplication on numbers.\n In such cases we often define \u003ccode\u003enewtype\u003c/code\u003es and make those instances\n of \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e, e.g. \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eProduct\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ideas.Common.Algebra.Group",
          "name": "Monoid",
          "package": "ideas",
          "type": "class"
        },
        "index": {
          "description": "The class of monoids types with an associative binary operation that has an identity Instances should satisfy the following laws mappend mempty mappend mempty mappend mappend mappend mappend mconcat foldr mappend mempty The method names refer to the monoid of lists under concatenation but there are many other instances Minimal complete definition mempty and mappend Some types can be viewed as monoid in more than one way e.g both addition and multiplication on numbers In such cases we often define newtype and make those instances of Monoid e.g Sum and Product",
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "Monoid",
          "package": "ideas",
          "partial": "Monoid",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#t:Monoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "MonoidZero",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Group.html#MonoidZero",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "MonoidZero",
          "package": "ideas",
          "partial": "Monoid Zero",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#t:MonoidZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "WithZero",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Group.html#WithZero",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "WithZero",
          "package": "ideas",
          "partial": "With Zero",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#t:WithZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ideas.Common.Algebra.Group",
          "name": "(\u003c\u003e)",
          "package": "ideas",
          "signature": "m -\u003e m -\u003e m",
          "type": "function"
        },
        "index": {
          "description": "An infix synonym for mappend",
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "m-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "(\u003c\u003e-)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Group.html#%3C%3E-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "(\u003c\u003e-) \u003c\u003e-",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:-60--62--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "appendInv",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Group.html#appendInv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "appendInv",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Inv",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:appendInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "associativeList",
          "package": "ideas",
          "signature": "a -\u003e [a]",
          "source": "src/Ideas-Common-Algebra-Group.html#associativeList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "associativeList",
          "normalized": "a-\u003e[a]",
          "package": "ideas",
          "partial": "List",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:associativeList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "fromWithZero",
          "package": "ideas",
          "signature": "WithZero a -\u003e Maybe a",
          "source": "src/Ideas-Common-Algebra-Group.html#fromWithZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "fromWithZero",
          "normalized": "WithZero a-\u003eMaybe a",
          "package": "ideas",
          "partial": "With Zero",
          "signature": "WithZero a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:fromWithZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "inverse",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Group.html#inverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "inverse",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "isAppend",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Group.html#isAppend",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "isAppend",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Append",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:isAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "isAppendInv",
          "package": "ideas",
          "signature": "a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Algebra-Group.html#isAppendInv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "isAppendInv",
          "normalized": "a-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Append Inv",
          "signature": "a-\u003eMaybe(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:isAppendInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "isEmpty",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Group.html#isEmpty",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "isEmpty",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Empty",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "isInverse",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Algebra-Group.html#isInverse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "isInverse",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "partial": "Inverse",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:isInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "isMonoidZero",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Group.html#isMonoidZero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "isMonoidZero",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Monoid Zero",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:isMonoidZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn associative operation\n\u003c/p\u003e",
          "module": "Ideas.Common.Algebra.Group",
          "name": "mappend",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "An associative operation",
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "mappend",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:mappend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold a list using the monoid.\n For most types, the default definition for \u003ccode\u003e\u003ca\u003emconcat\u003c/a\u003e\u003c/code\u003e will be\n used, but the function is included in the class definition so\n that an optimized version can be provided for specific types.\n\u003c/p\u003e",
          "module": "Ideas.Common.Algebra.Group",
          "name": "mconcat",
          "package": "ideas",
          "signature": "[a] -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Fold list using the monoid For most types the default definition for mconcat will be used but the function is included in the class definition so that an optimized version can be provided for specific types",
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "mconcat",
          "normalized": "[a]-\u003ea",
          "package": "ideas",
          "signature": "[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:mconcat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity of \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Algebra.Group",
          "name": "mempty",
          "package": "ideas",
          "signature": "a",
          "type": "method"
        },
        "index": {
          "description": "Identity of mappend",
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "mempty",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:mempty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Group",
          "name": "mzero",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Group.html#mzero",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Group",
          "module": "Ideas.Common.Algebra.Group",
          "name": "mzero",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Group.html#v:mzero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "GroupLaws",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "GroupLaws",
          "package": "ideas",
          "partial": "Group Laws",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "abelianGroupLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#abelianGroupLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "abelianGroupLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Group Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:abelianGroupLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "appendInverseLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#appendInverseLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "appendInverseLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Inverse Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:appendInverseLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "associative",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#associative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "associative",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:associative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "associativeFor",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#associativeFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "associativeFor",
          "normalized": "(a-\u003ea-\u003ea)-\u003eLaw a",
          "package": "ideas",
          "partial": "For",
          "signature": "(a-\u003ea-\u003ea)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:associativeFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "commutative",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#commutative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "commutative",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:commutative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "commutativeFor",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#commutativeFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "commutativeFor",
          "normalized": "(a-\u003ea-\u003ea)-\u003eLaw a",
          "package": "ideas",
          "partial": "For",
          "signature": "(a-\u003ea-\u003ea)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:commutativeFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "commutativeMonoidLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#commutativeMonoidLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "commutativeMonoidLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Monoid Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:commutativeMonoidLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "doubleInverse",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#doubleInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "doubleInverse",
          "package": "ideas",
          "partial": "Inverse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:doubleInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "groupLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#groupLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "groupLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:groupLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNot all monoids are idempotent (see: idempotentFor)\n\u003c/p\u003e",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "idempotent",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#idempotent",
          "type": "function"
        },
        "index": {
          "description": "Not all monoids are idempotent see idempotentFor",
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "idempotent",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:idempotent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "idempotentFor",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#idempotentFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "idempotentFor",
          "normalized": "(a-\u003ea-\u003ea)-\u003eLaw a",
          "package": "ideas",
          "partial": "For",
          "signature": "(a-\u003ea-\u003ea)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:idempotentFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "identityLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#identityLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "identityLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:identityLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseDistr",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#inverseDistr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseDistr",
          "package": "ideas",
          "partial": "Distr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:inverseDistr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseDistrFlipped",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#inverseDistrFlipped",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseDistrFlipped",
          "package": "ideas",
          "partial": "Distr Flipped",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:inverseDistrFlipped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseIdentity",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#inverseIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseIdentity",
          "package": "ideas",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:inverseIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#inverseLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "inverseLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:inverseLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftDistributiveFor",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e a) -\u003e (a -\u003e a -\u003e a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#leftDistributiveFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftDistributiveFor",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eLaw a",
          "package": "ideas",
          "partial": "Distributive For",
          "signature": "(a-\u003ea-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:leftDistributiveFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftIdentity",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#leftIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftIdentity",
          "package": "ideas",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:leftIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftInverse",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#leftInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftInverse",
          "package": "ideas",
          "partial": "Inverse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:leftInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftZero",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#leftZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "leftZero",
          "package": "ideas",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:leftZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "monoidLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#monoidLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "monoidLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:monoidLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "monoidZeroLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#monoidZeroLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "monoidZeroLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Zero Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:monoidZeroLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightDistributiveFor",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e a) -\u003e (a -\u003e a -\u003e a) -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#rightDistributiveFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightDistributiveFor",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eLaw a",
          "package": "ideas",
          "partial": "Distributive For",
          "signature": "(a-\u003ea-\u003ea)-\u003e(a-\u003ea-\u003ea)-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:rightDistributiveFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightIdentity",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#rightIdentity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightIdentity",
          "package": "ideas",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:rightIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightInverse",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#rightInverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightInverse",
          "package": "ideas",
          "partial": "Inverse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:rightInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightZero",
          "package": "ideas",
          "signature": "Law a",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#rightZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "rightZero",
          "package": "ideas",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:rightZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "zeroLaws",
          "package": "ideas",
          "signature": "[Law a]",
          "source": "src/Ideas-Common-Algebra-GroupLaws.html#zeroLaws",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra GroupLaws",
          "module": "Ideas.Common.Algebra.GroupLaws",
          "name": "zeroLaws",
          "normalized": "[Law a]",
          "package": "ideas",
          "partial": "Laws",
          "signature": "[Law a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-GroupLaws.html#v:zeroLaws"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": "Law",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Law.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": "Law",
          "package": "ideas",
          "partial": "Law",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": "Law",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Law.html#Law",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": "Law",
          "package": "ideas",
          "partial": "Law",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#t:Law"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": "LawSpec",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Law.html#LawSpec",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": "LawSpec",
          "package": "ideas",
          "partial": "Law Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#t:LawSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": ":==:",
          "package": "ideas",
          "signature": "a :==: a",
          "source": "src/Ideas-Common-Algebra-Law.html#LawSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": ":==:",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#v::-61--61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": "law",
          "package": "ideas",
          "signature": "String -\u003e l -\u003e Law a",
          "source": "src/Ideas-Common-Algebra-Law.html#law",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": "law",
          "normalized": "String-\u003ea-\u003eLaw b",
          "package": "ideas",
          "signature": "String-\u003el-\u003eLaw a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#v:law"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": "mapLaw",
          "package": "ideas",
          "signature": "(b -\u003e a) -\u003e (a -\u003e b) -\u003e Law a -\u003e Law b",
          "source": "src/Ideas-Common-Algebra-Law.html#mapLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": "mapLaw",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003eLaw b-\u003eLaw a",
          "package": "ideas",
          "partial": "Law",
          "signature": "(b-\u003ea)-\u003e(a-\u003eb)-\u003eLaw a-\u003eLaw b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#v:mapLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": "propertyLaw",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e b) -\u003e Law a -\u003e Property",
          "source": "src/Ideas-Common-Algebra-Law.html#propertyLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": "propertyLaw",
          "normalized": "(a-\u003ea-\u003eb)-\u003eLaw a-\u003eProperty",
          "package": "ideas",
          "partial": "Law",
          "signature": "(a-\u003ea-\u003eb)-\u003eLaw a-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#v:propertyLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.Law",
          "name": "rewriteLaw",
          "package": "ideas",
          "signature": "Law a -\u003e RewriteRule a",
          "source": "src/Ideas-Common-Algebra-Law.html#rewriteLaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra Law",
          "module": "Ideas.Common.Algebra.Law",
          "name": "rewriteLaw",
          "normalized": "Law a-\u003eRewriteRule a",
          "package": "ideas",
          "partial": "Law",
          "signature": "Law a-\u003eRewriteRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-Law.html#v:rewriteLaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartGroup",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartGroup",
          "package": "ideas",
          "partial": "Smart Group",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "Smart",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#Smart",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "Smart",
          "package": "ideas",
          "partial": "Smart",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#t:Smart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartField",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartField",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartField",
          "package": "ideas",
          "partial": "Smart Field",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#t:SmartField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartGroup",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartGroup",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartGroup",
          "package": "ideas",
          "partial": "Smart Group",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#t:SmartGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartZero",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartZero",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartZero",
          "package": "ideas",
          "partial": "Smart Zero",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#t:SmartZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.||.)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#.%7C%7C.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.||.) .||.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:.-124--124-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.&&.)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#.%26%26.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.&&.) .&&.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:.-38--38-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.*.)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#.%2A.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.*.) .*.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:.-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.+.)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#.%2B.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.+.) .+.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:.-43-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.-.)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#.-.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(.-.) .-.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:.-45-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(./.)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#.%2F.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "(./.) ./.",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:.-47-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "Smart",
          "package": "ideas",
          "signature": "Smart",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#Smart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "Smart",
          "package": "ideas",
          "partial": "Smart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:Smart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartField",
          "package": "ideas",
          "signature": "SmartField",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartField",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartField",
          "package": "ideas",
          "partial": "Smart Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:SmartField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartGroup",
          "package": "ideas",
          "signature": "SmartGroup",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartGroup",
          "package": "ideas",
          "partial": "Smart Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:SmartGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartZero",
          "package": "ideas",
          "signature": "SmartZero",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "SmartZero",
          "package": "ideas",
          "partial": "Smart Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:SmartZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmart",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#Smart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmart",
          "package": "ideas",
          "partial": "Smart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:fromSmart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmartField",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartField",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmartField",
          "package": "ideas",
          "partial": "Smart Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:fromSmartField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmartGroup",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmartGroup",
          "package": "ideas",
          "partial": "Smart Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:fromSmartGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmartZero",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#SmartZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "fromSmartZero",
          "package": "ideas",
          "partial": "Smart Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:fromSmartZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "neg",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Algebra-SmartGroup.html#neg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Algebra SmartGroup",
          "module": "Ideas.Common.Algebra.SmartGroup",
          "name": "neg",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Algebra-SmartGroup.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType classes and instances.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Classes",
          "name": "Classes",
          "package": "ideas",
          "source": "src/Ideas-Common-Classes.html",
          "type": "module"
        },
        "index": {
          "description": "Type classes and instances",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "Classes",
          "package": "ideas",
          "partial": "Classes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for functors that can be applied to a value. Transformation,\n Rule, and Strategy are all instances of this type class.\n\u003c/p\u003e",
          "module": "Ideas.Common.Classes",
          "name": "Apply",
          "package": "ideas",
          "source": "src/Ideas-Common-Classes.html#Apply",
          "type": "class"
        },
        "index": {
          "description": "type class for functors that can be applied to value Transformation Rule and Strategy are all instances of this type class",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "Apply",
          "package": "ideas",
          "partial": "Apply",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#t:Apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class for bi-directional arrows. \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e should be used instead of\n \u003ccode\u003earr\u003c/code\u003e from the arrow interface. Minimal complete definition: \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ideas.Common.Classes",
          "name": "BiArrow",
          "package": "ideas",
          "source": "src/Ideas-Common-Classes.html#BiArrow",
          "type": "class"
        },
        "index": {
          "description": "Type class for bi-directional arrows should be used instead of arr from the arrow interface Minimal complete definition",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "BiArrow",
          "package": "ideas",
          "partial": "Bi Arrow",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#t:BiArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "BiFunctor",
          "package": "ideas",
          "source": "src/Ideas-Common-Classes.html#BiFunctor",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "BiFunctor",
          "package": "ideas",
          "partial": "Bi Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#t:BiFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "Buggy",
          "package": "ideas",
          "source": "src/Ideas-Common-Classes.html#Buggy",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "Buggy",
          "package": "ideas",
          "partial": "Buggy",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#t:Buggy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances should satisfy the following law: \u003ccode\u003egetSingleton . singleton == Just\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Classes",
          "name": "Container",
          "package": "ideas",
          "source": "src/Ideas-Common-Classes.html#Container",
          "type": "class"
        },
        "index": {
          "description": "Instances should satisfy the following law getSingleton singleton Just",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "Container",
          "package": "ideas",
          "partial": "Container",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#t:Container"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "Minor",
          "package": "ideas",
          "source": "src/Ideas-Common-Classes.html#Minor",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "Minor",
          "package": "ideas",
          "partial": "Minor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#t:Minor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "(!-\u003e)",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e arr a b",
          "source": "src/Ideas-Common-Classes.html#%21-%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "(!-\u003e) !-\u003e",
          "normalized": "(a-\u003eb)-\u003ec a b",
          "package": "ideas",
          "signature": "(a-\u003eb)-\u003earr a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:-33--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "(\u003c-!)",
          "package": "ideas",
          "signature": "(b -\u003e a) -\u003e arr a b",
          "source": "src/Ideas-Common-Classes.html#%3C-%21",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "(\u003c-!) \u003c-!",
          "normalized": "(a-\u003eb)-\u003ec b a",
          "package": "ideas",
          "signature": "(b-\u003ea)-\u003earr a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:-60--45--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "(\u003c-\u003e)",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e (b -\u003e a) -\u003e arr a b",
          "source": "src/Ideas-Common-Classes.html#%3C-%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "(\u003c-\u003e) \u003c-\u003e",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea)-\u003ec a b",
          "package": "ideas",
          "signature": "(a-\u003eb)-\u003e(b-\u003ea)-\u003earr a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:-60--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks whether the functor is applicable (at least one result)\n\u003c/p\u003e",
          "module": "Ideas.Common.Classes",
          "name": "applicable",
          "package": "ideas",
          "signature": "t a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Classes.html#applicable",
          "type": "function"
        },
        "index": {
          "description": "Checks whether the functor is applicable at least one result",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "applicable",
          "normalized": "a b-\u003eb-\u003eBool",
          "package": "ideas",
          "signature": "t a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:applicable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns zero or one results\n\u003c/p\u003e",
          "module": "Ideas.Common.Classes",
          "name": "apply",
          "package": "ideas",
          "signature": "t a -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Classes.html#apply",
          "type": "function"
        },
        "index": {
          "description": "Returns zero or one results",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "apply",
          "normalized": "a b-\u003eb-\u003eMaybe b",
          "package": "ideas",
          "signature": "t a-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "applyAll",
          "package": "ideas",
          "signature": "applyAll",
          "source": "src/Ideas-Common-Classes.html#applyAll",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "applyAll",
          "package": "ideas",
          "partial": "All",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:applyAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf not applicable, return the current value (as default)\n\u003c/p\u003e",
          "module": "Ideas.Common.Classes",
          "name": "applyD",
          "package": "ideas",
          "signature": "t a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Classes.html#applyD",
          "type": "function"
        },
        "index": {
          "description": "If not applicable return the current value as default",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "applyD",
          "normalized": "a b-\u003eb-\u003eb",
          "package": "ideas",
          "signature": "t a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:applyD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "applyList",
          "package": "ideas",
          "signature": "[t a] -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Classes.html#applyList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "applyList",
          "normalized": "[a b]-\u003eb-\u003eMaybe b",
          "package": "ideas",
          "partial": "List",
          "signature": "[t a]-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:applyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as apply, except that the result (at most one) is returned in some monad\n\u003c/p\u003e",
          "module": "Ideas.Common.Classes",
          "name": "applyM",
          "package": "ideas",
          "signature": "t a -\u003e a -\u003e m a",
          "source": "src/Ideas-Common-Classes.html#applyM",
          "type": "function"
        },
        "index": {
          "description": "Same as apply except that the result at most one is returned in some monad",
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "applyM",
          "normalized": "a b-\u003eb-\u003ec b",
          "package": "ideas",
          "signature": "t a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:applyM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "biMap",
          "package": "ideas",
          "signature": "(a -\u003e c) -\u003e (b -\u003e d) -\u003e f a b -\u003e f c d",
          "source": "src/Ideas-Common-Classes.html#biMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "biMap",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ee a c-\u003ee b d",
          "package": "ideas",
          "partial": "Map",
          "signature": "(a-\u003ec)-\u003e(b-\u003ed)-\u003ef a b-\u003ef c d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:biMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "buggy",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Classes.html#buggy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "buggy",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:buggy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "getSingleton",
          "package": "ideas",
          "signature": "f a -\u003e Maybe a",
          "source": "src/Ideas-Common-Classes.html#getSingleton",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "getSingleton",
          "normalized": "a b-\u003eMaybe b",
          "package": "ideas",
          "partial": "Singleton",
          "signature": "f a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:getSingleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "isBuggy",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Classes.html#isBuggy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "isBuggy",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Buggy",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:isBuggy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "isMajor",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Classes.html#isMajor",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "isMajor",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Major",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:isMajor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "isMinor",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Classes.html#isMinor",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "isMinor",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Minor",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:isMinor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "mapBoth",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e f a a -\u003e f b b",
          "source": "src/Ideas-Common-Classes.html#mapBoth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "mapBoth",
          "normalized": "(a-\u003eb)-\u003ec a a-\u003ec b b",
          "package": "ideas",
          "partial": "Both",
          "signature": "(a-\u003eb)-\u003ef a a-\u003ef b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:mapBoth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "mapFirst",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e f a c -\u003e f b c",
          "source": "src/Ideas-Common-Classes.html#mapFirst",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "mapFirst",
          "normalized": "(a-\u003eb)-\u003ec a d-\u003ec b d",
          "package": "ideas",
          "partial": "First",
          "signature": "(a-\u003eb)-\u003ef a c-\u003ef b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:mapFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "mapSecond",
          "package": "ideas",
          "signature": "(b -\u003e c) -\u003e f a b -\u003e f a c",
          "source": "src/Ideas-Common-Classes.html#mapSecond",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "mapSecond",
          "normalized": "(a-\u003eb)-\u003ec d a-\u003ec d b",
          "package": "ideas",
          "partial": "Second",
          "signature": "(b-\u003ec)-\u003ef a b-\u003ef a c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:mapSecond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "minor",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Classes.html#minor",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "minor",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:minor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "setBuggy",
          "package": "ideas",
          "signature": "Bool -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Classes.html#setBuggy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "setBuggy",
          "normalized": "Bool-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Buggy",
          "signature": "Bool-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:setBuggy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "setMinor",
          "package": "ideas",
          "signature": "Bool -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Classes.html#setMinor",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "setMinor",
          "normalized": "Bool-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Minor",
          "signature": "Bool-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:setMinor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Classes",
          "name": "singleton",
          "package": "ideas",
          "signature": "a -\u003e f a",
          "source": "src/Ideas-Common-Classes.html#singleton",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Classes",
          "module": "Ideas.Common.Classes",
          "name": "singleton",
          "normalized": "a-\u003eb a",
          "package": "ideas",
          "signature": "a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Classes.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA context for a term that maintains an environment of\n key-value pairs. A context is both showable and parsable.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Context",
          "name": "Context",
          "package": "ideas",
          "source": "src/Ideas-Common-Context.html",
          "type": "module"
        },
        "index": {
          "description": "context for term that maintains an environment of key-value pairs context is both showable and parsable",
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "Context",
          "package": "ideas",
          "partial": "Context",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for a context: a context stores an envrionent\n (key-value pairs) and a value\n\u003c/p\u003e",
          "module": "Ideas.Common.Context",
          "name": "Context",
          "package": "ideas",
          "source": "src/Ideas-Common-Context.html#Context",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for context context stores an envrionent key-value pairs and value",
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "Context",
          "package": "ideas",
          "partial": "Context",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "ContextNavigator",
          "package": "ideas",
          "source": "src/Ideas-Common-Context.html#ContextNavigator",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "ContextNavigator",
          "package": "ideas",
          "partial": "Context Navigator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#t:ContextNavigator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "Location",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#Location",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "Location",
          "package": "ideas",
          "partial": "Location",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#t:Location"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function at top-level. Afterwards, try to return the focus\n to the old position\n\u003c/p\u003e",
          "module": "Ideas.Common.Context",
          "name": "applyTop",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e Context a -\u003e Context a",
          "source": "src/Ideas-Common-Context.html#applyTop",
          "type": "function"
        },
        "index": {
          "description": "Apply function at top-level Afterwards try to return the focus to the old position",
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "applyTop",
          "normalized": "(a-\u003ea)-\u003eContext a-\u003eContext a",
          "package": "ideas",
          "partial": "Top",
          "signature": "(a-\u003ea)-\u003eContext a-\u003eContext a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:applyTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "changeInContext",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e Context a -\u003e Context a",
          "source": "src/Ideas-Common-Context.html#changeInContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "changeInContext",
          "normalized": "(a-\u003ea)-\u003eContext a-\u003eContext a",
          "package": "ideas",
          "partial": "In Context",
          "signature": "(a-\u003ea)-\u003eContext a-\u003eContext a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:changeInContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "changeTerm",
          "package": "ideas",
          "signature": "(Term -\u003e Maybe Term) -\u003e Context a -\u003e Maybe (Context a)",
          "source": "src/Ideas-Common-Context.html#changeTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "changeTerm",
          "normalized": "(Term-\u003eMaybe Term)-\u003eContext a-\u003eMaybe(Context a)",
          "package": "ideas",
          "partial": "Term",
          "signature": "(Term-\u003eMaybe Term)-\u003eContext a-\u003eMaybe(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:changeTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "contextView",
          "package": "ideas",
          "signature": "View (Context a) (a, Context a)",
          "source": "src/Ideas-Common-Context.html#contextView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "contextView",
          "normalized": "View(Context a)(a,Context a)",
          "package": "ideas",
          "partial": "View",
          "signature": "View(Context a)(a,Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:contextView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "currentInContext",
          "package": "ideas",
          "signature": "Context a -\u003e Maybe a",
          "source": "src/Ideas-Common-Context.html#currentInContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "currentInContext",
          "normalized": "Context a-\u003eMaybe a",
          "package": "ideas",
          "partial": "In Context",
          "signature": "Context a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:currentInContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "currentTerm",
          "package": "ideas",
          "signature": "Context a -\u003e Maybe Term",
          "source": "src/Ideas-Common-Context.html#currentTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "currentTerm",
          "normalized": "Context a-\u003eMaybe Term",
          "package": "ideas",
          "partial": "Term",
          "signature": "Context a-\u003eMaybe Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:currentTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "fromContext",
          "package": "ideas",
          "signature": "Context a -\u003e m a",
          "source": "src/Ideas-Common-Context.html#fromContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "fromContext",
          "normalized": "Context a-\u003eb a",
          "package": "ideas",
          "partial": "Context",
          "signature": "Context a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:fromContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "fromContextWith",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e Context a -\u003e m b",
          "source": "src/Ideas-Common-Context.html#fromContextWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "fromContextWith",
          "normalized": "(a-\u003eb)-\u003eContext a-\u003ec b",
          "package": "ideas",
          "partial": "Context With",
          "signature": "(a-\u003eb)-\u003eContext a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:fromContextWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "fromContextWith2",
          "package": "ideas",
          "signature": "(a -\u003e b -\u003e c) -\u003e Context a -\u003e Context b -\u003e m c",
          "source": "src/Ideas-Common-Context.html#fromContextWith2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "fromContextWith2",
          "normalized": "(a-\u003eb-\u003ec)-\u003eContext a-\u003eContext b-\u003ed c",
          "package": "ideas",
          "partial": "Context With",
          "signature": "(a-\u003eb-\u003ec)-\u003eContext a-\u003eContext b-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:fromContextWith2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a rule to operate on a term in a context\n\u003c/p\u003e",
          "module": "Ideas.Common.Context",
          "name": "liftToContext",
          "package": "ideas",
          "signature": "f a -\u003e f (Context a)",
          "source": "src/Ideas-Common-Context.html#liftToContext",
          "type": "function"
        },
        "index": {
          "description": "Lift rule to operate on term in context",
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "liftToContext",
          "normalized": "a b-\u003ea(Context b)",
          "package": "ideas",
          "partial": "To Context",
          "signature": "f a-\u003ef(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:liftToContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "location",
          "package": "ideas",
          "signature": "a -\u003e Location",
          "source": "src/Ideas-Common-Traversal-Navigator.html#location",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "location",
          "normalized": "a-\u003eLocation",
          "package": "ideas",
          "signature": "a-\u003eLocation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:location"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "navigator",
          "package": "ideas",
          "signature": "a -\u003e ContextNavigator a",
          "source": "src/Ideas-Common-Context.html#navigator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "navigator",
          "normalized": "a-\u003eContextNavigator a",
          "package": "ideas",
          "signature": "a-\u003eContextNavigator a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:navigator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a context\n\u003c/p\u003e",
          "module": "Ideas.Common.Context",
          "name": "newContext",
          "package": "ideas",
          "signature": "Environment -\u003e ContextNavigator a -\u003e Context a",
          "source": "src/Ideas-Common-Context.html#newContext",
          "type": "function"
        },
        "index": {
          "description": "Construct context",
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "newContext",
          "normalized": "Environment-\u003eContextNavigator a-\u003eContext a",
          "package": "ideas",
          "partial": "Context",
          "signature": "Environment-\u003eContextNavigator a-\u003eContext a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:newContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "noNavigator",
          "package": "ideas",
          "signature": "a -\u003e ContextNavigator a",
          "source": "src/Ideas-Common-Context.html#noNavigator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "noNavigator",
          "normalized": "a-\u003eContextNavigator a",
          "package": "ideas",
          "partial": "Navigator",
          "signature": "a-\u003eContextNavigator a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:noNavigator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "replaceInContext",
          "package": "ideas",
          "signature": "a -\u003e Context a -\u003e Context a",
          "source": "src/Ideas-Common-Context.html#replaceInContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "replaceInContext",
          "normalized": "a-\u003eContext a-\u003eContext a",
          "package": "ideas",
          "partial": "In Context",
          "signature": "a-\u003eContext a-\u003eContext a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:replaceInContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "termNavigator",
          "package": "ideas",
          "signature": "a -\u003e ContextNavigator a",
          "source": "src/Ideas-Common-Context.html#termNavigator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "termNavigator",
          "normalized": "a-\u003eContextNavigator a",
          "package": "ideas",
          "partial": "Navigator",
          "signature": "a-\u003eContextNavigator a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:termNavigator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "use",
          "package": "ideas",
          "signature": "f a -\u003e f (Context b)",
          "source": "src/Ideas-Common-Context.html#use",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "use",
          "normalized": "a b-\u003ea(Context c)",
          "package": "ideas",
          "signature": "f a-\u003ef(Context b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:use"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Context",
          "name": "useC",
          "package": "ideas",
          "signature": "f (Context a) -\u003e f (Context b)",
          "source": "src/Ideas-Common-Context.html#useC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Context",
          "module": "Ideas.Common.Context",
          "name": "useC",
          "normalized": "a(Context b)-\u003ea(Context c)",
          "package": "ideas",
          "signature": "f(Context a)-\u003ef(Context b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Context.html#v:useC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDatatype for representing a derivation (parameterized both in the terms\n and the steps)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Derivation",
          "name": "Derivation",
          "package": "ideas",
          "source": "src/Ideas-Common-Derivation.html",
          "type": "module"
        },
        "index": {
          "description": "Datatype for representing derivation parameterized both in the terms and the steps",
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "Derivation",
          "package": "ideas",
          "partial": "Derivation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "Derivation",
          "package": "ideas",
          "source": "src/Ideas-Common-Derivation.html#Derivation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "Derivation",
          "package": "ideas",
          "partial": "Derivation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#t:Derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the number of steps in a derivation\n\u003c/p\u003e",
          "module": "Ideas.Common.Derivation",
          "name": "derivationLength",
          "package": "ideas",
          "signature": "Derivation s a -\u003e Int",
          "source": "src/Ideas-Common-Derivation.html#derivationLength",
          "type": "function"
        },
        "index": {
          "description": "Returns the number of steps in derivation",
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "derivationLength",
          "normalized": "Derivation a b-\u003eInt",
          "package": "ideas",
          "partial": "Length",
          "signature": "Derivation s a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:derivationLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a monadic function to each term, and to each step\n\u003c/p\u003e",
          "module": "Ideas.Common.Derivation",
          "name": "derivationM",
          "package": "ideas",
          "signature": "(s -\u003e m ()) -\u003e (a -\u003e m ()) -\u003e Derivation s a -\u003e m ()",
          "source": "src/Ideas-Common-Derivation.html#derivationM",
          "type": "function"
        },
        "index": {
          "description": "Apply monadic function to each term and to each step",
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "derivationM",
          "normalized": "(a-\u003eb())-\u003e(c-\u003eb())-\u003eDerivation a c-\u003eb()",
          "package": "ideas",
          "signature": "(s-\u003em())-\u003e(a-\u003em())-\u003eDerivation s a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:derivationM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "emptyDerivation",
          "package": "ideas",
          "signature": "a -\u003e Derivation s a",
          "source": "src/Ideas-Common-Derivation.html#emptyDerivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "emptyDerivation",
          "normalized": "a-\u003eDerivation b a",
          "package": "ideas",
          "partial": "Derivation",
          "signature": "a-\u003eDerivation s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:emptyDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "extend",
          "package": "ideas",
          "signature": "Derivation s a -\u003e (s, a) -\u003e Derivation s a",
          "source": "src/Ideas-Common-Derivation.html#extend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "extend",
          "normalized": "Derivation a b-\u003e(a,b)-\u003eDerivation a b",
          "package": "ideas",
          "signature": "Derivation s a-\u003e(s,a)-\u003eDerivation s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "firstTerm",
          "package": "ideas",
          "signature": "Derivation s a -\u003e a",
          "source": "src/Ideas-Common-Derivation.html#firstTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "firstTerm",
          "normalized": "Derivation a b-\u003eb",
          "package": "ideas",
          "partial": "Term",
          "signature": "Derivation s a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:firstTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTests whether the derivation is empty\n\u003c/p\u003e",
          "module": "Ideas.Common.Derivation",
          "name": "isEmpty",
          "package": "ideas",
          "signature": "Derivation s a -\u003e Bool",
          "source": "src/Ideas-Common-Derivation.html#isEmpty",
          "type": "function"
        },
        "index": {
          "description": "Tests whether the derivation is empty",
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "isEmpty",
          "normalized": "Derivation a b-\u003eBool",
          "package": "ideas",
          "partial": "Empty",
          "signature": "Derivation s a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "lastStep",
          "package": "ideas",
          "signature": "Derivation s a -\u003e Maybe s",
          "source": "src/Ideas-Common-Derivation.html#lastStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "lastStep",
          "normalized": "Derivation a b-\u003eMaybe a",
          "package": "ideas",
          "partial": "Step",
          "signature": "Derivation s a-\u003eMaybe s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:lastStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "lastTerm",
          "package": "ideas",
          "signature": "Derivation s a -\u003e a",
          "source": "src/Ideas-Common-Derivation.html#lastTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "lastTerm",
          "normalized": "Derivation a b-\u003eb",
          "package": "ideas",
          "partial": "Term",
          "signature": "Derivation s a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:lastTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "prepend",
          "package": "ideas",
          "signature": "(a, s) -\u003e Derivation s a -\u003e Derivation s a",
          "source": "src/Ideas-Common-Derivation.html#prepend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "prepend",
          "normalized": "(a,b)-\u003eDerivation b a-\u003eDerivation b a",
          "package": "ideas",
          "signature": "(a,s)-\u003eDerivation s a-\u003eDerivation s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:prepend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll steps in a derivation\n\u003c/p\u003e",
          "module": "Ideas.Common.Derivation",
          "name": "steps",
          "package": "ideas",
          "signature": "Derivation s a -\u003e [s]",
          "source": "src/Ideas-Common-Derivation.html#steps",
          "type": "function"
        },
        "index": {
          "description": "All steps in derivation",
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "steps",
          "normalized": "Derivation a b-\u003e[a]",
          "package": "ideas",
          "signature": "Derivation s a-\u003e[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:steps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll terms in a derivation\n\u003c/p\u003e",
          "module": "Ideas.Common.Derivation",
          "name": "terms",
          "package": "ideas",
          "signature": "Derivation s a -\u003e [a]",
          "source": "src/Ideas-Common-Derivation.html#terms",
          "type": "function"
        },
        "index": {
          "description": "All terms in derivation",
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "terms",
          "normalized": "Derivation a b-\u003e[b]",
          "package": "ideas",
          "signature": "Derivation s a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:terms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe triples of a derivation, consisting of the before term, the\n step, and the after term.\n\u003c/p\u003e",
          "module": "Ideas.Common.Derivation",
          "name": "triples",
          "package": "ideas",
          "signature": "Derivation s a -\u003e [(a, s, a)]",
          "source": "src/Ideas-Common-Derivation.html#triples",
          "type": "function"
        },
        "index": {
          "description": "The triples of derivation consisting of the before term the step and the after term",
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "triples",
          "normalized": "Derivation a b-\u003e[(b,a,b)]",
          "package": "ideas",
          "signature": "Derivation s a-\u003e[(a,s,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:triples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "updateSteps",
          "package": "ideas",
          "signature": "(a -\u003e s -\u003e a -\u003e t) -\u003e Derivation s a -\u003e Derivation t a",
          "source": "src/Ideas-Common-Derivation.html#updateSteps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "updateSteps",
          "normalized": "(a-\u003eb-\u003ea-\u003ec)-\u003eDerivation b a-\u003eDerivation c a",
          "package": "ideas",
          "partial": "Steps",
          "signature": "(a-\u003es-\u003ea-\u003et)-\u003eDerivation s a-\u003eDerivation t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:updateSteps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Derivation",
          "name": "withoutLast",
          "package": "ideas",
          "signature": "Derivation s a -\u003e Derivation s a",
          "source": "src/Ideas-Common-Derivation.html#withoutLast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Derivation",
          "module": "Ideas.Common.Derivation",
          "name": "withoutLast",
          "normalized": "Derivation a b-\u003eDerivation a b",
          "package": "ideas",
          "partial": "Last",
          "signature": "Derivation s a-\u003eDerivation s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Derivation.html#v:withoutLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDatatype for representing derivations as a tree. The datatype stores all\n intermediate results as well as annotations for the steps.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "DerivationTree",
          "package": "ideas",
          "source": "src/Ideas-Common-DerivationTree.html",
          "type": "module"
        },
        "index": {
          "description": "Datatype for representing derivations as tree The datatype stores all intermediate results as well as annotations for the steps",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "DerivationTree",
          "package": "ideas",
          "partial": "Derivation Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.DerivationTree",
          "name": "DerivationTree",
          "package": "ideas",
          "source": "src/Ideas-Common-DerivationTree.html#DerivationTree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "DerivationTree",
          "package": "ideas",
          "partial": "Derivation Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#t:DerivationTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBranches are attached after the existing ones (order matters)\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "addBranches",
          "package": "ideas",
          "signature": "[(s, DerivationTree s a)] -\u003e DerivationTree s a -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#addBranches",
          "type": "function"
        },
        "index": {
          "description": "Branches are attached after the existing ones order matters",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "addBranches",
          "normalized": "[(a,DerivationTree a b)]-\u003eDerivationTree a b-\u003eDerivationTree a b",
          "package": "ideas",
          "partial": "Branches",
          "signature": "[(s,DerivationTree s a)]-\u003eDerivationTree s a-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:addBranches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll branches\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "branches",
          "package": "ideas",
          "signature": "DerivationTree s a -\u003e [(s, DerivationTree s a)]",
          "source": "src/Ideas-Common-DerivationTree.html#branches",
          "type": "function"
        },
        "index": {
          "description": "All branches",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "branches",
          "normalized": "DerivationTree a b-\u003e[(a,DerivationTree a b)]",
          "package": "ideas",
          "signature": "DerivationTree s a-\u003e[(s,DerivationTree s a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:branches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.DerivationTree",
          "name": "cutOnStep",
          "package": "ideas",
          "signature": "(s -\u003e Bool) -\u003e DerivationTree s a -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#cutOnStep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "cutOnStep",
          "normalized": "(a-\u003eBool)-\u003eDerivationTree a b-\u003eDerivationTree a b",
          "package": "ideas",
          "partial": "On Step",
          "signature": "(s-\u003eBool)-\u003eDerivationTree s a-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:cutOnStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.DerivationTree",
          "name": "cutOnTerm",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e DerivationTree s a -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#cutOnTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "cutOnTerm",
          "normalized": "(a-\u003eBool)-\u003eDerivationTree b a-\u003eDerivationTree b a",
          "package": "ideas",
          "partial": "On Term",
          "signature": "(a-\u003eBool)-\u003eDerivationTree s a-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:cutOnTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe first derivation (if any)\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "derivation",
          "package": "ideas",
          "signature": "DerivationTree s a -\u003e Maybe (Derivation s a)",
          "source": "src/Ideas-Common-DerivationTree.html#derivation",
          "type": "function"
        },
        "index": {
          "description": "The first derivation if any",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "derivation",
          "normalized": "DerivationTree a b-\u003eMaybe(Derivation a b)",
          "package": "ideas",
          "signature": "DerivationTree s a-\u003eMaybe(Derivation s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll possible derivations (returned in a list)\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "derivations",
          "package": "ideas",
          "signature": "DerivationTree s a -\u003e [Derivation s a]",
          "source": "src/Ideas-Common-DerivationTree.html#derivations",
          "type": "function"
        },
        "index": {
          "description": "All possible derivations returned in list",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "derivations",
          "normalized": "DerivationTree a b-\u003e[Derivation a b]",
          "package": "ideas",
          "signature": "DerivationTree s a-\u003e[Derivation s a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:derivations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs this node an endpoint?\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "endpoint",
          "package": "ideas",
          "signature": "DerivationTree s a -\u003e Bool",
          "source": "src/Ideas-Common-DerivationTree.html#endpoint",
          "type": "function"
        },
        "index": {
          "description": "Is this node an endpoint",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "endpoint",
          "normalized": "DerivationTree a b-\u003eBool",
          "package": "ideas",
          "signature": "DerivationTree s a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:endpoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all leafs, i.e., final results in derivation. Be careful:\n the returned list may be very long\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "leafs",
          "package": "ideas",
          "signature": "DerivationTree s a -\u003e [a]",
          "source": "src/Ideas-Common-DerivationTree.html#leafs",
          "type": "function"
        },
        "index": {
          "description": "Returns all leafs i.e final results in derivation Be careful the returned list may be very long",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "leafs",
          "normalized": "DerivationTree a b-\u003e[b]",
          "package": "ideas",
          "signature": "DerivationTree s a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:leafs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe argument supplied is the maximum number of steps; if more steps are\n needed, Nothing is returned\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "lengthMax",
          "package": "ideas",
          "signature": "Int -\u003e DerivationTree s a -\u003e Maybe Int",
          "source": "src/Ideas-Common-DerivationTree.html#lengthMax",
          "type": "function"
        },
        "index": {
          "description": "The argument supplied is the maximum number of steps if more steps are needed Nothing is returned",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "lengthMax",
          "normalized": "Int-\u003eDerivationTree a b-\u003eMaybe Int",
          "package": "ideas",
          "partial": "Max",
          "signature": "Int-\u003eDerivationTree s a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:lengthMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.DerivationTree",
          "name": "makeTree",
          "package": "ideas",
          "signature": "(a -\u003e (Bool, [(s, a)])) -\u003e a -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#makeTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "makeTree",
          "normalized": "(a-\u003e(Bool,[(b,a)]))-\u003ea-\u003eDerivationTree b a",
          "package": "ideas",
          "partial": "Tree",
          "signature": "(a-\u003e(Bool,[(s,a)]))-\u003ea-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:makeTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.DerivationTree",
          "name": "mergeMaybeSteps",
          "package": "ideas",
          "signature": "DerivationTree (Maybe s) a -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#mergeMaybeSteps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "mergeMaybeSteps",
          "normalized": "DerivationTree(Maybe a)b-\u003eDerivationTree a b",
          "package": "ideas",
          "partial": "Maybe Steps",
          "signature": "DerivationTree(Maybe s)a-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:mergeMaybeSteps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn  a random derivation (if any exists at all)\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "randomDerivation",
          "package": "ideas",
          "signature": "g -\u003e DerivationTree s a -\u003e Maybe (Derivation s a)",
          "source": "src/Ideas-Common-DerivationTree.html#randomDerivation",
          "type": "function"
        },
        "index": {
          "description": "Return random derivation if any exists at all",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "randomDerivation",
          "normalized": "a-\u003eDerivationTree b c-\u003eMaybe(Derivation b c)",
          "package": "ideas",
          "partial": "Derivation",
          "signature": "g-\u003eDerivationTree s a-\u003eMaybe(Derivation s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:randomDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRestrict the height of the tree (by cutting off branches at a certain depth).\n Nodes at this particular depth are turned into endpoints\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "restrictHeight",
          "package": "ideas",
          "signature": "Int -\u003e DerivationTree s a -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#restrictHeight",
          "type": "function"
        },
        "index": {
          "description": "Restrict the height of the tree by cutting off branches at certain depth Nodes at this particular depth are turned into endpoints",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "restrictHeight",
          "normalized": "Int-\u003eDerivationTree a b-\u003eDerivationTree a b",
          "package": "ideas",
          "partial": "Height",
          "signature": "Int-\u003eDerivationTree s a-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:restrictHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRestrict the width of the tree (by cutting off branches).\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "restrictWidth",
          "package": "ideas",
          "signature": "Int -\u003e DerivationTree s a -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#restrictWidth",
          "type": "function"
        },
        "index": {
          "description": "Restrict the width of the tree by cutting off branches",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "restrictWidth",
          "normalized": "Int-\u003eDerivationTree a b-\u003eDerivationTree a b",
          "package": "ideas",
          "partial": "Width",
          "signature": "Int-\u003eDerivationTree s a-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:restrictWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe root of the tree\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "root",
          "package": "ideas",
          "signature": "DerivationTree s a -\u003e a",
          "source": "src/Ideas-Common-DerivationTree.html#root",
          "type": "function"
        },
        "index": {
          "description": "The root of the tree",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "root",
          "normalized": "DerivationTree a b-\u003eb",
          "package": "ideas",
          "signature": "DerivationTree s a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a node without branches; the boolean indicates whether the\n node is an endpoint or not\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "singleNode",
          "package": "ideas",
          "signature": "a -\u003e Bool -\u003e DerivationTree s a",
          "source": "src/Ideas-Common-DerivationTree.html#singleNode",
          "type": "function"
        },
        "index": {
          "description": "Constructs node without branches the boolean indicates whether the node is an endpoint or not",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "singleNode",
          "normalized": "a-\u003eBool-\u003eDerivationTree b a",
          "package": "ideas",
          "partial": "Node",
          "signature": "a-\u003eBool-\u003eDerivationTree s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:singleNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.DerivationTree",
          "name": "sortTree",
          "package": "ideas",
          "signature": "(l -\u003e l -\u003e Ordering) -\u003e DerivationTree l a -\u003e DerivationTree l a",
          "source": "src/Ideas-Common-DerivationTree.html#sortTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "sortTree",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eDerivationTree a b-\u003eDerivationTree a b",
          "package": "ideas",
          "partial": "Tree",
          "signature": "(l-\u003el-\u003eOrdering)-\u003eDerivationTree l a-\u003eDerivationTree l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:sortTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all subtrees at a given node\n\u003c/p\u003e",
          "module": "Ideas.Common.DerivationTree",
          "name": "subtrees",
          "package": "ideas",
          "signature": "DerivationTree s a -\u003e [DerivationTree s a]",
          "source": "src/Ideas-Common-DerivationTree.html#subtrees",
          "type": "function"
        },
        "index": {
          "description": "Returns all subtrees at given node",
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "subtrees",
          "normalized": "DerivationTree a b-\u003e[DerivationTree a b]",
          "package": "ideas",
          "signature": "DerivationTree s a-\u003e[DerivationTree s a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:subtrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.DerivationTree",
          "name": "updateAnnotations",
          "package": "ideas",
          "signature": "(a -\u003e s -\u003e a -\u003e t) -\u003e DerivationTree s a -\u003e DerivationTree t a",
          "source": "src/Ideas-Common-DerivationTree.html#updateAnnotations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common DerivationTree",
          "module": "Ideas.Common.DerivationTree",
          "name": "updateAnnotations",
          "normalized": "(a-\u003eb-\u003ea-\u003ec)-\u003eDerivationTree b a-\u003eDerivationTree c a",
          "package": "ideas",
          "partial": "Annotations",
          "signature": "(a-\u003es-\u003ea-\u003et)-\u003eDerivationTree s a-\u003eDerivationTree t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-DerivationTree.html#v:updateAnnotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences, bindings, and heterogenous environments\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Environment",
          "name": "Environment",
          "package": "ideas",
          "source": "src/Ideas-Common-Environment.html",
          "type": "module"
        },
        "index": {
          "description": "References bindings and heterogenous environments",
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "Environment",
          "package": "ideas",
          "partial": "Environment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "Binding",
          "package": "ideas",
          "source": "src/Ideas-Common-Environment.html#Binding",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "Binding",
          "package": "ideas",
          "partial": "Binding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#t:Binding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "Environment",
          "package": "ideas",
          "source": "src/Ideas-Common-Environment.html#Environment",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "Environment",
          "package": "ideas",
          "partial": "Environment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#t:Environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "HasEnvironment",
          "package": "ideas",
          "source": "src/Ideas-Common-Environment.html#HasEnvironment",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "HasEnvironment",
          "package": "ideas",
          "partial": "Has Environment",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#t:HasEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "HasRefs",
          "package": "ideas",
          "source": "src/Ideas-Common-Environment.html#HasRefs",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "HasRefs",
          "package": "ideas",
          "partial": "Has Refs",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#t:HasRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data type for references (without a value)\n\u003c/p\u003e",
          "module": "Ideas.Common.Environment",
          "name": "Ref",
          "package": "ideas",
          "source": "src/Ideas-Common-Environment.html#Ref",
          "type": "data"
        },
        "index": {
          "description": "data type for references without value",
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "Ref",
          "package": "ideas",
          "partial": "Ref",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#t:Ref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for types as references\n\u003c/p\u003e",
          "module": "Ideas.Common.Environment",
          "name": "Reference",
          "package": "ideas",
          "source": "src/Ideas-Common-Environment.html#Reference",
          "type": "class"
        },
        "index": {
          "description": "type class for types as references",
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "Reference",
          "package": "ideas",
          "partial": "Reference",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#t:Reference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "(?)",
          "package": "ideas",
          "signature": "Ref a -\u003e env -\u003e Maybe a",
          "source": "src/Ideas-Common-Environment.html#%3F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "(?) ?",
          "normalized": "Ref a-\u003eb-\u003eMaybe a",
          "package": "ideas",
          "signature": "Ref a-\u003eenv-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:-63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "allRefs",
          "package": "ideas",
          "signature": "a -\u003e [Some Ref]",
          "source": "src/Ideas-Common-Environment.html#allRefs",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "allRefs",
          "normalized": "a-\u003e[Some Ref]",
          "package": "ideas",
          "partial": "Refs",
          "signature": "a-\u003e[Some Ref]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:allRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "bindings",
          "package": "ideas",
          "signature": "env -\u003e [Binding]",
          "source": "src/Ideas-Common-Environment.html#bindings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "bindings",
          "normalized": "a-\u003e[Binding]",
          "package": "ideas",
          "signature": "env-\u003e[Binding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:bindings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "changeRef",
          "package": "ideas",
          "signature": "Ref a -\u003e (a -\u003e a) -\u003e env -\u003e env",
          "source": "src/Ideas-Common-Environment.html#changeRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "changeRef",
          "normalized": "Ref a-\u003e(a-\u003ea)-\u003eb-\u003eb",
          "package": "ideas",
          "partial": "Ref",
          "signature": "Ref a-\u003e(a-\u003ea)-\u003eenv-\u003eenv",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:changeRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "deleteRef",
          "package": "ideas",
          "signature": "Ref a -\u003e env -\u003e env",
          "source": "src/Ideas-Common-Environment.html#deleteRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "deleteRef",
          "normalized": "Ref a-\u003eb-\u003eb",
          "package": "ideas",
          "partial": "Ref",
          "signature": "Ref a-\u003eenv-\u003eenv",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:deleteRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "environment",
          "package": "ideas",
          "signature": "env -\u003e Environment",
          "source": "src/Ideas-Common-Environment.html#environment",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "environment",
          "normalized": "a-\u003eEnvironment",
          "package": "ideas",
          "signature": "env-\u003eEnvironment",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "fromBinding",
          "package": "ideas",
          "signature": "Binding -\u003e Maybe (Ref a, a)",
          "source": "src/Ideas-Common-Environment.html#fromBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "fromBinding",
          "normalized": "Binding-\u003eMaybe(Ref a,a)",
          "package": "ideas",
          "partial": "Binding",
          "signature": "Binding-\u003eMaybe(Ref a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:fromBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "getRefIds",
          "package": "ideas",
          "signature": "a -\u003e [Id]",
          "source": "src/Ideas-Common-Environment.html#getRefIds",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "getRefIds",
          "normalized": "a-\u003e[Id]",
          "package": "ideas",
          "partial": "Ref Ids",
          "signature": "a-\u003e[Id]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:getRefIds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "getRefs",
          "package": "ideas",
          "signature": "a -\u003e [Some Ref]",
          "source": "src/Ideas-Common-Environment.html#getRefs",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "getRefs",
          "normalized": "a-\u003e[Some Ref]",
          "package": "ideas",
          "partial": "Refs",
          "signature": "a-\u003e[Some Ref]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:getRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "getTermValue",
          "package": "ideas",
          "signature": "Binding -\u003e Term",
          "source": "src/Ideas-Common-Environment.html#getTermValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "getTermValue",
          "normalized": "Binding-\u003eTerm",
          "package": "ideas",
          "partial": "Term Value",
          "signature": "Binding-\u003eTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:getTermValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "insertRef",
          "package": "ideas",
          "signature": "Ref a -\u003e a -\u003e env -\u003e env",
          "source": "src/Ideas-Common-Environment.html#insertRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "insertRef",
          "normalized": "Ref a-\u003ea-\u003eb-\u003eb",
          "package": "ideas",
          "partial": "Ref",
          "signature": "Ref a-\u003ea-\u003eenv-\u003eenv",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:insertRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "makeBinding",
          "package": "ideas",
          "signature": "Ref a -\u003e a -\u003e Binding",
          "source": "src/Ideas-Common-Environment.html#makeBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "makeBinding",
          "normalized": "Ref a-\u003ea-\u003eBinding",
          "package": "ideas",
          "partial": "Binding",
          "signature": "Ref a-\u003ea-\u003eBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:makeBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "makeEnvironment",
          "package": "ideas",
          "signature": "[Binding] -\u003e Environment",
          "source": "src/Ideas-Common-Environment.html#makeEnvironment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "makeEnvironment",
          "normalized": "[Binding]-\u003eEnvironment",
          "package": "ideas",
          "partial": "Environment",
          "signature": "[Binding]-\u003eEnvironment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:makeEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "makeRef",
          "package": "ideas",
          "signature": "n -\u003e Ref a",
          "source": "src/Ideas-Common-Environment.html#makeRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "makeRef",
          "normalized": "a-\u003eRef b",
          "package": "ideas",
          "partial": "Ref",
          "signature": "n-\u003eRef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:makeRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "makeRefList",
          "package": "ideas",
          "signature": "n -\u003e Ref [a]",
          "source": "src/Ideas-Common-Environment.html#makeRefList",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "makeRefList",
          "normalized": "a-\u003eRef[b]",
          "package": "ideas",
          "partial": "Ref List",
          "signature": "n-\u003eRef[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:makeRefList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "noBindings",
          "package": "ideas",
          "signature": "env -\u003e Bool",
          "source": "src/Ideas-Common-Environment.html#noBindings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "noBindings",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Bindings",
          "signature": "env-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:noBindings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "setEnvironment",
          "package": "ideas",
          "signature": "Environment -\u003e env -\u003e env",
          "source": "src/Ideas-Common-Environment.html#setEnvironment",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "setEnvironment",
          "normalized": "Environment-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Environment",
          "signature": "Environment-\u003eenv-\u003eenv",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:setEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "showValue",
          "package": "ideas",
          "signature": "Binding -\u003e String",
          "source": "src/Ideas-Common-Environment.html#showValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "showValue",
          "normalized": "Binding-\u003eString",
          "package": "ideas",
          "partial": "Value",
          "signature": "Binding-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:showValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Environment",
          "name": "singleBinding",
          "package": "ideas",
          "signature": "Ref a -\u003e a -\u003e Environment",
          "source": "src/Ideas-Common-Environment.html#singleBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Environment",
          "module": "Ideas.Common.Environment",
          "name": "singleBinding",
          "normalized": "Ref a-\u003ea-\u003eEnvironment",
          "package": "ideas",
          "partial": "Binding",
          "signature": "Ref a-\u003ea-\u003eEnvironment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Environment.html#v:singleBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the concept of an exercise\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "Exercise",
          "package": "ideas",
          "source": "src/Ideas-Common-Exercise.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the concept of an exercise",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Exercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "Difficulty",
          "package": "ideas",
          "source": "src/Ideas-Common-Exercise.html#Difficulty",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Difficulty",
          "package": "ideas",
          "partial": "Difficulty",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#t:Difficulty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "Examples",
          "package": "ideas",
          "source": "src/Ideas-Common-Exercise.html#Examples",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Examples",
          "package": "ideas",
          "partial": "Examples",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#t:Examples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "Exercise",
          "package": "ideas",
          "source": "src/Ideas-Common-Exercise.html#Exercise",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Exercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#t:Exercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "ExerciseDerivation",
          "package": "ideas",
          "source": "src/Ideas-Common-Exercise.html#ExerciseDerivation",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "ExerciseDerivation",
          "package": "ideas",
          "partial": "Exercise Derivation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#t:ExerciseDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "Status",
          "package": "ideas",
          "source": "src/Ideas-Common-Exercise.html#Status",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Status",
          "package": "ideas",
          "partial": "Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#t:Status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn exercise that is under development\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "Alpha",
          "package": "ideas",
          "signature": "Alpha",
          "source": "src/Ideas-Common-Exercise.html#Status",
          "type": "function"
        },
        "index": {
          "description": "An exercise that is under development",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Alpha",
          "package": "ideas",
          "partial": "Alpha",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:Alpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "Difficult",
          "package": "ideas",
          "signature": "Difficult",
          "source": "src/Ideas-Common-Exercise.html#Difficulty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Difficult",
          "package": "ideas",
          "partial": "Difficult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:Difficult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "Easy",
          "package": "ideas",
          "signature": "Easy",
          "source": "src/Ideas-Common-Exercise.html#Difficulty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Easy",
          "package": "ideas",
          "partial": "Easy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:Easy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn exercise for experimentation purposes only\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "Experimental",
          "package": "ideas",
          "signature": "Experimental",
          "source": "src/Ideas-Common-Exercise.html#Status",
          "type": "function"
        },
        "index": {
          "description": "An exercise for experimentation purposes only",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Experimental",
          "package": "ideas",
          "partial": "Experimental",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:Experimental"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "Medium",
          "package": "ideas",
          "signature": "Medium",
          "source": "src/Ideas-Common-Exercise.html#Difficulty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Medium",
          "package": "ideas",
          "partial": "Medium",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:Medium"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA released exercise, possibly with some deficiencies\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "Provisional",
          "package": "ideas",
          "signature": "Provisional",
          "source": "src/Ideas-Common-Exercise.html#Status",
          "type": "function"
        },
        "index": {
          "description": "released exercise possibly with some deficiencies",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Provisional",
          "package": "ideas",
          "partial": "Provisional",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:Provisional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA released exercise that has undergone some thorough testing\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "Stable",
          "package": "ideas",
          "signature": "Stable",
          "source": "src/Ideas-Common-Exercise.html#Status",
          "type": "function"
        },
        "index": {
          "description": "released exercise that has undergone some thorough testing",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "Stable",
          "package": "ideas",
          "partial": "Stable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:Stable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "VeryDifficult",
          "package": "ideas",
          "signature": "VeryDifficult",
          "source": "src/Ideas-Common-Exercise.html#Difficulty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "VeryDifficult",
          "package": "ideas",
          "partial": "Very Difficult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:VeryDifficult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "VeryEasy",
          "package": "ideas",
          "signature": "VeryEasy",
          "source": "src/Ideas-Common-Exercise.html#Difficulty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "VeryEasy",
          "package": "ideas",
          "partial": "Very Easy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:VeryEasy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "canBeRestarted",
          "package": "ideas",
          "signature": "Exercise a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#canBeRestarted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "canBeRestarted",
          "normalized": "Exercise a-\u003eBool",
          "package": "ideas",
          "partial": "Be Restarted",
          "signature": "Exercise a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:canBeRestarted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "castFrom",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e Maybe b",
          "source": "src/Ideas-Common-Exercise.html#castFrom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "castFrom",
          "normalized": "Exercise a-\u003ea-\u003eMaybe b",
          "package": "ideas",
          "partial": "From",
          "signature": "Exercise a-\u003ea-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:castFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "castTo",
          "package": "ideas",
          "signature": "Exercise a -\u003e b -\u003e Maybe a",
          "source": "src/Ideas-Common-Exercise.html#castTo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "castTo",
          "normalized": "Exercise a-\u003eb-\u003eMaybe a",
          "package": "ideas",
          "partial": "To",
          "signature": "Exercise a-\u003eb-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:castTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "checkExamples",
          "package": "ideas",
          "signature": "Exercise a -\u003e TestSuite",
          "source": "src/Ideas-Common-Exercise.html#checkExamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "checkExamples",
          "normalized": "Exercise a-\u003eTestSuite",
          "package": "ideas",
          "partial": "Examples",
          "signature": "Exercise a-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:checkExamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "checkExercise",
          "package": "ideas",
          "signature": "Exercise a -\u003e IO ()",
          "source": "src/Ideas-Common-Exercise.html#checkExercise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "checkExercise",
          "normalized": "Exercise a-\u003eIO()",
          "package": "ideas",
          "partial": "Exercise",
          "signature": "Exercise a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:checkExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "checkParserPretty",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e (String -\u003e Either String a) -\u003e (a -\u003e String) -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#checkParserPretty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "checkParserPretty",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e(String-\u003eEither String a)-\u003e(a-\u003eString)-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Parser Pretty",
          "signature": "(a-\u003ea-\u003eBool)-\u003e(String-\u003eEither String a)-\u003e(a-\u003eString)-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:checkParserPretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "defaultDerivation",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e ExerciseDerivation a",
          "source": "src/Ideas-Common-Exercise.html#defaultDerivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "defaultDerivation",
          "normalized": "Exercise a-\u003ea-\u003eExerciseDerivation a",
          "package": "ideas",
          "partial": "Derivation",
          "signature": "Exercise a-\u003ea-\u003eExerciseDerivation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:defaultDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "derivationDiffEnv",
          "package": "ideas",
          "signature": "Derivation s (Context a) -\u003e Derivation (s, Environment) (Context a)",
          "source": "src/Ideas-Common-Exercise.html#derivationDiffEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "derivationDiffEnv",
          "normalized": "Derivation a(Context b)-\u003eDerivation(a,Environment)(Context b)",
          "package": "ideas",
          "partial": "Diff Env",
          "signature": "Derivation s(Context a)-\u003eDerivation(s,Environment)(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:derivationDiffEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "difference",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Exercise.html#difference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "difference",
          "normalized": "Exercise a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "package": "ideas",
          "signature": "Exercise a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "differenceEqual",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Exercise.html#differenceEqual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "differenceEqual",
          "normalized": "Exercise a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Equal",
          "signature": "Exercise a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:differenceEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "emptyExercise",
          "package": "ideas",
          "signature": "Exercise a",
          "source": "src/Ideas-Common-Exercise.html#emptyExercise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "emptyExercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:emptyExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "equivalence",
          "package": "ideas",
          "signature": "Exercise a -\u003e Context a -\u003e Context a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#equivalence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "equivalence",
          "normalized": "Exercise a-\u003eContext a-\u003eContext a-\u003eBool",
          "package": "ideas",
          "signature": "Exercise a-\u003eContext a-\u003eContext a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:equivalence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "examples",
          "package": "ideas",
          "signature": "Exercise a -\u003e [(Difficulty, a)]",
          "source": "src/Ideas-Common-Exercise.html#examples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "examples",
          "normalized": "Exercise a-\u003e[(Difficulty,a)]",
          "package": "ideas",
          "signature": "Exercise a-\u003e[(Difficulty,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:examples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "examplesContext",
          "package": "ideas",
          "signature": "Exercise a -\u003e Examples (Context a)",
          "source": "src/Ideas-Common-Exercise.html#examplesContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "examplesContext",
          "normalized": "Exercise a-\u003eExamples(Context a)",
          "package": "ideas",
          "partial": "Context",
          "signature": "Exercise a-\u003eExamples(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:examplesContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "exerciseId",
          "package": "ideas",
          "signature": "Exercise a -\u003e Id",
          "source": "src/Ideas-Common-Exercise.html#exerciseId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "exerciseId",
          "normalized": "Exercise a-\u003eId",
          "package": "ideas",
          "partial": "Id",
          "signature": "Exercise a-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:exerciseId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "exerciseTestSuite",
          "package": "ideas",
          "signature": "Exercise a -\u003e TestSuite",
          "source": "src/Ideas-Common-Exercise.html#exerciseTestSuite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "exerciseTestSuite",
          "normalized": "Exercise a-\u003eTestSuite",
          "package": "ideas",
          "partial": "Test Suite",
          "signature": "Exercise a-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:exerciseTestSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "extraRules",
          "package": "ideas",
          "signature": "Exercise a -\u003e [Rule (Context a)]",
          "source": "src/Ideas-Common-Exercise.html#extraRules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "extraRules",
          "normalized": "Exercise a-\u003e[Rule(Context a)]",
          "package": "ideas",
          "partial": "Rules",
          "signature": "Exercise a-\u003e[Rule(Context a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:extraRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "getRule",
          "package": "ideas",
          "signature": "Exercise a -\u003e Id -\u003e m (Rule (Context a))",
          "source": "src/Ideas-Common-Exercise.html#getRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "getRule",
          "normalized": "Exercise a-\u003eId-\u003eb(Rule(Context a))",
          "package": "ideas",
          "partial": "Rule",
          "signature": "Exercise a-\u003eId-\u003em(Rule(Context a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:getRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "hasTermView",
          "package": "ideas",
          "signature": "Exercise a -\u003e Maybe (View Term a)",
          "source": "src/Ideas-Common-Exercise.html#hasTermView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "hasTermView",
          "normalized": "Exercise a-\u003eMaybe(View Term a)",
          "package": "ideas",
          "partial": "Term View",
          "signature": "Exercise a-\u003eMaybe(View Term a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:hasTermView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "hasTypeable",
          "package": "ideas",
          "signature": "Exercise a -\u003e Maybe (IsTypeable a)",
          "source": "src/Ideas-Common-Exercise.html#hasTypeable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "hasTypeable",
          "normalized": "Exercise a-\u003eMaybe(IsTypeable a)",
          "package": "ideas",
          "partial": "Typeable",
          "signature": "Exercise a-\u003eMaybe(IsTypeable a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:hasTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut a value into an empty environment\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "inContext",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e Context a",
          "source": "src/Ideas-Common-Exercise.html#inContext",
          "type": "function"
        },
        "index": {
          "description": "Put value into an empty environment",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "inContext",
          "normalized": "Exercise a-\u003ea-\u003eContext a",
          "package": "ideas",
          "partial": "Context",
          "signature": "Exercise a-\u003ea-\u003eContext a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:inContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn exercise that is not public\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "isPrivate",
          "package": "ideas",
          "signature": "Exercise a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#isPrivate",
          "type": "function"
        },
        "index": {
          "description": "An exercise that is not public",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "isPrivate",
          "normalized": "Exercise a-\u003eBool",
          "package": "ideas",
          "partial": "Private",
          "signature": "Exercise a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:isPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn exercise with the status \u003ccode\u003eStable\u003c/code\u003e or \u003ccode\u003eProvisional\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "isPublic",
          "package": "ideas",
          "signature": "Exercise a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#isPublic",
          "type": "function"
        },
        "index": {
          "description": "An exercise with the status Stable or Provisional",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "isPublic",
          "normalized": "Exercise a-\u003eBool",
          "package": "ideas",
          "partial": "Public",
          "signature": "Exercise a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:isPublic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "isReady",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#isReady",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "isReady",
          "normalized": "Exercise a-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Ready",
          "signature": "Exercise a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:isReady"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "isSuitable",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#isSuitable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "isSuitable",
          "normalized": "Exercise a-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Suitable",
          "signature": "Exercise a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:isSuitable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "level",
          "package": "ideas",
          "signature": "Difficulty -\u003e [a] -\u003e Examples a",
          "source": "src/Ideas-Common-Exercise.html#level",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "level",
          "normalized": "Difficulty-\u003e[a]-\u003eExamples a",
          "package": "ideas",
          "signature": "Difficulty-\u003e[a]-\u003eExamples a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:level"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "makeContext",
          "package": "ideas",
          "signature": "Exercise a -\u003e Environment -\u003e a -\u003e Context a",
          "source": "src/Ideas-Common-Exercise.html#makeContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "makeContext",
          "normalized": "Exercise a-\u003eEnvironment-\u003ea-\u003eContext a",
          "package": "ideas",
          "partial": "Context",
          "signature": "Exercise a-\u003eEnvironment-\u003ea-\u003eContext a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:makeContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "makeExercise",
          "package": "ideas",
          "signature": "Exercise a",
          "source": "src/Ideas-Common-Exercise.html#makeExercise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "makeExercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:makeExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "mapExamples",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e Examples a -\u003e Examples b",
          "source": "src/Ideas-Common-Exercise.html#mapExamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "mapExamples",
          "normalized": "(a-\u003eb)-\u003eExamples a-\u003eExamples b",
          "package": "ideas",
          "partial": "Examples",
          "signature": "(a-\u003eb)-\u003eExamples a-\u003eExamples b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:mapExamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "navigation",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e ContextNavigator a",
          "source": "src/Ideas-Common-Exercise.html#navigation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "navigation",
          "normalized": "Exercise a-\u003ea-\u003eContextNavigator a",
          "package": "ideas",
          "signature": "Exercise a-\u003ea-\u003eContextNavigator a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:navigation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "parser",
          "package": "ideas",
          "signature": "Exercise a -\u003e String -\u003e Either String a",
          "source": "src/Ideas-Common-Exercise.html#parser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "parser",
          "normalized": "Exercise a-\u003eString-\u003eEither String a",
          "package": "ideas",
          "signature": "Exercise a-\u003eString-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "prettyPrinter",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e String",
          "source": "src/Ideas-Common-Exercise.html#prettyPrinter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "prettyPrinter",
          "normalized": "Exercise a-\u003ea-\u003eString",
          "package": "ideas",
          "partial": "Printer",
          "signature": "Exercise a-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:prettyPrinter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "prettyPrinterContext",
          "package": "ideas",
          "signature": "Exercise a -\u003e Context a -\u003e String",
          "source": "src/Ideas-Common-Exercise.html#prettyPrinterContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "prettyPrinterContext",
          "normalized": "Exercise a-\u003eContext a-\u003eString",
          "package": "ideas",
          "partial": "Printer Context",
          "signature": "Exercise a-\u003eContext a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:prettyPrinterContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "printDerivation",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e IO ()",
          "source": "src/Ideas-Common-Exercise.html#printDerivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "printDerivation",
          "normalized": "Exercise a-\u003ea-\u003eIO()",
          "package": "ideas",
          "partial": "Derivation",
          "signature": "Exercise a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:printDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "randomExercise",
          "package": "ideas",
          "signature": "Exercise a -\u003e Maybe (StdGen -\u003e Maybe Difficulty -\u003e a)",
          "source": "src/Ideas-Common-Exercise.html#randomExercise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "randomExercise",
          "normalized": "Exercise a-\u003eMaybe(StdGen-\u003eMaybe Difficulty-\u003ea)",
          "package": "ideas",
          "partial": "Exercise",
          "signature": "Exercise a-\u003eMaybe(StdGen-\u003eMaybe Difficulty-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:randomExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "randomTerm",
          "package": "ideas",
          "signature": "Exercise a -\u003e Maybe Difficulty -\u003e IO a",
          "source": "src/Ideas-Common-Exercise.html#randomTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "randomTerm",
          "normalized": "Exercise a-\u003eMaybe Difficulty-\u003eIO a",
          "package": "ideas",
          "partial": "Term",
          "signature": "Exercise a-\u003eMaybe Difficulty-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:randomTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "randomTermWith",
          "package": "ideas",
          "signature": "StdGen -\u003e Exercise a -\u003e Maybe Difficulty -\u003e Maybe a",
          "source": "src/Ideas-Common-Exercise.html#randomTermWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "randomTermWith",
          "normalized": "StdGen-\u003eExercise a-\u003eMaybe Difficulty-\u003eMaybe a",
          "package": "ideas",
          "partial": "Term With",
          "signature": "StdGen-\u003eExercise a-\u003eMaybe Difficulty-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:randomTermWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "readDifficulty",
          "package": "ideas",
          "signature": "String -\u003e Maybe Difficulty",
          "source": "src/Ideas-Common-Exercise.html#readDifficulty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "readDifficulty",
          "normalized": "String-\u003eMaybe Difficulty",
          "package": "ideas",
          "partial": "Difficulty",
          "signature": "String-\u003eMaybe Difficulty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:readDifficulty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "ready",
          "package": "ideas",
          "signature": "Exercise a -\u003e Predicate a",
          "source": "src/Ideas-Common-Exercise.html#ready",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "ready",
          "normalized": "Exercise a-\u003ePredicate a",
          "package": "ideas",
          "signature": "Exercise a-\u003ePredicate a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:ready"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "recognizeRule",
          "package": "ideas",
          "signature": "Exercise a -\u003e Rule (Context a) -\u003e Context a -\u003e Context a -\u003e [(Location, Environment)]",
          "source": "src/Ideas-Common-Exercise.html#recognizeRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "recognizeRule",
          "normalized": "Exercise a-\u003eRule(Context a)-\u003eContext a-\u003eContext a-\u003e[(Location,Environment)]",
          "package": "ideas",
          "partial": "Rule",
          "signature": "Exercise a-\u003eRule(Context a)-\u003eContext a-\u003eContext a-\u003e[(Location,Environment)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:recognizeRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "restrictGenerator",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e Gen a -\u003e Gen a",
          "source": "src/Ideas-Common-Exercise.html#restrictGenerator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "restrictGenerator",
          "normalized": "(a-\u003eBool)-\u003eGen a-\u003eGen a",
          "package": "ideas",
          "partial": "Generator",
          "signature": "(a-\u003eBool)-\u003eGen a-\u003eGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:restrictGenerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "ruleOrdering",
          "package": "ideas",
          "signature": "Exercise a -\u003e Rule (Context a) -\u003e Rule (Context a) -\u003e Ordering",
          "source": "src/Ideas-Common-Exercise.html#ruleOrdering",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "ruleOrdering",
          "normalized": "Exercise a-\u003eRule(Context a)-\u003eRule(Context a)-\u003eOrdering",
          "package": "ideas",
          "partial": "Ordering",
          "signature": "Exercise a-\u003eRule(Context a)-\u003eRule(Context a)-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:ruleOrdering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "ruleOrderingWith",
          "package": "ideas",
          "signature": "[Rule a] -\u003e Rule a -\u003e Rule a -\u003e Ordering",
          "source": "src/Ideas-Common-Exercise.html#ruleOrderingWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "ruleOrderingWith",
          "normalized": "[Rule a]-\u003eRule a-\u003eRule a-\u003eOrdering",
          "package": "ideas",
          "partial": "Ordering With",
          "signature": "[Rule a]-\u003eRule a-\u003eRule a-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:ruleOrderingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "ruleOrderingWithId",
          "package": "ideas",
          "signature": "[b] -\u003e Rule a -\u003e Rule a -\u003e Ordering",
          "source": "src/Ideas-Common-Exercise.html#ruleOrderingWithId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "ruleOrderingWithId",
          "normalized": "[a]-\u003eRule b-\u003eRule b-\u003eOrdering",
          "package": "ideas",
          "partial": "Ordering With Id",
          "signature": "[b]-\u003eRule a-\u003eRule a-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:ruleOrderingWithId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "ruleset",
          "package": "ideas",
          "signature": "Exercise a -\u003e [Rule (Context a)]",
          "source": "src/Ideas-Common-Exercise.html#ruleset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "ruleset",
          "normalized": "Exercise a-\u003e[Rule(Context a)]",
          "package": "ideas",
          "signature": "Exercise a-\u003e[Rule(Context a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:ruleset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShows a derivation for a given start term. The specified rule ordering\n is used for selection.\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "showDerivation",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e String",
          "source": "src/Ideas-Common-Exercise.html#showDerivation",
          "type": "function"
        },
        "index": {
          "description": "Shows derivation for given start term The specified rule ordering is used for selection",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "showDerivation",
          "normalized": "Exercise a-\u003ea-\u003eString",
          "package": "ideas",
          "partial": "Derivation",
          "signature": "Exercise a-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:showDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "similarity",
          "package": "ideas",
          "signature": "Exercise a -\u003e Context a -\u003e Context a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#similarity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "similarity",
          "normalized": "Exercise a-\u003eContext a-\u003eContext a-\u003eBool",
          "package": "ideas",
          "signature": "Exercise a-\u003eContext a-\u003eContext a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:similarity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalence on terms without a context\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "simpleEquivalence",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#simpleEquivalence",
          "type": "function"
        },
        "index": {
          "description": "Equivalence on terms without context",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "simpleEquivalence",
          "normalized": "Exercise a-\u003ea-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Equivalence",
          "signature": "Exercise a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:simpleEquivalence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "simpleGenerator",
          "package": "ideas",
          "signature": "Gen a -\u003e Maybe (StdGen -\u003e Maybe Difficulty -\u003e a)",
          "source": "src/Ideas-Common-Exercise.html#simpleGenerator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "simpleGenerator",
          "normalized": "Gen a-\u003eMaybe(StdGen-\u003eMaybe Difficulty-\u003ea)",
          "package": "ideas",
          "partial": "Generator",
          "signature": "Gen a-\u003eMaybe(StdGen-\u003eMaybe Difficulty-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:simpleGenerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilarity on terms without a context\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "simpleSimilarity",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#simpleSimilarity",
          "type": "function"
        },
        "index": {
          "description": "Similarity on terms without context",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "simpleSimilarity",
          "normalized": "Exercise a-\u003ea-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Similarity",
          "signature": "Exercise a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:simpleSimilarity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "status",
          "package": "ideas",
          "signature": "Exercise a -\u003e Status",
          "source": "src/Ideas-Common-Exercise.html#status",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "status",
          "normalized": "Exercise a-\u003eStatus",
          "package": "ideas",
          "signature": "Exercise a-\u003eStatus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "strategy",
          "package": "ideas",
          "signature": "Exercise a -\u003e LabeledStrategy (Context a)",
          "source": "src/Ideas-Common-Exercise.html#strategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "strategy",
          "normalized": "Exercise a-\u003eLabeledStrategy(Context a)",
          "package": "ideas",
          "signature": "Exercise a-\u003eLabeledStrategy(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:strategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "suitable",
          "package": "ideas",
          "signature": "Exercise a -\u003e Predicate a",
          "source": "src/Ideas-Common-Exercise.html#suitable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "suitable",
          "normalized": "Exercise a-\u003ePredicate a",
          "package": "ideas",
          "signature": "Exercise a-\u003ePredicate a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:suitable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "testGenerator",
          "package": "ideas",
          "signature": "Exercise a -\u003e Maybe (Gen a)",
          "source": "src/Ideas-Common-Exercise.html#testGenerator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "testGenerator",
          "normalized": "Exercise a-\u003eMaybe(Gen a)",
          "package": "ideas",
          "partial": "Generator",
          "signature": "Exercise a-\u003eMaybe(Gen a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:testGenerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "useGenerator",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e (Maybe Difficulty -\u003e Gen a) -\u003e Maybe (StdGen -\u003e Maybe Difficulty -\u003e a)",
          "source": "src/Ideas-Common-Exercise.html#useGenerator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "useGenerator",
          "normalized": "(a-\u003eBool)-\u003e(Maybe Difficulty-\u003eGen a)-\u003eMaybe(StdGen-\u003eMaybe Difficulty-\u003ea)",
          "package": "ideas",
          "partial": "Generator",
          "signature": "(a-\u003eBool)-\u003e(Maybe Difficulty-\u003eGen a)-\u003eMaybe(StdGen-\u003eMaybe Difficulty-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:useGenerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Exercise",
          "name": "useTypeable",
          "package": "ideas",
          "signature": "Maybe (IsTypeable a)",
          "source": "src/Ideas-Common-Exercise.html#useTypeable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "useTypeable",
          "package": "ideas",
          "partial": "Typeable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:useTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction for defining equivalence or similarity without taking\n the context into account.\n\u003c/p\u003e",
          "module": "Ideas.Common.Exercise",
          "name": "withoutContext",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Context a -\u003e Context a -\u003e Bool",
          "source": "src/Ideas-Common-Exercise.html#withoutContext",
          "type": "function"
        },
        "index": {
          "description": "Function for defining equivalence or similarity without taking the context into account",
          "hierarchy": "Ideas Common Exercise",
          "module": "Ideas.Common.Exercise",
          "name": "withoutContext",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eContext a-\u003eContext a-\u003eBool",
          "package": "ideas",
          "partial": "Context",
          "signature": "(a-\u003ea-\u003eBool)-\u003eContext a-\u003eContext a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Exercise.html#v:withoutContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIdentification of entities\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Id",
          "name": "Id",
          "package": "ideas",
          "source": "src/Ideas-Common-Id.html",
          "type": "module"
        },
        "index": {
          "description": "Identification of entities",
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "Id",
          "package": "ideas",
          "partial": "Id",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "HasId",
          "package": "ideas",
          "source": "src/Ideas-Common-Id.html#HasId",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "HasId",
          "package": "ideas",
          "partial": "Has Id",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#t:HasId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "Id",
          "package": "ideas",
          "source": "src/Ideas-Common-Id.html#Id",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "Id",
          "package": "ideas",
          "partial": "Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#t:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "Identify",
          "package": "ideas",
          "source": "src/Ideas-Common-Id.html#Identify",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "Identify",
          "package": "ideas",
          "partial": "Identify",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#t:Identify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "IsId",
          "package": "ideas",
          "source": "src/Ideas-Common-Id.html#IsId",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "IsId",
          "package": "ideas",
          "partial": "Is Id",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#t:IsId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "(#)",
          "package": "ideas",
          "signature": "a -\u003e b -\u003e Id",
          "source": "src/Ideas-Common-Id.html#%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "(#) #",
          "normalized": "a-\u003eb-\u003eId",
          "package": "ideas",
          "signature": "a-\u003eb-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "(@\u003e)",
          "package": "ideas",
          "signature": "n -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Id.html#%40%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "(@\u003e) @\u003e",
          "normalized": "a-\u003eb-\u003eb",
          "package": "ideas",
          "signature": "n-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:-64--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "changeId",
          "package": "ideas",
          "signature": "(Id -\u003e Id) -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Id.html#changeId",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "changeId",
          "normalized": "(Id-\u003eId)-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Id",
          "signature": "(Id-\u003eId)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:changeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "compareId",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e Ordering",
          "source": "src/Ideas-Common-Id.html#compareId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "compareId",
          "normalized": "a-\u003ea-\u003eOrdering",
          "package": "ideas",
          "partial": "Id",
          "signature": "a-\u003ea-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:compareId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "concatId",
          "package": "ideas",
          "signature": "[a] -\u003e Id",
          "source": "src/Ideas-Common-Id.html#concatId",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "concatId",
          "normalized": "[a]-\u003eId",
          "package": "ideas",
          "partial": "Id",
          "signature": "[a]-\u003eId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:concatId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "describe",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Id.html#describe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "describe",
          "normalized": "String-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:describe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "description",
          "package": "ideas",
          "signature": "a -\u003e String",
          "source": "src/Ideas-Common-Id.html#description",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "description",
          "normalized": "a-\u003eString",
          "package": "ideas",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:description"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "getId",
          "package": "ideas",
          "signature": "a -\u003e Id",
          "source": "src/Ideas-Common-Id.html#getId",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "getId",
          "normalized": "a-\u003eId",
          "package": "ideas",
          "partial": "Id",
          "signature": "a-\u003eId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:getId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "isEmptyId",
          "package": "ideas",
          "signature": "Id -\u003e Bool",
          "source": "src/Ideas-Common-Id.html#isEmptyId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "isEmptyId",
          "normalized": "Id-\u003eBool",
          "package": "ideas",
          "partial": "Empty Id",
          "signature": "Id-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:isEmptyId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "listQualify",
          "package": "ideas",
          "signature": "[a] -\u003e b -\u003e Id",
          "source": "src/Ideas-Common-Id.html#listQualify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "listQualify",
          "normalized": "[a]-\u003eb-\u003eId",
          "package": "ideas",
          "partial": "Qualify",
          "signature": "[a]-\u003eb-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:listQualify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity of \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Id",
          "name": "mempty",
          "package": "ideas",
          "signature": "a",
          "type": "function"
        },
        "index": {
          "description": "Identity of mappend",
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "mempty",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:mempty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "newId",
          "package": "ideas",
          "signature": "a -\u003e Id",
          "source": "src/Ideas-Common-Id.html#newId",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "newId",
          "normalized": "a-\u003eId",
          "package": "ideas",
          "partial": "Id",
          "signature": "a-\u003eId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:newId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "qualification",
          "package": "ideas",
          "signature": "a -\u003e String",
          "source": "src/Ideas-Common-Id.html#qualification",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "qualification",
          "normalized": "a-\u003eString",
          "package": "ideas",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:qualification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "qualifiers",
          "package": "ideas",
          "signature": "a -\u003e [String]",
          "source": "src/Ideas-Common-Id.html#qualifiers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "qualifiers",
          "normalized": "a-\u003e[String]",
          "package": "ideas",
          "signature": "a-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:qualifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "sameId",
          "package": "ideas",
          "signature": "a -\u003e b -\u003e Bool",
          "source": "src/Ideas-Common-Id.html#sameId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "sameId",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "ideas",
          "partial": "Id",
          "signature": "a-\u003eb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:sameId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "showId",
          "package": "ideas",
          "signature": "a -\u003e String",
          "source": "src/Ideas-Common-Id.html#showId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "showId",
          "normalized": "a-\u003eString",
          "package": "ideas",
          "partial": "Id",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:showId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Id",
          "name": "unqualified",
          "package": "ideas",
          "signature": "a -\u003e String",
          "source": "src/Ideas-Common-Id.html#unqualified",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Id",
          "module": "Ideas.Common.Id",
          "name": "unqualified",
          "normalized": "a-\u003eString",
          "package": "ideas",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Id.html#v:unqualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExports most from package Common\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Library",
          "name": "Library",
          "package": "ideas",
          "source": "src/Ideas-Common-Library.html",
          "type": "module"
        },
        "index": {
          "description": "Exports most from package Common",
          "hierarchy": "Ideas Common Library",
          "module": "Ideas.Common.Library",
          "name": "Library",
          "package": "ideas",
          "partial": "Library",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Library.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for strategy combinator \u003ccode\u003efail\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Library",
          "name": "failS",
          "package": "ideas",
          "signature": "Strategy a",
          "source": "src/Ideas-Common-Library.html#failS",
          "type": "function"
        },
        "index": {
          "description": "Alias for strategy combinator fail",
          "hierarchy": "Ideas Common Library",
          "module": "Ideas.Common.Library",
          "name": "failS",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Library.html#v:failS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for strategy combinator \u003ccode\u003enot\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Library",
          "name": "notS",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Library.html#notS",
          "type": "function"
        },
        "index": {
          "description": "Alias for strategy combinator not",
          "hierarchy": "Ideas Common Library",
          "module": "Ideas.Common.Library",
          "name": "notS",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Library.html#v:notS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for strategy combinator \u003ccode\u003erepeat\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Library",
          "name": "repeatS",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Library.html#repeatS",
          "type": "function"
        },
        "index": {
          "description": "Alias for strategy combinator repeat",
          "hierarchy": "Ideas Common Library",
          "module": "Ideas.Common.Library",
          "name": "repeatS",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Library.html#v:repeatS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for strategy combinator \u003ccode\u003ereplicate\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Library",
          "name": "replicateS",
          "package": "ideas",
          "signature": "Int -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Library.html#replicateS",
          "type": "function"
        },
        "index": {
          "description": "Alias for strategy combinator replicate",
          "hierarchy": "Ideas Common Library",
          "module": "Ideas.Common.Library",
          "name": "replicateS",
          "normalized": "Int-\u003ea b-\u003eStrategy b",
          "package": "ideas",
          "signature": "Int-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Library.html#v:replicateS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for strategy combinator \u003ccode\u003esequence\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Library",
          "name": "sequenceS",
          "package": "ideas",
          "signature": "[f a] -\u003e Strategy a",
          "source": "src/Ideas-Common-Library.html#sequenceS",
          "type": "function"
        },
        "index": {
          "description": "Alias for strategy combinator sequence",
          "hierarchy": "Ideas Common Library",
          "module": "Ideas.Common.Library",
          "name": "sequenceS",
          "normalized": "[a b]-\u003eStrategy b",
          "package": "ideas",
          "signature": "[f a]-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Library.html#v:sequenceS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for strategy combinator \u003ccode\u003euntil\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Library",
          "name": "untilS",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Library.html#untilS",
          "type": "function"
        },
        "index": {
          "description": "Alias for strategy combinator until",
          "hierarchy": "Ideas Common Library",
          "module": "Ideas.Common.Library",
          "name": "untilS",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eStrategy a",
          "package": "ideas",
          "signature": "(a-\u003eBool)-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Library.html#v:untilS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation for predicates\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Predicate",
          "name": "Predicate",
          "package": "ideas",
          "source": "src/Ideas-Common-Predicate.html",
          "type": "module"
        },
        "index": {
          "description": "Representation for predicates",
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "Predicate",
          "package": "ideas",
          "partial": "Predicate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "BoolValue",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#BoolValue",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "BoolValue",
          "package": "ideas",
          "partial": "Bool Value",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#t:BoolValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "Boolean",
          "package": "ideas",
          "source": "src/Ideas-Common-Algebra-Boolean.html#Boolean",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "Boolean",
          "package": "ideas",
          "partial": "Boolean",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#t:Boolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "Predicate",
          "package": "ideas",
          "source": "src/Ideas-Common-Predicate.html#Predicate",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "Predicate",
          "package": "ideas",
          "partial": "Predicate",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#t:Predicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "(\u003c||\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#%3C%7C%7C%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "(\u003c||\u003e) \u003c||\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:-60--124--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "(\u003c&&\u003e)",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#%3C%26%26%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "(\u003c&&\u003e) \u003c&&\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:-60--38--38--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "complement",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#complement",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "complement",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:complement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "evalPredicate",
          "package": "ideas",
          "signature": "Predicate a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Predicate.html#evalPredicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "evalPredicate",
          "normalized": "Predicate a-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Predicate",
          "signature": "Predicate a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:evalPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "false",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#false",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "false",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:false"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "fromBool",
          "package": "ideas",
          "signature": "Bool -\u003e a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#fromBool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "fromBool",
          "normalized": "Bool-\u003ea",
          "package": "ideas",
          "partial": "Bool",
          "signature": "Bool-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:fromBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "isFalse",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Boolean.html#isFalse",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "isFalse",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "False",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:isFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "isTrue",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Algebra-Boolean.html#isTrue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "isTrue",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "True",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:isTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "predicate",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e Predicate a",
          "source": "src/Ideas-Common-Predicate.html#predicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "predicate",
          "normalized": "(a-\u003eBool)-\u003ePredicate a",
          "package": "ideas",
          "signature": "(a-\u003eBool)-\u003ePredicate a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:predicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "predicateView",
          "package": "ideas",
          "signature": "View a b -\u003e Predicate a",
          "source": "src/Ideas-Common-Predicate.html#predicateView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "predicateView",
          "normalized": "View a b-\u003ePredicate a",
          "package": "ideas",
          "partial": "View",
          "signature": "View a b-\u003ePredicate a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:predicateView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Predicate",
          "name": "true",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Common-Algebra-Boolean.html#true",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Predicate",
          "module": "Ideas.Common.Predicate",
          "name": "true",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Predicate.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "AC",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-AC.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "AC",
          "package": "ideas",
          "partial": "AC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "Pairings",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-AC.html#Pairings",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "Pairings",
          "package": "ideas",
          "partial": "Pairings",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#t:Pairings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "PairingsList",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-AC.html#PairingsList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "PairingsList",
          "package": "ideas",
          "partial": "Pairings List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#t:PairingsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "PairingsPair",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-AC.html#PairingsPair",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "PairingsPair",
          "package": "ideas",
          "partial": "Pairings Pair",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#t:PairingsPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsA",
          "package": "ideas",
          "signature": "Bool -\u003e PairingsList a b",
          "source": "src/Ideas-Common-Rewriting-AC.html#pairingsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsA",
          "normalized": "Bool-\u003ePairingsList a b",
          "package": "ideas",
          "signature": "Bool-\u003ePairingsList a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#v:pairingsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsAC",
          "package": "ideas",
          "signature": "Bool -\u003e PairingsList a b",
          "source": "src/Ideas-Common-Rewriting-AC.html#pairingsAC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsAC",
          "normalized": "Bool-\u003ePairingsList a b",
          "package": "ideas",
          "partial": "AC",
          "signature": "Bool-\u003ePairingsList a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#v:pairingsAC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsC",
          "package": "ideas",
          "signature": "PairingsPair a b",
          "source": "src/Ideas-Common-Rewriting-AC.html#pairingsC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsC",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#v:pairingsC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsMatchA",
          "package": "ideas",
          "signature": "(a -\u003e [b] -\u003e c) -\u003e [a] -\u003e [b] -\u003e [[c]]",
          "source": "src/Ideas-Common-Rewriting-AC.html#pairingsMatchA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsMatchA",
          "normalized": "(a-\u003e[b]-\u003ec)-\u003e[a]-\u003e[b]-\u003e[[c]]",
          "package": "ideas",
          "partial": "Match",
          "signature": "(a-\u003e[b]-\u003ec)-\u003e[a]-\u003e[b]-\u003e[[c]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#v:pairingsMatchA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsNone",
          "package": "ideas",
          "signature": "PairingsPair a b",
          "source": "src/Ideas-Common-Rewriting-AC.html#pairingsNone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting AC",
          "module": "Ideas.Common.Rewriting.AC",
          "name": "pairingsNone",
          "package": "ideas",
          "partial": "None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-AC.html#v:pairingsNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "Confluence",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Confluence.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "Confluence",
          "package": "ideas",
          "partial": "Confluence",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "Config",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#Config",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "Config",
          "package": "ideas",
          "partial": "Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#t:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "checkConfluence",
          "package": "ideas",
          "signature": "[RewriteRule a] -\u003e IO ()",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#checkConfluence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "checkConfluence",
          "normalized": "[RewriteRule a]-\u003eIO()",
          "package": "ideas",
          "partial": "Confluence",
          "signature": "[RewriteRule a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:checkConfluence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "checkConfluenceWith",
          "package": "ideas",
          "signature": "Config -\u003e [RewriteRule a] -\u003e IO ()",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#checkConfluenceWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "checkConfluenceWith",
          "normalized": "Config-\u003e[RewriteRule a]-\u003eIO()",
          "package": "ideas",
          "partial": "Confluence With",
          "signature": "Config-\u003e[RewriteRule a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:checkConfluenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "complexity",
          "package": "ideas",
          "signature": "Config -\u003e Term -\u003e Int",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#complexity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "complexity",
          "normalized": "Config-\u003eTerm-\u003eInt",
          "package": "ideas",
          "signature": "Config-\u003eTerm-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:complexity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "defaultConfig",
          "package": "ideas",
          "signature": "Config",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#defaultConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "defaultConfig",
          "package": "ideas",
          "partial": "Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:defaultConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "isConfluent",
          "package": "ideas",
          "signature": "[RewriteRule a] -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#isConfluent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "isConfluent",
          "normalized": "[RewriteRule a]-\u003eBool",
          "package": "ideas",
          "partial": "Confluent",
          "signature": "[RewriteRule a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:isConfluent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "showTerm",
          "package": "ideas",
          "signature": "Config -\u003e Term -\u003e String",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#showTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "showTerm",
          "normalized": "Config-\u003eTerm-\u003eString",
          "package": "ideas",
          "partial": "Term",
          "signature": "Config-\u003eTerm-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:showTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "somewhereM",
          "package": "ideas",
          "signature": "(a -\u003e [a]) -\u003e a -\u003e [a]",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#somewhereM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "somewhereM",
          "normalized": "(a-\u003e[a])-\u003ea-\u003e[a]",
          "package": "ideas",
          "signature": "(a-\u003e[a])-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:somewhereM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "termEquality",
          "package": "ideas",
          "signature": "Config -\u003e Term -\u003e Term -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Confluence.html#termEquality",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Confluence",
          "module": "Ideas.Common.Rewriting.Confluence",
          "name": "termEquality",
          "normalized": "Config-\u003eTerm-\u003eTerm-\u003eBool",
          "package": "ideas",
          "partial": "Equality",
          "signature": "Config-\u003eTerm-\u003eTerm-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Confluence.html#v:termEquality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompute the difference of two terms generically, taking associativity\n into account.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "Difference",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Difference.html",
          "type": "module"
        },
        "index": {
          "description": "Compute the difference of two terms generically taking associativity into account",
          "hierarchy": "Ideas Common Rewriting Difference",
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "Difference",
          "package": "ideas",
          "partial": "Difference",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Difference.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "difference",
          "package": "ideas",
          "signature": "a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Rewriting-Difference.html#difference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Difference",
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "difference",
          "normalized": "a-\u003ea-\u003eMaybe(a,a)",
          "package": "ideas",
          "signature": "a-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Difference.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function returns the difference, except that the\n returned terms should be logically equivalent. Nothing can signal that\n there is no difference, or that the terms to start with are not equivalent.\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "differenceEqual",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Rewriting-Difference.html#differenceEqual",
          "type": "function"
        },
        "index": {
          "description": "This function returns the difference except that the returned terms should be logically equivalent Nothing can signal that there is no difference or that the terms to start with are not equivalent",
          "hierarchy": "Ideas Common Rewriting Difference",
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "differenceEqual",
          "normalized": "(a-\u003ea-\u003eBool)-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Equal",
          "signature": "(a-\u003ea-\u003eBool)-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Difference.html#v:differenceEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "differenceEqualWith",
          "package": "ideas",
          "signature": "View Term a -\u003e (a -\u003e a -\u003e Bool) -\u003e a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Rewriting-Difference.html#differenceEqualWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Difference",
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "differenceEqualWith",
          "normalized": "View Term a-\u003e(a-\u003ea-\u003eBool)-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "Equal With",
          "signature": "View Term a-\u003e(a-\u003ea-\u003eBool)-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Difference.html#v:differenceEqualWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "differenceWith",
          "package": "ideas",
          "signature": "View Term a -\u003e a -\u003e a -\u003e Maybe (a, a)",
          "source": "src/Ideas-Common-Rewriting-Difference.html#differenceWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Difference",
          "module": "Ideas.Common.Rewriting.Difference",
          "name": "differenceWith",
          "normalized": "View Term a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "package": "ideas",
          "partial": "With",
          "signature": "View Term a-\u003ea-\u003ea-\u003eMaybe(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Difference.html#v:differenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RewriteRule",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RewriteRule",
          "package": "ideas",
          "partial": "Rewrite Rule",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "Different",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#Different",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "Different",
          "package": "ideas",
          "partial": "Different",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#t:Different"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RewriteRule",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#RewriteRule",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RewriteRule",
          "package": "ideas",
          "partial": "Rewrite Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#t:RewriteRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RuleBuilder",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#RuleBuilder",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RuleBuilder",
          "package": "ideas",
          "partial": "Rule Builder",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#t:RuleBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RuleSpec",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#RuleSpec",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "RuleSpec",
          "package": "ideas",
          "partial": "Rule Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#t:RuleSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": ":~\u003e",
          "package": "ideas",
          "signature": "a :~\u003e a",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#RuleSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": ":~\u003e",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v::-126--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "buildRuleSpec",
          "package": "ideas",
          "signature": "Int -\u003e t -\u003e RuleSpec Term",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#buildRuleSpec",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "buildRuleSpec",
          "normalized": "Int-\u003ea-\u003eRuleSpec Term",
          "package": "ideas",
          "partial": "Rule Spec",
          "signature": "Int-\u003et-\u003eRuleSpec Term",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:buildRuleSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "different",
          "package": "ideas",
          "signature": "(a, a)",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#different",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "different",
          "normalized": "(a,a)",
          "package": "ideas",
          "signature": "(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:different"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "makeRewriteRule",
          "package": "ideas",
          "signature": "n -\u003e f -\u003e RewriteRule a",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#makeRewriteRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "makeRewriteRule",
          "normalized": "a-\u003eb-\u003eRewriteRule c",
          "package": "ideas",
          "partial": "Rewrite Rule",
          "signature": "n-\u003ef-\u003eRewriteRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:makeRewriteRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "metaInRewriteRule",
          "package": "ideas",
          "signature": "RewriteRule a -\u003e [Int]",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#metaInRewriteRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "metaInRewriteRule",
          "normalized": "RewriteRule a-\u003e[Int]",
          "package": "ideas",
          "partial": "In Rewrite Rule",
          "signature": "RewriteRule a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:metaInRewriteRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "renumberRewriteRule",
          "package": "ideas",
          "signature": "Int -\u003e RewriteRule a -\u003e RewriteRule a",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#renumberRewriteRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "renumberRewriteRule",
          "normalized": "Int-\u003eRewriteRule a-\u003eRewriteRule a",
          "package": "ideas",
          "partial": "Rewrite Rule",
          "signature": "Int-\u003eRewriteRule a-\u003eRewriteRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:renumberRewriteRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "ruleSpecTerm",
          "package": "ideas",
          "signature": "RewriteRule a -\u003e RuleSpec Term",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#ruleSpecTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "ruleSpecTerm",
          "normalized": "RewriteRule a-\u003eRuleSpec Term",
          "package": "ideas",
          "partial": "Spec Term",
          "signature": "RewriteRule a-\u003eRuleSpec Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:ruleSpecTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "showRewriteRule",
          "package": "ideas",
          "signature": "Bool -\u003e RewriteRule a -\u003e Maybe String",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#showRewriteRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "showRewriteRule",
          "normalized": "Bool-\u003eRewriteRule a-\u003eMaybe String",
          "package": "ideas",
          "partial": "Rewrite Rule",
          "signature": "Bool-\u003eRewriteRule a-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:showRewriteRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "symbolBuilder",
          "package": "ideas",
          "signature": "Symbol -\u003e ([Term] -\u003e Term) -\u003e RewriteRule a -\u003e RewriteRule a",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#symbolBuilder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "symbolBuilder",
          "normalized": "Symbol-\u003e([Term]-\u003eTerm)-\u003eRewriteRule a-\u003eRewriteRule a",
          "package": "ideas",
          "partial": "Builder",
          "signature": "Symbol-\u003e([Term]-\u003eTerm)-\u003eRewriteRule a-\u003eRewriteRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:symbolBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "symbolMatcher",
          "package": "ideas",
          "signature": "Symbol -\u003e SymbolMatch -\u003e RewriteRule a -\u003e RewriteRule a",
          "source": "src/Ideas-Common-Rewriting-RewriteRule.html#symbolMatcher",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting RewriteRule",
          "module": "Ideas.Common.Rewriting.RewriteRule",
          "name": "symbolMatcher",
          "normalized": "Symbol-\u003eSymbolMatch-\u003eRewriteRule a-\u003eRewriteRule a",
          "package": "ideas",
          "partial": "Matcher",
          "signature": "Symbol-\u003eSymbolMatch-\u003eRewriteRule a-\u003eRewriteRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-RewriteRule.html#v:symbolMatcher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSubstitutions on terms. Substitutions are idempotent, and non-cyclic.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "Substitution",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Substitution.html",
          "type": "module"
        },
        "index": {
          "description": "Substitutions on terms Substitutions are idempotent and non-cyclic",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "Substitution",
          "package": "ideas",
          "partial": "Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for substitutions\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "Substitution",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#Substitution",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for substitutions",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "Substitution",
          "package": "ideas",
          "partial": "Substitution",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#t:Substitution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the substitution\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "(|-\u003e)",
          "package": "ideas",
          "signature": "Substitution -\u003e Term -\u003e Term",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#%7C-%3E",
          "type": "function"
        },
        "index": {
          "description": "Apply the substitution",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "(|-\u003e) |-\u003e",
          "normalized": "Substitution-\u003eTerm-\u003eTerm",
          "package": "ideas",
          "signature": "Substitution-\u003eTerm-\u003eTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:-124--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "(@+@)",
          "package": "ideas",
          "signature": "Substitution -\u003e Substitution -\u003e Maybe Substitution",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#%40%2B%40",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "(@+@) @+@",
          "normalized": "Substitution-\u003eSubstitution-\u003eMaybe Substitution",
          "package": "ideas",
          "signature": "Substitution-\u003eSubstitution-\u003eMaybe Substitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:-64--43--64-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines two substitutions. The left-hand side substitution is first applied to\n the co-domain of the right-hand side substitution\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "(@@)",
          "package": "ideas",
          "signature": "Substitution -\u003e Substitution -\u003e Substitution",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#%40%40",
          "type": "function"
        },
        "index": {
          "description": "Combines two substitutions The left-hand side substitution is first applied to the co-domain of the right-hand side substitution",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "(@@) @@",
          "normalized": "Substitution-\u003eSubstitution-\u003eSubstitution",
          "package": "ideas",
          "signature": "Substitution-\u003eSubstitution-\u003eSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:-64--64-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "composable",
          "package": "ideas",
          "signature": "Substitution -\u003e Substitution -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#composable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "composable",
          "normalized": "Substitution-\u003eSubstitution-\u003eBool",
          "package": "ideas",
          "signature": "Substitution-\u003eSubstitution-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:composable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the domain of a substitution (as a set)\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "dom",
          "package": "ideas",
          "signature": "Substitution -\u003e IntSet",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#dom",
          "type": "function"
        },
        "index": {
          "description": "Returns the domain of substitution as set",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "dom",
          "normalized": "Substitution-\u003eIntSet",
          "package": "ideas",
          "signature": "Substitution-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:dom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the empty substitution\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "emptySubst",
          "package": "ideas",
          "signature": "Substitution",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#emptySubst",
          "type": "function"
        },
        "index": {
          "description": "Returns the empty substitution",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "emptySubst",
          "package": "ideas",
          "partial": "Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:emptySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurns a list into a substitution\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "listToSubst",
          "package": "ideas",
          "signature": "[(Int, Term)] -\u003e Substitution",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#listToSubst",
          "type": "function"
        },
        "index": {
          "description": "Turns list into substitution",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "listToSubst",
          "normalized": "[(Int,Term)]-\u003eSubstitution",
          "package": "ideas",
          "partial": "To Subst",
          "signature": "[(Int,Term)]-\u003eSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:listToSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookups a variable in a substitution. Nothing indicates that the variable is\n not in the domain of the substitution\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "lookupVar",
          "package": "ideas",
          "signature": "Int -\u003e Substitution -\u003e Maybe Term",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#lookupVar",
          "type": "function"
        },
        "index": {
          "description": "Lookups variable in substitution Nothing indicates that the variable is not in the domain of the substitution",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "lookupVar",
          "normalized": "Int-\u003eSubstitution-\u003eMaybe Term",
          "package": "ideas",
          "partial": "Var",
          "signature": "Int-\u003eSubstitution-\u003eMaybe Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:lookupVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a singleton substitution\n\u003c/p\u003e",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "singletonSubst",
          "package": "ideas",
          "signature": "Int -\u003e Term -\u003e Substitution",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#singletonSubst",
          "type": "function"
        },
        "index": {
          "description": "Returns singleton substitution",
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "singletonSubst",
          "normalized": "Int-\u003eTerm-\u003eSubstitution",
          "package": "ideas",
          "partial": "Subst",
          "signature": "Int-\u003eTerm-\u003eSubstitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:singletonSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "tests",
          "package": "ideas",
          "signature": "TestSuite",
          "source": "src/Ideas-Common-Rewriting-Substitution.html#tests",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Substitution",
          "module": "Ideas.Common.Rewriting.Substitution",
          "name": "tests",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Substitution.html#v:tests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple data type for term rewriting\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "Term",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Term.html",
          "type": "module"
        },
        "index": {
          "description": "simple data type for term rewriting",
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "Term",
          "package": "ideas",
          "partial": "Term",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "IsTerm",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Term.html#IsTerm",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "IsTerm",
          "package": "ideas",
          "partial": "Is Term",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#t:IsTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "Symbol",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Term.html#Symbol",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "Symbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#t:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "Term",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Term.html#Term",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "Term",
          "package": "ideas",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "WithFunctions",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Term.html#WithFunctions",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "WithFunctions",
          "package": "ideas",
          "partial": "With Functions",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#t:WithFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "WithMetaVars",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Term.html#WithMetaVars",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "WithMetaVars",
          "package": "ideas",
          "partial": "With Meta Vars",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#t:WithMetaVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "WithVars",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Term.html#WithVars",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "WithVars",
          "package": "ideas",
          "partial": "With Vars",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#t:WithVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TCon",
          "package": "ideas",
          "signature": "TCon Symbol [Term]",
          "source": "src/Ideas-Common-Rewriting-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TCon",
          "normalized": "TCon Symbol[Term]",
          "package": "ideas",
          "partial": "TCon",
          "signature": "TCon Symbol[Term]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:TCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TFloat",
          "package": "ideas",
          "signature": "TFloat Double",
          "source": "src/Ideas-Common-Rewriting-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TFloat",
          "package": "ideas",
          "partial": "TFloat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:TFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TList",
          "package": "ideas",
          "signature": "TList [Term]",
          "source": "src/Ideas-Common-Rewriting-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TList",
          "normalized": "TList[Term]",
          "package": "ideas",
          "partial": "TList",
          "signature": "TList[Term]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:TList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TMeta",
          "package": "ideas",
          "signature": "TMeta Int",
          "source": "src/Ideas-Common-Rewriting-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TMeta",
          "package": "ideas",
          "partial": "TMeta",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:TMeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TNum",
          "package": "ideas",
          "signature": "TNum Integer",
          "source": "src/Ideas-Common-Rewriting-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TNum",
          "package": "ideas",
          "partial": "TNum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:TNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TVar",
          "package": "ideas",
          "signature": "TVar String",
          "source": "src/Ideas-Common-Rewriting-Term.html#Term",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "TVar",
          "package": "ideas",
          "partial": "TVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:TVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "binary",
          "package": "ideas",
          "signature": "Symbol -\u003e a -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Rewriting-Term.html#binary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "binary",
          "normalized": "Symbol-\u003ea-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "Symbol-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:binary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "fromTerm",
          "package": "ideas",
          "signature": "Term -\u003e m a",
          "source": "src/Ideas-Common-Rewriting-Term.html#fromTerm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "fromTerm",
          "normalized": "Term-\u003ea b",
          "package": "ideas",
          "partial": "Term",
          "signature": "Term-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:fromTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "fromTermM",
          "package": "ideas",
          "signature": "Term -\u003e m a",
          "source": "src/Ideas-Common-Rewriting-Term.html#fromTermM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "fromTermM",
          "normalized": "Term-\u003ea b",
          "package": "ideas",
          "partial": "Term",
          "signature": "Term-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:fromTermM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "fromTermWith",
          "package": "ideas",
          "signature": "(Symbol -\u003e [a] -\u003e m a) -\u003e Term -\u003e m a",
          "source": "src/Ideas-Common-Rewriting-Term.html#fromTermWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "fromTermWith",
          "normalized": "(Symbol-\u003e[a]-\u003eb a)-\u003eTerm-\u003eb a",
          "package": "ideas",
          "partial": "Term With",
          "signature": "(Symbol-\u003e[a]-\u003em a)-\u003eTerm-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:fromTermWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "function",
          "package": "ideas",
          "signature": "Symbol -\u003e [a] -\u003e a",
          "source": "src/Ideas-Common-Rewriting-Term.html#function",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "function",
          "normalized": "Symbol-\u003e[a]-\u003ea",
          "package": "ideas",
          "signature": "Symbol-\u003e[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getFunction",
          "package": "ideas",
          "signature": "a -\u003e m (Symbol, [a])",
          "source": "src/Ideas-Common-Rewriting-Term.html#getFunction",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getFunction",
          "normalized": "a-\u003eb(Symbol,[a])",
          "package": "ideas",
          "partial": "Function",
          "signature": "a-\u003em(Symbol,[a])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:getFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getMetaVar",
          "package": "ideas",
          "signature": "a -\u003e m Int",
          "source": "src/Ideas-Common-Rewriting-Term.html#getMetaVar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getMetaVar",
          "normalized": "a-\u003eb Int",
          "package": "ideas",
          "partial": "Meta Var",
          "signature": "a-\u003em Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:getMetaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getSymbol",
          "package": "ideas",
          "signature": "a -\u003e m Symbol",
          "source": "src/Ideas-Common-Rewriting-Term.html#getSymbol",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getSymbol",
          "normalized": "a-\u003eb Symbol",
          "package": "ideas",
          "partial": "Symbol",
          "signature": "a-\u003em Symbol",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:getSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getVariable",
          "package": "ideas",
          "signature": "a -\u003e m String",
          "source": "src/Ideas-Common-Rewriting-Term.html#getVariable",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "getVariable",
          "normalized": "a-\u003eb String",
          "package": "ideas",
          "partial": "Variable",
          "signature": "a-\u003em String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:getVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasMetaVar",
          "package": "ideas",
          "signature": "Int -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#hasMetaVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasMetaVar",
          "normalized": "Int-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Meta Var",
          "signature": "Int-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:hasMetaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasNoVar",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#hasNoVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasNoVar",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "No Var",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:hasNoVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasSomeVar",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#hasSomeVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasSomeVar",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Some Var",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:hasSomeVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasVar",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#hasVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "hasVar",
          "normalized": "String-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Var",
          "signature": "String-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:hasVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isAssociative",
          "package": "ideas",
          "signature": "Symbol -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#isAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isAssociative",
          "normalized": "Symbol-\u003eBool",
          "package": "ideas",
          "partial": "Associative",
          "signature": "Symbol-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:isAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isBinary",
          "package": "ideas",
          "signature": "Symbol -\u003e a -\u003e m (a, a)",
          "source": "src/Ideas-Common-Rewriting-Term.html#isBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isBinary",
          "normalized": "Symbol-\u003ea-\u003eb(a,a)",
          "package": "ideas",
          "partial": "Binary",
          "signature": "Symbol-\u003ea-\u003em(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:isBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isFunction",
          "package": "ideas",
          "signature": "Symbol -\u003e a -\u003e m [a]",
          "source": "src/Ideas-Common-Rewriting-Term.html#isFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isFunction",
          "normalized": "Symbol-\u003ea-\u003eb[a]",
          "package": "ideas",
          "partial": "Function",
          "signature": "Symbol-\u003ea-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:isFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isMetaVar",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#isMetaVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isMetaVar",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Meta Var",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:isMetaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isSymbol",
          "package": "ideas",
          "signature": "Symbol -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#isSymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isSymbol",
          "normalized": "Symbol-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Symbol",
          "signature": "Symbol-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:isSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isUnary",
          "package": "ideas",
          "signature": "Symbol -\u003e a -\u003e m a",
          "source": "src/Ideas-Common-Rewriting-Term.html#isUnary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isUnary",
          "normalized": "Symbol-\u003ea-\u003eb a",
          "package": "ideas",
          "partial": "Unary",
          "signature": "Symbol-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:isUnary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isVariable",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#isVariable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "isVariable",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Variable",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:isVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "makeAssociative",
          "package": "ideas",
          "signature": "Symbol -\u003e Symbol",
          "source": "src/Ideas-Common-Rewriting-Term.html#makeAssociative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "makeAssociative",
          "normalized": "Symbol-\u003eSymbol",
          "package": "ideas",
          "partial": "Associative",
          "signature": "Symbol-\u003eSymbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:makeAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "metaVar",
          "package": "ideas",
          "signature": "Int -\u003e a",
          "source": "src/Ideas-Common-Rewriting-Term.html#metaVar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "metaVar",
          "normalized": "Int-\u003ea",
          "package": "ideas",
          "partial": "Var",
          "signature": "Int-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:metaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "metaVarSet",
          "package": "ideas",
          "signature": "a -\u003e IntSet",
          "source": "src/Ideas-Common-Rewriting-Term.html#metaVarSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "metaVarSet",
          "normalized": "a-\u003eIntSet",
          "package": "ideas",
          "partial": "Var Set",
          "signature": "a-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:metaVarSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "metaVars",
          "package": "ideas",
          "signature": "a -\u003e [Int]",
          "source": "src/Ideas-Common-Rewriting-Term.html#metaVars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "metaVars",
          "normalized": "a-\u003e[Int]",
          "package": "ideas",
          "partial": "Vars",
          "signature": "a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:metaVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "newSymbol",
          "package": "ideas",
          "signature": "a -\u003e Symbol",
          "source": "src/Ideas-Common-Rewriting-Term.html#newSymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "newSymbol",
          "normalized": "a-\u003eSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "signature": "a-\u003eSymbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:newSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "nextMetaVar",
          "package": "ideas",
          "signature": "a -\u003e Int",
          "source": "src/Ideas-Common-Rewriting-Term.html#nextMetaVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "nextMetaVar",
          "normalized": "a-\u003eInt",
          "package": "ideas",
          "partial": "Meta Var",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:nextMetaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "symbol",
          "package": "ideas",
          "signature": "Symbol -\u003e a",
          "source": "src/Ideas-Common-Rewriting-Term.html#symbol",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "symbol",
          "normalized": "Symbol-\u003ea",
          "package": "ideas",
          "signature": "Symbol-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "termView",
          "package": "ideas",
          "signature": "View Term a",
          "source": "src/Ideas-Common-Rewriting-Term.html#termView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "termView",
          "package": "ideas",
          "partial": "View",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:termView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "toTerm",
          "package": "ideas",
          "signature": "a -\u003e Term",
          "source": "src/Ideas-Common-Rewriting-Term.html#toTerm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "toTerm",
          "normalized": "a-\u003eTerm",
          "package": "ideas",
          "partial": "Term",
          "signature": "a-\u003eTerm",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:toTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "unary",
          "package": "ideas",
          "signature": "Symbol -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Rewriting-Term.html#unary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "unary",
          "normalized": "Symbol-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "Symbol-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:unary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "varSet",
          "package": "ideas",
          "signature": "a -\u003e Set String",
          "source": "src/Ideas-Common-Rewriting-Term.html#varSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "varSet",
          "normalized": "a-\u003eSet String",
          "package": "ideas",
          "partial": "Set",
          "signature": "a-\u003eSet String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:varSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "variable",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Common-Rewriting-Term.html#variable",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "variable",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:variable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "variableView",
          "package": "ideas",
          "signature": "View a String",
          "source": "src/Ideas-Common-Rewriting-Term.html#variableView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "variableView",
          "package": "ideas",
          "partial": "View",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:variableView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "vars",
          "package": "ideas",
          "signature": "a -\u003e [String]",
          "source": "src/Ideas-Common-Rewriting-Term.html#vars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "vars",
          "normalized": "a-\u003e[String]",
          "package": "ideas",
          "signature": "a-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Term",
          "name": "withoutVar",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-Rewriting-Term.html#withoutVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Term",
          "module": "Ideas.Common.Rewriting.Term",
          "name": "withoutVar",
          "normalized": "String-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Var",
          "signature": "String-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Term.html#v:withoutVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "Unification",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Unification.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "Unification",
          "package": "ideas",
          "partial": "Unification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "Match",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Unification.html#Match",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "Match",
          "package": "ideas",
          "partial": "Match",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#t:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "SymbolMatch",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting-Unification.html#SymbolMatch",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "SymbolMatch",
          "package": "ideas",
          "partial": "Symbol Match",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#t:SymbolMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "match",
          "package": "ideas",
          "signature": "Term -\u003e Term -\u003e m Substitution",
          "source": "src/Ideas-Common-Rewriting-Unification.html#match",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "match",
          "normalized": "Term-\u003eTerm-\u003ea Substitution",
          "package": "ideas",
          "signature": "Term-\u003eTerm-\u003em Substitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "matchExtended",
          "package": "ideas",
          "signature": "Map Symbol SymbolMatch -\u003e Term -\u003e Term -\u003e [(Substitution, Maybe Term, Maybe Term)]",
          "source": "src/Ideas-Common-Rewriting-Unification.html#matchExtended",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "matchExtended",
          "normalized": "Map Symbol SymbolMatch-\u003eTerm-\u003eTerm-\u003e[(Substitution,Maybe Term,Maybe Term)]",
          "package": "ideas",
          "partial": "Extended",
          "signature": "Map Symbol SymbolMatch-\u003eTerm-\u003eTerm-\u003e[(Substitution,Maybe Term,Maybe Term)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#v:matchExtended"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "matchList",
          "package": "ideas",
          "signature": "Match Term -\u003e Match [Term]",
          "source": "src/Ideas-Common-Rewriting-Unification.html#matchList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "matchList",
          "normalized": "Match Term-\u003eMatch[Term]",
          "package": "ideas",
          "partial": "List",
          "signature": "Match Term-\u003eMatch[Term]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#v:matchList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "unificationTests",
          "package": "ideas",
          "signature": "TestSuite",
          "source": "src/Ideas-Common-Rewriting-Unification.html#unificationTests",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "unificationTests",
          "package": "ideas",
          "partial": "Tests",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#v:unificationTests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "unify",
          "package": "ideas",
          "signature": "Term -\u003e Term -\u003e Maybe Substitution",
          "source": "src/Ideas-Common-Rewriting-Unification.html#unify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting Unification",
          "module": "Ideas.Common.Rewriting.Unification",
          "name": "unify",
          "normalized": "Term-\u003eTerm-\u003eMaybe Substitution",
          "package": "ideas",
          "signature": "Term-\u003eTerm-\u003eMaybe Substitution",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting-Unification.html#v:unify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rewriting",
          "name": "Rewriting",
          "package": "ideas",
          "source": "src/Ideas-Common-Rewriting.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Rewriting",
          "module": "Ideas.Common.Rewriting",
          "name": "Rewriting",
          "package": "ideas",
          "partial": "Rewriting",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rewriting.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA rule is just a transformation with some meta-information, such as a name\n (which should be unique) and properties such as \u003ca\u003ebuggy\u003c/a\u003e or \u003ca\u003eminor\u003c/a\u003e. Rules\n can be lifted with a view using the LiftView type class.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "Abstract",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Abstract.html",
          "type": "module"
        },
        "index": {
          "description": "rule is just transformation with some meta-information such as name which should be unique and properties such as buggy or minor Rules can be lifted with view using the LiftView type class",
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "Abstract",
          "package": "ideas",
          "partial": "Abstract",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for representing rules\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "Rule",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Abstract.html#Rule",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for representing rules",
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "Rule",
          "package": "ideas",
          "partial": "Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#t:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addRecognizer",
          "package": "ideas",
          "signature": "Recognizer a -\u003e Rule a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#addRecognizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addRecognizer",
          "normalized": "Recognizer a-\u003eRule a-\u003eRule a",
          "package": "ideas",
          "partial": "Recognizer",
          "signature": "Recognizer a-\u003eRule a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:addRecognizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addRecognizerBool",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Rule a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#addRecognizerBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addRecognizerBool",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eRule a-\u003eRule a",
          "package": "ideas",
          "partial": "Recognizer Bool",
          "signature": "(a-\u003ea-\u003eBool)-\u003eRule a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:addRecognizerBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addRecognizerEnvMonad",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e EnvMonad ()) -\u003e Rule a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#addRecognizerEnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addRecognizerEnvMonad",
          "normalized": "(a-\u003ea-\u003eEnvMonad())-\u003eRule a-\u003eRule a",
          "package": "ideas",
          "partial": "Recognizer Env Monad",
          "signature": "(a-\u003ea-\u003eEnvMonad())-\u003eRule a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:addRecognizerEnvMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addTransRecognizer",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Rule a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#addTransRecognizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "addTransRecognizer",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eRule a-\u003eRule a",
          "package": "ideas",
          "partial": "Trans Recognizer",
          "signature": "(a-\u003ea-\u003eBool)-\u003eRule a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:addTransRecognizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "buggyRule",
          "package": "ideas",
          "signature": "n -\u003e (a -\u003e f a) -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#buggyRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "buggyRule",
          "normalized": "a-\u003e(b-\u003ec b)-\u003eRule b",
          "package": "ideas",
          "partial": "Rule",
          "signature": "n-\u003e(a-\u003ef a)-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:buggyRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "checkReferences",
          "package": "ideas",
          "signature": "Rule a -\u003e Environment -\u003e Maybe String",
          "source": "src/Ideas-Common-Rule-Abstract.html#checkReferences",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "checkReferences",
          "normalized": "Rule a-\u003eEnvironment-\u003eMaybe String",
          "package": "ideas",
          "partial": "References",
          "signature": "Rule a-\u003eEnvironment-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:checkReferences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special (minor) rule that checks a predicate (and returns the identity\n if the predicate holds)\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "checkRule",
          "package": "ideas",
          "signature": "n -\u003e (a -\u003e Bool) -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#checkRule",
          "type": "function"
        },
        "index": {
          "description": "special minor rule that checks predicate and returns the identity if the predicate holds",
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "checkRule",
          "normalized": "a-\u003e(b-\u003eBool)-\u003eRule b",
          "package": "ideas",
          "partial": "Rule",
          "signature": "n-\u003e(a-\u003eBool)-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:checkRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform the function after the rule has been fired\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "doAfter",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e Rule a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#doAfter",
          "type": "function"
        },
        "index": {
          "description": "Perform the function after the rule has been fired",
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "doAfter",
          "normalized": "(a-\u003ea)-\u003eRule a-\u003eRule a",
          "package": "ideas",
          "partial": "After",
          "signature": "(a-\u003ea)-\u003eRule a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:doAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special (minor) rule that is never applicable (i.e., this rule always fails)\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "emptyRule",
          "package": "ideas",
          "signature": "n -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#emptyRule",
          "type": "function"
        },
        "index": {
          "description": "special minor rule that is never applicable i.e this rule always fails",
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "emptyRule",
          "normalized": "a-\u003eRule b",
          "package": "ideas",
          "partial": "Rule",
          "signature": "n-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:emptyRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special (minor) rule that always returns the identity\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "idRule",
          "package": "ideas",
          "signature": "n -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#idRule",
          "type": "function"
        },
        "index": {
          "description": "special minor rule that always returns the identity",
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "idRule",
          "normalized": "a-\u003eRule b",
          "package": "ideas",
          "partial": "Rule",
          "signature": "n-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:idRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "isRecognizer",
          "package": "ideas",
          "signature": "Rule a -\u003e Bool",
          "source": "src/Ideas-Common-Rule-Abstract.html#isRecognizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "isRecognizer",
          "normalized": "Rule a-\u003eBool",
          "package": "ideas",
          "partial": "Recognizer",
          "signature": "Rule a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:isRecognizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "isRewriteRule",
          "package": "ideas",
          "signature": "Rule a -\u003e Bool",
          "source": "src/Ideas-Common-Rule-Abstract.html#isRewriteRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "isRewriteRule",
          "normalized": "Rule a-\u003eBool",
          "package": "ideas",
          "partial": "Rewrite Rule",
          "signature": "Rule a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:isRewriteRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "makeRule",
          "package": "ideas",
          "signature": "n -\u003e (a -\u003e f a) -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#makeRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "makeRule",
          "normalized": "a-\u003e(b-\u003ec b)-\u003eRule b",
          "package": "ideas",
          "partial": "Rule",
          "signature": "n-\u003e(a-\u003ef a)-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:makeRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "minorRule",
          "package": "ideas",
          "signature": "n -\u003e (a -\u003e f a) -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#minorRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "minorRule",
          "normalized": "a-\u003e(b-\u003ec b)-\u003eRule b",
          "package": "ideas",
          "partial": "Rule",
          "signature": "n-\u003e(a-\u003ef a)-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:minorRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "recognizer",
          "package": "ideas",
          "signature": "f a -\u003e Recognizer a",
          "source": "src/Ideas-Common-Rule-Recognizer.html#recognizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "recognizer",
          "normalized": "a b-\u003eRecognizer b",
          "package": "ideas",
          "signature": "f a-\u003eRecognizer a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:recognizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "rewriteRule",
          "package": "ideas",
          "signature": "n -\u003e f -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#rewriteRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "rewriteRule",
          "normalized": "a-\u003eb-\u003eRule c",
          "package": "ideas",
          "partial": "Rule",
          "signature": "n-\u003ef-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:rewriteRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "rewriteRules",
          "package": "ideas",
          "signature": "n -\u003e [f] -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#rewriteRules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "rewriteRules",
          "normalized": "a-\u003e[b]-\u003eRule c",
          "package": "ideas",
          "partial": "Rules",
          "signature": "n-\u003e[f]-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:rewriteRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleList",
          "package": "ideas",
          "signature": "n -\u003e (a -\u003e [a]) -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#ruleList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleList",
          "normalized": "a-\u003e(b-\u003e[b])-\u003eRule b",
          "package": "ideas",
          "partial": "List",
          "signature": "n-\u003e(a-\u003e[a])-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:ruleList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleMaybe",
          "package": "ideas",
          "signature": "n -\u003e (a -\u003e Maybe a) -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#ruleMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleMaybe",
          "normalized": "a-\u003e(b-\u003eMaybe b)-\u003eRule b",
          "package": "ideas",
          "partial": "Maybe",
          "signature": "n-\u003e(a-\u003eMaybe a)-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:ruleMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleRewrite",
          "package": "ideas",
          "signature": "RewriteRule a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#ruleRewrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleRewrite",
          "normalized": "RewriteRule a-\u003eRule a",
          "package": "ideas",
          "partial": "Rewrite",
          "signature": "RewriteRule a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:ruleRewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleSiblings",
          "package": "ideas",
          "signature": "Rule a -\u003e [Id]",
          "source": "src/Ideas-Common-Rule-Abstract.html#ruleSiblings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleSiblings",
          "normalized": "Rule a-\u003e[Id]",
          "package": "ideas",
          "partial": "Siblings",
          "signature": "Rule a-\u003e[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:ruleSiblings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleTrans",
          "package": "ideas",
          "signature": "n -\u003e Transformation a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#ruleTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "ruleTrans",
          "normalized": "a-\u003eTransformation b-\u003eRule b",
          "package": "ideas",
          "partial": "Trans",
          "signature": "n-\u003eTransformation a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:ruleTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "siblingOf",
          "package": "ideas",
          "signature": "b -\u003e Rule a -\u003e Rule a",
          "source": "src/Ideas-Common-Rule-Abstract.html#siblingOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "siblingOf",
          "normalized": "a-\u003eRule b-\u003eRule b",
          "package": "ideas",
          "partial": "Of",
          "signature": "b-\u003eRule a-\u003eRule a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:siblingOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Abstract",
          "name": "transformation",
          "package": "ideas",
          "signature": "Rule a -\u003e Transformation a",
          "source": "src/Ideas-Common-Rule-Abstract.html#transformation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Abstract",
          "module": "Ideas.Common.Rule.Abstract",
          "name": "transformation",
          "normalized": "Rule a-\u003eTransformation a",
          "package": "ideas",
          "signature": "Rule a-\u003eTransformation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Abstract.html#v:transformation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eState monad for environments\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "EnvironmentMonad",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html",
          "type": "module"
        },
        "index": {
          "description": "State monad for environments",
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "EnvironmentMonad",
          "package": "ideas",
          "partial": "Environment Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "EnvMonad",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#EnvMonad",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "EnvMonad",
          "package": "ideas",
          "partial": "Env Monad",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#t:EnvMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": ":~",
          "package": "ideas",
          "signature": "Ref a -\u003e (a -\u003e a) -\u003e EnvMonad ()",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#EnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": ":~",
          "normalized": "Ref a-\u003e(a-\u003ea)-\u003eEnvMonad()",
          "package": "ideas",
          "signature": "Ref a-\u003e(a-\u003ea)-\u003eEnvMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v::-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": ":=",
          "package": "ideas",
          "signature": "Ref a -\u003e a -\u003e EnvMonad ()",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#EnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": ":=",
          "normalized": "Ref a-\u003ea-\u003eEnvMonad()",
          "package": "ideas",
          "signature": "Ref a-\u003ea-\u003eEnvMonad()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v::-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": ":?",
          "package": "ideas",
          "signature": "Ref a -\u003e a -\u003e EnvMonad a",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#EnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": ":?",
          "normalized": "Ref a-\u003ea-\u003eEnvMonad a",
          "package": "ideas",
          "signature": "Ref a-\u003ea-\u003eEnvMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v::-63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "envMonadFunctionRefs",
          "package": "ideas",
          "signature": "(a -\u003e EnvMonad b) -\u003e [Some Ref]",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#envMonadFunctionRefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "envMonadFunctionRefs",
          "normalized": "(a-\u003eEnvMonad b)-\u003e[Some Ref]",
          "package": "ideas",
          "partial": "Monad Function Refs",
          "signature": "(a-\u003eEnvMonad b)-\u003e[Some Ref]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v:envMonadFunctionRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "envMonadRefs",
          "package": "ideas",
          "signature": "EnvMonad a -\u003e [Some Ref]",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#envMonadRefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "envMonadRefs",
          "normalized": "EnvMonad a-\u003e[Some Ref]",
          "package": "ideas",
          "partial": "Monad Refs",
          "signature": "EnvMonad a-\u003e[Some Ref]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v:envMonadRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "evalEnvMonad",
          "package": "ideas",
          "signature": "EnvMonad a -\u003e Environment -\u003e [a]",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#evalEnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "evalEnvMonad",
          "normalized": "EnvMonad a-\u003eEnvironment-\u003e[a]",
          "package": "ideas",
          "partial": "Env Monad",
          "signature": "EnvMonad a-\u003eEnvironment-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v:evalEnvMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "execEnvMonad",
          "package": "ideas",
          "signature": "EnvMonad a -\u003e Environment -\u003e [Environment]",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#execEnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "execEnvMonad",
          "normalized": "EnvMonad a-\u003eEnvironment-\u003e[Environment]",
          "package": "ideas",
          "partial": "Env Monad",
          "signature": "EnvMonad a-\u003eEnvironment-\u003e[Environment]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v:execEnvMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "getRef",
          "package": "ideas",
          "signature": "Ref a -\u003e EnvMonad a",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#getRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "getRef",
          "normalized": "Ref a-\u003eEnvMonad a",
          "package": "ideas",
          "partial": "Ref",
          "signature": "Ref a-\u003eEnvMonad a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v:getRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "runEnvMonad",
          "package": "ideas",
          "signature": "EnvMonad a -\u003e Environment -\u003e [(a, Environment)]",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#runEnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "runEnvMonad",
          "normalized": "EnvMonad a-\u003eEnvironment-\u003e[(a,Environment)]",
          "package": "ideas",
          "partial": "Env Monad",
          "signature": "EnvMonad a-\u003eEnvironment-\u003e[(a,Environment)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v:runEnvMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "updateRefs",
          "package": "ideas",
          "signature": "[EnvMonad a] -\u003e Environment -\u003e m Environment",
          "source": "src/Ideas-Common-Rule-EnvironmentMonad.html#updateRefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule EnvironmentMonad",
          "module": "Ideas.Common.Rule.EnvironmentMonad",
          "name": "updateRefs",
          "normalized": "[EnvMonad a]-\u003eEnvironment-\u003eb Environment",
          "package": "ideas",
          "partial": "Refs",
          "signature": "[EnvMonad a]-\u003eEnvironment-\u003em Environment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-EnvironmentMonad.html#v:updateRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines transformations. Given a term, a transformation returns\n a list of results (often a singleton list or the empty list). A\n transformation can be parameterized with one or more Bindables.\n Transformations rules can be lifted to work on more complex domains with\n the LiftView type class.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "Parameter",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Parameter.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines transformations Given term transformation returns list of results often singleton list or the empty list transformation can be parameterized with one or more Bindables Transformations rules can be lifted to work on more complex domains with the LiftView type class",
          "hierarchy": "Ideas Common Rule Parameter",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "Parameter",
          "package": "ideas",
          "partial": "Parameter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Parameter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Parameter",
          "name": "ParamTrans",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Parameter.html#ParamTrans",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Parameter",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "ParamTrans",
          "package": "ideas",
          "partial": "Param Trans",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Parameter.html#t:ParamTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Parameter",
          "name": "parameter1",
          "package": "ideas",
          "signature": "n1 -\u003e (a -\u003e Transformation b) -\u003e ParamTrans a b",
          "source": "src/Ideas-Common-Rule-Parameter.html#parameter1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Parameter",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "parameter1",
          "normalized": "a-\u003e(b-\u003eTransformation c)-\u003eParamTrans b c",
          "package": "ideas",
          "signature": "n-\u003e(a-\u003eTransformation b)-\u003eParamTrans a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Parameter.html#v:parameter1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Parameter",
          "name": "parameter2",
          "package": "ideas",
          "signature": "n1 -\u003e n2 -\u003e (a -\u003e b -\u003e Transformation c) -\u003e ParamTrans (a, b) c",
          "source": "src/Ideas-Common-Rule-Parameter.html#parameter2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Parameter",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "parameter2",
          "normalized": "a-\u003ea-\u003e(b-\u003ec-\u003eTransformation d)-\u003eParamTrans(b,c)d",
          "package": "ideas",
          "signature": "n-\u003en-\u003e(a-\u003eb-\u003eTransformation c)-\u003eParamTrans(a,b)c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Parameter.html#v:parameter2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Parameter",
          "name": "parameter3",
          "package": "ideas",
          "signature": "n1 -\u003e n2 -\u003e n3 -\u003e (a -\u003e b -\u003e c -\u003e Transformation d) -\u003e ParamTrans (a, b, c) d",
          "source": "src/Ideas-Common-Rule-Parameter.html#parameter3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Parameter",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "parameter3",
          "normalized": "a-\u003ea-\u003ea-\u003e(b-\u003ec-\u003ed-\u003eTransformation e)-\u003eParamTrans(b,c,d)e",
          "package": "ideas",
          "signature": "n-\u003en-\u003en-\u003e(a-\u003eb-\u003ec-\u003eTransformation d)-\u003eParamTrans(a,b,c)d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Parameter.html#v:parameter3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Parameter",
          "name": "supplyContextParameters",
          "package": "ideas",
          "signature": "ParamTrans b a -\u003e (a -\u003e EnvMonad b) -\u003e Transformation (Context a)",
          "source": "src/Ideas-Common-Rule-Parameter.html#supplyContextParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Parameter",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "supplyContextParameters",
          "normalized": "ParamTrans a b-\u003e(b-\u003eEnvMonad a)-\u003eTransformation(Context b)",
          "package": "ideas",
          "partial": "Context Parameters",
          "signature": "ParamTrans b a-\u003e(a-\u003eEnvMonad b)-\u003eTransformation(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Parameter.html#v:supplyContextParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Parameter",
          "name": "supplyParameters",
          "package": "ideas",
          "signature": "ParamTrans b a -\u003e (a -\u003e Maybe b) -\u003e Transformation a",
          "source": "src/Ideas-Common-Rule-Parameter.html#supplyParameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Parameter",
          "module": "Ideas.Common.Rule.Parameter",
          "name": "supplyParameters",
          "normalized": "ParamTrans a b-\u003e(b-\u003eMaybe a)-\u003eTransformation b",
          "package": "ideas",
          "partial": "Parameters",
          "signature": "ParamTrans b a-\u003e(a-\u003eMaybe b)-\u003eTransformation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Parameter.html#v:supplyParameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "Recognizer",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Recognizer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "Recognizer",
          "package": "ideas",
          "partial": "Recognizer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "Recognizable",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Recognizer.html#Recognizable",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "Recognizable",
          "package": "ideas",
          "partial": "Recognizable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#t:Recognizable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "Recognizer",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Recognizer.html#Recognizer",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "Recognizer",
          "package": "ideas",
          "partial": "Recognizer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#t:Recognizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "makeRecognizer",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Recognizer a",
          "source": "src/Ideas-Common-Rule-Recognizer.html#makeRecognizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "makeRecognizer",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eRecognizer a",
          "package": "ideas",
          "partial": "Recognizer",
          "signature": "(a-\u003ea-\u003eBool)-\u003eRecognizer a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#v:makeRecognizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "makeRecognizerEnvMonad",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e EnvMonad ()) -\u003e Recognizer a",
          "source": "src/Ideas-Common-Rule-Recognizer.html#makeRecognizerEnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "makeRecognizerEnvMonad",
          "normalized": "(a-\u003ea-\u003eEnvMonad())-\u003eRecognizer a",
          "package": "ideas",
          "partial": "Recognizer Env Monad",
          "signature": "(a-\u003ea-\u003eEnvMonad())-\u003eRecognizer a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#v:makeRecognizerEnvMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "makeRecognizerTrans",
          "package": "ideas",
          "signature": "Trans (a, a) () -\u003e Recognizer a",
          "source": "src/Ideas-Common-Rule-Recognizer.html#makeRecognizerTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "makeRecognizerTrans",
          "normalized": "Trans(a,a)()-\u003eRecognizer a",
          "package": "ideas",
          "partial": "Recognizer Trans",
          "signature": "Trans(a,a)()-\u003eRecognizer a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#v:makeRecognizerTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognize",
          "package": "ideas",
          "signature": "f a -\u003e a -\u003e a -\u003e Maybe Environment",
          "source": "src/Ideas-Common-Rule-Recognizer.html#recognize",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognize",
          "normalized": "a b-\u003eb-\u003eb-\u003eMaybe Environment",
          "package": "ideas",
          "signature": "f a-\u003ea-\u003ea-\u003eMaybe Environment",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#v:recognize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognizeAll",
          "package": "ideas",
          "signature": "f a -\u003e a -\u003e a -\u003e [Environment]",
          "source": "src/Ideas-Common-Rule-Recognizer.html#recognizeAll",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognizeAll",
          "normalized": "a b-\u003eb-\u003eb-\u003e[Environment]",
          "package": "ideas",
          "partial": "All",
          "signature": "f a-\u003ea-\u003ea-\u003e[Environment]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#v:recognizeAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognizeTrans",
          "package": "ideas",
          "signature": "f a -\u003e Trans (a, a) ()",
          "source": "src/Ideas-Common-Rule-Recognizer.html#recognizeTrans",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognizeTrans",
          "normalized": "a b-\u003eTrans(b,b)()",
          "package": "ideas",
          "partial": "Trans",
          "signature": "f a-\u003eTrans(a,a)()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#v:recognizeTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognizer",
          "package": "ideas",
          "signature": "f a -\u003e Recognizer a",
          "source": "src/Ideas-Common-Rule-Recognizer.html#recognizer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Recognizer",
          "module": "Ideas.Common.Rule.Recognizer",
          "name": "recognizer",
          "normalized": "a b-\u003eRecognizer b",
          "package": "ideas",
          "signature": "f a-\u003eRecognizer a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Recognizer.html#v:recognizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines transformations. Given a term, a transformation returns\n a list of results (often a singleton list or the empty list).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "Transformation",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Transformation.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines transformations Given term transformation returns list of results often singleton list or the empty list",
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "Transformation",
          "package": "ideas",
          "partial": "Transformation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for constructing a transformation. If possible, \u003ccode\u003emakeTrans\u003c/code\u003e\n should be used. Use specialized constructor functions for disambiguation.\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "MakeTrans",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Transformation.html#MakeTrans",
          "type": "class"
        },
        "index": {
          "description": "type class for constructing transformation If possible makeTrans should be used Use specialized constructor functions for disambiguation",
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "MakeTrans",
          "package": "ideas",
          "partial": "Make Trans",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#t:MakeTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "Trans",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Transformation.html#Trans",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "Trans",
          "package": "ideas",
          "partial": "Trans",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#t:Trans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "Transformation",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule-Transformation.html#Transformation",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "Transformation",
          "package": "ideas",
          "partial": "Transformation",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#t:Transformation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "getRewriteRules",
          "package": "ideas",
          "signature": "Trans a b -\u003e [Some RewriteRule]",
          "source": "src/Ideas-Common-Rule-Transformation.html#getRewriteRules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "getRewriteRules",
          "normalized": "Trans a b-\u003e[Some RewriteRule]",
          "package": "ideas",
          "partial": "Rewrite Rules",
          "signature": "Trans a b-\u003e[Some RewriteRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:getRewriteRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "isZeroTrans",
          "package": "ideas",
          "signature": "Trans a b -\u003e Bool",
          "source": "src/Ideas-Common-Rule-Transformation.html#isZeroTrans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "isZeroTrans",
          "normalized": "Trans a b-\u003eBool",
          "package": "ideas",
          "partial": "Zero Trans",
          "signature": "Trans a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:isZeroTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "makeTrans",
          "package": "ideas",
          "signature": "(a -\u003e f b) -\u003e Trans a b",
          "source": "src/Ideas-Common-Rule-Transformation.html#makeTrans",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "makeTrans",
          "normalized": "(a-\u003eb c)-\u003eTrans a c",
          "package": "ideas",
          "partial": "Trans",
          "signature": "(a-\u003ef b)-\u003eTrans a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:makeTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOverloaded variant of \u003ccode\u003etransLiftContext\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "makeTransLiftContext",
          "package": "ideas",
          "signature": "(a -\u003e f a) -\u003e Transformation (Context a)",
          "source": "src/Ideas-Common-Rule-Transformation.html#makeTransLiftContext",
          "type": "function"
        },
        "index": {
          "description": "Overloaded variant of transLiftContext",
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "makeTransLiftContext",
          "normalized": "(a-\u003eb a)-\u003eTransformation(Context a)",
          "package": "ideas",
          "partial": "Trans Lift Context",
          "signature": "(a-\u003ef a)-\u003eTransformation(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:makeTransLiftContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOverloaded variant of \u003ccode\u003etransLiftContext\u003c/code\u003e; ignores result\n\u003c/p\u003e",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "makeTransLiftContext_",
          "package": "ideas",
          "signature": "(a -\u003e f ()) -\u003e Transformation (Context a)",
          "source": "src/Ideas-Common-Rule-Transformation.html#makeTransLiftContext_",
          "type": "function"
        },
        "index": {
          "description": "Overloaded variant of transLiftContext ignores result",
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "makeTransLiftContext_",
          "normalized": "(a-\u003eb())-\u003eTransformation(Context a)",
          "package": "ideas",
          "partial": "Trans Lift Context",
          "signature": "(a-\u003ef())-\u003eTransformation(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:makeTransLiftContext_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transApply",
          "package": "ideas",
          "signature": "Trans a b -\u003e a -\u003e [(b, Environment)]",
          "source": "src/Ideas-Common-Rule-Transformation.html#transApply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transApply",
          "normalized": "Trans a b-\u003ea-\u003e[(b,Environment)]",
          "package": "ideas",
          "partial": "Apply",
          "signature": "Trans a b-\u003ea-\u003e[(b,Environment)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transApplyWith",
          "package": "ideas",
          "signature": "Environment -\u003e Trans a b -\u003e a -\u003e [(b, Environment)]",
          "source": "src/Ideas-Common-Rule-Transformation.html#transApplyWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transApplyWith",
          "normalized": "Environment-\u003eTrans a b-\u003ea-\u003e[(b,Environment)]",
          "package": "ideas",
          "partial": "Apply With",
          "signature": "Environment-\u003eTrans a b-\u003ea-\u003e[(b,Environment)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transApplyWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transEnvMonad",
          "package": "ideas",
          "signature": "(a -\u003e EnvMonad b) -\u003e Trans a b",
          "source": "src/Ideas-Common-Rule-Transformation.html#transEnvMonad",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transEnvMonad",
          "normalized": "(a-\u003eEnvMonad b)-\u003eTrans a b",
          "package": "ideas",
          "partial": "Env Monad",
          "signature": "(a-\u003eEnvMonad b)-\u003eTrans a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transEnvMonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftContext",
          "package": "ideas",
          "signature": "Transformation a -\u003e Transformation (Context a)",
          "source": "src/Ideas-Common-Rule-Transformation.html#transLiftContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftContext",
          "normalized": "Transformation a-\u003eTransformation(Context a)",
          "package": "ideas",
          "partial": "Lift Context",
          "signature": "Transformation a-\u003eTransformation(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transLiftContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftContextIn",
          "package": "ideas",
          "signature": "Transformation (a, Environment) -\u003e Transformation (Context a)",
          "source": "src/Ideas-Common-Rule-Transformation.html#transLiftContextIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftContextIn",
          "normalized": "Transformation(a,Environment)-\u003eTransformation(Context a)",
          "package": "ideas",
          "partial": "Lift Context In",
          "signature": "Transformation(a,Environment)-\u003eTransformation(Context a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transLiftContextIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftView",
          "package": "ideas",
          "signature": "View a b -\u003e Transformation b -\u003e Transformation a",
          "source": "src/Ideas-Common-Rule-Transformation.html#transLiftView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftView",
          "normalized": "View a b-\u003eTransformation b-\u003eTransformation a",
          "package": "ideas",
          "partial": "Lift View",
          "signature": "View a b-\u003eTransformation b-\u003eTransformation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transLiftView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftViewIn",
          "package": "ideas",
          "signature": "View a (b, c) -\u003e Transformation b -\u003e Transformation a",
          "source": "src/Ideas-Common-Rule-Transformation.html#transLiftViewIn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transLiftViewIn",
          "normalized": "View a(b,c)-\u003eTransformation b-\u003eTransformation a",
          "package": "ideas",
          "partial": "Lift View In",
          "signature": "View a(b,c)-\u003eTransformation b-\u003eTransformation a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transLiftViewIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transList",
          "package": "ideas",
          "signature": "(a -\u003e [b]) -\u003e Trans a b",
          "source": "src/Ideas-Common-Rule-Transformation.html#transList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transList",
          "normalized": "(a-\u003e[b])-\u003eTrans a b",
          "package": "ideas",
          "partial": "List",
          "signature": "(a-\u003e[b])-\u003eTrans a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transMaybe",
          "package": "ideas",
          "signature": "(a -\u003e Maybe b) -\u003e Trans a b",
          "source": "src/Ideas-Common-Rule-Transformation.html#transMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eTrans a b",
          "package": "ideas",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eTrans a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transPure",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e Trans a b",
          "source": "src/Ideas-Common-Rule-Transformation.html#transPure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transPure",
          "normalized": "(a-\u003eb)-\u003eTrans a b",
          "package": "ideas",
          "partial": "Pure",
          "signature": "(a-\u003eb)-\u003eTrans a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transRef",
          "package": "ideas",
          "signature": "Ref a -\u003e Trans a a",
          "source": "src/Ideas-Common-Rule-Transformation.html#transRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transRef",
          "normalized": "Ref a-\u003eTrans a a",
          "package": "ideas",
          "partial": "Ref",
          "signature": "Ref a-\u003eTrans a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transRewrite",
          "package": "ideas",
          "signature": "RewriteRule a -\u003e Trans a a",
          "source": "src/Ideas-Common-Rule-Transformation.html#transRewrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transRewrite",
          "normalized": "RewriteRule a-\u003eTrans a a",
          "package": "ideas",
          "partial": "Rewrite",
          "signature": "RewriteRule a-\u003eTrans a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transRewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transUseEnvironment",
          "package": "ideas",
          "signature": "Trans a b -\u003e Trans (a, Environment) (b, Environment)",
          "source": "src/Ideas-Common-Rule-Transformation.html#transUseEnvironment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Rule Transformation",
          "module": "Ideas.Common.Rule.Transformation",
          "name": "transUseEnvironment",
          "normalized": "Trans a b-\u003eTrans(a,Environment)(b,Environment)",
          "package": "ideas",
          "partial": "Use Environment",
          "signature": "Trans a b-\u003eTrans(a,Environment)(b,Environment)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule-Transformation.html#v:transUseEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Rule",
          "name": "Rule",
          "package": "ideas",
          "source": "src/Ideas-Common-Rule.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Rule",
          "module": "Ideas.Common.Rule",
          "name": "Rule",
          "package": "ideas",
          "partial": "Rule",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Rule.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "Abstract",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "Abstract",
          "package": "ideas",
          "partial": "Abstract",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "IsLabeled",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#IsLabeled",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "IsLabeled",
          "package": "ideas",
          "partial": "Is Labeled",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#t:IsLabeled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class to turn values into strategies\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "IsStrategy",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#IsStrategy",
          "type": "class"
        },
        "index": {
          "description": "Type class to turn values into strategies",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "IsStrategy",
          "package": "ideas",
          "partial": "Is Strategy",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#t:IsStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "LabelInfo",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#LabelInfo",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "LabelInfo",
          "package": "ideas",
          "partial": "Label Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#t:LabelInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strategy which is labeled with a string\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "LabeledStrategy",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#LabeledStrategy",
          "type": "data"
        },
        "index": {
          "description": "strategy which is labeled with string",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "LabeledStrategy",
          "package": "ideas",
          "partial": "Labeled Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#t:LabeledStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for strategies\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "Strategy",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#Strategy",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for strategies",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "Strategy",
          "package": "ideas",
          "partial": "Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#t:Strategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "changeInfo",
          "package": "ideas",
          "signature": "(LabelInfo -\u003e LabelInfo) -\u003e f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#changeInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "changeInfo",
          "normalized": "(LabelInfo-\u003eLabelInfo)-\u003ea b-\u003eLabeledStrategy b",
          "package": "ideas",
          "partial": "Info",
          "signature": "(LabelInfo-\u003eLabelInfo)-\u003ef a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:changeInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a function as do-after hook for all rules in a labeled strategy, but\n also use the function beforehand\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Abstract\",\"Ideas.Common.Strategy\"]",
          "name": "cleanUpStrategy",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e LabeledStrategy a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#cleanUpStrategy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:cleanUpStrategy\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:cleanUpStrategy\"]"
        },
        "index": {
          "description": "Use function as do-after hook for all rules in labeled strategy but also use the function beforehand",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "cleanUpStrategy",
          "normalized": "(a-\u003ea)-\u003eLabeledStrategy a-\u003eLabeledStrategy a",
          "package": "ideas",
          "partial": "Up Strategy",
          "signature": "(a-\u003ea)-\u003eLabeledStrategy a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:cleanUpStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a function as do-after hook for all rules in a labeled strategy\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Abstract\",\"Ideas.Common.Strategy\"]",
          "name": "cleanUpStrategyAfter",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e LabeledStrategy a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#cleanUpStrategyAfter",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:cleanUpStrategyAfter\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:cleanUpStrategyAfter\"]"
        },
        "index": {
          "description": "Use function as do-after hook for all rules in labeled strategy",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "cleanUpStrategyAfter",
          "normalized": "(a-\u003ea)-\u003eLabeledStrategy a-\u003eLabeledStrategy a",
          "package": "ideas",
          "partial": "Up Strategy After",
          "signature": "(a-\u003ea)-\u003eLabeledStrategy a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:cleanUpStrategyAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "collapsed",
          "package": "ideas",
          "signature": "LabelInfo -\u003e Bool",
          "source": "src/Ideas-Common-Strategy-Abstract.html#collapsed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "collapsed",
          "normalized": "LabelInfo-\u003eBool",
          "package": "ideas",
          "signature": "LabelInfo-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:collapsed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the derivation tree for a strategy and a term with only major rules\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Abstract\",\"Ideas.Common.Strategy\"]",
          "name": "derivationTree",
          "package": "ideas",
          "signature": "Bool -\u003e f a -\u003e a -\u003e DerivationTree (Rule a, Environment) a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#derivationTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:derivationTree\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:derivationTree\"]"
        },
        "index": {
          "description": "Returns the derivation tree for strategy and term with only major rules",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "derivationTree",
          "normalized": "Bool-\u003ea b-\u003eb-\u003eDerivationTree(Rule b,Environment)b",
          "package": "ideas",
          "partial": "Tree",
          "signature": "Bool-\u003ef a-\u003ea-\u003eDerivationTree(Rule a,Environment)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:derivationTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "fromCore",
          "package": "ideas",
          "signature": "Core LabelInfo a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#fromCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "fromCore",
          "normalized": "Core LabelInfo a-\u003eStrategy a",
          "package": "ideas",
          "partial": "Core",
          "signature": "Core LabelInfo a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:fromCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the derivation tree for a strategy and a term, including all\n minor rules\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Abstract\",\"Ideas.Common.Strategy\"]",
          "name": "fullDerivationTree",
          "package": "ideas",
          "signature": "Bool -\u003e f a -\u003e a -\u003e DerivationTree (Step LabelInfo a) a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#fullDerivationTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:fullDerivationTree\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:fullDerivationTree\"]"
        },
        "index": {
          "description": "Returns the derivation tree for strategy and term including all minor rules",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "fullDerivationTree",
          "normalized": "Bool-\u003ea b-\u003eb-\u003eDerivationTree(Step LabelInfo b)b",
          "package": "ideas",
          "partial": "Derivation Tree",
          "signature": "Bool-\u003ef a-\u003ea-\u003eDerivationTree(Step LabelInfo a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:fullDerivationTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "hidden",
          "package": "ideas",
          "signature": "LabelInfo -\u003e Bool",
          "source": "src/Ideas-Common-Strategy-Abstract.html#hidden",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "hidden",
          "normalized": "LabelInfo-\u003eBool",
          "package": "ideas",
          "signature": "LabelInfo-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:hidden"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabels a strategy with a string\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Abstract\",\"Ideas.Common.Strategy\"]",
          "name": "label",
          "package": "ideas",
          "signature": "l -\u003e f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#label",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:label\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:label\"]"
        },
        "index": {
          "description": "Labels strategy with string",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "label",
          "normalized": "a-\u003eb c-\u003eLabeledStrategy c",
          "package": "ideas",
          "signature": "l-\u003ef a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "liftCore",
          "package": "ideas",
          "signature": "(Core LabelInfo a -\u003e Core LabelInfo a) -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#liftCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "liftCore",
          "normalized": "(Core LabelInfo a-\u003eCore LabelInfo a)-\u003eb a-\u003eStrategy a",
          "package": "ideas",
          "partial": "Core",
          "signature": "(Core LabelInfo a-\u003eCore LabelInfo a)-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:liftCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "liftCore2",
          "package": "ideas",
          "signature": "(Core LabelInfo a -\u003e Core LabelInfo a -\u003e Core LabelInfo a) -\u003e f a -\u003e g a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#liftCore2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "liftCore2",
          "normalized": "(Core LabelInfo a-\u003eCore LabelInfo a-\u003eCore LabelInfo a)-\u003eb a-\u003ec a-\u003eStrategy a",
          "package": "ideas",
          "partial": "Core",
          "signature": "(Core LabelInfo a-\u003eCore LabelInfo a-\u003eCore LabelInfo a)-\u003ef a-\u003eg a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:liftCore2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "makeInfo",
          "package": "ideas",
          "signature": "a -\u003e LabelInfo",
          "source": "src/Ideas-Common-Strategy-Abstract.html#makeInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "makeInfo",
          "normalized": "a-\u003eLabelInfo",
          "package": "ideas",
          "partial": "Info",
          "signature": "a-\u003eLabelInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:makeInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "makeLabeledStrategy",
          "package": "ideas",
          "signature": "LabelInfo -\u003e f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#makeLabeledStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "makeLabeledStrategy",
          "normalized": "LabelInfo-\u003ea b-\u003eLabeledStrategy b",
          "package": "ideas",
          "partial": "Labeled Strategy",
          "signature": "LabelInfo-\u003ef a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:makeLabeledStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to all the rules that make up a labeled strategy\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "mapRules",
          "package": "ideas",
          "signature": "(Rule a -\u003e Rule b) -\u003e LabeledStrategy a -\u003e LabeledStrategy b",
          "source": "src/Ideas-Common-Strategy-Abstract.html#mapRules",
          "type": "function"
        },
        "index": {
          "description": "Apply function to all the rules that make up labeled strategy",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "mapRules",
          "normalized": "(Rule a-\u003eRule b)-\u003eLabeledStrategy a-\u003eLabeledStrategy b",
          "package": "ideas",
          "partial": "Rules",
          "signature": "(Rule a-\u003eRule b)-\u003eLabeledStrategy a-\u003eLabeledStrategy b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:mapRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "mapRulesS",
          "package": "ideas",
          "signature": "(Rule a -\u003e Rule b) -\u003e Strategy a -\u003e Strategy b",
          "source": "src/Ideas-Common-Strategy-Abstract.html#mapRulesS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "mapRulesS",
          "normalized": "(Rule a-\u003eRule b)-\u003eStrategy a-\u003eStrategy b",
          "package": "ideas",
          "partial": "Rules",
          "signature": "(Rule a-\u003eRule b)-\u003eStrategy a-\u003eStrategy b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:mapRulesS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "noInterleaving",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#noInterleaving",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "noInterleaving",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "partial": "Interleaving",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:noInterleaving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "processLabelInfo",
          "package": "ideas",
          "signature": "(l -\u003e LabelInfo) -\u003e Core l a -\u003e Core l a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#processLabelInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "processLabelInfo",
          "normalized": "(a-\u003eLabelInfo)-\u003eCore a b-\u003eCore a b",
          "package": "ideas",
          "partial": "Label Info",
          "signature": "(l-\u003eLabelInfo)-\u003eCore l a-\u003eCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:processLabelInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "removed",
          "package": "ideas",
          "signature": "LabelInfo -\u003e Bool",
          "source": "src/Ideas-Common-Strategy-Abstract.html#removed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "removed",
          "normalized": "LabelInfo-\u003eBool",
          "package": "ideas",
          "signature": "LabelInfo-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:removed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a list of all major rules that are part of a labeled strategy\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Abstract\",\"Ideas.Common.Strategy\"]",
          "name": "rulesInStrategy",
          "package": "ideas",
          "signature": "f a -\u003e [Rule a]",
          "source": "src/Ideas-Common-Strategy-Abstract.html#rulesInStrategy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:rulesInStrategy\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:rulesInStrategy\"]"
        },
        "index": {
          "description": "Returns list of all major rules that are part of labeled strategy",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "rulesInStrategy",
          "normalized": "a b-\u003e[Rule b]",
          "package": "ideas",
          "partial": "In Strategy",
          "signature": "f a-\u003e[Rule a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:rulesInStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toCore",
          "package": "ideas",
          "signature": "Strategy a -\u003e Core LabelInfo a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#toCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toCore",
          "normalized": "Strategy a-\u003eCore LabelInfo a",
          "package": "ideas",
          "partial": "Core",
          "signature": "Strategy a-\u003eCore LabelInfo a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:toCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toLabeled",
          "package": "ideas",
          "signature": "f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#toLabeled",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toLabeled",
          "normalized": "a b-\u003eLabeledStrategy b",
          "package": "ideas",
          "partial": "Labeled",
          "signature": "f a-\u003eLabeledStrategy a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:toLabeled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toLabeledStrategy",
          "package": "ideas",
          "signature": "Strategy a -\u003e m (LabeledStrategy a)",
          "source": "src/Ideas-Common-Strategy-Abstract.html#toLabeledStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toLabeledStrategy",
          "normalized": "Strategy a-\u003eb(LabeledStrategy a)",
          "package": "ideas",
          "partial": "Labeled Strategy",
          "signature": "Strategy a-\u003em(LabeledStrategy a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:toLabeledStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toStrategy",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#toStrategy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "toStrategy",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "partial": "Strategy",
          "signature": "f a-\u003eStrategy a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:toStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemoves the label from a strategy\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "unlabel",
          "package": "ideas",
          "signature": "LabeledStrategy a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#unlabel",
          "type": "function"
        },
        "index": {
          "description": "Removes the label from strategy",
          "hierarchy": "Ideas Common Strategy Abstract",
          "module": "Ideas.Common.Strategy.Abstract",
          "name": "unlabel",
          "normalized": "LabeledStrategy a-\u003eStrategy a",
          "package": "ideas",
          "signature": "LabeledStrategy a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Abstract.html#v:unlabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA collection of strategy combinators: all lifted to work on different\n data types\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "Combinators",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Combinators.html",
          "type": "module"
        },
        "index": {
          "description": "collection of strategy combinators all lifted to work on different data types",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "Combinators",
          "package": "ideas",
          "partial": "Combinators",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-biased choice: if the left-operand strategy can be applied, do so. Otherwise,\n   try the right-operand strategy\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "(|\u003e)",
          "package": "ideas",
          "signature": "f a -\u003e g a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#%7C%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-124--62-\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:-124--62-\"]"
        },
        "index": {
          "description": "Left-biased choice if the left-operand strategy can be applied do so Otherwise try the right-operand strategy",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "(|\u003e) |\u003e",
          "normalized": "a b-\u003ec b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eg a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChoose between the two strategies (either do this or do that)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "(\u003c|\u003e)",
          "package": "ideas",
          "signature": "f a -\u003e g a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#%3C%7C%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-60--124--62-\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:-60--124--62-\"]"
        },
        "index": {
          "description": "Choose between the two strategies either do this or do that",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "(\u003c|\u003e) \u003c|\u003e",
          "normalized": "a b-\u003ec b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eg a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterleave two strategies\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "(\u003c%\u003e)",
          "package": "ideas",
          "signature": "f a -\u003e g a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#%3C%25%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-60--37--62-\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:-60--37--62-\"]"
        },
        "index": {
          "description": "Interleave two strategies",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "(\u003c%\u003e) \u003c%\u003e",
          "normalized": "a b-\u003ec b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eg a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-60--37--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut two strategies in sequence (first do this, then do that)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "(\u003c*\u003e)",
          "package": "ideas",
          "signature": "f a -\u003e g a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#%3C%2A%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-60--42--62-\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:-60--42--62-\"]"
        },
        "index": {
          "description": "Put two strategies in sequence first do this then do that",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a b-\u003ec b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eg a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines a list of alternative strategies\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "alternatives",
          "package": "ideas",
          "signature": "[f a] -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#alternatives",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:alternatives\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:alternatives\"]"
        },
        "index": {
          "description": "Combines list of alternative strategies",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "alternatives",
          "normalized": "[a b]-\u003eStrategy b",
          "package": "ideas",
          "signature": "[f a]-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:alternatives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes a strategy atomic (w.r.t. parallel composition)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "atomic",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#atomic",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:atomic\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:atomic\"]"
        },
        "index": {
          "description": "Makes strategy atomic w.r.t parallel composition",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "atomic",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:atomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks whether a predicate holds for the current term. The\n   check is considered to be a minor step.\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "check",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#check",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:check\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:check\"]"
        },
        "index": {
          "description": "Checks whether predicate holds for the current term The check is considered to be minor step",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "check",
          "normalized": "(a-\u003eBool)-\u003eStrategy a",
          "package": "ideas",
          "signature": "(a-\u003eBool)-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the strategies from the list exhaustively (until this is no longer possible)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "exhaustive",
          "package": "ideas",
          "signature": "[f a] -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#exhaustive",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:exhaustive\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:exhaustive\"]"
        },
        "index": {
          "description": "Apply the strategies from the list exhaustively until this is no longer possible",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "exhaustive",
          "normalized": "[a b]-\u003eStrategy b",
          "package": "ideas",
          "signature": "[f a]-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:exhaustive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strategy that always fails\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "fail",
          "package": "ideas",
          "signature": "Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#fail",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:fail\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:fail\"]"
        },
        "index": {
          "description": "The strategy that always fails",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "fail",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fix-point combinator on strategies (to model recursion). Powerful\n (but dangerous) combinator\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "fix",
          "package": "ideas",
          "signature": "(Strategy a -\u003e Strategy a) -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#fix",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:fix\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:fix\"]"
        },
        "index": {
          "description": "fix-point combinator on strategies to model recursion Powerful but dangerous combinator",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "fix",
          "normalized": "(Strategy a-\u003eStrategy a)-\u003eStrategy a",
          "package": "ideas",
          "signature": "(Strategy a-\u003eStrategy a)-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:fix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerges a list of strategies (in parallel)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "interleave",
          "package": "ideas",
          "signature": "[f a] -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#interleave",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:interleave\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:interleave\"]"
        },
        "index": {
          "description": "Merges list of strategies in parallel",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "interleave",
          "normalized": "[a b]-\u003eStrategy b",
          "package": "ideas",
          "signature": "[f a]-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:interleave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat a strategy zero or more times (non-greedy)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "many",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#many",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:many\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:many\"]"
        },
        "index": {
          "description": "Repeat strategy zero or more times non-greedy",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "many",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a certain strategy at least once (non-greedy)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "many1",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#many1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:many1\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:many1\"]"
        },
        "index": {
          "description": "Apply certain strategy at least once non-greedy",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "many1",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:many1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a strategy at least once, but collapse into a single step\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "multi",
          "package": "ideas",
          "signature": "l -\u003e f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#multi",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:multi\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:multi\"]"
        },
        "index": {
          "description": "Apply strategy at least once but collapse into single step",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "multi",
          "normalized": "a-\u003eb c-\u003eLabeledStrategy c",
          "package": "ideas",
          "signature": "l-\u003ef a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:multi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether or not the argument strategy cannot be applied: the result\n   strategy only succeeds if this is not the case (otherwise it fails).\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "not",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#not",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:not\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:not\"]"
        },
        "index": {
          "description": "Check whether or not the argument strategy cannot be applied the result strategy only succeeds if this is not the case otherwise it fails",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "not",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a certain strategy or do nothing (non-greedy)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "option",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#option",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:option\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:option\"]"
        },
        "index": {
          "description": "Apply certain strategy or do nothing non-greedy",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "option",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllows all permutations of the list\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "permute",
          "package": "ideas",
          "signature": "[f a] -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#permute",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:permute\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:permute\"]"
        },
        "index": {
          "description": "Allows all permutations of the list",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "permute",
          "normalized": "[a b]-\u003eStrategy b",
          "package": "ideas",
          "signature": "[f a]-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:permute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat a strategy zero or more times (greedy version of \u003ccode\u003e\u003ca\u003emany\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "repeat",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#repeat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:repeat\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:repeat\"]"
        },
        "index": {
          "description": "Repeat strategy zero or more times greedy version of many",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "repeat",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a certain strategy at least once (greedy version of \u003ccode\u003e\u003ca\u003emany1\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "repeat1",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#repeat1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:repeat1\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:repeat1\"]"
        },
        "index": {
          "description": "Apply certain strategy at least once greedy version of many1",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "repeat1",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:repeat1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a strategy a certain number of times\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "replicate",
          "package": "ideas",
          "signature": "Int -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#replicate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:replicate\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:replicate\"]"
        },
        "index": {
          "description": "Apply strategy certain number of times",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "replicate",
          "normalized": "Int-\u003ea b-\u003eStrategy b",
          "package": "ideas",
          "signature": "Int-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePuts a list of strategies into a sequence\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "sequence",
          "package": "ideas",
          "signature": "[f a] -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#sequence",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:sequence\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:sequence\"]"
        },
        "index": {
          "description": "Puts list of strategies into sequence",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "sequence",
          "normalized": "[a b]-\u003eStrategy b",
          "package": "ideas",
          "signature": "[f a]-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strategy that always succeeds (without doing anything)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "succeed",
          "package": "ideas",
          "signature": "Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#succeed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:succeed\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:succeed\"]"
        },
        "index": {
          "description": "The strategy that always succeeds without doing anything",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "succeed",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:succeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a certain strategy if this is possible (greedy version of \u003ccode\u003e\u003ca\u003eoption\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "try",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#try",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:try\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:try\"]"
        },
        "index": {
          "description": "Apply certain strategy if this is possible greedy version of option",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "try",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:try"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat the strategy until the predicate holds\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "until",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#until",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:until\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:until\"]"
        },
        "index": {
          "description": "Repeat the strategy until the predicate holds",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "until",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eStrategy a",
          "package": "ideas",
          "signature": "(a-\u003eBool)-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:until"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat the strategy as long as the predicate holds\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Combinators\",\"Ideas.Common.Strategy\"]",
          "name": "while",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Combinators.html#while",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:while\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:while\"]"
        },
        "index": {
          "description": "Repeat the strategy as long as the predicate holds",
          "hierarchy": "Ideas Common Strategy Combinators",
          "module": "Ideas.Common.Strategy.Combinators",
          "name": "while",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eStrategy a",
          "package": "ideas",
          "signature": "(a-\u003eBool)-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Combinators.html#v:while"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Configuration",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Configuration.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Configuration",
          "package": "ideas",
          "partial": "Configuration",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "ConfigAction",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigAction",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "ConfigAction",
          "package": "ideas",
          "partial": "Config Action",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#t:ConfigAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "ConfigItem",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigItem",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "ConfigItem",
          "package": "ideas",
          "partial": "Config Item",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#t:ConfigItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "ConfigLocation",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigLocation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "ConfigLocation",
          "package": "ideas",
          "partial": "Config Location",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#t:ConfigLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "StrategyConfiguration",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Configuration.html#StrategyConfiguration",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "StrategyConfiguration",
          "package": "ideas",
          "partial": "Strategy Configuration",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#t:StrategyConfiguration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Collapse",
          "package": "ideas",
          "signature": "Collapse",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Collapse",
          "package": "ideas",
          "partial": "Collapse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:Collapse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Expand",
          "package": "ideas",
          "signature": "Expand",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Expand",
          "package": "ideas",
          "partial": "Expand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:Expand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Hide",
          "package": "ideas",
          "signature": "Hide",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Hide",
          "package": "ideas",
          "partial": "Hide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:Hide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Reinsert",
          "package": "ideas",
          "signature": "Reinsert",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Reinsert",
          "package": "ideas",
          "partial": "Reinsert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:Reinsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Remove",
          "package": "ideas",
          "signature": "Remove",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Remove",
          "package": "ideas",
          "partial": "Remove",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:Remove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Reveal",
          "package": "ideas",
          "signature": "Reveal",
          "source": "src/Ideas-Common-Strategy-Configuration.html#ConfigAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "Reveal",
          "package": "ideas",
          "partial": "Reveal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:Reveal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "byGroup",
          "package": "ideas",
          "signature": "a -\u003e ConfigLocation",
          "source": "src/Ideas-Common-Strategy-Configuration.html#byGroup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "byGroup",
          "normalized": "a-\u003eConfigLocation",
          "package": "ideas",
          "partial": "Group",
          "signature": "a-\u003eConfigLocation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:byGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "byName",
          "package": "ideas",
          "signature": "a -\u003e ConfigLocation",
          "source": "src/Ideas-Common-Strategy-Configuration.html#byName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "byName",
          "normalized": "a-\u003eConfigLocation",
          "package": "ideas",
          "partial": "Name",
          "signature": "a-\u003eConfigLocation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:byName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "collapse",
          "package": "ideas",
          "signature": "f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#collapse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "collapse",
          "normalized": "a b-\u003eLabeledStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:collapse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "configActions",
          "package": "ideas",
          "signature": "[ConfigAction]",
          "source": "src/Ideas-Common-Strategy-Configuration.html#configActions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "configActions",
          "normalized": "[ConfigAction]",
          "package": "ideas",
          "partial": "Actions",
          "signature": "[ConfigAction]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:configActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "configure",
          "package": "ideas",
          "signature": "StrategyConfiguration -\u003e LabeledStrategy a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#configure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "configure",
          "normalized": "StrategyConfiguration-\u003eLabeledStrategy a-\u003eLabeledStrategy a",
          "package": "ideas",
          "signature": "StrategyConfiguration-\u003eLabeledStrategy a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:configure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "configureNow",
          "package": "ideas",
          "signature": "LabeledStrategy a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#configureNow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "configureNow",
          "normalized": "LabeledStrategy a-\u003eLabeledStrategy a",
          "package": "ideas",
          "partial": "Now",
          "signature": "LabeledStrategy a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:configureNow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "expand",
          "package": "ideas",
          "signature": "f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#expand",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "expand",
          "normalized": "a b-\u003eLabeledStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:expand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "hide",
          "package": "ideas",
          "signature": "f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#hide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "hide",
          "normalized": "a b-\u003eLabeledStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:hide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "makeStrategyConfiguration",
          "package": "ideas",
          "signature": "[ConfigItem] -\u003e StrategyConfiguration",
          "source": "src/Ideas-Common-Strategy-Configuration.html#makeStrategyConfiguration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "makeStrategyConfiguration",
          "normalized": "[ConfigItem]-\u003eStrategyConfiguration",
          "package": "ideas",
          "partial": "Strategy Configuration",
          "signature": "[ConfigItem]-\u003eStrategyConfiguration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:makeStrategyConfiguration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "reinsert",
          "package": "ideas",
          "signature": "f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#reinsert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "reinsert",
          "normalized": "a b-\u003eLabeledStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:reinsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "remove",
          "package": "ideas",
          "signature": "f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#remove",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "remove",
          "normalized": "a b-\u003eLabeledStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:remove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "reveal",
          "package": "ideas",
          "signature": "f a -\u003e LabeledStrategy a",
          "source": "src/Ideas-Common-Strategy-Configuration.html#reveal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Configuration",
          "module": "Ideas.Common.Strategy.Configuration",
          "name": "reveal",
          "normalized": "a b-\u003eLabeledStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eLabeledStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Configuration.html#v:reveal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe core strategy combinators. This module defines the interal data\n structure of a strategy, and some utility functions that operate\n directly on it.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Core",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Core.html",
          "type": "module"
        },
        "index": {
          "description": "The core strategy combinators This module defines the interal data structure of strategy and some utility functions that operate directly on it",
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Core",
          "package": "ideas",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCore expression, with rules\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Core",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Core.html#Core",
          "type": "type"
        },
        "index": {
          "description": "Core expression with rules",
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Core",
          "package": "ideas",
          "partial": "Core",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#t:Core"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalized Core expression, not restricted to rules. This makes GCore\n a (traversable and foldable) functor.\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Core",
          "name": "GCore",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "data"
        },
        "index": {
          "description": "generalized Core expression not restricted to rules This makes GCore traversable and foldable functor",
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "GCore",
          "package": "ideas",
          "partial": "GCore",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#t:GCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "(.|.)",
          "package": "ideas",
          "signature": "GCore l a -\u003e GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#.%7C.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "(.|.) .|.",
          "normalized": "GCore a b-\u003eGCore a b-\u003eGCore a b",
          "package": "ideas",
          "signature": "GCore l a-\u003eGCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:.-124-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "(.%.)",
          "package": "ideas",
          "signature": "GCore l a -\u003e GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#.%25.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "(.%.) .%.",
          "normalized": "GCore a b-\u003eGCore a b-\u003eGCore a b",
          "package": "ideas",
          "signature": "GCore l a-\u003eGCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:.-37-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "(.*.)",
          "package": "ideas",
          "signature": "GCore l a -\u003e GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#.%2A.",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "(.*.) .*.",
          "normalized": "GCore a b-\u003eGCore a b-\u003eGCore a b",
          "package": "ideas",
          "signature": "GCore l a-\u003eGCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:.-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": ":|\u003e:",
          "package": "ideas",
          "signature": "(GCore l a) :|\u003e: (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": ":|\u003e:",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v::-124--62-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": ":|:",
          "package": "ideas",
          "signature": "(GCore l a) :|: (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": ":|:",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v::-124-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": ":!%:",
          "package": "ideas",
          "signature": "(GCore l a) :!%: (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": ":!%:",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v::-33--37-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": ":%:",
          "package": "ideas",
          "signature": "(GCore l a) :%: (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": ":%:",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v::-37-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": ":*:",
          "package": "ideas",
          "signature": "(GCore l a) :*: (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": ":*:",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Atomic",
          "package": "ideas",
          "signature": "Atomic (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Atomic",
          "package": "ideas",
          "partial": "Atomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Atomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Fail",
          "package": "ideas",
          "signature": "Fail",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Fail",
          "package": "ideas",
          "partial": "Fail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Label",
          "package": "ideas",
          "signature": "Label l (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Label",
          "package": "ideas",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Many",
          "package": "ideas",
          "signature": "Many (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Many",
          "package": "ideas",
          "partial": "Many",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Not",
          "package": "ideas",
          "signature": "Not (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Not",
          "package": "ideas",
          "partial": "Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Not"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Rec",
          "package": "ideas",
          "signature": "Rec Int (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Rec",
          "package": "ideas",
          "partial": "Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Repeat",
          "package": "ideas",
          "signature": "Repeat (GCore l a)",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Repeat",
          "package": "ideas",
          "partial": "Repeat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized constructor (not restricted to rules)\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Rule",
          "package": "ideas",
          "signature": "Rule a",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "description": "Generalized constructor not restricted to rules",
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Rule",
          "package": "ideas",
          "partial": "Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Succeed",
          "package": "ideas",
          "signature": "Succeed",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Succeed",
          "package": "ideas",
          "partial": "Succeed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Succeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "Var",
          "package": "ideas",
          "signature": "Var Int",
          "source": "src/Ideas-Common-Strategy-Core.html#GCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "Var",
          "package": "ideas",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreFix",
          "package": "ideas",
          "signature": "(GCore l a -\u003e GCore l a) -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#coreFix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreFix",
          "normalized": "(GCore a b-\u003eGCore a b)-\u003eGCore a b",
          "package": "ideas",
          "partial": "Fix",
          "signature": "(GCore l a-\u003eGCore l a)-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:coreFix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreMany",
          "package": "ideas",
          "signature": "GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#coreMany",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreMany",
          "normalized": "GCore a b-\u003eGCore a b",
          "package": "ideas",
          "partial": "Many",
          "signature": "GCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:coreMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreOrElse",
          "package": "ideas",
          "signature": "GCore l a -\u003e GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#coreOrElse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreOrElse",
          "normalized": "GCore a b-\u003eGCore a b-\u003eGCore a b",
          "package": "ideas",
          "partial": "Or Else",
          "signature": "GCore l a-\u003eGCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:coreOrElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreRepeat",
          "package": "ideas",
          "signature": "GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#coreRepeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "coreRepeat",
          "normalized": "GCore a b-\u003eGCore a b",
          "package": "ideas",
          "partial": "Repeat",
          "signature": "GCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:coreRepeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "noLabels",
          "package": "ideas",
          "signature": "GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#noLabels",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "noLabels",
          "normalized": "GCore a b-\u003eGCore a b",
          "package": "ideas",
          "partial": "Labels",
          "signature": "GCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:noLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Core",
          "name": "substCoreVar",
          "package": "ideas",
          "signature": "Int -\u003e GCore l a -\u003e GCore l a -\u003e GCore l a",
          "source": "src/Ideas-Common-Strategy-Core.html#substCoreVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Core",
          "module": "Ideas.Common.Strategy.Core",
          "name": "substCoreVar",
          "normalized": "Int-\u003eGCore a b-\u003eGCore a b-\u003eGCore a b",
          "package": "ideas",
          "partial": "Core Var",
          "signature": "Int-\u003eGCore l a-\u003eGCore l a-\u003eGCore l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Core.html#v:substCoreVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLocations in a strategy\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Strategy.Location",
          "name": "Location",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Location.html",
          "type": "module"
        },
        "index": {
          "description": "Locations in strategy",
          "hierarchy": "Ideas Common Strategy Location",
          "module": "Ideas.Common.Strategy.Location",
          "name": "Location",
          "package": "ideas",
          "partial": "Location",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Strategy.Location\",\"Ideas.Common.Strategy\"]",
          "name": "nextTaskLocation",
          "package": "ideas",
          "signature": "LabeledStrategy a -\u003e Id -\u003e Id -\u003e Id",
          "source": "src/Ideas-Common-Strategy-Location.html#nextTaskLocation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:nextTaskLocation\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:nextTaskLocation\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Location",
          "module": "Ideas.Common.Strategy.Location",
          "name": "nextTaskLocation",
          "normalized": "LabeledStrategy a-\u003eId-\u003eId-\u003eId",
          "package": "ideas",
          "partial": "Task Location",
          "signature": "LabeledStrategy a-\u003eId-\u003eId-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:nextTaskLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a list of all strategy locations, paired with the labeled\n substrategy at that location\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Location\",\"Ideas.Common.Strategy\"]",
          "name": "strategyLocations",
          "package": "ideas",
          "signature": "LabeledStrategy a -\u003e [([Int], LabeledStrategy a)]",
          "source": "src/Ideas-Common-Strategy-Location.html#strategyLocations",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:strategyLocations\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:strategyLocations\"]"
        },
        "index": {
          "description": "Returns list of all strategy locations paired with the labeled substrategy at that location",
          "hierarchy": "Ideas Common Strategy Location",
          "module": "Ideas.Common.Strategy.Location",
          "name": "strategyLocations",
          "normalized": "LabeledStrategy a-\u003e[([Int],LabeledStrategy a)]",
          "package": "ideas",
          "partial": "Locations",
          "signature": "LabeledStrategy a-\u003e[([Int],LabeledStrategy a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:strategyLocations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the substrategy or rule at a strategy location. Nothing\n indicates that the location is invalid\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Location\",\"Ideas.Common.Strategy\"]",
          "name": "subStrategy",
          "package": "ideas",
          "signature": "Id -\u003e LabeledStrategy a -\u003e Maybe (LabeledStrategy a)",
          "source": "src/Ideas-Common-Strategy-Location.html#subStrategy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:subStrategy\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:subStrategy\"]"
        },
        "index": {
          "description": "Returns the substrategy or rule at strategy location Nothing indicates that the location is invalid",
          "hierarchy": "Ideas Common Strategy Location",
          "module": "Ideas.Common.Strategy.Location",
          "name": "subStrategy",
          "normalized": "Id-\u003eLabeledStrategy a-\u003eMaybe(LabeledStrategy a)",
          "package": "ideas",
          "partial": "Strategy",
          "signature": "Id-\u003eLabeledStrategy a-\u003eMaybe(LabeledStrategy a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:subStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Strategy.Location\",\"Ideas.Common.Strategy\"]",
          "name": "subTaskLocation",
          "package": "ideas",
          "signature": "LabeledStrategy a -\u003e Id -\u003e Id -\u003e Id",
          "source": "src/Ideas-Common-Strategy-Location.html#subTaskLocation",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:subTaskLocation\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:subTaskLocation\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Location",
          "module": "Ideas.Common.Strategy.Location",
          "name": "subTaskLocation",
          "normalized": "LabeledStrategy a-\u003eId-\u003eId-\u003eId",
          "package": "ideas",
          "partial": "Task Location",
          "signature": "LabeledStrategy a-\u003eId-\u003eId-\u003eId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Location.html#v:subTaskLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic machinery for executing a core strategy expression.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Parsing",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Parsing.html",
          "type": "module"
        },
        "index": {
          "description": "Basic machinery for executing core strategy expression",
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Parsing",
          "package": "ideas",
          "partial": "Parsing",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Result",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Result",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Result",
          "package": "ideas",
          "partial": "Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#t:Result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "State",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Parsing.html#State",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "State",
          "package": "ideas",
          "partial": "State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#t:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Step",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Step",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Step",
          "package": "ideas",
          "partial": "Step",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#t:Step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Strategy.Parsing\",\"Ideas.Common.Strategy\"]",
          "name": "Enter",
          "package": "ideas",
          "signature": "Enter l",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Step",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:Enter\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:Enter\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Enter",
          "package": "ideas",
          "partial": "Enter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:Enter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Strategy.Parsing\",\"Ideas.Common.Strategy\"]",
          "name": "Exit",
          "package": "ideas",
          "signature": "Exit l",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Step",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:Exit\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:Exit\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Exit",
          "package": "ideas",
          "partial": "Exit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:Exit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Ready",
          "package": "ideas",
          "signature": "Ready",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Ready",
          "package": "ideas",
          "partial": "Ready",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:Ready"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Result",
          "package": "ideas",
          "signature": "Result a",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "Result",
          "package": "ideas",
          "partial": "Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:Result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Strategy.Parsing\",\"Ideas.Common.Strategy\"]",
          "name": "RuleStep",
          "package": "ideas",
          "signature": "RuleStep Environment (Rule a)",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Step",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:RuleStep\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:RuleStep\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "RuleStep",
          "package": "ideas",
          "partial": "Rule Step",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:RuleStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "choices",
          "package": "ideas",
          "signature": "State l a -\u003e [Bool]",
          "source": "src/Ideas-Common-Strategy-Parsing.html#choices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "choices",
          "normalized": "State a b-\u003e[Bool]",
          "package": "ideas",
          "signature": "State l a-\u003e[Bool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:choices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "firsts",
          "package": "ideas",
          "signature": "Bool -\u003e State l a -\u003e [(Result (Step l a), State l a)]",
          "source": "src/Ideas-Common-Strategy-Parsing.html#firsts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "firsts",
          "normalized": "Bool-\u003eState a b-\u003e[(Result(Step a b),State a b)]",
          "package": "ideas",
          "signature": "Bool-\u003eState l a-\u003e[(Result(Step l a),State l a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:firsts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "isReady",
          "package": "ideas",
          "signature": "Result a -\u003e Bool",
          "source": "src/Ideas-Common-Strategy-Parsing.html#isReady",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "isReady",
          "normalized": "Result a-\u003eBool",
          "package": "ideas",
          "partial": "Ready",
          "signature": "Result a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:isReady"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "makeState",
          "package": "ideas",
          "signature": "Core l a -\u003e a -\u003e State l a",
          "source": "src/Ideas-Common-Strategy-Parsing.html#makeState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "makeState",
          "normalized": "Core a b-\u003eb-\u003eState a b",
          "package": "ideas",
          "partial": "State",
          "signature": "Core l a-\u003ea-\u003eState l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:makeState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "parseDerivationTree",
          "package": "ideas",
          "signature": "Bool -\u003e State l a -\u003e DerivationTree (Step l a) (State l a)",
          "source": "src/Ideas-Common-Strategy-Parsing.html#parseDerivationTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "parseDerivationTree",
          "normalized": "Bool-\u003eState a b-\u003eDerivationTree(Step a b)(State a b)",
          "package": "ideas",
          "partial": "Derivation Tree",
          "signature": "Bool-\u003eState l a-\u003eDerivationTree(Step l a)(State l a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:parseDerivationTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "replay",
          "package": "ideas",
          "signature": "Int -\u003e [Bool] -\u003e Core l a -\u003e m (State l a)",
          "source": "src/Ideas-Common-Strategy-Parsing.html#replay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "replay",
          "normalized": "Int-\u003e[Bool]-\u003eCore a b-\u003ec(State a b)",
          "package": "ideas",
          "signature": "Int-\u003e[Bool]-\u003eCore l a-\u003em(State l a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:replay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "runCore",
          "package": "ideas",
          "signature": "Core l a -\u003e a -\u003e [a]",
          "source": "src/Ideas-Common-Strategy-Parsing.html#runCore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "runCore",
          "normalized": "Core a b-\u003eb-\u003e[b]",
          "package": "ideas",
          "partial": "Core",
          "signature": "Core l a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:runCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "stack",
          "package": "ideas",
          "signature": "State l a -\u003e Stack l a",
          "source": "src/Ideas-Common-Strategy-Parsing.html#stack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "stack",
          "normalized": "State a b-\u003eStack a b",
          "package": "ideas",
          "signature": "State l a-\u003eStack l a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:stack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "trace",
          "package": "ideas",
          "signature": "State l a -\u003e [Step l a]",
          "source": "src/Ideas-Common-Strategy-Parsing.html#trace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "trace",
          "normalized": "State a b-\u003e[Step a b]",
          "package": "ideas",
          "signature": "State l a-\u003e[Step l a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:trace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "value",
          "package": "ideas",
          "signature": "State l a -\u003e a",
          "source": "src/Ideas-Common-Strategy-Parsing.html#value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Parsing",
          "module": "Ideas.Common.Strategy.Parsing",
          "name": "value",
          "normalized": "State a b-\u003eb",
          "package": "ideas",
          "signature": "State l a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Parsing.html#v:value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA prefix encodes a sequence of steps already performed (a so-called trace),\n and allows to continue the derivation at that particular point.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "Prefix",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Prefix.html",
          "type": "module"
        },
        "index": {
          "description": "prefix encodes sequence of steps already performed so-called trace and allows to continue the derivation at that particular point",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "Prefix",
          "package": "ideas",
          "partial": "Prefix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for a (labeled) strategy with a prefix (a sequence of\n executed rules). A prefix is still \u003ca\u003eaware\u003c/a\u003e of the labels that appear in the\n strategy. A prefix is encoded as a list of integers (and can be reconstructed\n from such a list: see \u003ccode\u003emakePrefix\u003c/code\u003e). The list is stored in reversed order.\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "Prefix",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Prefix.html#Prefix",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for labeled strategy with prefix sequence of executed rules prefix is still aware of the labels that appear in the strategy prefix is encoded as list of integers and can be reconstructed from such list see makePrefix The list is stored in reversed order",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "Prefix",
          "package": "ideas",
          "partial": "Prefix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#t:Prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the active labels\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "activeLabels",
          "package": "ideas",
          "signature": "Prefix a -\u003e [LabelInfo]",
          "source": "src/Ideas-Common-Strategy-Prefix.html#activeLabels",
          "type": "function"
        },
        "index": {
          "description": "Calculate the active labels",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "activeLabels",
          "normalized": "Prefix a-\u003e[LabelInfo]",
          "package": "ideas",
          "partial": "Labels",
          "signature": "Prefix a-\u003e[LabelInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:activeLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the empty prefix for a labeled strategy\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Prefix\",\"Ideas.Common.Strategy\"]",
          "name": "emptyPrefix",
          "package": "ideas",
          "signature": "LabeledStrategy a -\u003e Prefix a",
          "source": "src/Ideas-Common-Strategy-Prefix.html#emptyPrefix",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:emptyPrefix\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:emptyPrefix\"]"
        },
        "index": {
          "description": "Construct the empty prefix for labeled strategy",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "emptyPrefix",
          "normalized": "LabeledStrategy a-\u003ePrefix a",
          "package": "ideas",
          "partial": "Prefix",
          "signature": "LabeledStrategy a-\u003ePrefix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:emptyPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the last rule of a prefix (if such a rule exists)\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Prefix\",\"Ideas.Common.Strategy\"]",
          "name": "lastStepInPrefix",
          "package": "ideas",
          "signature": "Prefix a -\u003e Maybe (Step LabelInfo a)",
          "source": "src/Ideas-Common-Strategy-Prefix.html#lastStepInPrefix",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:lastStepInPrefix\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:lastStepInPrefix\"]"
        },
        "index": {
          "description": "Returns the last rule of prefix if such rule exists",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "lastStepInPrefix",
          "normalized": "Prefix a-\u003eMaybe(Step LabelInfo a)",
          "package": "ideas",
          "partial": "Step In Prefix",
          "signature": "Prefix a-\u003eMaybe(Step LabelInfo a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:lastStepInPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a prefix for a given list of integers and a labeled strategy.\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Prefix\",\"Ideas.Common.Strategy\"]",
          "name": "makePrefix",
          "package": "ideas",
          "signature": "[Int] -\u003e LabeledStrategy a -\u003e m (Prefix a)",
          "source": "src/Ideas-Common-Strategy-Prefix.html#makePrefix",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:makePrefix\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:makePrefix\"]"
        },
        "index": {
          "description": "Construct prefix for given list of integers and labeled strategy",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "makePrefix",
          "normalized": "[Int]-\u003eLabeledStrategy a-\u003eb(Prefix a)",
          "package": "ideas",
          "partial": "Prefix",
          "signature": "[Int]-\u003eLabeledStrategy a-\u003em(Prefix a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:makePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Common.Strategy.Prefix\",\"Ideas.Common.Strategy\"]",
          "name": "prefixToSteps",
          "package": "ideas",
          "signature": "Prefix a -\u003e [Step LabelInfo a]",
          "source": "src/Ideas-Common-Strategy-Prefix.html#prefixToSteps",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:prefixToSteps\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:prefixToSteps\"]"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "prefixToSteps",
          "normalized": "Prefix a-\u003e[Step LabelInfo a]",
          "package": "ideas",
          "partial": "To Steps",
          "signature": "Prefix a-\u003e[Step LabelInfo a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:prefixToSteps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a derivation tree with a \u003ca\u003eprefix\u003c/a\u003e as annotation.\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Prefix\",\"Ideas.Common.Strategy\"]",
          "name": "prefixTree",
          "package": "ideas",
          "signature": "Bool -\u003e Prefix a -\u003e a -\u003e DerivationTree (Prefix a) a",
          "source": "src/Ideas-Common-Strategy-Prefix.html#prefixTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:prefixTree\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:prefixTree\"]"
        },
        "index": {
          "description": "Create derivation tree with prefix as annotation",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "prefixTree",
          "normalized": "Bool-\u003ePrefix a-\u003ea-\u003eDerivationTree(Prefix a)a",
          "package": "ideas",
          "partial": "Tree",
          "signature": "Bool-\u003ePrefix a-\u003ea-\u003eDerivationTree(Prefix a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:prefixTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieves the rules from a list of steps\n\u003c/p\u003e",
          "module": "[\"Ideas.Common.Strategy.Prefix\",\"Ideas.Common.Strategy\"]",
          "name": "stepsToRules",
          "package": "ideas",
          "signature": "[Step l a] -\u003e [Rule a]",
          "source": "src/Ideas-Common-Strategy-Prefix.html#stepsToRules",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:stepsToRules\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:stepsToRules\"]"
        },
        "index": {
          "description": "Retrieves the rules from list of steps",
          "hierarchy": "Ideas Common Strategy Prefix",
          "module": "Ideas.Common.Strategy.Prefix",
          "name": "stepsToRules",
          "normalized": "[Step a b]-\u003e[Rule b]",
          "package": "ideas",
          "partial": "To Rules",
          "signature": "[Step l a]-\u003e[Rule a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Prefix.html#v:stepsToRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTesting strategy combinator properties\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Strategy.Tests",
          "name": "Tests",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Tests.html",
          "type": "module"
        },
        "index": {
          "description": "Testing strategy combinator properties",
          "hierarchy": "Ideas Common Strategy Tests",
          "module": "Ideas.Common.Strategy.Tests",
          "name": "Tests",
          "package": "ideas",
          "partial": "Tests",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Tests.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Tests",
          "name": "tests",
          "package": "ideas",
          "signature": "TestSuite",
          "source": "src/Ideas-Common-Strategy-Tests.html#tests",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Tests",
          "module": "Ideas.Common.Strategy.Tests",
          "name": "tests",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Tests.html#v:tests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "Traversal",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Traversal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "Traversal",
          "package": "ideas",
          "partial": "Traversal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "Option",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Traversal.html#Option",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "Option",
          "package": "ideas",
          "partial": "Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#t:Option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "bottomup",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#bottomup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "bottomup",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:bottomup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "full",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#full",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "full",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:full"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "fullbu",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#fullbu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "fullbu",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:fullbu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "fulltd",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#fulltd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "fulltd",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:fulltd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "innermost",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#innermost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "innermost",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:innermost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "layer",
          "package": "ideas",
          "signature": "[Option a] -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#layer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "layer",
          "normalized": "[Option a]-\u003eb a-\u003eStrategy a",
          "package": "ideas",
          "signature": "[Option a]-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:layer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "leftToRight",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#leftToRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "leftToRight",
          "package": "ideas",
          "partial": "To Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:leftToRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "once",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#once",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "once",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:once"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "oncebu",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#oncebu",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "oncebu",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:oncebu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "oncetd",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#oncetd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "oncetd",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:oncetd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "outermost",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#outermost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "outermost",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:outermost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "parentFilter",
          "package": "ideas",
          "signature": "(a -\u003e [Int]) -\u003e Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#parentFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "parentFilter",
          "normalized": "(a-\u003e[Int])-\u003eOption a",
          "package": "ideas",
          "partial": "Filter",
          "signature": "(a-\u003e[Int])-\u003eOption a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:parentFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "rightToLeft",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#rightToLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "rightToLeft",
          "package": "ideas",
          "partial": "To Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:rightToLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "somewhere",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#somewhere",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "somewhere",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "signature": "f a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:somewhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "spine",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#spine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "spine",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:spine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "stop",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#stop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "stop",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:stop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "topdown",
          "package": "ideas",
          "signature": "Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#topdown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "topdown",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:topdown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "traversalFilter",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e Option a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#traversalFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "traversalFilter",
          "normalized": "(a-\u003eBool)-\u003eOption a",
          "package": "ideas",
          "partial": "Filter",
          "signature": "(a-\u003eBool)-\u003eOption a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:traversalFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "traverse",
          "package": "ideas",
          "signature": "[Option a] -\u003e f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Traversal.html#traverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy Traversal",
          "module": "Ideas.Common.Strategy.Traversal",
          "name": "traverse",
          "normalized": "[Option a]-\u003eb a-\u003eStrategy a",
          "package": "ideas",
          "signature": "[Option a]-\u003ef a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy-Traversal.html#v:traverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA strategy is a context-free grammar with rules as symbols. Strategies can be\n labeled with strings. A type class is introduced to lift all the combinators\n that work on strategies, only to prevent that you have to insert these lifting\n functions yourself.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Strategy",
          "name": "Strategy",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy.html",
          "type": "module"
        },
        "index": {
          "description": "strategy is context-free grammar with rules as symbols Strategies can be labeled with strings type class is introduced to lift all the combinators that work on strategies only to prevent that you have to insert these lifting functions yourself",
          "hierarchy": "Ideas Common Strategy",
          "module": "Ideas.Common.Strategy",
          "name": "Strategy",
          "package": "ideas",
          "partial": "Strategy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType class to turn values into strategies\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy",
          "name": "IsStrategy",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#IsStrategy",
          "type": "class"
        },
        "index": {
          "description": "Type class to turn values into strategies",
          "hierarchy": "Ideas Common Strategy",
          "module": "Ideas.Common.Strategy",
          "name": "IsStrategy",
          "package": "ideas",
          "partial": "Is Strategy",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#t:IsStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strategy which is labeled with a string\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy",
          "name": "LabeledStrategy",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#LabeledStrategy",
          "type": "data"
        },
        "index": {
          "description": "strategy which is labeled with string",
          "hierarchy": "Ideas Common Strategy",
          "module": "Ideas.Common.Strategy",
          "name": "LabeledStrategy",
          "package": "ideas",
          "partial": "Labeled Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#t:LabeledStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for a (labeled) strategy with a prefix (a sequence of\n executed rules). A prefix is still \u003ca\u003eaware\u003c/a\u003e of the labels that appear in the\n strategy. A prefix is encoded as a list of integers (and can be reconstructed\n from such a list: see \u003ccode\u003emakePrefix\u003c/code\u003e). The list is stored in reversed order.\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy",
          "name": "Prefix",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Prefix.html#Prefix",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for labeled strategy with prefix sequence of executed rules prefix is still aware of the labels that appear in the strategy prefix is encoded as list of integers and can be reconstructed from such list see makePrefix The list is stored in reversed order",
          "hierarchy": "Ideas Common Strategy",
          "module": "Ideas.Common.Strategy",
          "name": "Prefix",
          "package": "ideas",
          "partial": "Prefix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#t:Prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy",
          "name": "Step",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Parsing.html#Step",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy",
          "module": "Ideas.Common.Strategy",
          "name": "Step",
          "package": "ideas",
          "partial": "Step",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#t:Step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract data type for strategies\n\u003c/p\u003e",
          "module": "Ideas.Common.Strategy",
          "name": "Strategy",
          "package": "ideas",
          "source": "src/Ideas-Common-Strategy-Abstract.html#Strategy",
          "type": "data"
        },
        "index": {
          "description": "Abstract data type for strategies",
          "hierarchy": "Ideas Common Strategy",
          "module": "Ideas.Common.Strategy",
          "name": "Strategy",
          "package": "ideas",
          "partial": "Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#t:Strategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Strategy",
          "name": "toStrategy",
          "package": "ideas",
          "signature": "f a -\u003e Strategy a",
          "source": "src/Ideas-Common-Strategy-Abstract.html#toStrategy",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Strategy",
          "module": "Ideas.Common.Strategy",
          "name": "toStrategy",
          "normalized": "a b-\u003eStrategy b",
          "package": "ideas",
          "partial": "Strategy",
          "signature": "f a-\u003eStrategy a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Strategy.html#v:toStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "Iterator",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Iterator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "Iterator",
          "package": "ideas",
          "partial": "Iterator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "Iterator",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Iterator.html#Iterator",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "Iterator",
          "package": "ideas",
          "partial": "Iterator",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#t:Iterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "ListIterator",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Iterator.html#ListIterator",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "ListIterator",
          "package": "ideas",
          "partial": "List Iterator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#t:ListIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "final",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#final",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "final",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:final"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "first",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#first",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "first",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:first"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "hasNext",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Iterator.html#hasNext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "hasNext",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Next",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:hasNext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "hasPrevious",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Iterator.html#hasPrevious",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "hasPrevious",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Previous",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:hasPrevious"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "isFinal",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Iterator.html#isFinal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "isFinal",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Final",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:isFinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "isFirst",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Iterator.html#isFirst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "isFirst",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "First",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:isFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "next",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#next",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "next",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:next"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "position",
          "package": "ideas",
          "signature": "a -\u003e Int",
          "source": "src/Ideas-Common-Traversal-Iterator.html#position",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "position",
          "normalized": "a-\u003eInt",
          "package": "ideas",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:position"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "previous",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#previous",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "previous",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:previous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchBackward",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#searchBackward",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchBackward",
          "normalized": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "Backward",
          "signature": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:searchBackward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchForward",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#searchForward",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchForward",
          "normalized": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "Forward",
          "signature": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:searchForward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchNext",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#searchNext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchNext",
          "normalized": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "Next",
          "signature": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:searchNext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchPrevious",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#searchPrevious",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchPrevious",
          "normalized": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "Previous",
          "signature": "(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:searchPrevious"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchWith",
          "package": "ideas",
          "signature": "(a -\u003e Maybe a) -\u003e (a -\u003e Bool) -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Iterator.html#searchWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Iterator",
          "module": "Ideas.Common.Traversal.Iterator",
          "name": "searchWith",
          "normalized": "(a-\u003eMaybe a)-\u003e(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "With",
          "signature": "(a-\u003eMaybe a)-\u003e(a-\u003eBool)-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Iterator.html#v:searchWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Navigator",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Navigator",
          "package": "ideas",
          "partial": "Navigator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Horizontal",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#Horizontal",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Horizontal",
          "package": "ideas",
          "partial": "Horizontal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:Horizontal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Leafs",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#Leafs",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Leafs",
          "package": "ideas",
          "partial": "Leafs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:Leafs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "LevelOrder",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#LevelOrder",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "LevelOrder",
          "package": "ideas",
          "partial": "Level Order",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:LevelOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Location",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#Location",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Location",
          "package": "ideas",
          "partial": "Location",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:Location"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor a minimal complete definition, provide an implemention for downs or\n allDowns. All other functions need an implementation as well, except for\n change. Note that a constructor (a -\u003e f a) is not included in the type class\n to allow additional type class constraints on type a.\n\u003c/p\u003e",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Navigator",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#Navigator",
          "type": "class"
        },
        "index": {
          "description": "For minimal complete definition provide an implemention for downs or allDowns All other functions need an implementation as well except for change Note that constructor is not included in the type class to allow additional type class constraints on type",
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "Navigator",
          "package": "ideas",
          "partial": "Navigator",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:Navigator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "PostOrder",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#PostOrder",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "PostOrder",
          "package": "ideas",
          "partial": "Post Order",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:PostOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "PreOrder",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#PreOrder",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "PreOrder",
          "package": "ideas",
          "partial": "Pre Order",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:PreOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "UniplateNavigator",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Navigator.html#UniplateNavigator",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "UniplateNavigator",
          "package": "ideas",
          "partial": "Uniplate Navigator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#t:UniplateNavigator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "arity",
          "package": "ideas",
          "signature": "a -\u003e Int",
          "source": "src/Ideas-Common-Traversal-Navigator.html#arity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "arity",
          "normalized": "a-\u003eInt",
          "package": "ideas",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:arity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "childnr",
          "package": "ideas",
          "signature": "a -\u003e Int",
          "source": "src/Ideas-Common-Traversal-Navigator.html#childnr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "childnr",
          "normalized": "a-\u003eInt",
          "package": "ideas",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:childnr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "depth",
          "package": "ideas",
          "signature": "a -\u003e Int",
          "source": "src/Ideas-Common-Traversal-Navigator.html#depth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "depth",
          "normalized": "a-\u003eInt",
          "package": "ideas",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:depth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "down",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#down",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "down",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "downLast",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#downLast",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "downLast",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "partial": "Last",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:downLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "downTo",
          "package": "ideas",
          "signature": "Int -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#downTo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "downTo",
          "normalized": "Int-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "To",
          "signature": "Int-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:downTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "downs",
          "package": "ideas",
          "signature": "a -\u003e [a]",
          "source": "src/Ideas-Common-Traversal-Navigator.html#downs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "downs",
          "normalized": "a-\u003e[a]",
          "package": "ideas",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:downs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "fromLocation",
          "package": "ideas",
          "signature": "Location -\u003e [Int]",
          "source": "src/Ideas-Common-Traversal-Navigator.html#fromLocation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "fromLocation",
          "normalized": "Location-\u003e[Int]",
          "package": "ideas",
          "partial": "Location",
          "signature": "Location-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:fromLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasDown",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Navigator.html#hasDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasDown",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Down",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:hasDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasLeft",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Navigator.html#hasLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasLeft",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Left",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:hasLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasRight",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Navigator.html#hasRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasRight",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Right",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:hasRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasUp",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Navigator.html#hasUp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "hasUp",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Up",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:hasUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "isLeaf",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Navigator.html#isLeaf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "isLeaf",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Leaf",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:isLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "isTop",
          "package": "ideas",
          "signature": "a -\u003e Bool",
          "source": "src/Ideas-Common-Traversal-Navigator.html#isTop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "isTop",
          "normalized": "a-\u003eBool",
          "package": "ideas",
          "partial": "Top",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:isTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "left",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#left",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "left",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "leftMost",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#leftMost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "leftMost",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "partial": "Most",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:leftMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "leftMostAt",
          "package": "ideas",
          "signature": "Int -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#leftMostAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "leftMostAt",
          "normalized": "Int-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "Most At",
          "signature": "Int-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:leftMostAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "leftMostLeaf",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#leftMostLeaf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "leftMostLeaf",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "partial": "Most Leaf",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:leftMostLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "level",
          "package": "ideas",
          "signature": "a -\u003e Int",
          "source": "src/Ideas-Common-Traversal-Navigator.html#level",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "level",
          "normalized": "a-\u003eInt",
          "package": "ideas",
          "signature": "a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:level"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "levelNext",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#levelNext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "levelNext",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "partial": "Next",
          "signature": "a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:levelNext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "levelPrevious",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#levelPrevious",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "levelPrevious",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "partial": "Previous",
          "signature": "a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:levelPrevious"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "location",
          "package": "ideas",
          "signature": "a -\u003e Location",
          "source": "src/Ideas-Common-Traversal-Navigator.html#location",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "location",
          "normalized": "a-\u003eLocation",
          "package": "ideas",
          "signature": "a-\u003eLocation",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:location"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makeHorizontal",
          "package": "ideas",
          "signature": "a -\u003e Horizontal a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#makeHorizontal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makeHorizontal",
          "normalized": "a-\u003eHorizontal a",
          "package": "ideas",
          "partial": "Horizontal",
          "signature": "a-\u003eHorizontal a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:makeHorizontal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makeLeafs",
          "package": "ideas",
          "signature": "a -\u003e Leafs a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#makeLeafs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makeLeafs",
          "normalized": "a-\u003eLeafs a",
          "package": "ideas",
          "partial": "Leafs",
          "signature": "a-\u003eLeafs a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:makeLeafs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makeLevelOrder",
          "package": "ideas",
          "signature": "a -\u003e LevelOrder a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#makeLevelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makeLevelOrder",
          "normalized": "a-\u003eLevelOrder a",
          "package": "ideas",
          "partial": "Level Order",
          "signature": "a-\u003eLevelOrder a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:makeLevelOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makePostOrder",
          "package": "ideas",
          "signature": "a -\u003e PostOrder a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#makePostOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makePostOrder",
          "normalized": "a-\u003ePostOrder a",
          "package": "ideas",
          "partial": "Post Order",
          "signature": "a-\u003ePostOrder a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:makePostOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makePreOrder",
          "package": "ideas",
          "signature": "a -\u003e PreOrder a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#makePreOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "makePreOrder",
          "normalized": "a-\u003ePreOrder a",
          "package": "ideas",
          "partial": "Pre Order",
          "signature": "a-\u003ePreOrder a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:makePreOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "navigateTo",
          "package": "ideas",
          "signature": "Location -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#navigateTo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "navigateTo",
          "normalized": "Location-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "To",
          "signature": "Location-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:navigateTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "navigateTowards",
          "package": "ideas",
          "signature": "Location -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#navigateTowards",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "navigateTowards",
          "normalized": "Location-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Towards",
          "signature": "Location-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:navigateTowards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "right",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#right",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "right",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "rightMost",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#rightMost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "rightMost",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "partial": "Most",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:rightMost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "rightMostAt",
          "package": "ideas",
          "signature": "Int -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#rightMostAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "rightMostAt",
          "normalized": "Int-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "Most At",
          "signature": "Int-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:rightMostAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "rightMostLeaf",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#rightMostLeaf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "rightMostLeaf",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "partial": "Most Leaf",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:rightMostLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "toLocation",
          "package": "ideas",
          "signature": "[Int] -\u003e Location",
          "source": "src/Ideas-Common-Traversal-Navigator.html#toLocation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "toLocation",
          "normalized": "[Int]-\u003eLocation",
          "package": "ideas",
          "partial": "Location",
          "signature": "[Int]-\u003eLocation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:toLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "top",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#top",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "top",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:top"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "up",
          "package": "ideas",
          "signature": "a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Navigator.html#up",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Navigator",
          "module": "Ideas.Common.Traversal.Navigator",
          "name": "up",
          "normalized": "a-\u003eMaybe a",
          "package": "ideas",
          "signature": "a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Navigator.html#v:up"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Tests",
          "name": "Tests",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Tests.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Tests",
          "module": "Ideas.Common.Traversal.Tests",
          "name": "Tests",
          "package": "ideas",
          "partial": "Tests",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Tests.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Tests",
          "name": "listGen",
          "package": "ideas",
          "signature": "Gen (ListIterator Int)",
          "source": "src/Ideas-Common-Traversal-Tests.html#listGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Tests",
          "module": "Ideas.Common.Traversal.Tests",
          "name": "listGen",
          "package": "ideas",
          "partial": "Gen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Tests.html#v:listGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Tests",
          "name": "testIterator",
          "package": "ideas",
          "signature": "String -\u003e Gen a -\u003e TestSuite",
          "source": "src/Ideas-Common-Traversal-Tests.html#testIterator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Tests",
          "module": "Ideas.Common.Traversal.Tests",
          "name": "testIterator",
          "normalized": "String-\u003eGen a-\u003eTestSuite",
          "package": "ideas",
          "partial": "Iterator",
          "signature": "String-\u003eGen a-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Tests.html#v:testIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Tests",
          "name": "testNavigator",
          "package": "ideas",
          "signature": "String -\u003e Gen a -\u003e TestSuite",
          "source": "src/Ideas-Common-Traversal-Tests.html#testNavigator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Tests",
          "module": "Ideas.Common.Traversal.Tests",
          "name": "testNavigator",
          "normalized": "String-\u003eGen a-\u003eTestSuite",
          "package": "ideas",
          "partial": "Navigator",
          "signature": "String-\u003eGen a-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Tests.html#v:testNavigator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Tests",
          "name": "tests",
          "package": "ideas",
          "signature": "TestSuite",
          "source": "src/Ideas-Common-Traversal-Tests.html#tests",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Tests",
          "module": "Ideas.Common.Traversal.Tests",
          "name": "tests",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Tests.html#v:tests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Tests",
          "name": "uniGen",
          "package": "ideas",
          "signature": "Gen (UniplateNavigator (T Int))",
          "source": "src/Ideas-Common-Traversal-Tests.html#uniGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Tests",
          "module": "Ideas.Common.Traversal.Tests",
          "name": "uniGen",
          "package": "ideas",
          "partial": "Gen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Tests.html#v:uniGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Utils",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Utils.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Utils",
          "package": "ideas",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Focus",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Utils.html#Focus",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Focus",
          "package": "ideas",
          "partial": "Focus",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#t:Focus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Mirror",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Utils.html#Mirror",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Mirror",
          "package": "ideas",
          "partial": "Mirror",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#t:Mirror"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Update",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Utils.html#Update",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Update",
          "package": "ideas",
          "partial": "Update",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#t:Update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Wrapper",
          "package": "ideas",
          "source": "src/Ideas-Common-Traversal-Utils.html#Wrapper",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "Wrapper",
          "package": "ideas",
          "partial": "Wrapper",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#t:Wrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "(\u003e|\u003c)",
          "package": "ideas",
          "signature": "(a -\u003e Maybe a) -\u003e (a -\u003e Maybe a) -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Utils.html#%3E%7C%3C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "(\u003e|\u003c) \u003e|\u003c",
          "normalized": "(a-\u003eMaybe a)-\u003e(a-\u003eMaybe a)-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "signature": "(a-\u003eMaybe a)-\u003e(a-\u003eMaybe a)-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:-62--124--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-to-right Kleisli composition of monads.\n\u003c/p\u003e",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "(\u003e=\u003e)",
          "package": "ideas",
          "signature": "(a -\u003e m b) -\u003e (b -\u003e m c) -\u003e a -\u003e m c",
          "type": "function"
        },
        "index": {
          "description": "Left-to-right Kleisli composition of monads",
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "(\u003e=\u003e) \u003e=\u003e",
          "normalized": "(a-\u003eb c)-\u003e(c-\u003eb d)-\u003ea-\u003eb d",
          "package": "ideas",
          "signature": "(a-\u003em b)-\u003e(b-\u003em c)-\u003ea-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:-62--61--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "change",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e f a -\u003e f a",
          "source": "src/Ideas-Common-Traversal-Utils.html#change",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "change",
          "normalized": "(a-\u003ea)-\u003eb a-\u003eb a",
          "package": "ideas",
          "signature": "(a-\u003ea)-\u003ef a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:change"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "changeG",
          "package": "ideas",
          "signature": "(a -\u003e g a) -\u003e f a -\u003e g (f a)",
          "source": "src/Ideas-Common-Traversal-Utils.html#changeG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "changeG",
          "normalized": "(a-\u003eb a)-\u003ec a-\u003eb(c a)",
          "package": "ideas",
          "signature": "(a-\u003eg a)-\u003ef a-\u003eg(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:changeG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "changeM",
          "package": "ideas",
          "signature": "(a -\u003e Maybe a) -\u003e f a -\u003e Maybe (f a)",
          "source": "src/Ideas-Common-Traversal-Utils.html#changeM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "changeM",
          "normalized": "(a-\u003eMaybe a)-\u003eb a-\u003eMaybe(b a)",
          "package": "ideas",
          "signature": "(a-\u003eMaybe a)-\u003ef a-\u003eMaybe(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:changeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "current",
          "package": "ideas",
          "signature": "f a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Utils.html#current",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "current",
          "normalized": "a b-\u003eb",
          "package": "ideas",
          "signature": "f a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:current"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "fixp",
          "package": "ideas",
          "signature": "(a -\u003e Maybe a) -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Utils.html#fixp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "fixp",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:fixp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "fixpl",
          "package": "ideas",
          "signature": "(a -\u003e Maybe a) -\u003e a -\u003e [a]",
          "source": "src/Ideas-Common-Traversal-Utils.html#fixpl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "fixpl",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003e[a]",
          "package": "ideas",
          "signature": "(a-\u003eMaybe a)-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:fixpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "focus",
          "package": "ideas",
          "signature": "Unfocus a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Utils.html#focus",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "focus",
          "normalized": "Unfocus a-\u003ea",
          "package": "ideas",
          "signature": "Unfocus a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:focus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "focusM",
          "package": "ideas",
          "signature": "Unfocus a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Utils.html#focusM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "focusM",
          "normalized": "Unfocus a-\u003eMaybe a",
          "package": "ideas",
          "signature": "Unfocus a-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:focusM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "liftFocus",
          "package": "ideas",
          "signature": "(Unfocus a -\u003e Maybe (Unfocus a)) -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-Traversal-Utils.html#liftFocus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "liftFocus",
          "normalized": "(Unfocus a-\u003eMaybe(Unfocus a))-\u003ea-\u003eMaybe a",
          "package": "ideas",
          "partial": "Focus",
          "signature": "(Unfocus a-\u003eMaybe(Unfocus a))-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:liftFocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "liftWrapper",
          "package": "ideas",
          "signature": "(a -\u003e m a) -\u003e f a -\u003e m (f a)",
          "source": "src/Ideas-Common-Traversal-Utils.html#liftWrapper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "liftWrapper",
          "normalized": "(a-\u003eb a)-\u003ec a-\u003eb(c a)",
          "package": "ideas",
          "partial": "Wrapper",
          "signature": "(a-\u003em a)-\u003ef a-\u003em(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:liftWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "makeMirror",
          "package": "ideas",
          "signature": "a -\u003e Mirror a",
          "source": "src/Ideas-Common-Traversal-Utils.html#makeMirror",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "makeMirror",
          "normalized": "a-\u003eMirror a",
          "package": "ideas",
          "partial": "Mirror",
          "signature": "a-\u003eMirror a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:makeMirror"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "mapWrapper",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e f a -\u003e f a",
          "source": "src/Ideas-Common-Traversal-Utils.html#mapWrapper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "mapWrapper",
          "normalized": "(a-\u003ea)-\u003eb a-\u003eb a",
          "package": "ideas",
          "partial": "Wrapper",
          "signature": "(a-\u003ea)-\u003ef a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:mapWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associative operation\n\u003c/p\u003e",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "mplus",
          "package": "ideas",
          "signature": "forall a.  m a -\u003e m a -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "an associative operation",
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "mplus",
          "normalized": "a b c d-\u003ec d-\u003ec d",
          "package": "ideas",
          "signature": "forall a. m a-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:mplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "replace",
          "package": "ideas",
          "signature": "a -\u003e f a -\u003e f a",
          "source": "src/Ideas-Common-Traversal-Utils.html#replace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "replace",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "ideas",
          "signature": "a-\u003ef a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "safe",
          "package": "ideas",
          "signature": "(a -\u003e Maybe a) -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Utils.html#safe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "safe",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:safe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unfocus",
          "package": "ideas",
          "signature": "a -\u003e Unfocus a",
          "source": "src/Ideas-Common-Traversal-Utils.html#unfocus",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unfocus",
          "normalized": "a-\u003eUnfocus a",
          "package": "ideas",
          "signature": "a-\u003eUnfocus a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:unfocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unliftFocus",
          "package": "ideas",
          "signature": "(a -\u003e Maybe a) -\u003e Unfocus a -\u003e Maybe (Unfocus a)",
          "source": "src/Ideas-Common-Traversal-Utils.html#unliftFocus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unliftFocus",
          "normalized": "(a-\u003eMaybe a)-\u003eUnfocus a-\u003eMaybe(Unfocus a)",
          "package": "ideas",
          "partial": "Focus",
          "signature": "(a-\u003eMaybe a)-\u003eUnfocus a-\u003eMaybe(Unfocus a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:unliftFocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unliftWrapper",
          "package": "ideas",
          "signature": "(f a -\u003e m (f a)) -\u003e a -\u003e m a",
          "source": "src/Ideas-Common-Traversal-Utils.html#unliftWrapper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unliftWrapper",
          "normalized": "(a b-\u003ec(a b))-\u003eb-\u003ec b",
          "package": "ideas",
          "partial": "Wrapper",
          "signature": "(f a-\u003em(f a))-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:unliftWrapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unwrap",
          "package": "ideas",
          "signature": "f a -\u003e a",
          "source": "src/Ideas-Common-Traversal-Utils.html#unwrap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "unwrap",
          "normalized": "a b-\u003eb",
          "package": "ideas",
          "signature": "f a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:unwrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "update",
          "package": "ideas",
          "signature": "f a -\u003e (a, a -\u003e f a)",
          "source": "src/Ideas-Common-Traversal-Utils.html#update",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "update",
          "normalized": "a b-\u003e(b,b-\u003ea b)",
          "package": "ideas",
          "signature": "f a-\u003e(a,a-\u003ef a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Traversal.Utils",
          "name": "wrap",
          "package": "ideas",
          "signature": "a -\u003e f a",
          "source": "src/Ideas-Common-Traversal-Utils.html#wrap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common Traversal Utils",
          "module": "Ideas.Common.Traversal.Utils",
          "name": "wrap",
          "normalized": "a-\u003eb a",
          "package": "ideas",
          "signature": "a-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Traversal-Utils.html#v:wrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExtensions to the QuickCheck library\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "QuickCheck",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-QuickCheck.html",
          "type": "module"
        },
        "index": {
          "description": "Extensions to the QuickCheck library",
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "QuickCheck",
          "package": "ideas",
          "partial": "Quick Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "ArbGen",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#ArbGen",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "ArbGen",
          "package": "ideas",
          "partial": "Arb Gen",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#t:ArbGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "arbGen",
          "package": "ideas",
          "signature": "(b -\u003e a) -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#arbGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "arbGen",
          "normalized": "(a-\u003eb)-\u003eArbGen b",
          "package": "ideas",
          "partial": "Gen",
          "signature": "(b-\u003ea)-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:arbGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "binaryGen",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e a) -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#binaryGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "binaryGen",
          "normalized": "(a-\u003ea-\u003ea)-\u003eArbGen a",
          "package": "ideas",
          "partial": "Gen",
          "signature": "(a-\u003ea-\u003ea)-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:binaryGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "binaryGens",
          "package": "ideas",
          "signature": "[a -\u003e a -\u003e a] -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#binaryGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "binaryGens",
          "normalized": "[a-\u003ea-\u003ea]-\u003eArbGen a",
          "package": "ideas",
          "partial": "Gens",
          "signature": "[a-\u003ea-\u003ea]-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:binaryGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "changeFrequency",
          "package": "ideas",
          "signature": "Rational -\u003e ArbGen a -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#changeFrequency",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "changeFrequency",
          "normalized": "Rational-\u003eArbGen a-\u003eArbGen a",
          "package": "ideas",
          "partial": "Frequency",
          "signature": "Rational-\u003eArbGen a-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:changeFrequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "common",
          "package": "ideas",
          "signature": "ArbGen a -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#common",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "common",
          "normalized": "ArbGen a-\u003eArbGen a",
          "package": "ideas",
          "signature": "ArbGen a-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:common"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "constGen",
          "package": "ideas",
          "signature": "a -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#constGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "constGen",
          "normalized": "a-\u003eArbGen a",
          "package": "ideas",
          "partial": "Gen",
          "signature": "a-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:constGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "constGens",
          "package": "ideas",
          "signature": "[a] -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#constGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "constGens",
          "normalized": "[a]-\u003eArbGen a",
          "package": "ideas",
          "partial": "Gens",
          "signature": "[a]-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:constGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "generator",
          "package": "ideas",
          "signature": "ArbGen a -\u003e Gen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#generator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "generator",
          "normalized": "ArbGen a-\u003eGen a",
          "package": "ideas",
          "signature": "ArbGen a-\u003eGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:generator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "generators",
          "package": "ideas",
          "signature": "[ArbGen a] -\u003e Gen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#generators",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "generators",
          "normalized": "[ArbGen a]-\u003eGen a",
          "package": "ideas",
          "signature": "[ArbGen a]-\u003eGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:generators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "rare",
          "package": "ideas",
          "signature": "ArbGen a -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#rare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "rare",
          "normalized": "ArbGen a-\u003eArbGen a",
          "package": "ideas",
          "signature": "ArbGen a-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:rare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "toArbGen",
          "package": "ideas",
          "signature": "Gen a -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#toArbGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "toArbGen",
          "normalized": "Gen a-\u003eArbGen a",
          "package": "ideas",
          "partial": "Arb Gen",
          "signature": "Gen a-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:toArbGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "unaryArbGen",
          "package": "ideas",
          "signature": "(b -\u003e a -\u003e a) -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#unaryArbGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "unaryArbGen",
          "normalized": "(a-\u003eb-\u003eb)-\u003eArbGen b",
          "package": "ideas",
          "partial": "Arb Gen",
          "signature": "(b-\u003ea-\u003ea)-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:unaryArbGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "unaryGen",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#unaryGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "unaryGen",
          "normalized": "(a-\u003ea)-\u003eArbGen a",
          "package": "ideas",
          "partial": "Gen",
          "signature": "(a-\u003ea)-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:unaryGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "unaryGens",
          "package": "ideas",
          "signature": "[a -\u003e a] -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#unaryGens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "unaryGens",
          "normalized": "[a-\u003ea]-\u003eArbGen a",
          "package": "ideas",
          "partial": "Gens",
          "signature": "[a-\u003ea]-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:unaryGens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "uncommon",
          "package": "ideas",
          "signature": "ArbGen a -\u003e ArbGen a",
          "source": "src/Ideas-Common-Utils-QuickCheck.html#uncommon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils QuickCheck",
          "module": "Ideas.Common.Utils.QuickCheck",
          "name": "uncommon",
          "normalized": "ArbGen a-\u003eArbGen a",
          "package": "ideas",
          "signature": "ArbGen a-\u003eArbGen a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-QuickCheck.html#v:uncommon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReferences to Strings, proving a fast comparison implementation (Eq and\n Ord) that uses a hash function. Code is based on Daan Leijen's Lazy\n Virutal Machine (LVM) identifiers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Utils.StringRef",
          "name": "StringRef",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-StringRef.html",
          "type": "module"
        },
        "index": {
          "description": "References to Strings proving fast comparison implementation Eq and Ord that uses hash function Code is based on Daan Leijen Lazy Virutal Machine LVM identifiers",
          "hierarchy": "Ideas Common Utils StringRef",
          "module": "Ideas.Common.Utils.StringRef",
          "name": "StringRef",
          "package": "ideas",
          "partial": "String Ref",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-StringRef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.StringRef",
          "name": "StringRef",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-StringRef.html#StringRef",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Utils StringRef",
          "module": "Ideas.Common.Utils.StringRef",
          "name": "StringRef",
          "package": "ideas",
          "partial": "String Ref",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-StringRef.html#t:StringRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.StringRef",
          "name": "stringRef",
          "package": "ideas",
          "signature": "String -\u003e StringRef",
          "source": "src/Ideas-Common-Utils-StringRef.html#stringRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils StringRef",
          "module": "Ideas.Common.Utils.StringRef",
          "name": "stringRef",
          "normalized": "String-\u003eStringRef",
          "package": "ideas",
          "partial": "Ref",
          "signature": "String-\u003eStringRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-StringRef.html#v:stringRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.StringRef",
          "name": "tableStatus",
          "package": "ideas",
          "signature": "IO String",
          "source": "src/Ideas-Common-Utils-StringRef.html#tableStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils StringRef",
          "module": "Ideas.Common.Utils.StringRef",
          "name": "tableStatus",
          "package": "ideas",
          "partial": "Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-StringRef.html#v:tableStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.StringRef",
          "name": "toString",
          "package": "ideas",
          "signature": "StringRef -\u003e String",
          "source": "src/Ideas-Common-Utils-StringRef.html#toString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils StringRef",
          "module": "Ideas.Common.Utils.StringRef",
          "name": "toString",
          "normalized": "StringRef-\u003eString",
          "package": "ideas",
          "partial": "String",
          "signature": "StringRef-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-StringRef.html#v:toString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA lightweight wrapper around the QuickCheck library. It introduces the\n notion of a test suite, and it stores the test results for later inspection\n (e.g., for the generation of a test report). A test suite has a monadic\n interface.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "TestSuite",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-TestSuite.html",
          "type": "module"
        },
        "index": {
          "description": "lightweight wrapper around the QuickCheck library It introduces the notion of test suite and it stores the test results for later inspection e.g for the generation of test report test suite has monadic interface",
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "TestSuite",
          "package": "ideas",
          "partial": "Test Suite",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "Message",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-TestSuite.html#Message",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "Message",
          "package": "ideas",
          "partial": "Message",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#t:Message"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonads in which \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e computations may be embedded.\n Any monad built by applying a sequence of monad transformers to the\n \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad will be an instance of this class.\n\u003c/p\u003e\u003cp\u003eInstances should satisfy the following laws, which state that \u003ccode\u003e\u003ca\u003eliftIO\u003c/a\u003e\u003c/code\u003e\n is a transformer of monads:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eliftIO\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eliftIO\u003c/a\u003e\u003c/code\u003e (m \u003e\u003e= f) = \u003ccode\u003e\u003ca\u003eliftIO\u003c/a\u003e\u003c/code\u003e m \u003e\u003e= (\u003ccode\u003e\u003ca\u003eliftIO\u003c/a\u003e\u003c/code\u003e . f)\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "MonadIO",
          "package": "ideas",
          "type": "class"
        },
        "index": {
          "description": "Monads in which IO computations may be embedded Any monad built by applying sequence of monad transformers to the IO monad will be an instance of this class Instances should satisfy the following laws which state that liftIO is transformer of monads liftIO return return liftIO liftIO liftIO",
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "MonadIO",
          "package": "ideas",
          "partial": "Monad IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#t:MonadIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "TestSuite",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-TestSuite.html#TestSuite",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "TestSuite",
          "package": "ideas",
          "partial": "Test Suite",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#t:TestSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "TestSuiteResult",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-TestSuite.html#TestSuiteResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "TestSuiteResult",
          "package": "ideas",
          "partial": "Test Suite Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#t:TestSuiteResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a QuickCheck property to the test suite. The first argument is\n a label for the property\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "addProperty",
          "package": "ideas",
          "signature": "String -\u003e prop -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#addProperty",
          "type": "function"
        },
        "index": {
          "description": "Add QuickCheck property to the test suite The first argument is label for the property",
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "addProperty",
          "normalized": "String-\u003ea-\u003eTestSuite",
          "package": "ideas",
          "partial": "Property",
          "signature": "String-\u003eprop-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:addProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a QuickCheck property to the test suite, also providing a test\n configuration (Args)\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "addPropertyWith",
          "package": "ideas",
          "signature": "String -\u003e Args -\u003e prop -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#addPropertyWith",
          "type": "function"
        },
        "index": {
          "description": "Add QuickCheck property to the test suite also providing test configuration Args",
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "addPropertyWith",
          "normalized": "String-\u003eArgs-\u003ea-\u003eTestSuite",
          "package": "ideas",
          "partial": "Property With",
          "signature": "String-\u003eArgs-\u003eprop-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:addPropertyWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertEquals",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e a -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#assertEquals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertEquals",
          "normalized": "String-\u003ea-\u003ea-\u003eTestSuite",
          "package": "ideas",
          "partial": "Equals",
          "signature": "String-\u003ea-\u003ea-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:assertEquals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertIO",
          "package": "ideas",
          "signature": "String -\u003e IO Bool -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#assertIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertIO",
          "normalized": "String-\u003eIO Bool-\u003eTestSuite",
          "package": "ideas",
          "partial": "IO",
          "signature": "String-\u003eIO Bool-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:assertIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertNull",
          "package": "ideas",
          "signature": "String -\u003e [a] -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#assertNull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertNull",
          "normalized": "String-\u003e[a]-\u003eTestSuite",
          "package": "ideas",
          "partial": "Null",
          "signature": "String-\u003e[a]-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:assertNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertTrue",
          "package": "ideas",
          "signature": "String -\u003e Bool -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#assertTrue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "assertTrue",
          "normalized": "String-\u003eBool-\u003eTestSuite",
          "package": "ideas",
          "partial": "True",
          "signature": "String-\u003eBool-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:assertTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "findSubResult",
          "package": "ideas",
          "signature": "String -\u003e TestSuiteResult -\u003e Maybe TestSuiteResult",
          "source": "src/Ideas-Common-Utils-TestSuite.html#findSubResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "findSubResult",
          "normalized": "String-\u003eTestSuiteResult-\u003eMaybe TestSuiteResult",
          "package": "ideas",
          "partial": "Sub Result",
          "signature": "String-\u003eTestSuiteResult-\u003eMaybe TestSuiteResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:findSubResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "isError",
          "package": "ideas",
          "signature": "Message -\u003e Bool",
          "source": "src/Ideas-Common-Utils-TestSuite.html#isError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "isError",
          "normalized": "Message-\u003eBool",
          "package": "ideas",
          "partial": "Error",
          "signature": "Message-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:isError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a computation from the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad.\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "liftIO",
          "package": "ideas",
          "signature": "IO a -\u003e m a",
          "type": "method"
        },
        "index": {
          "description": "Lift computation from the IO monad",
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "liftIO",
          "normalized": "IO a-\u003eb a",
          "package": "ideas",
          "partial": "IO",
          "signature": "IO a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:liftIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "makeSummary",
          "package": "ideas",
          "signature": "TestSuiteResult -\u003e String",
          "source": "src/Ideas-Common-Utils-TestSuite.html#makeSummary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "makeSummary",
          "normalized": "TestSuiteResult-\u003eString",
          "package": "ideas",
          "partial": "Summary",
          "signature": "TestSuiteResult-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:makeSummary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "messageLabel",
          "package": "ideas",
          "signature": "Message -\u003e Maybe String",
          "source": "src/Ideas-Common-Utils-TestSuite.html#messageLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "messageLabel",
          "normalized": "Message-\u003eMaybe String",
          "package": "ideas",
          "partial": "Label",
          "signature": "Message-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:messageLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "messages",
          "package": "ideas",
          "signature": "TestSuiteResult -\u003e [Message]",
          "source": "src/Ideas-Common-Utils-TestSuite.html#messages",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "messages",
          "normalized": "TestSuiteResult-\u003e[Message]",
          "package": "ideas",
          "signature": "TestSuiteResult-\u003e[Message]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:messages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "newMessage",
          "package": "ideas",
          "signature": "String -\u003e Message",
          "source": "src/Ideas-Common-Utils-TestSuite.html#newMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "newMessage",
          "normalized": "String-\u003eMessage",
          "package": "ideas",
          "partial": "Message",
          "signature": "String-\u003eMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:newMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "numberOfTests",
          "package": "ideas",
          "signature": "TestSuiteResult -\u003e Int",
          "source": "src/Ideas-Common-Utils-TestSuite.html#numberOfTests",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "numberOfTests",
          "normalized": "TestSuiteResult-\u003eInt",
          "package": "ideas",
          "partial": "Of Tests",
          "signature": "TestSuiteResult-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:numberOfTests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "printSummary",
          "package": "ideas",
          "signature": "TestSuiteResult -\u003e IO ()",
          "source": "src/Ideas-Common-Utils-TestSuite.html#printSummary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "printSummary",
          "normalized": "TestSuiteResult-\u003eIO()",
          "package": "ideas",
          "partial": "Summary",
          "signature": "TestSuiteResult-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:printSummary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "runTestSuite",
          "package": "ideas",
          "signature": "TestSuite -\u003e IO ()",
          "source": "src/Ideas-Common-Utils-TestSuite.html#runTestSuite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "runTestSuite",
          "normalized": "TestSuite-\u003eIO()",
          "package": "ideas",
          "partial": "Test Suite",
          "signature": "TestSuite-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:runTestSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "runTestSuiteResult",
          "package": "ideas",
          "signature": "TestSuite -\u003e IO TestSuiteResult",
          "source": "src/Ideas-Common-Utils-TestSuite.html#runTestSuiteResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "runTestSuiteResult",
          "normalized": "TestSuite-\u003eIO TestSuiteResult",
          "package": "ideas",
          "partial": "Test Suite Result",
          "signature": "TestSuite-\u003eIO TestSuiteResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:runTestSuiteResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "subResults",
          "package": "ideas",
          "signature": "TestSuiteResult -\u003e [(String, TestSuiteResult)]",
          "source": "src/Ideas-Common-Utils-TestSuite.html#subResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "subResults",
          "normalized": "TestSuiteResult-\u003e[(String,TestSuiteResult)]",
          "package": "ideas",
          "partial": "Results",
          "signature": "TestSuiteResult-\u003e[(String,TestSuiteResult)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:subResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a (named) test suite containing tests and other suites\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "suite",
          "package": "ideas",
          "signature": "String -\u003e TestSuite -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#suite",
          "type": "function"
        },
        "index": {
          "description": "Construct named test suite containing tests and other suites",
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "suite",
          "normalized": "String-\u003eTestSuite-\u003eTestSuite",
          "package": "ideas",
          "signature": "String-\u003eTestSuite-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:suite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "topMessages",
          "package": "ideas",
          "signature": "TestSuiteResult -\u003e [Message]",
          "source": "src/Ideas-Common-Utils-TestSuite.html#topMessages",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "topMessages",
          "normalized": "TestSuiteResult-\u003e[Message]",
          "package": "ideas",
          "partial": "Messages",
          "signature": "TestSuiteResult-\u003e[Message]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:topMessages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "warn",
          "package": "ideas",
          "signature": "String -\u003e TestSuite",
          "source": "src/Ideas-Common-Utils-TestSuite.html#warn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "warn",
          "normalized": "String-\u003eTestSuite",
          "package": "ideas",
          "signature": "String-\u003eTestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:warn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "warning",
          "package": "ideas",
          "signature": "Message -\u003e Message",
          "source": "src/Ideas-Common-Utils-TestSuite.html#warning",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils TestSuite",
          "module": "Ideas.Common.Utils.TestSuite",
          "name": "warning",
          "normalized": "Message-\u003eMessage",
          "package": "ideas",
          "signature": "Message-\u003eMessage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-TestSuite.html#v:warning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExports a subset of Data.Generics.Uniplate.Direct (the \u003ccode\u003eUniplate\u003c/code\u003e type\n class and its utility plus constructor functions)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "Uniplate",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils-Uniplate.html",
          "type": "module"
        },
        "index": {
          "description": "Exports subset of Data.Generics.Uniplate.Direct the Uniplate type class and its utility plus constructor functions",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "Uniplate",
          "package": "ideas",
          "partial": "Uniplate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe standard Uniplate class, all operations require this. All definitions must\n   define \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e, while \u003ccode\u003e\u003ca\u003edescend\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edescendM\u003c/a\u003e\u003c/code\u003e are optional.\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "Uniplate",
          "package": "ideas",
          "type": "class"
        },
        "index": {
          "description": "The standard Uniplate class all operations require this All definitions must define uniplate while descend and descendM are optional",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "Uniplate",
          "package": "ideas",
          "partial": "Uniplate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#t:Uniplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe field to the right is a list of the type of the target\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "(||*)",
          "package": "ideas",
          "signature": "Type ([to] -\u003e from) to -\u003e [to] -\u003e Type from to",
          "type": "function"
        },
        "index": {
          "description": "The field to the right is list of the type of the target",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "(||*) ||*",
          "normalized": "Type([a]-\u003eb)a-\u003e[a]-\u003eType b a",
          "package": "ideas",
          "signature": "Type([to]-\u003efrom)to-\u003e[to]-\u003eType from to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:-124--124--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe field to the right is the target.\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "(|*)",
          "package": "ideas",
          "signature": "Type (to -\u003e from) to -\u003e to -\u003e Type from to",
          "type": "function"
        },
        "index": {
          "description": "The field to the right is the target",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "(|*) |*",
          "normalized": "Type(a-\u003eb)a-\u003ea-\u003eType b a",
          "package": "ideas",
          "signature": "Type(to-\u003efrom)to-\u003eto-\u003eType from to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:-124--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe field to the right \u003cem\u003edoes not\u003c/em\u003e contain the target.\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "(|-)",
          "package": "ideas",
          "signature": "Type (item -\u003e from) to -\u003e item -\u003e Type from to",
          "type": "function"
        },
        "index": {
          "description": "The field to the right does not contain the target",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "(|-) |-",
          "normalized": "Type(a-\u003eb)c-\u003ea-\u003eType b c",
          "package": "ideas",
          "signature": "Type(item-\u003efrom)to-\u003eitem-\u003eType from to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:-124--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the direct children of a node. Usually using \u003ccode\u003e\u003ca\u003euniverse\u003c/a\u003e\u003c/code\u003e is more appropriate.\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "children",
          "package": "ideas",
          "signature": "on -\u003e [on]",
          "type": "function"
        },
        "index": {
          "description": "Get the direct children of node Usually using universe is more appropriate",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "children",
          "normalized": "a-\u003e[a]",
          "package": "ideas",
          "signature": "on-\u003e[on]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:children"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all the contexts and holes.\n\u003c/p\u003e\u003cpre\u003e universe x == map fst (contexts x)\n all (== x) [b a | (a,b) \u003c- contexts x]\n\u003c/pre\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "contexts",
          "package": "ideas",
          "signature": "on -\u003e [(on, on -\u003e on)]",
          "type": "function"
        },
        "index": {
          "description": "Return all the contexts and holes universe map fst contexts all contexts",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "contexts",
          "normalized": "a-\u003e[(a,a-\u003ea)]",
          "package": "ideas",
          "signature": "on-\u003e[(on,on-\u003eon)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:contexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a transformation on all the immediate children, then combine them back.\n   This operation allows additional information to be passed downwards, and can be\n   used to provide a top-down transformation. This function can be defined explicitly,\n   or can be provided by automatically in terms of \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example, on the sample type, we could write:\n\u003c/p\u003e\u003cpre\u003e descend f (Val i  ) = Val i\n descend f (Neg a  ) = Neg (f a)\n descend f (Add a b) = Add (f a) (f b)\n\u003c/pre\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "descend",
          "package": "ideas",
          "signature": "(on -\u003e on) -\u003e on -\u003e on",
          "type": "function"
        },
        "index": {
          "description": "Perform transformation on all the immediate children then combine them back This operation allows additional information to be passed downwards and can be used to provide top-down transformation This function can be defined explicitly or can be provided by automatically in terms of uniplate For example on the sample type we could write descend Val Val descend Neg Neg descend Add Add",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "descend",
          "normalized": "(a-\u003ea)-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "(on-\u003eon)-\u003eon-\u003eon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:descend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic variant of \u003ccode\u003e\u003ca\u003edescend\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "descendM",
          "package": "ideas",
          "signature": "(on -\u003e m on) -\u003e on -\u003e m on",
          "type": "function"
        },
        "index": {
          "description": "Monadic variant of descend",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "descendM",
          "normalized": "(a-\u003eb a)-\u003ea-\u003eb a",
          "package": "ideas",
          "signature": "(on-\u003em on)-\u003eon-\u003em on",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:descendM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe one depth version of \u003ccode\u003e\u003ca\u003econtexts\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e children x == map fst (holes x)\n all (== x) [b a | (a,b) \u003c- holes x]\n\u003c/pre\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "holes",
          "package": "ideas",
          "signature": "on -\u003e [(on, on -\u003e on)]",
          "type": "function"
        },
        "index": {
          "description": "The one depth version of contexts children map fst holes all holes",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "holes",
          "normalized": "a-\u003e[(a,a-\u003ea)]",
          "package": "ideas",
          "signature": "on-\u003e[(on,on-\u003eon)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:holes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a fold-like computation on each value,\n   technically a paramorphism\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "para",
          "package": "ideas",
          "signature": "(on -\u003e [r] -\u003e r) -\u003e on -\u003e r",
          "type": "function"
        },
        "index": {
          "description": "Perform fold-like computation on each value technically paramorphism",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "para",
          "normalized": "(a-\u003e[b]-\u003eb)-\u003ea-\u003eb",
          "package": "ideas",
          "signature": "(on-\u003e[r]-\u003er)-\u003eon-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:para"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main combinator used to start the chain.\n\u003c/p\u003e\u003cp\u003eThe following rule can be used for optimisation:\n\u003c/p\u003e\u003cpre\u003e plate Ctor |- x == plate (Ctor x)\n\u003c/pre\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "plate",
          "package": "ideas",
          "signature": "from -\u003e Type from to",
          "type": "function"
        },
        "index": {
          "description": "The main combinator used to start the chain The following rule can be used for optimisation plate Ctor plate Ctor",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "plate",
          "normalized": "a-\u003eType a b",
          "package": "ideas",
          "signature": "from-\u003eType from to",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:plate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite by applying a rule everywhere you can. Ensures that the rule cannot\n be applied anywhere in the result:\n\u003c/p\u003e\u003cpre\u003e propRewrite r x = all (isNothing . r) (universe (rewrite r x))\n\u003c/pre\u003e\u003cp\u003eUsually \u003ccode\u003e\u003ca\u003etransform\u003c/a\u003e\u003c/code\u003e is more appropriate, but \u003ccode\u003e\u003ca\u003erewrite\u003c/a\u003e\u003c/code\u003e can give better\n compositionality. Given two single transformations \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e, you can\n construct \u003ccode\u003ef \u003ccode\u003e\u003ca\u003emplus\u003c/a\u003e\u003c/code\u003e g\u003c/code\u003e which performs both rewrites until a fixed point.\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "rewrite",
          "package": "ideas",
          "signature": "(on -\u003e Maybe on) -\u003e on -\u003e on",
          "type": "function"
        },
        "index": {
          "description": "Rewrite by applying rule everywhere you can Ensures that the rule cannot be applied anywhere in the result propRewrite all isNothing universe rewrite Usually transform is more appropriate but rewrite can give better compositionality Given two single transformations and you can construct mplus which performs both rewrites until fixed point",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "rewrite",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "(on-\u003eMaybe on)-\u003eon-\u003eon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:rewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic variant of \u003ccode\u003e\u003ca\u003erewrite\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "rewriteM",
          "package": "ideas",
          "signature": "(on -\u003e m (Maybe on)) -\u003e on -\u003e m on",
          "type": "function"
        },
        "index": {
          "description": "Monadic variant of rewrite",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "rewriteM",
          "normalized": "(a-\u003eb(Maybe a))-\u003ea-\u003eb a",
          "package": "ideas",
          "signature": "(on-\u003em(Maybe on))-\u003eon-\u003em on",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:rewriteM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in the tree, in a bottom-up manner.\n\u003c/p\u003e\u003cp\u003eFor example, replacing negative literals with literals:\n\u003c/p\u003e\u003cpre\u003e negLits = transform f\n    where f (Neg (Lit i)) = Lit (negate i)\n          f x = x\n\u003c/pre\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "transform",
          "package": "ideas",
          "signature": "(on -\u003e on) -\u003e on -\u003e on",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in the tree in bottom-up manner For example replacing negative literals with literals negLits transform where Neg Lit Lit negate",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "transform",
          "normalized": "(a-\u003ea)-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "(on-\u003eon)-\u003eon-\u003eon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic variant of \u003ccode\u003e\u003ca\u003etransform\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "transformM",
          "package": "ideas",
          "signature": "(on -\u003e m on) -\u003e on -\u003e m on",
          "type": "function"
        },
        "index": {
          "description": "Monadic variant of transform",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "transformM",
          "normalized": "(a-\u003eb a)-\u003ea-\u003eb a",
          "package": "ideas",
          "signature": "(on-\u003em on)-\u003eon-\u003em on",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:transformM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe underlying method in the class.\n   Taking a value, the function should return all the immediate children\n   of the same type, and a function to replace them.\n\u003c/p\u003e\u003cp\u003eGiven \u003ccode\u003euniplate x = (cs, gen)\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ecs\u003c/code\u003e should be a \u003ccode\u003eStr on\u003c/code\u003e, constructed of \u003ccode\u003eZero\u003c/code\u003e, \u003ccode\u003eOne\u003c/code\u003e and \u003ccode\u003eTwo\u003c/code\u003e,\n   containing all \u003ccode\u003ex\u003c/code\u003e's direct children of the same type as \u003ccode\u003ex\u003c/code\u003e. \u003ccode\u003egen\u003c/code\u003e\n   should take a \u003ccode\u003eStr on\u003c/code\u003e with exactly the same structure as \u003ccode\u003ecs\u003c/code\u003e,\n   and generate a new element with the children replaced.\n\u003c/p\u003e\u003cp\u003eExample instance:\n\u003c/p\u003e\u003cpre\u003e instance Uniplate Expr where\n     uniplate (Val i  ) = (Zero               , \\Zero                  -\u003e Val i  )\n     uniplate (Neg a  ) = (One a              , \\(One a)               -\u003e Neg a  )\n     uniplate (Add a b) = (Two (One a) (One b), \\(Two (One a) (One b)) -\u003e Add a b)\n\u003c/pre\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "uniplate",
          "package": "ideas",
          "signature": "on -\u003e (Str on, Str on -\u003e on)",
          "type": "function"
        },
        "index": {
          "description": "The underlying method in the class Taking value the function should return all the immediate children of the same type and function to replace them Given uniplate cs gen cs should be Str on constructed of Zero One and Two containing all direct children of the same type as gen should take Str on with exactly the same structure as cs and generate new element with the children replaced Example instance instance Uniplate Expr where uniplate Val Zero Zero Val uniplate Neg One One Neg uniplate Add Two One One Two One One Add",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "uniplate",
          "normalized": "a-\u003e(Str a,Str a-\u003ea)",
          "package": "ideas",
          "signature": "on-\u003e(Str on,Str on-\u003eon)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:uniplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet all the children of a node, including itself and all children.\n\u003c/p\u003e\u003cpre\u003e universe (Add (Val 1) (Neg (Val 2))) =\n     [Add (Val 1) (Neg (Val 2)), Val 1, Neg (Val 2), Val 2]\n\u003c/pre\u003e\u003cp\u003eThis method is often combined with a list comprehension, for example:\n\u003c/p\u003e\u003cpre\u003e vals x = [i | Val i \u003c- universe x]\n\u003c/pre\u003e",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "universe",
          "package": "ideas",
          "signature": "on -\u003e [on]",
          "type": "function"
        },
        "index": {
          "description": "Get all the children of node including itself and all children universe Add Val Neg Val Add Val Neg Val Val Neg Val Val This method is often combined with list comprehension for example vals Val universe",
          "hierarchy": "Ideas Common Utils Uniplate",
          "module": "Ideas.Common.Utils.Uniplate",
          "name": "universe",
          "normalized": "a-\u003e[a]",
          "package": "ideas",
          "signature": "on-\u003e[on]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils-Uniplate.html#v:universe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA collection of general utility functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.Utils",
          "name": "Utils",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "collection of general utility functions",
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "Utils",
          "package": "ideas",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "ShowString",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils.html#ShowString",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "ShowString",
          "package": "ideas",
          "partial": "Show String",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#t:ShowString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "Some",
          "package": "ideas",
          "source": "src/Ideas-Common-Utils.html#Some",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "Some",
          "package": "ideas",
          "partial": "Some",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#t:Some"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "ShowString",
          "package": "ideas",
          "signature": "ShowString",
          "source": "src/Ideas-Common-Utils.html#ShowString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "ShowString",
          "package": "ideas",
          "partial": "Show String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:ShowString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "Some",
          "package": "ideas",
          "signature": "forall a . Some (f a)",
          "source": "src/Ideas-Common-Utils.html#Some",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "Some",
          "package": "ideas",
          "partial": "Some",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:Some"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "allsame",
          "package": "ideas",
          "signature": "[a] -\u003e Bool",
          "source": "src/Ideas-Common-Utils.html#allsame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "allsame",
          "normalized": "[a]-\u003eBool",
          "package": "ideas",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:allsame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "cartesian",
          "package": "ideas",
          "signature": "[a] -\u003e [b] -\u003e [(a, b)]",
          "source": "src/Ideas-Common-Utils.html#cartesian",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "cartesian",
          "normalized": "[a]-\u003e[b]-\u003e[(a,b)]",
          "package": "ideas",
          "signature": "[a]-\u003e[b]-\u003e[(a,b)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:cartesian"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "changeAt",
          "package": "ideas",
          "signature": "Int -\u003e (a -\u003e a) -\u003e [a] -\u003e m [a]",
          "source": "src/Ideas-Common-Utils.html#changeAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "changeAt",
          "normalized": "Int-\u003e(a-\u003ea)-\u003e[a]-\u003eb[a]",
          "package": "ideas",
          "partial": "At",
          "signature": "Int-\u003e(a-\u003ea)-\u003e[a]-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:changeAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "distinct",
          "package": "ideas",
          "signature": "[a] -\u003e Bool",
          "source": "src/Ideas-Common-Utils.html#distinct",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "distinct",
          "normalized": "[a]-\u003eBool",
          "package": "ideas",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:distinct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "elementAt",
          "package": "ideas",
          "signature": "Int -\u003e [a] -\u003e m a",
          "source": "src/Ideas-Common-Utils.html#elementAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "elementAt",
          "normalized": "Int-\u003e[a]-\u003eb a",
          "package": "ideas",
          "partial": "At",
          "signature": "Int-\u003e[a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:elementAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "findIndexM",
          "package": "ideas",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e m Int",
          "source": "src/Ideas-Common-Utils.html#findIndexM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "findIndexM",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eb Int",
          "package": "ideas",
          "partial": "Index",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003em Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:findIndexM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "fixpoint",
          "package": "ideas",
          "signature": "(a -\u003e a) -\u003e a -\u003e a",
          "source": "src/Ideas-Common-Utils.html#fixpoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "fixpoint",
          "normalized": "(a-\u003ea)-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "(a-\u003ea)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:fixpoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "fromShowString",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Common-Utils.html#ShowString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "fromShowString",
          "package": "ideas",
          "partial": "Show String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:fromShowString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "fst3",
          "package": "ideas",
          "signature": "(a, b, c) -\u003e a",
          "source": "src/Ideas-Common-Utils.html#fst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "fst3",
          "normalized": "(a,b,c)-\u003ea",
          "package": "ideas",
          "signature": "(a,b,c)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:fst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "headM",
          "package": "ideas",
          "signature": "[a] -\u003e m a",
          "source": "src/Ideas-Common-Utils.html#headM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "headM",
          "normalized": "[a]-\u003eb a",
          "package": "ideas",
          "signature": "[a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:headM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "isSubsetOf",
          "package": "ideas",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "source": "src/Ideas-Common-Utils.html#isSubsetOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "isSubsetOf",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "ideas",
          "partial": "Subset Of",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:isSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "list",
          "package": "ideas",
          "signature": "b -\u003e ([a] -\u003e b) -\u003e [a] -\u003e b",
          "source": "src/Ideas-Common-Utils.html#list",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "list",
          "normalized": "a-\u003e([b]-\u003ea)-\u003e[b]-\u003ea",
          "package": "ideas",
          "signature": "b-\u003e([a]-\u003eb)-\u003e[a]-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "readInt",
          "package": "ideas",
          "signature": "String -\u003e Maybe Int",
          "source": "src/Ideas-Common-Utils.html#readInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "readInt",
          "normalized": "String-\u003eMaybe Int",
          "package": "ideas",
          "partial": "Int",
          "signature": "String-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:readInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "readM",
          "package": "ideas",
          "signature": "String -\u003e m a",
          "source": "src/Ideas-Common-Utils.html#readM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "readM",
          "normalized": "String-\u003ea b",
          "package": "ideas",
          "signature": "String-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:readM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "replaceAt",
          "package": "ideas",
          "signature": "Int -\u003e a -\u003e [a] -\u003e m [a]",
          "source": "src/Ideas-Common-Utils.html#replaceAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "replaceAt",
          "normalized": "Int-\u003ea-\u003e[a]-\u003eb[a]",
          "package": "ideas",
          "partial": "At",
          "signature": "Int-\u003ea-\u003e[a]-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:replaceAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "snd3",
          "package": "ideas",
          "signature": "(a, b, c) -\u003e b",
          "source": "src/Ideas-Common-Utils.html#snd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "snd3",
          "normalized": "(a,b,c)-\u003eb",
          "package": "ideas",
          "signature": "(a,b,c)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:snd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "splitAtElem",
          "package": "ideas",
          "signature": "a -\u003e [a] -\u003e Maybe ([a], [a])",
          "source": "src/Ideas-Common-Utils.html#splitAtElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "splitAtElem",
          "normalized": "a-\u003e[a]-\u003eMaybe([a],[a])",
          "package": "ideas",
          "partial": "At Elem",
          "signature": "a-\u003e[a]-\u003eMaybe([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:splitAtElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "splitsWithElem",
          "package": "ideas",
          "signature": "a -\u003e [a] -\u003e [[a]]",
          "source": "src/Ideas-Common-Utils.html#splitsWithElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "splitsWithElem",
          "normalized": "a-\u003e[a]-\u003e[[a]]",
          "package": "ideas",
          "partial": "With Elem",
          "signature": "a-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:splitsWithElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "subsets",
          "package": "ideas",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Ideas-Common-Utils.html#subsets",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "subsets",
          "normalized": "[a]-\u003e[[a]]",
          "package": "ideas",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:subsets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "thd3",
          "package": "ideas",
          "signature": "(a, b, c) -\u003e c",
          "source": "src/Ideas-Common-Utils.html#thd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "thd3",
          "normalized": "(a,b,c)-\u003ec",
          "package": "ideas",
          "signature": "(a,b,c)-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:thd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.Utils",
          "name": "timedSeconds",
          "package": "ideas",
          "signature": "Int -\u003e IO a -\u003e IO a",
          "source": "src/Ideas-Common-Utils.html#timedSeconds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "timedSeconds",
          "normalized": "Int-\u003eIO a-\u003eIO a",
          "package": "ideas",
          "partial": "Seconds",
          "signature": "Int-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:timedSeconds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a fixed standard \u003ca\u003erandom\u003c/a\u003e number generator. This generator is\n accessible by calling System.Random.getStdGen\n\u003c/p\u003e",
          "module": "Ideas.Common.Utils",
          "name": "useFixedStdGen",
          "package": "ideas",
          "signature": "IO ()",
          "source": "src/Ideas-Common-Utils.html#useFixedStdGen",
          "type": "function"
        },
        "index": {
          "description": "Use fixed standard random number generator This generator is accessible by calling System.Random.getStdGen",
          "hierarchy": "Ideas Common Utils",
          "module": "Ideas.Common.Utils",
          "name": "useFixedStdGen",
          "normalized": "IO()",
          "package": "ideas",
          "partial": "Fixed Std Gen",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-Utils.html#v:useFixedStdGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines views on data-types, as described in \u003ca\u003eCanonical Forms\n in Interactive Exercise Assistants\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Common.View",
          "name": "View",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines views on data-types as described in Canonical Forms in Interactive Exercise Assistants",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "View",
          "package": "ideas",
          "partial": "View",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe basic arrow class.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e, satisfying the laws\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e id = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e \u003e\u003e\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e *** g) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassoc\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassoc\u003c/code\u003e \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ewhere\n\u003c/p\u003e\u003cpre\u003e assoc ((a,b),c) = (a,(b,c))\n\u003c/pre\u003e\u003cp\u003eThe other combinators have sensible default definitions,\n which may be overridden for efficiency.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "Arrow",
          "package": "ideas",
          "type": "class"
        },
        "index": {
          "description": "The basic arrow class Minimal complete definition arr and first satisfying the laws arr id id arr arr arr first arr arr first first first first first arr fst arr fst first arr id arr id first first first arr assoc arr assoc first where assoc The other combinators have sensible default definitions which may be overridden for efficiency",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "Arrow",
          "package": "ideas",
          "partial": "Arrow",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:Arrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChoice, for arrows that support it.  This class underlies the\n \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003ecase\u003c/code\u003e constructs in arrow notation.\n Minimal complete definition: \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e, satisfying the laws\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e f) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e (f \u003e\u003e\u003e g) = \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003ef \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e +++ g) = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e +++ g) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f) \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassocsum\u003c/code\u003e = \u003ccode\u003e\u003ca\u003earr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eassocsum\u003c/code\u003e \u003e\u003e\u003e \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ewhere\n\u003c/p\u003e\u003cpre\u003e assocsum (Left (Left x)) = Left x\n assocsum (Left (Right y)) = Right (Left y)\n assocsum (Right z) = Right (Right z)\n\u003c/pre\u003e\u003cp\u003eThe other combinators have sensible default definitions, which may\n be overridden for efficiency.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "ArrowChoice",
          "package": "ideas",
          "type": "class"
        },
        "index": {
          "description": "Choice for arrows that support it This class underlies the if and case constructs in arrow notation Minimal complete definition left satisfying the laws left arr arr left left left left arr Left arr Left left left arr id arr id left left left arr assocsum arr assocsum left where assocsum Left Left Left assocsum Left Right Right Left assocsum Right Right Right The other combinators have sensible default definitions which may be overridden for efficiency",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "ArrowChoice",
          "package": "ideas",
          "partial": "Arrow Choice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:ArrowChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA monoid on arrows.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "ArrowPlus",
          "package": "ideas",
          "type": "class"
        },
        "index": {
          "description": "monoid on arrows",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "ArrowPlus",
          "package": "ideas",
          "partial": "Arrow Plus",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:ArrowPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "ArrowZero",
          "package": "ideas",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "ArrowZero",
          "package": "ideas",
          "partial": "Arrow Zero",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:ArrowZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "IsMatcher",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html#IsMatcher",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "IsMatcher",
          "package": "ideas",
          "partial": "Is Matcher",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:IsMatcher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal complete definition: \u003ccode\u003etoView\u003c/code\u003e or both \u003ccode\u003ematch\u003c/code\u003e and \u003ccode\u003ebuild\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "IsView",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html#IsView",
          "type": "class"
        },
        "index": {
          "description": "Minimal complete definition toView or both match and build",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "IsView",
          "package": "ideas",
          "partial": "Is View",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:IsView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "Isomorphism",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html#Isomorphism",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "Isomorphism",
          "package": "ideas",
          "partial": "Isomorphism",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:Isomorphism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "LiftView",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html#LiftView",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "LiftView",
          "package": "ideas",
          "partial": "Lift View",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:LiftView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "Matcher",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html#Matcher",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "Matcher",
          "package": "ideas",
          "partial": "Matcher",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:Matcher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "View",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html#View",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "View",
          "package": "ideas",
          "partial": "View",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:View"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "ViewPackage",
          "package": "ideas",
          "source": "src/Ideas-Common-View.html#ViewPackage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "ViewPackage",
          "package": "ideas",
          "partial": "View Package",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#t:ViewPackage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFanin: Split the input between the two argument arrows and\n   merge their outputs.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "(|||)",
          "package": "ideas",
          "signature": "a b d -\u003e a c d -\u003e a (Either b c) d",
          "type": "method"
        },
        "index": {
          "description": "Fanin Split the input between the two argument arrows and merge their outputs The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "(|||) |||",
          "normalized": "a b c-\u003ea d c-\u003ea(Either b d)c",
          "package": "ideas",
          "signature": "a b d-\u003ea c d-\u003ea(Either b c)d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-124--124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "($\u003c)",
          "package": "ideas",
          "signature": "View a (f b) -\u003e View b c -\u003e View a (f c)",
          "source": "src/Ideas-Common-View.html#%24%3C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "($\u003c) $\u003c",
          "normalized": "View a(b c)-\u003eView c d-\u003eView a(b d)",
          "package": "ideas",
          "signature": "View a(f b)-\u003eView b c-\u003eView a(f c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-36--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFanout: send the input to both argument arrows and combine\n   their output.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "(&&&)",
          "package": "ideas",
          "signature": "a b c -\u003e a b c' -\u003e a b (c, c')",
          "type": "method"
        },
        "index": {
          "description": "Fanout send the input to both argument arrows and combine their output The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "(&&&) &&&",
          "normalized": "a b c-\u003ea b d-\u003ea b(c,d)",
          "package": "ideas",
          "signature": "a b c-\u003ea b c'-\u003ea b(c,c')",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-38--38--38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the input between the two argument arrows and combine\n   their output.  Note that this is in general not a functor.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "(***)",
          "package": "ideas",
          "signature": "a b c -\u003e a b' c' -\u003e a (b, b') (c, c')",
          "type": "method"
        },
        "index": {
          "description": "Split the input between the two argument arrows and combine their output Note that this is in general not functor The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "(***) ***",
          "normalized": "a b c-\u003ea d e-\u003ea(b,d)(c,e)",
          "package": "ideas",
          "signature": "a b c-\u003ea b' c'-\u003ea(b,b')(c,c')",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-42--42--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the input between the two argument arrows, retagging\n   and merging their outputs.\n   Note that this is in general not a functor.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "(+++)",
          "package": "ideas",
          "signature": "a b c -\u003e a b' c' -\u003e a (Either b b') (Either c c')",
          "type": "method"
        },
        "index": {
          "description": "Split the input between the two argument arrows retagging and merging their outputs Note that this is in general not functor The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "(+++) +++",
          "normalized": "a b c-\u003ea d e-\u003ea(Either b d)(Either c e)",
          "package": "ideas",
          "signature": "a b c-\u003ea b' c'-\u003ea(Either b b')(Either c c')",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-43--43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn associative operation with identity \u003ccode\u003e\u003ca\u003ezeroArrow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "(\u003c+\u003e)",
          "package": "ideas",
          "signature": "a b c -\u003e a b c -\u003e a b c",
          "type": "method"
        },
        "index": {
          "description": "An associative operation with identity zeroArrow",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a b c-\u003ea b c-\u003ea b c",
          "package": "ideas",
          "signature": "a b c-\u003ea b c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-to-left composition\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "(\u003c\u003c\u003c)",
          "package": "ideas",
          "signature": "cat b c -\u003e cat a b -\u003e cat a c",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left composition",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "(\u003c\u003c\u003c) \u003c\u003c\u003c",
          "normalized": "a b c-\u003ea d b-\u003ea d c",
          "package": "ideas",
          "signature": "cat b c-\u003ecat a b-\u003ecat a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-60--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-to-right composition\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "(\u003e\u003e\u003e)",
          "package": "ideas",
          "signature": "cat a b -\u003e cat b c -\u003e cat a c",
          "type": "function"
        },
        "index": {
          "description": "Left-to-right composition",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "(\u003e\u003e\u003e) \u003e\u003e\u003e",
          "normalized": "a b c-\u003ea c d-\u003ea b d",
          "package": "ideas",
          "signature": "cat a b-\u003ecat b c-\u003ecat a c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:-62--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "ViewPackage",
          "package": "ideas",
          "signature": "(String -\u003e Maybe a) -\u003e View a b -\u003e ViewPackage",
          "source": "src/Ideas-Common-View.html#ViewPackage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "ViewPackage",
          "normalized": "(String-\u003eMaybe a)-\u003eView a b-\u003eViewPackage",
          "package": "ideas",
          "partial": "View Package",
          "signature": "(String-\u003eMaybe a)-\u003eView a b-\u003eViewPackage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:ViewPackage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a function to an arrow.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "arr",
          "package": "ideas",
          "signature": "(b -\u003e c) -\u003e a b c",
          "type": "method"
        },
        "index": {
          "description": "Lift function to an arrow",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "arr",
          "normalized": "(a-\u003eb)-\u003ec a b",
          "package": "ideas",
          "signature": "(b-\u003ec)-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:arr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "belongsTo",
          "package": "ideas",
          "signature": "a -\u003e f a b -\u003e Bool",
          "source": "src/Ideas-Common-View.html#belongsTo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "belongsTo",
          "normalized": "a-\u003eb a c-\u003eBool",
          "package": "ideas",
          "partial": "To",
          "signature": "a-\u003ef a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:belongsTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "build",
          "package": "ideas",
          "signature": "f a b -\u003e b -\u003e a",
          "source": "src/Ideas-Common-View.html#build",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "build",
          "normalized": "a b c-\u003ec-\u003eb",
          "package": "ideas",
          "signature": "f a b-\u003eb-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "canonical",
          "package": "ideas",
          "signature": "f a b -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-View.html#canonical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "canonical",
          "normalized": "a b c-\u003eb-\u003eMaybe b",
          "package": "ideas",
          "signature": "f a b-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:canonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "canonicalWith",
          "package": "ideas",
          "signature": "(b -\u003e b) -\u003e f a b -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-View.html#canonicalWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "canonicalWith",
          "normalized": "(a-\u003ea)-\u003eb c a-\u003ec-\u003eMaybe c",
          "package": "ideas",
          "partial": "With",
          "signature": "(b-\u003eb)-\u003ef a b-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:canonicalWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "canonicalWithM",
          "package": "ideas",
          "signature": "(b -\u003e Maybe b) -\u003e f a b -\u003e a -\u003e Maybe a",
          "source": "src/Ideas-Common-View.html#canonicalWithM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "canonicalWithM",
          "normalized": "(a-\u003eMaybe a)-\u003eb c a-\u003ec-\u003eMaybe c",
          "package": "ideas",
          "partial": "With",
          "signature": "(b-\u003eMaybe b)-\u003ef a b-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:canonicalWithM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend the first component of the input through the argument\n   arrow, and copy the rest unchanged to the output.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "first",
          "package": "ideas",
          "signature": "a b c -\u003e a (b, d) (c, d)",
          "type": "method"
        },
        "index": {
          "description": "Send the first component of the input through the argument arrow and copy the rest unchanged to the output",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "first",
          "normalized": "a b c-\u003ea(b,d)(c,d)",
          "package": "ideas",
          "signature": "a b c-\u003ea(b,d)(c,d)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:first"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "from",
          "package": "ideas",
          "signature": "Isomorphism a b -\u003e a -\u003e b",
          "source": "src/Ideas-Common-View.html#from",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "from",
          "normalized": "Isomorphism a b-\u003ea-\u003eb",
          "package": "ideas",
          "signature": "Isomorphism a b-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:from"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "identity",
          "package": "ideas",
          "signature": "f a a",
          "source": "src/Ideas-Common-View.html#identity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "identity",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "inverse",
          "package": "ideas",
          "signature": "Isomorphism a b -\u003e Isomorphism b a",
          "source": "src/Ideas-Common-View.html#inverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "inverse",
          "normalized": "Isomorphism a b-\u003eIsomorphism b a",
          "package": "ideas",
          "signature": "Isomorphism a b-\u003eIsomorphism b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "isCanonical",
          "package": "ideas",
          "signature": "f a b -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-View.html#isCanonical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "isCanonical",
          "normalized": "a b c-\u003eb-\u003eBool",
          "package": "ideas",
          "partial": "Canonical",
          "signature": "f a b-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:isCanonical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "isCanonicalWith",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e f a b -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-View.html#isCanonicalWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "isCanonicalWith",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eb a c-\u003ea-\u003eBool",
          "package": "ideas",
          "partial": "Canonical With",
          "signature": "(a-\u003ea-\u003eBool)-\u003ef a b-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:isCanonicalWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFeed marked inputs through the argument arrow, passing the\n   rest through unchanged to the output.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "left",
          "package": "ideas",
          "signature": "a b c -\u003e a (Either b d) (Either c d)",
          "type": "method"
        },
        "index": {
          "description": "Feed marked inputs through the argument arrow passing the rest through unchanged to the output",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "left",
          "normalized": "a b c-\u003ea(Either b d)(Either c d)",
          "package": "ideas",
          "signature": "a b c-\u003ea(Either b d)(Either c d)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "liftView",
          "package": "ideas",
          "signature": "View a b -\u003e f b -\u003e f a",
          "source": "src/Ideas-Common-View.html#liftView",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "liftView",
          "normalized": "View a b-\u003ec b-\u003ec a",
          "package": "ideas",
          "partial": "View",
          "signature": "View a b-\u003ef b-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:liftView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "liftViewIn",
          "package": "ideas",
          "signature": "View a (b, c) -\u003e f b -\u003e f a",
          "source": "src/Ideas-Common-View.html#liftViewIn",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "liftViewIn",
          "normalized": "View a(b,c)-\u003ed b-\u003ed a",
          "package": "ideas",
          "partial": "View In",
          "signature": "View a(b,c)-\u003ef b-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:liftViewIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecialized version of traverseView\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "listView",
          "package": "ideas",
          "signature": "View a b -\u003e View [a] [b]",
          "source": "src/Ideas-Common-View.html#listView",
          "type": "function"
        },
        "index": {
          "description": "Specialized version of traverseView",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "listView",
          "normalized": "View a b-\u003eView[a][b]",
          "package": "ideas",
          "partial": "View",
          "signature": "View a b-\u003eView[a][b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:listView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "makeMatcher",
          "package": "ideas",
          "signature": "(a -\u003e Maybe b) -\u003e Matcher a b",
          "source": "src/Ideas-Common-View.html#makeMatcher",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "makeMatcher",
          "normalized": "(a-\u003eMaybe b)-\u003eMatcher a b",
          "package": "ideas",
          "partial": "Matcher",
          "signature": "(a-\u003eMaybe b)-\u003eMatcher a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:makeMatcher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "makeView",
          "package": "ideas",
          "signature": "(a -\u003e Maybe b) -\u003e (b -\u003e a) -\u003e View a b",
          "source": "src/Ideas-Common-View.html#makeView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "makeView",
          "normalized": "(a-\u003eMaybe b)-\u003e(b-\u003ea)-\u003eView a b",
          "package": "ideas",
          "partial": "View",
          "signature": "(a-\u003eMaybe b)-\u003e(b-\u003ea)-\u003eView a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:makeView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "match",
          "package": "ideas",
          "signature": "f a b -\u003e a -\u003e Maybe b",
          "source": "src/Ideas-Common-View.html#match",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "match",
          "normalized": "a b c-\u003eb-\u003eMaybe c",
          "package": "ideas",
          "signature": "f a b-\u003ea-\u003eMaybe b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralized monadic variant of \u003ccode\u003ematch\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "matchM",
          "package": "ideas",
          "signature": "f a b -\u003e a -\u003e m b",
          "source": "src/Ideas-Common-View.html#matchM",
          "type": "function"
        },
        "index": {
          "description": "generalized monadic variant of match",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "matchM",
          "normalized": "a b c-\u003eb-\u003ed c",
          "package": "ideas",
          "signature": "f a b-\u003ea-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:matchM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "matcher",
          "package": "ideas",
          "signature": "f a b -\u003e Matcher a b",
          "source": "src/Ideas-Common-View.html#matcher",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "matcher",
          "normalized": "a b c-\u003eMatcher b c",
          "package": "ideas",
          "signature": "f a b-\u003eMatcher a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:matcher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "matcherView",
          "package": "ideas",
          "signature": "Matcher a b -\u003e (b -\u003e a) -\u003e View a b",
          "source": "src/Ideas-Common-View.html#matcherView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "matcherView",
          "normalized": "Matcher a b-\u003e(b-\u003ea)-\u003eView a b",
          "package": "ideas",
          "partial": "View",
          "signature": "Matcher a b-\u003e(b-\u003ea)-\u003eView a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:matcherView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "propIdempotence",
          "package": "ideas",
          "signature": "Gen a -\u003e View a b -\u003e Property",
          "source": "src/Ideas-Common-View.html#propIdempotence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "propIdempotence",
          "normalized": "Gen a-\u003eView a b-\u003eProperty",
          "package": "ideas",
          "partial": "Idempotence",
          "signature": "Gen a-\u003eView a b-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:propIdempotence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "propNormalForm",
          "package": "ideas",
          "signature": "Gen a -\u003e View a b -\u003e Property",
          "source": "src/Ideas-Common-View.html#propNormalForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "propNormalForm",
          "normalized": "Gen a-\u003eView a b-\u003eProperty",
          "package": "ideas",
          "partial": "Normal Form",
          "signature": "Gen a-\u003eView a b-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:propNormalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "propSoundness",
          "package": "ideas",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e Gen a -\u003e View a c -\u003e Property",
          "source": "src/Ideas-Common-View.html#propSoundness",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "propSoundness",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eGen a-\u003eView a b-\u003eProperty",
          "package": "ideas",
          "partial": "Soundness",
          "signature": "(a-\u003ea-\u003eBool)-\u003eGen a-\u003eView a c-\u003eProperty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:propSoundness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mirror image of \u003ccode\u003e\u003ca\u003eleft\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "right",
          "package": "ideas",
          "signature": "a b c -\u003e a (Either d b) (Either d c)",
          "type": "method"
        },
        "index": {
          "description": "mirror image of left The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "right",
          "normalized": "a b c-\u003ea(Either d b)(Either d c)",
          "package": "ideas",
          "signature": "a b c-\u003ea(Either d b)(Either d c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mirror image of \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe default definition may be overridden with a more efficient\n   version if desired.\n\u003c/p\u003e",
          "module": "Ideas.Common.View",
          "name": "second",
          "package": "ideas",
          "signature": "a b c -\u003e a (d, b) (d, c)",
          "type": "method"
        },
        "index": {
          "description": "mirror image of first The default definition may be overridden with more efficient version if desired",
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "second",
          "normalized": "a b c-\u003ea(d,b)(d,c)",
          "package": "ideas",
          "signature": "a b c-\u003ea(d,b)(d,c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:second"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "simplify",
          "package": "ideas",
          "signature": "f a b -\u003e a -\u003e a",
          "source": "src/Ideas-Common-View.html#simplify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "simplify",
          "normalized": "a b c-\u003eb-\u003eb",
          "package": "ideas",
          "signature": "f a b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:simplify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "simplifyWith",
          "package": "ideas",
          "signature": "(b -\u003e b) -\u003e f a b -\u003e a -\u003e a",
          "source": "src/Ideas-Common-View.html#simplifyWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "simplifyWith",
          "normalized": "(a-\u003ea)-\u003eb c a-\u003ec-\u003ec",
          "package": "ideas",
          "partial": "With",
          "signature": "(b-\u003eb)-\u003ef a b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:simplifyWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "simplifyWithM",
          "package": "ideas",
          "signature": "(b -\u003e Maybe b) -\u003e f a b -\u003e a -\u003e a",
          "source": "src/Ideas-Common-View.html#simplifyWithM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "simplifyWithM",
          "normalized": "(a-\u003eMaybe a)-\u003eb c a-\u003ec-\u003ec",
          "package": "ideas",
          "partial": "With",
          "signature": "(b-\u003eMaybe b)-\u003ef a b-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:simplifyWithM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "swapView",
          "package": "ideas",
          "signature": "Isomorphism (a, b) (b, a)",
          "source": "src/Ideas-Common-View.html#swapView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "swapView",
          "normalized": "Isomorphism(a,b)(b,a)",
          "package": "ideas",
          "partial": "View",
          "signature": "Isomorphism(a,b)(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:swapView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "to",
          "package": "ideas",
          "signature": "Isomorphism a b -\u003e b -\u003e a",
          "source": "src/Ideas-Common-View.html#to",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "to",
          "normalized": "Isomorphism a b-\u003eb-\u003ea",
          "package": "ideas",
          "signature": "Isomorphism a b-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "toView",
          "package": "ideas",
          "signature": "f a b -\u003e View a b",
          "source": "src/Ideas-Common-View.html#toView",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "toView",
          "normalized": "a b c-\u003eView b c",
          "package": "ideas",
          "partial": "View",
          "signature": "f a b-\u003eView a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:toView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "traverseView",
          "package": "ideas",
          "signature": "View a b -\u003e View (f a) (f b)",
          "source": "src/Ideas-Common-View.html#traverseView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "traverseView",
          "normalized": "View a b-\u003eView(c a)(c b)",
          "package": "ideas",
          "partial": "View",
          "signature": "View a b-\u003eView(f a)(f b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:traverseView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "viewEquivalent",
          "package": "ideas",
          "signature": "f a b -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-View.html#viewEquivalent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "viewEquivalent",
          "normalized": "a b c-\u003eb-\u003eb-\u003eBool",
          "package": "ideas",
          "partial": "Equivalent",
          "signature": "f a b-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:viewEquivalent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "viewEquivalentWith",
          "package": "ideas",
          "signature": "(b -\u003e b -\u003e Bool) -\u003e f a b -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Ideas-Common-View.html#viewEquivalentWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "viewEquivalentWith",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eb c a-\u003ec-\u003ec-\u003eBool",
          "package": "ideas",
          "partial": "Equivalent With",
          "signature": "(b-\u003eb-\u003eBool)-\u003ef a b-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:viewEquivalentWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Common.View",
          "name": "zeroArrow",
          "package": "ideas",
          "signature": "a b c",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Common View",
          "module": "Ideas.Common.View",
          "name": "zeroArrow",
          "package": "ideas",
          "partial": "Arrow",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Common-View.html#v:zeroArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServices using JSON notation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "DecoderJSON",
          "package": "ideas",
          "source": "src/Ideas-Encoding-DecoderJSON.html",
          "type": "module"
        },
        "index": {
          "description": "Services using JSON notation",
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "DecoderJSON",
          "package": "ideas",
          "partial": "Decoder JSON",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "JSONDecoder",
          "package": "ideas",
          "source": "src/Ideas-Encoding-DecoderJSON.html#JSONDecoder",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "JSONDecoder",
          "package": "ideas",
          "partial": "JSONDecoder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#t:JSONDecoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "JSONDecoderState",
          "package": "ideas",
          "source": "src/Ideas-Encoding-DecoderJSON.html#JSONDecoderState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "JSONDecoderState",
          "package": "ideas",
          "partial": "JSONDecoder State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#t:JSONDecoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "JSONDecoderState",
          "package": "ideas",
          "signature": "JSONDecoderState",
          "source": "src/Ideas-Encoding-DecoderJSON.html#JSONDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "JSONDecoderState",
          "package": "ideas",
          "partial": "JSONDecoder State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#v:JSONDecoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "getExercise",
          "package": "ideas",
          "signature": "Exercise a",
          "source": "src/Ideas-Encoding-DecoderJSON.html#JSONDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "getExercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#v:getExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "getScript",
          "package": "ideas",
          "signature": "Script",
          "source": "src/Ideas-Encoding-DecoderJSON.html#JSONDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "getScript",
          "package": "ideas",
          "partial": "Script",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#v:getScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "getStdGen",
          "package": "ideas",
          "signature": "StdGen",
          "source": "src/Ideas-Encoding-DecoderJSON.html#JSONDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "getStdGen",
          "package": "ideas",
          "partial": "Std Gen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#v:getStdGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "jsonDecoder",
          "package": "ideas",
          "signature": "Type a t -\u003e JSONDecoder a t",
          "source": "src/Ideas-Encoding-DecoderJSON.html#jsonDecoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderJSON",
          "module": "Ideas.Encoding.DecoderJSON",
          "name": "jsonDecoder",
          "normalized": "Type a b-\u003eJSONDecoder a b",
          "package": "ideas",
          "partial": "Decoder",
          "signature": "Type a t-\u003eJSONDecoder a t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderJSON.html#v:jsonDecoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServices using XML notation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "DecoderXML",
          "package": "ideas",
          "source": "src/Ideas-Encoding-DecoderXML.html",
          "type": "module"
        },
        "index": {
          "description": "Services using XML notation",
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "DecoderXML",
          "package": "ideas",
          "partial": "Decoder XML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "XMLDecoder",
          "package": "ideas",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoder",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "XMLDecoder",
          "package": "ideas",
          "partial": "XMLDecoder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#t:XMLDecoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "XMLDecoderState",
          "package": "ideas",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoderState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "XMLDecoderState",
          "package": "ideas",
          "partial": "XMLDecoder State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#t:XMLDecoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "XMLDecoderState",
          "package": "ideas",
          "signature": "XMLDecoderState",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "XMLDecoderState",
          "package": "ideas",
          "partial": "XMLDecoder State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#v:XMLDecoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "decodeTerm",
          "package": "ideas",
          "signature": "XML -\u003e Either String a",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "decodeTerm",
          "normalized": "XML-\u003eEither String a",
          "package": "ideas",
          "partial": "Term",
          "signature": "XML-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#v:decodeTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "getExercise",
          "package": "ideas",
          "signature": "Exercise a",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "getExercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#v:getExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "getScript",
          "package": "ideas",
          "signature": "Script",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "getScript",
          "package": "ideas",
          "partial": "Script",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#v:getScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "getStdGen",
          "package": "ideas",
          "signature": "StdGen",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "getStdGen",
          "package": "ideas",
          "partial": "Std Gen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#v:getStdGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "isOpenMath",
          "package": "ideas",
          "signature": "Bool",
          "source": "src/Ideas-Encoding-DecoderXML.html#XMLDecoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "isOpenMath",
          "package": "ideas",
          "partial": "Open Math",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#v:isOpenMath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.DecoderXML",
          "name": "xmlDecoder",
          "package": "ideas",
          "signature": "Type a t -\u003e XMLDecoder a t",
          "source": "src/Ideas-Encoding-DecoderXML.html#xmlDecoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding DecoderXML",
          "module": "Ideas.Encoding.DecoderXML",
          "name": "xmlDecoder",
          "normalized": "Type a b-\u003eXMLDecoder a b",
          "package": "ideas",
          "partial": "Decoder",
          "signature": "Type a t-\u003eXMLDecoder a t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-DecoderXML.html#v:xmlDecoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEncoding in HTML\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.EncoderHTML",
          "name": "EncoderHTML",
          "package": "ideas",
          "source": "src/Ideas-Encoding-EncoderHTML.html",
          "type": "module"
        },
        "index": {
          "description": "Encoding in HTML",
          "hierarchy": "Ideas Encoding EncoderHTML",
          "module": "Ideas.Encoding.EncoderHTML",
          "name": "EncoderHTML",
          "package": "ideas",
          "partial": "Encoder HTML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderHTML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderHTML",
          "name": "htmlEncoder",
          "package": "ideas",
          "signature": "LinkManager -\u003e DomainReasoner -\u003e Exercise a -\u003e TypedValue (Type a) -\u003e HTMLPage",
          "source": "src/Ideas-Encoding-EncoderHTML.html#htmlEncoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderHTML",
          "module": "Ideas.Encoding.EncoderHTML",
          "name": "htmlEncoder",
          "normalized": "LinkManager-\u003eDomainReasoner-\u003eExercise a-\u003eTypedValue(Type a)-\u003eHTMLPage",
          "package": "ideas",
          "partial": "Encoder",
          "signature": "LinkManager-\u003eDomainReasoner-\u003eExercise a-\u003eTypedValue(Type a)-\u003eHTMLPage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderHTML.html#v:htmlEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServices using JSON notation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.EncoderJSON",
          "name": "EncoderJSON",
          "package": "ideas",
          "source": "src/Ideas-Encoding-EncoderJSON.html",
          "type": "module"
        },
        "index": {
          "description": "Services using JSON notation",
          "hierarchy": "Ideas Encoding EncoderJSON",
          "module": "Ideas.Encoding.EncoderJSON",
          "name": "EncoderJSON",
          "package": "ideas",
          "partial": "Encoder JSON",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderJSON.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderJSON",
          "name": "jsonEncoder",
          "package": "ideas",
          "signature": "JSONEncoder a (TypedValue (Type a))",
          "source": "src/Ideas-Encoding-EncoderJSON.html#jsonEncoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderJSON",
          "module": "Ideas.Encoding.EncoderJSON",
          "name": "jsonEncoder",
          "package": "ideas",
          "partial": "Encoder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderJSON.html#v:jsonEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServices using XML notation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "EncoderXML",
          "package": "ideas",
          "source": "src/Ideas-Encoding-EncoderXML.html",
          "type": "module"
        },
        "index": {
          "description": "Services using XML notation",
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "EncoderXML",
          "package": "ideas",
          "partial": "Encoder XML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "XMLEncoder",
          "package": "ideas",
          "source": "src/Ideas-Encoding-EncoderXML.html#XMLEncoder",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "XMLEncoder",
          "package": "ideas",
          "partial": "XMLEncoder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#t:XMLEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "XMLEncoderState",
          "package": "ideas",
          "source": "src/Ideas-Encoding-EncoderXML.html#XMLEncoderState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "XMLEncoderState",
          "package": "ideas",
          "partial": "XMLEncoder State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#t:XMLEncoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "XMLEncoderState",
          "package": "ideas",
          "signature": "XMLEncoderState",
          "source": "src/Ideas-Encoding-EncoderXML.html#XMLEncoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "XMLEncoderState",
          "package": "ideas",
          "partial": "XMLEncoder State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#v:XMLEncoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "encodeState",
          "package": "ideas",
          "signature": "XMLEncoder a (State a)",
          "source": "src/Ideas-Encoding-EncoderXML.html#encodeState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "encodeState",
          "package": "ideas",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#v:encodeState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "encodeTerm",
          "package": "ideas",
          "signature": "a -\u003e XMLBuilder",
          "source": "src/Ideas-Encoding-EncoderXML.html#XMLEncoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "encodeTerm",
          "normalized": "a-\u003eXMLBuilder",
          "package": "ideas",
          "partial": "Term",
          "signature": "a-\u003eXMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#v:encodeTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "getExercise",
          "package": "ideas",
          "signature": "Exercise a",
          "source": "src/Ideas-Encoding-EncoderXML.html#XMLEncoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "getExercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#v:getExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "isOpenMath",
          "package": "ideas",
          "signature": "Bool",
          "source": "src/Ideas-Encoding-EncoderXML.html#XMLEncoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "isOpenMath",
          "package": "ideas",
          "partial": "Open Math",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#v:isOpenMath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.EncoderXML",
          "name": "xmlEncoder",
          "package": "ideas",
          "signature": "XMLEncoder a (TypedValue (Type a))",
          "source": "src/Ideas-Encoding-EncoderXML.html#xmlEncoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding EncoderXML",
          "module": "Ideas.Encoding.EncoderXML",
          "name": "xmlEncoder",
          "package": "ideas",
          "partial": "Encoder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-EncoderXML.html#v:xmlEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "Evaluator",
          "package": "ideas",
          "source": "src/Ideas-Encoding-Evaluator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "Evaluator",
          "package": "ideas",
          "partial": "Evaluator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "EncoderState",
          "package": "ideas",
          "source": "src/Ideas-Encoding-Evaluator.html#EncoderState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "EncoderState",
          "package": "ideas",
          "partial": "Encoder State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#t:EncoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "Evaluator",
          "package": "ideas",
          "source": "src/Ideas-Encoding-Evaluator.html#Evaluator",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "Evaluator",
          "package": "ideas",
          "partial": "Evaluator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#t:Evaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "(//)",
          "package": "ideas",
          "signature": "EncoderState st a c -\u003e a -\u003e EncoderState st b c",
          "source": "src/Ideas-Encoding-Evaluator.html#%2F%2F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "(//) //",
          "normalized": "EncoderState a b c-\u003eb-\u003eEncoderState a d c",
          "package": "ideas",
          "signature": "EncoderState st a c-\u003ea-\u003eEncoderState st b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:-47--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Ideas.Encoding.Evaluator\",\"Ideas.Text.Parsing\"]",
          "name": "(\u003c$\u003e)",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:-60--36--62-\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:-60--36--62-\"]"
        },
        "index": {
          "description": "An infix synonym for fmap",
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "(\u003c$\u003e) \u003c$\u003e",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "ideas",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:-60--36--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e with the arguments reversed.\n\u003c/p\u003e",
          "module": "[\"Ideas.Encoding.Evaluator\",\"Ideas.Text.Parsing\"]",
          "name": "(\u003c**\u003e)",
          "package": "ideas",
          "signature": "f a -\u003e f (a -\u003e b) -\u003e f b",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:-60--42--42--62-\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:-60--42--42--62-\"]"
        },
        "index": {
          "description": "variant of with the arguments reversed",
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "(\u003c**\u003e) \u003c**\u003e",
          "normalized": "a b-\u003ea(b-\u003ec)-\u003ea c",
          "package": "ideas",
          "signature": "f a-\u003ef(a-\u003eb)-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:-60--42--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "Evaluator",
          "package": "ideas",
          "signature": "(TypedValue (Type a) -\u003e m b) -\u003e (forall t.  Type a t -\u003e m t) -\u003e Evaluator a m b",
          "source": "src/Ideas-Encoding-Evaluator.html#Evaluator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "Evaluator",
          "normalized": "(TypedValue(Type a)-\u003eb c)-\u003e(d e Type a f-\u003eb f)-\u003eEvaluator a b c",
          "package": "ideas",
          "partial": "Evaluator",
          "signature": "(TypedValue(Type a)-\u003em b)-\u003e(forall t. Type a t-\u003em t)-\u003eEvaluator a m b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:Evaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "eitherEncoder",
          "package": "ideas",
          "signature": "(a -\u003e Either String b) -\u003e EncoderState st a b",
          "source": "src/Ideas-Encoding-Evaluator.html#eitherEncoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "eitherEncoder",
          "normalized": "(a-\u003eEither String b)-\u003eEncoderState c a b",
          "package": "ideas",
          "partial": "Encoder",
          "signature": "(a-\u003eEither String b)-\u003eEncoderState st a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:eitherEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "encodeTyped",
          "package": "ideas",
          "signature": "EncoderState st t b -\u003e EncoderState st (TypedValue (Type a)) b",
          "source": "src/Ideas-Encoding-Evaluator.html#encodeTyped",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "encodeTyped",
          "normalized": "EncoderState a b c-\u003eEncoderState a(TypedValue(Type d))c",
          "package": "ideas",
          "partial": "Typed",
          "signature": "EncoderState st t b-\u003eEncoderState st(TypedValue(Type a))b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:encodeTyped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "encoderFor",
          "package": "ideas",
          "signature": "(a -\u003e EncoderState st a b) -\u003e EncoderState st a b",
          "source": "src/Ideas-Encoding-Evaluator.html#encoderFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "encoderFor",
          "normalized": "(a-\u003eEncoderState b a c)-\u003eEncoderState b a c",
          "package": "ideas",
          "partial": "For",
          "signature": "(a-\u003eEncoderState st a b)-\u003eEncoderState st a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:encoderFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "encoderStateFor",
          "package": "ideas",
          "signature": "(st -\u003e a -\u003e EncoderState st a b) -\u003e EncoderState st a b",
          "source": "src/Ideas-Encoding-Evaluator.html#encoderStateFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "encoderStateFor",
          "normalized": "(a-\u003eb-\u003eEncoderState a b c)-\u003eEncoderState a b c",
          "package": "ideas",
          "partial": "State For",
          "signature": "(st-\u003ea-\u003eEncoderState st a b)-\u003eEncoderState st a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:encoderStateFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "evalService",
          "package": "ideas",
          "signature": "Evaluator a m b -\u003e Service -\u003e m b",
          "source": "src/Ideas-Encoding-Evaluator.html#evalService",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "evalService",
          "normalized": "Evaluator a b c-\u003eService-\u003eb c",
          "package": "ideas",
          "partial": "Service",
          "signature": "Evaluator a m b-\u003eService-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:evalService"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "getState",
          "package": "ideas",
          "signature": "EncoderState st a st",
          "source": "src/Ideas-Encoding-Evaluator.html#getState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "getState",
          "package": "ideas",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:getState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a binary function to actions.\n\u003c/p\u003e",
          "module": "Ideas.Encoding.Evaluator",
          "name": "liftA2",
          "package": "ideas",
          "signature": "(a -\u003e b -\u003e c) -\u003e f a -\u003e f b -\u003e f c",
          "type": "function"
        },
        "index": {
          "description": "Lift binary function to actions",
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "liftA2",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "ideas",
          "signature": "(a-\u003eb-\u003ec)-\u003ef a-\u003ef b-\u003ef c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:liftA2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "maybeEncoder",
          "package": "ideas",
          "signature": "(a -\u003e Maybe b) -\u003e EncoderState st a b",
          "source": "src/Ideas-Encoding-Evaluator.html#maybeEncoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "maybeEncoder",
          "normalized": "(a-\u003eMaybe b)-\u003eEncoderState c a b",
          "package": "ideas",
          "partial": "Encoder",
          "signature": "(a-\u003eMaybe b)-\u003eEncoderState st a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:maybeEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a value.\n\u003c/p\u003e",
          "module": "Ideas.Encoding.Evaluator",
          "name": "pure",
          "package": "ideas",
          "signature": "forall a.  a -\u003e f a",
          "type": "function"
        },
        "index": {
          "description": "Lift value",
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "pure",
          "normalized": "a b c-\u003ed c",
          "package": "ideas",
          "signature": "forall a. a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:pure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "runEncoderState",
          "package": "ideas",
          "signature": "EncoderState st a b -\u003e st -\u003e a -\u003e Either String b",
          "source": "src/Ideas-Encoding-Evaluator.html#runEncoderState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "runEncoderState",
          "normalized": "EncoderState a b c-\u003ea-\u003eb-\u003eEither String c",
          "package": "ideas",
          "partial": "Encoder State",
          "signature": "EncoderState st a b-\u003est-\u003ea-\u003eEither String b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:runEncoderState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "runEncoderStateM",
          "package": "ideas",
          "signature": "EncoderState st a b -\u003e st -\u003e a -\u003e m b",
          "source": "src/Ideas-Encoding-Evaluator.html#runEncoderStateM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "runEncoderStateM",
          "normalized": "EncoderState a b c-\u003ea-\u003eb-\u003ed c",
          "package": "ideas",
          "partial": "Encoder State",
          "signature": "EncoderState st a b-\u003est-\u003ea-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:runEncoderStateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "simpleEncoder",
          "package": "ideas",
          "signature": "(a -\u003e b) -\u003e EncoderState st a b",
          "source": "src/Ideas-Encoding-Evaluator.html#simpleEncoder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "simpleEncoder",
          "normalized": "(a-\u003eb)-\u003eEncoderState c a b",
          "package": "ideas",
          "partial": "Encoder",
          "signature": "(a-\u003eb)-\u003eEncoderState st a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:simpleEncoder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.Evaluator",
          "name": "withState",
          "package": "ideas",
          "signature": "(st -\u003e b) -\u003e EncoderState st a b",
          "source": "src/Ideas-Encoding-Evaluator.html#withState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding Evaluator",
          "module": "Ideas.Encoding.Evaluator",
          "name": "withState",
          "normalized": "(a-\u003eb)-\u003eEncoderState a c b",
          "package": "ideas",
          "partial": "State",
          "signature": "(st-\u003eb)-\u003eEncoderState st a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-Evaluator.html#v:withState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eManages links to information\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.LinkManager",
          "name": "LinkManager",
          "package": "ideas",
          "source": "src/Ideas-Encoding-LinkManager.html",
          "type": "module"
        },
        "index": {
          "description": "Manages links to information",
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "LinkManager",
          "package": "ideas",
          "partial": "Link Manager",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "LinkManager",
          "package": "ideas",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "LinkManager",
          "package": "ideas",
          "partial": "Link Manager",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#t:LinkManager"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "(\u003c/\u003e)",
          "package": "ideas",
          "signature": "String -\u003e FilePath -\u003e FilePath",
          "source": "src/Ideas-Encoding-LinkManager.html#%3C%2F%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "(\u003c/\u003e) \u003c/\u003e",
          "normalized": "String-\u003eFilePath-\u003eFilePath",
          "package": "ideas",
          "signature": "String-\u003eFilePath-\u003eFilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:-60--47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "LinkManager",
          "package": "ideas",
          "signature": "LinkManager",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "LinkManager",
          "package": "ideas",
          "partial": "Link Manager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:LinkManager"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "dynamicLinks",
          "package": "ideas",
          "signature": "String -\u003e LinkManager",
          "source": "src/Ideas-Encoding-LinkManager.html#dynamicLinks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "dynamicLinks",
          "normalized": "String-\u003eLinkManager",
          "package": "ideas",
          "partial": "Links",
          "signature": "String-\u003eLinkManager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:dynamicLinks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "isStatic",
          "package": "ideas",
          "signature": "Bool",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "isStatic",
          "package": "ideas",
          "partial": "Static",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:isStatic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToApplications",
          "package": "ideas",
          "signature": "LinkManager -\u003e State a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToApplications",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToApplications",
          "normalized": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Applications",
          "signature": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToApplications"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToDerivation",
          "package": "ideas",
          "signature": "LinkManager -\u003e State a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToDerivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToDerivation",
          "normalized": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Derivation",
          "signature": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToDerivations",
          "package": "ideas",
          "signature": "LinkManager -\u003e Exercise a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToDerivations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToDerivations",
          "normalized": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Derivations",
          "signature": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToDerivations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToExamples",
          "package": "ideas",
          "signature": "LinkManager -\u003e Exercise a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToExamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToExamples",
          "normalized": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Examples",
          "signature": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToExamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToExercise",
          "package": "ideas",
          "signature": "LinkManager -\u003e Exercise a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToExercise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToExercise",
          "normalized": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Exercise",
          "signature": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToExercises",
          "package": "ideas",
          "signature": "LinkManager -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToExercises",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToExercises",
          "normalized": "LinkManager-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Exercises",
          "signature": "LinkManager-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToExercises"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToFirsts",
          "package": "ideas",
          "signature": "LinkManager -\u003e State a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToFirsts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToFirsts",
          "normalized": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Firsts",
          "signature": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToFirsts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToIndex",
          "package": "ideas",
          "signature": "LinkManager -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToIndex",
          "normalized": "LinkManager-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Index",
          "signature": "LinkManager-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToRandomExample",
          "package": "ideas",
          "signature": "LinkManager -\u003e Exercise a -\u003e Difficulty -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToRandomExample",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToRandomExample",
          "normalized": "LinkManager-\u003eExercise a-\u003eDifficulty-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Random Example",
          "signature": "LinkManager-\u003eExercise a-\u003eDifficulty-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToRandomExample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToRule",
          "package": "ideas",
          "signature": "LinkManager -\u003e Exercise a -\u003e Rule (Context a) -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToRule",
          "normalized": "LinkManager-\u003eExercise a-\u003eRule(Context a)-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Rule",
          "signature": "LinkManager-\u003eExercise a-\u003eRule(Context a)-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToRules",
          "package": "ideas",
          "signature": "LinkManager -\u003e Exercise a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToRules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToRules",
          "normalized": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Rules",
          "signature": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToService",
          "package": "ideas",
          "signature": "LinkManager -\u003e Service -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToService",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToService",
          "normalized": "LinkManager-\u003eService-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Service",
          "signature": "LinkManager-\u003eService-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToService"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToServices",
          "package": "ideas",
          "signature": "LinkManager -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToServices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToServices",
          "normalized": "LinkManager-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Services",
          "signature": "LinkManager-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToServices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToState",
          "package": "ideas",
          "signature": "LinkManager -\u003e State a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToState",
          "normalized": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To State",
          "signature": "LinkManager-\u003eState a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToStrategy",
          "package": "ideas",
          "signature": "LinkManager -\u003e Exercise a -\u003e HTMLBuilder -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#linkToStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linkToStrategy",
          "normalized": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To Strategy",
          "signature": "LinkManager-\u003eExercise a-\u003eHTMLBuilder-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linkToStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "linksUp",
          "package": "ideas",
          "signature": "Int -\u003e LinkManager -\u003e LinkManager",
          "source": "src/Ideas-Encoding-LinkManager.html#linksUp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "linksUp",
          "normalized": "Int-\u003eLinkManager-\u003eLinkManager",
          "package": "ideas",
          "partial": "Up",
          "signature": "Int-\u003eLinkManager-\u003eLinkManager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:linksUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "pathLevel",
          "package": "ideas",
          "signature": "FilePath -\u003e Int",
          "source": "src/Ideas-Encoding-LinkManager.html#pathLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "pathLevel",
          "normalized": "FilePath-\u003eInt",
          "package": "ideas",
          "partial": "Level",
          "signature": "FilePath-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:pathLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "stateToXML",
          "package": "ideas",
          "signature": "State a -\u003e XMLBuilder",
          "source": "src/Ideas-Encoding-LinkManager.html#stateToXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "stateToXML",
          "normalized": "State a-\u003eXMLBuilder",
          "package": "ideas",
          "partial": "To XML",
          "signature": "State a-\u003eXMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:stateToXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "staticLinks",
          "package": "ideas",
          "signature": "LinkManager",
          "source": "src/Ideas-Encoding-LinkManager.html#staticLinks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "staticLinks",
          "package": "ideas",
          "partial": "Links",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:staticLinks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForApplications",
          "package": "ideas",
          "signature": "forall a.  State a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForApplications",
          "normalized": "a b State c-\u003eString",
          "package": "ideas",
          "partial": "For Applications",
          "signature": "forall a. State a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForApplications"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForDerivation",
          "package": "ideas",
          "signature": "forall a.  State a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForDerivation",
          "normalized": "a b State c-\u003eString",
          "package": "ideas",
          "partial": "For Derivation",
          "signature": "forall a. State a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForDerivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForDerivations",
          "package": "ideas",
          "signature": "forall a.  Exercise a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForDerivations",
          "normalized": "a b Exercise c-\u003eString",
          "package": "ideas",
          "partial": "For Derivations",
          "signature": "forall a. Exercise a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForDerivations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForExamples",
          "package": "ideas",
          "signature": "forall a.  Exercise a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForExamples",
          "normalized": "a b Exercise c-\u003eString",
          "package": "ideas",
          "partial": "For Examples",
          "signature": "forall a. Exercise a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForExamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForExercise",
          "package": "ideas",
          "signature": "forall a.  Exercise a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForExercise",
          "normalized": "a b Exercise c-\u003eString",
          "package": "ideas",
          "partial": "For Exercise",
          "signature": "forall a. Exercise a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForExercises",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForExercises",
          "package": "ideas",
          "partial": "For Exercises",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForExercises"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForFirsts",
          "package": "ideas",
          "signature": "forall a.  State a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForFirsts",
          "normalized": "a b State c-\u003eString",
          "package": "ideas",
          "partial": "For Firsts",
          "signature": "forall a. State a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForFirsts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForIndex",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForIndex",
          "package": "ideas",
          "partial": "For Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRandomExample",
          "package": "ideas",
          "signature": "forall a.  Exercise a -\u003e Difficulty -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRandomExample",
          "normalized": "a b Exercise c-\u003eDifficulty-\u003eString",
          "package": "ideas",
          "partial": "For Random Example",
          "signature": "forall a. Exercise a-\u003eDifficulty-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForRandomExample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRequest",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRequest",
          "package": "ideas",
          "partial": "For Request",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForRequest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForResource",
          "package": "ideas",
          "signature": "String -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForResource",
          "normalized": "String-\u003eString",
          "package": "ideas",
          "partial": "For Resource",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRule",
          "package": "ideas",
          "signature": "forall a.  Exercise a -\u003e Rule (Context a) -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRule",
          "normalized": "a b Exercise c-\u003eRule(Context c)-\u003eString",
          "package": "ideas",
          "partial": "For Rule",
          "signature": "forall a. Exercise a-\u003eRule(Context a)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRules",
          "package": "ideas",
          "signature": "forall a.  Exercise a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForRules",
          "normalized": "a b Exercise c-\u003eString",
          "package": "ideas",
          "partial": "For Rules",
          "signature": "forall a. Exercise a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForService",
          "package": "ideas",
          "signature": "Service -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForService",
          "normalized": "Service-\u003eString",
          "package": "ideas",
          "partial": "For Service",
          "signature": "Service-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForService"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForServices",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForServices",
          "package": "ideas",
          "partial": "For Services",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForServices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForState",
          "package": "ideas",
          "signature": "forall a.  State a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForState",
          "normalized": "a b State c-\u003eString",
          "package": "ideas",
          "partial": "For State",
          "signature": "forall a. State a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForStrategy",
          "package": "ideas",
          "signature": "forall a.  Exercise a -\u003e String",
          "source": "src/Ideas-Encoding-LinkManager.html#LinkManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding LinkManager",
          "module": "Ideas.Encoding.LinkManager",
          "name": "urlForStrategy",
          "normalized": "a b Exercise c-\u003eString",
          "package": "ideas",
          "partial": "For Strategy",
          "signature": "forall a. Exercise a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-LinkManager.html#v:urlForStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServices using JSON notation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.ModeJSON",
          "name": "ModeJSON",
          "package": "ideas",
          "source": "src/Ideas-Encoding-ModeJSON.html",
          "type": "module"
        },
        "index": {
          "description": "Services using JSON notation",
          "hierarchy": "Ideas Encoding ModeJSON",
          "module": "Ideas.Encoding.ModeJSON",
          "name": "ModeJSON",
          "package": "ideas",
          "partial": "Mode JSON",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-ModeJSON.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.ModeJSON",
          "name": "processJSON",
          "package": "ideas",
          "signature": "Bool -\u003e DomainReasoner -\u003e String -\u003e IO (Request, String, String)",
          "source": "src/Ideas-Encoding-ModeJSON.html#processJSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding ModeJSON",
          "module": "Ideas.Encoding.ModeJSON",
          "name": "processJSON",
          "normalized": "Bool-\u003eDomainReasoner-\u003eString-\u003eIO(Request,String,String)",
          "package": "ideas",
          "partial": "JSON",
          "signature": "Bool-\u003eDomainReasoner-\u003eString-\u003eIO(Request,String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-ModeJSON.html#v:processJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServices using XML notation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.ModeXML",
          "name": "ModeXML",
          "package": "ideas",
          "source": "src/Ideas-Encoding-ModeXML.html",
          "type": "module"
        },
        "index": {
          "description": "Services using XML notation",
          "hierarchy": "Ideas Encoding ModeXML",
          "module": "Ideas.Encoding.ModeXML",
          "name": "ModeXML",
          "package": "ideas",
          "partial": "Mode XML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-ModeXML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.ModeXML",
          "name": "processXML",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e Maybe String -\u003e String -\u003e IO (Request, String, String)",
          "source": "src/Ideas-Encoding-ModeXML.html#processXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding ModeXML",
          "module": "Ideas.Encoding.ModeXML",
          "name": "processXML",
          "normalized": "DomainReasoner-\u003eMaybe String-\u003eString-\u003eIO(Request,String,String)",
          "package": "ideas",
          "partial": "XML",
          "signature": "DomainReasoner-\u003eMaybe String-\u003eString-\u003eIO(Request,String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-ModeXML.html#v:processXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "OpenMathSupport",
          "package": "ideas",
          "source": "src/Ideas-Encoding-OpenMathSupport.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Encoding OpenMathSupport",
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "OpenMathSupport",
          "package": "ideas",
          "partial": "Open Math Support",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-OpenMathSupport.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "fromOMOBJ",
          "package": "ideas",
          "signature": "OMOBJ -\u003e m a",
          "source": "src/Ideas-Encoding-OpenMathSupport.html#fromOMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding OpenMathSupport",
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "fromOMOBJ",
          "normalized": "OMOBJ-\u003ea b",
          "package": "ideas",
          "partial": "OMOBJ",
          "signature": "OMOBJ-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-OpenMathSupport.html#v:fromOMOBJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "fromOpenMath",
          "package": "ideas",
          "signature": "Exercise a -\u003e OMOBJ -\u003e m a",
          "source": "src/Ideas-Encoding-OpenMathSupport.html#fromOpenMath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding OpenMathSupport",
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "fromOpenMath",
          "normalized": "Exercise a-\u003eOMOBJ-\u003eb a",
          "package": "ideas",
          "partial": "Open Math",
          "signature": "Exercise a-\u003eOMOBJ-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-OpenMathSupport.html#v:fromOpenMath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "noMixedFractions",
          "package": "ideas",
          "signature": "OMOBJ -\u003e OMOBJ",
          "source": "src/Ideas-Encoding-OpenMathSupport.html#noMixedFractions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding OpenMathSupport",
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "noMixedFractions",
          "normalized": "OMOBJ-\u003eOMOBJ",
          "package": "ideas",
          "partial": "Mixed Fractions",
          "signature": "OMOBJ-\u003eOMOBJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-OpenMathSupport.html#v:noMixedFractions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "toOMOBJ",
          "package": "ideas",
          "signature": "a -\u003e OMOBJ",
          "source": "src/Ideas-Encoding-OpenMathSupport.html#toOMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding OpenMathSupport",
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "toOMOBJ",
          "normalized": "a-\u003eOMOBJ",
          "package": "ideas",
          "partial": "OMOBJ",
          "signature": "a-\u003eOMOBJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-OpenMathSupport.html#v:toOMOBJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "toOpenMath",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e m OMOBJ",
          "source": "src/Ideas-Encoding-OpenMathSupport.html#toOpenMath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding OpenMathSupport",
          "module": "Ideas.Encoding.OpenMathSupport",
          "name": "toOpenMath",
          "normalized": "Exercise a-\u003ea-\u003eb OMOBJ",
          "package": "ideas",
          "partial": "Open Math",
          "signature": "Exercise a-\u003ea-\u003em OMOBJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-OpenMathSupport.html#v:toOpenMath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.RulePresenter",
          "name": "RulePresenter",
          "package": "ideas",
          "source": "src/Ideas-Encoding-RulePresenter.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Encoding RulePresenter",
          "module": "Ideas.Encoding.RulePresenter",
          "name": "RulePresenter",
          "package": "ideas",
          "partial": "Rule Presenter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-RulePresenter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.RulePresenter",
          "name": "ruleToHTML",
          "package": "ideas",
          "signature": "Some Exercise -\u003e Rule a -\u003e HTMLBuilder",
          "source": "src/Ideas-Encoding-RulePresenter.html#ruleToHTML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding RulePresenter",
          "module": "Ideas.Encoding.RulePresenter",
          "name": "ruleToHTML",
          "normalized": "Some Exercise-\u003eRule a-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "To HTML",
          "signature": "Some Exercise-\u003eRule a-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-RulePresenter.html#v:ruleToHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.RulesInfo",
          "name": "RulesInfo",
          "package": "ideas",
          "source": "src/Ideas-Encoding-RulesInfo.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Encoding RulesInfo",
          "module": "Ideas.Encoding.RulesInfo",
          "name": "RulesInfo",
          "package": "ideas",
          "partial": "Rules Info",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-RulesInfo.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.RulesInfo",
          "name": "ExampleMap",
          "package": "ideas",
          "source": "src/Ideas-Encoding-RulesInfo.html#ExampleMap",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Encoding RulesInfo",
          "module": "Ideas.Encoding.RulesInfo",
          "name": "ExampleMap",
          "package": "ideas",
          "partial": "Example Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-RulesInfo.html#t:ExampleMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.RulesInfo",
          "name": "collectExamples",
          "package": "ideas",
          "signature": "Exercise a -\u003e ExampleMap a",
          "source": "src/Ideas-Encoding-RulesInfo.html#collectExamples",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding RulesInfo",
          "module": "Ideas.Encoding.RulesInfo",
          "name": "collectExamples",
          "normalized": "Exercise a-\u003eExampleMap a",
          "package": "ideas",
          "partial": "Examples",
          "signature": "Exercise a-\u003eExampleMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-RulesInfo.html#v:collectExamples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.RulesInfo",
          "name": "rewriteRuleToFMP",
          "package": "ideas",
          "signature": "Bool -\u003e RewriteRule a -\u003e FMP",
          "source": "src/Ideas-Encoding-RulesInfo.html#rewriteRuleToFMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding RulesInfo",
          "module": "Ideas.Encoding.RulesInfo",
          "name": "rewriteRuleToFMP",
          "normalized": "Bool-\u003eRewriteRule a-\u003eFMP",
          "package": "ideas",
          "partial": "Rule To FMP",
          "signature": "Bool-\u003eRewriteRule a-\u003eFMP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-RulesInfo.html#v:rewriteRuleToFMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.RulesInfo",
          "name": "rulesInfoXML",
          "package": "ideas",
          "signature": "Exercise a -\u003e (a -\u003e XMLBuilder) -\u003e XMLBuilder",
          "source": "src/Ideas-Encoding-RulesInfo.html#rulesInfoXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding RulesInfo",
          "module": "Ideas.Encoding.RulesInfo",
          "name": "rulesInfoXML",
          "normalized": "Exercise a-\u003e(a-\u003eXMLBuilder)-\u003eXMLBuilder",
          "package": "ideas",
          "partial": "Info XML",
          "signature": "Exercise a-\u003e(a-\u003eXMLBuilder)-\u003eXMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-RulesInfo.html#v:rulesInfoXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConverting a strategy to XML, and the other way around.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Encoding.StrategyInfo",
          "name": "StrategyInfo",
          "package": "ideas",
          "source": "src/Ideas-Encoding-StrategyInfo.html",
          "type": "module"
        },
        "index": {
          "description": "Converting strategy to XML and the other way around",
          "hierarchy": "Ideas Encoding StrategyInfo",
          "module": "Ideas.Encoding.StrategyInfo",
          "name": "StrategyInfo",
          "package": "ideas",
          "partial": "Strategy Info",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-StrategyInfo.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.StrategyInfo",
          "name": "strategyToXML",
          "package": "ideas",
          "signature": "f a -\u003e XML",
          "source": "src/Ideas-Encoding-StrategyInfo.html#strategyToXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding StrategyInfo",
          "module": "Ideas.Encoding.StrategyInfo",
          "name": "strategyToXML",
          "normalized": "a b-\u003eXML",
          "package": "ideas",
          "partial": "To XML",
          "signature": "f a-\u003eXML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-StrategyInfo.html#v:strategyToXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Encoding.StrategyInfo",
          "name": "xmlToStrategy",
          "package": "ideas",
          "signature": "(String -\u003e Maybe (Rule a)) -\u003e XML -\u003e m (Strategy a)",
          "source": "src/Ideas-Encoding-StrategyInfo.html#xmlToStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Encoding StrategyInfo",
          "module": "Ideas.Encoding.StrategyInfo",
          "name": "xmlToStrategy",
          "normalized": "(String-\u003eMaybe(Rule a))-\u003eXML-\u003eb(Strategy a)",
          "package": "ideas",
          "partial": "To Strategy",
          "signature": "(String-\u003eMaybe(Rule a))-\u003eXML-\u003em(Strategy a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Encoding-StrategyInfo.html#v:xmlToStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.BlackBoxTests",
          "name": "BlackBoxTests",
          "package": "ideas",
          "source": "src/Ideas-Main-BlackBoxTests.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Main BlackBoxTests",
          "module": "Ideas.Main.BlackBoxTests",
          "name": "BlackBoxTests",
          "package": "ideas",
          "partial": "Black Box Tests",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-BlackBoxTests.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.BlackBoxTests",
          "name": "blackBoxTests",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e String -\u003e IO TestSuite",
          "source": "src/Ideas-Main-BlackBoxTests.html#blackBoxTests",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main BlackBoxTests",
          "module": "Ideas.Main.BlackBoxTests",
          "name": "blackBoxTests",
          "normalized": "DomainReasoner-\u003eString-\u003eIO TestSuite",
          "package": "ideas",
          "partial": "Box Tests",
          "signature": "DomainReasoner-\u003eString-\u003eIO TestSuite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-BlackBoxTests.html#v:blackBoxTests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMain module for feedback services\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Main.Default",
          "name": "Default",
          "package": "ideas",
          "source": "src/Ideas-Main-Default.html",
          "type": "module"
        },
        "index": {
          "description": "Main module for feedback services",
          "hierarchy": "Ideas Main Default",
          "module": "Ideas.Main.Default",
          "name": "Default",
          "package": "ideas",
          "partial": "Default",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Default.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Default",
          "name": "defaultMain",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e IO ()",
          "source": "src/Ideas-Main-Default.html#defaultMain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Default",
          "module": "Ideas.Main.Default",
          "name": "defaultMain",
          "normalized": "DomainReasoner-\u003eIO()",
          "package": "ideas",
          "partial": "Main",
          "signature": "DomainReasoner-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Default.html#v:defaultMain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Default",
          "name": "newDomainReasoner",
          "package": "ideas",
          "signature": "a -\u003e DomainReasoner",
          "source": "src/Ideas-Main-Default.html#newDomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Default",
          "module": "Ideas.Main.Default",
          "name": "newDomainReasoner",
          "normalized": "a-\u003eDomainReasoner",
          "package": "ideas",
          "partial": "Domain Reasoner",
          "signature": "a-\u003eDomainReasoner",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Default.html#v:newDomainReasoner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eManages links to information\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Main.Documentation",
          "name": "Documentation",
          "package": "ideas",
          "source": "src/Ideas-Main-Documentation.html",
          "type": "module"
        },
        "index": {
          "description": "Manages links to information",
          "hierarchy": "Ideas Main Documentation",
          "module": "Ideas.Main.Documentation",
          "name": "Documentation",
          "package": "ideas",
          "partial": "Documentation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Documentation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Documentation",
          "name": "makeDocumentation",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e String -\u003e IO ()",
          "source": "src/Ideas-Main-Documentation.html#makeDocumentation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Documentation",
          "module": "Ideas.Main.Documentation",
          "name": "makeDocumentation",
          "normalized": "DomainReasoner-\u003eString-\u003eIO()",
          "package": "ideas",
          "partial": "Documentation",
          "signature": "DomainReasoner-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Documentation.html#v:makeDocumentation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFacilities to create a log database\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Main.LoggingDatabase",
          "name": "LoggingDatabase",
          "package": "ideas",
          "source": "src/Ideas-Main-LoggingDatabase.html",
          "type": "module"
        },
        "index": {
          "description": "Facilities to create log database",
          "hierarchy": "Ideas Main LoggingDatabase",
          "module": "Ideas.Main.LoggingDatabase",
          "name": "LoggingDatabase",
          "package": "ideas",
          "partial": "Logging Database",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-LoggingDatabase.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.LoggingDatabase",
          "name": "logEnabled",
          "package": "ideas",
          "signature": "Bool",
          "source": "src/Ideas-Main-LoggingDatabase.html#logEnabled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main LoggingDatabase",
          "module": "Ideas.Main.LoggingDatabase",
          "name": "logEnabled",
          "package": "ideas",
          "partial": "Enabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-LoggingDatabase.html#v:logEnabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.LoggingDatabase",
          "name": "logMessage",
          "package": "ideas",
          "signature": "Request -\u003e String -\u003e String -\u003e String -\u003e UTCTime -\u003e IO ()",
          "source": "src/Ideas-Main-LoggingDatabase.html#logMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main LoggingDatabase",
          "module": "Ideas.Main.LoggingDatabase",
          "name": "logMessage",
          "normalized": "Request-\u003eString-\u003eString-\u003eString-\u003eUTCTime-\u003eIO()",
          "package": "ideas",
          "partial": "Message",
          "signature": "Request-\u003eString-\u003eString-\u003eString-\u003eUTCTime-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-LoggingDatabase.html#v:logMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOptions and command-line flags for services\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Main.Options",
          "name": "Options",
          "package": "ideas",
          "source": "src/Ideas-Main-Options.html",
          "type": "module"
        },
        "index": {
          "description": "Options and command-line flags for services",
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "Options",
          "package": "ideas",
          "partial": "Options",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "Flag",
          "package": "ideas",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "Flag",
          "package": "ideas",
          "partial": "Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#t:Flag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "AnalyzeScript",
          "package": "ideas",
          "signature": "AnalyzeScript FilePath",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "AnalyzeScript",
          "package": "ideas",
          "partial": "Analyze Script",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:AnalyzeScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "Help",
          "package": "ideas",
          "signature": "Help",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "Help",
          "package": "ideas",
          "partial": "Help",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:Help"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "InputFile",
          "package": "ideas",
          "signature": "InputFile String",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "InputFile",
          "package": "ideas",
          "partial": "Input File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:InputFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "MakePages",
          "package": "ideas",
          "signature": "MakePages FilePath",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "MakePages",
          "package": "ideas",
          "partial": "Make Pages",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:MakePages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "MakeScriptFor",
          "package": "ideas",
          "signature": "MakeScriptFor String",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "MakeScriptFor",
          "package": "ideas",
          "partial": "Make Script For",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:MakeScriptFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "Test",
          "package": "ideas",
          "signature": "Test FilePath",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "Test",
          "package": "ideas",
          "partial": "Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:Test"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "Version",
          "package": "ideas",
          "signature": "Version",
          "source": "src/Ideas-Main-Options.html#Flag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "Version",
          "package": "ideas",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:Version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "fullVersion",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Main-Options.html#fullVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "fullVersion",
          "package": "ideas",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:fullVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "getFlags",
          "package": "ideas",
          "signature": "IO [Flag]",
          "source": "src/Ideas-Main-Options.html#getFlags",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "getFlags",
          "normalized": "IO[Flag]",
          "package": "ideas",
          "partial": "Flags",
          "signature": "IO[Flag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:getFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "helpText",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Main-Options.html#helpText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "helpText",
          "package": "ideas",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:helpText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "shortVersion",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Main-Options.html#shortVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "shortVersion",
          "package": "ideas",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:shortVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Options",
          "name": "versionText",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Main-Options.html#versionText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Options",
          "module": "Ideas.Main.Options",
          "name": "versionText",
          "package": "ideas",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Options.html#v:versionText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Revision",
          "name": "Revision",
          "package": "ideas",
          "source": "src/Ideas-Main-Revision.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Main Revision",
          "module": "Ideas.Main.Revision",
          "name": "Revision",
          "package": "ideas",
          "partial": "Revision",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Revision.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Revision",
          "name": "ideasLastChanged",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Main-Revision.html#ideasLastChanged",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Revision",
          "module": "Ideas.Main.Revision",
          "name": "ideasLastChanged",
          "package": "ideas",
          "partial": "Last Changed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Revision.html#v:ideasLastChanged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Revision",
          "name": "ideasRevision",
          "package": "ideas",
          "signature": "Int",
          "source": "src/Ideas-Main-Revision.html#ideasRevision",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Revision",
          "module": "Ideas.Main.Revision",
          "name": "ideasRevision",
          "package": "ideas",
          "partial": "Revision",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Revision.html#v:ideasRevision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Main.Revision",
          "name": "ideasVersion",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Main-Revision.html#ideasVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Main Revision",
          "module": "Ideas.Main.Revision",
          "name": "ideasVersion",
          "package": "ideas",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Main-Revision.html#v:ideasVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "BasicServices",
          "package": "ideas",
          "source": "src/Ideas-Service-BasicServices.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "BasicServices",
          "package": "ideas",
          "partial": "Basic Services",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "StepInfo",
          "package": "ideas",
          "source": "src/Ideas-Service-BasicServices.html#StepInfo",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "StepInfo",
          "package": "ideas",
          "partial": "Step Info",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#t:StepInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "allapplications",
          "package": "ideas",
          "signature": "State a -\u003e [(Rule (Context a), Location, State a)]",
          "source": "src/Ideas-Service-BasicServices.html#allapplications",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "allapplications",
          "normalized": "State a-\u003e[(Rule(Context a),Location,State a)]",
          "package": "ideas",
          "signature": "State a-\u003e[(Rule(Context a),Location,State a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:allapplications"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "allfirsts",
          "package": "ideas",
          "signature": "State a -\u003e Either String [(StepInfo a, State a)]",
          "source": "src/Ideas-Service-BasicServices.html#allfirsts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "allfirsts",
          "normalized": "State a-\u003eEither String[(StepInfo a,State a)]",
          "package": "ideas",
          "signature": "State a-\u003eEither String[(StepInfo a,State a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:allfirsts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "applicable",
          "package": "ideas",
          "signature": "Location -\u003e State a -\u003e [Rule (Context a)]",
          "source": "src/Ideas-Service-BasicServices.html#applicable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "applicable",
          "normalized": "Location-\u003eState a-\u003e[Rule(Context a)]",
          "package": "ideas",
          "signature": "Location-\u003eState a-\u003e[Rule(Context a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:applicable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "apply",
          "package": "ideas",
          "signature": "Rule (Context a) -\u003e Location -\u003e Environment -\u003e State a -\u003e Either String (State a)",
          "source": "src/Ideas-Service-BasicServices.html#apply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "apply",
          "normalized": "Rule(Context a)-\u003eLocation-\u003eEnvironment-\u003eState a-\u003eEither String(State a)",
          "package": "ideas",
          "signature": "Rule(Context a)-\u003eLocation-\u003eEnvironment-\u003eState a-\u003eEither String(State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "derivation",
          "package": "ideas",
          "signature": "Maybe StrategyConfiguration -\u003e State a -\u003e Either String (Derivation (Rule (Context a), Environment) (Context a))",
          "source": "src/Ideas-Service-BasicServices.html#derivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "derivation",
          "normalized": "Maybe StrategyConfiguration-\u003eState a-\u003eEither String(Derivation(Rule(Context a),Environment)(Context a))",
          "package": "ideas",
          "signature": "Maybe StrategyConfiguration-\u003eState a-\u003eEither String(Derivation(Rule(Context a),Environment)(Context a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:derivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "exampleDerivations",
          "package": "ideas",
          "signature": "Exercise a -\u003e Either String [Derivation (Rule (Context a), Environment) (Context a)]",
          "source": "src/Ideas-Service-BasicServices.html#exampleDerivations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "exampleDerivations",
          "normalized": "Exercise a-\u003eEither String[Derivation(Rule(Context a),Environment)(Context a)]",
          "package": "ideas",
          "partial": "Derivations",
          "signature": "Exercise a-\u003eEither String[Derivation(Rule(Context a),Environment)(Context a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:exampleDerivations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "findbuggyrules",
          "package": "ideas",
          "signature": "State a -\u003e Context a -\u003e [(Rule (Context a), Location, Environment)]",
          "source": "src/Ideas-Service-BasicServices.html#findbuggyrules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "findbuggyrules",
          "normalized": "State a-\u003eContext a-\u003e[(Rule(Context a),Location,Environment)]",
          "package": "ideas",
          "signature": "State a-\u003eContext a-\u003e[(Rule(Context a),Location,Environment)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:findbuggyrules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "generate",
          "package": "ideas",
          "signature": "Exercise a -\u003e Maybe Difficulty -\u003e IO (State a)",
          "source": "src/Ideas-Service-BasicServices.html#generate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "generate",
          "normalized": "Exercise a-\u003eMaybe Difficulty-\u003eIO(State a)",
          "package": "ideas",
          "signature": "Exercise a-\u003eMaybe Difficulty-\u003eIO(State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:generate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "generateWith",
          "package": "ideas",
          "signature": "StdGen -\u003e Exercise a -\u003e Maybe Difficulty -\u003e Either String (State a)",
          "source": "src/Ideas-Service-BasicServices.html#generateWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "generateWith",
          "normalized": "StdGen-\u003eExercise a-\u003eMaybe Difficulty-\u003eEither String(State a)",
          "package": "ideas",
          "partial": "With",
          "signature": "StdGen-\u003eExercise a-\u003eMaybe Difficulty-\u003eEither String(State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:generateWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "onefirst",
          "package": "ideas",
          "signature": "State a -\u003e Either String (StepInfo a, State a)",
          "source": "src/Ideas-Service-BasicServices.html#onefirst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "onefirst",
          "normalized": "State a-\u003eEither String(StepInfo a,State a)",
          "package": "ideas",
          "signature": "State a-\u003eEither String(StepInfo a,State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:onefirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "ready",
          "package": "ideas",
          "signature": "State a -\u003e Bool",
          "source": "src/Ideas-Service-BasicServices.html#ready",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "ready",
          "normalized": "State a-\u003eBool",
          "package": "ideas",
          "signature": "State a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:ready"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.BasicServices",
          "name": "stepsremaining",
          "package": "ideas",
          "signature": "State a -\u003e Either String Int",
          "source": "src/Ideas-Service-BasicServices.html#stepsremaining",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service BasicServices",
          "module": "Ideas.Service.BasicServices",
          "name": "stepsremaining",
          "normalized": "State a-\u003eEither String Int",
          "package": "ideas",
          "signature": "State a-\u003eEither String Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-BasicServices.html#v:stepsremaining"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDiagnose a term submitted by a student\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Service.Diagnose",
          "name": "Diagnose",
          "package": "ideas",
          "source": "src/Ideas-Service-Diagnose.html",
          "type": "module"
        },
        "index": {
          "description": "Diagnose term submitted by student",
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "Diagnose",
          "package": "ideas",
          "partial": "Diagnose",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "Diagnosis",
          "package": "ideas",
          "source": "src/Ideas-Service-Diagnose.html#Diagnosis",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "Diagnosis",
          "package": "ideas",
          "partial": "Diagnosis",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#t:Diagnosis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "Buggy",
          "package": "ideas",
          "signature": "Buggy Environment (Rule (Context a))",
          "source": "src/Ideas-Service-Diagnose.html#Diagnosis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "Buggy",
          "package": "ideas",
          "partial": "Buggy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:Buggy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "Correct",
          "package": "ideas",
          "signature": "Correct Bool (State a)",
          "source": "src/Ideas-Service-Diagnose.html#Diagnosis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "Correct",
          "package": "ideas",
          "partial": "Correct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:Correct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "Detour",
          "package": "ideas",
          "signature": "Detour Bool (State a) Environment (Rule (Context a))",
          "source": "src/Ideas-Service-Diagnose.html#Diagnosis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "Detour",
          "package": "ideas",
          "partial": "Detour",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:Detour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "Expected",
          "package": "ideas",
          "signature": "Expected Bool (State a) (Rule (Context a))",
          "source": "src/Ideas-Service-Diagnose.html#Diagnosis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "Expected",
          "package": "ideas",
          "partial": "Expected",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:Expected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "NotEquivalent",
          "package": "ideas",
          "signature": "NotEquivalent",
          "source": "src/Ideas-Service-Diagnose.html#Diagnosis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "NotEquivalent",
          "package": "ideas",
          "partial": "Not Equivalent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:NotEquivalent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "Similar",
          "package": "ideas",
          "signature": "Similar Bool (State a)",
          "source": "src/Ideas-Service-Diagnose.html#Diagnosis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "Similar",
          "package": "ideas",
          "partial": "Similar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:Similar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "diagnose",
          "package": "ideas",
          "signature": "State a -\u003e Context a -\u003e Diagnosis a",
          "source": "src/Ideas-Service-Diagnose.html#diagnose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "diagnose",
          "normalized": "State a-\u003eContext a-\u003eDiagnosis a",
          "package": "ideas",
          "signature": "State a-\u003eContext a-\u003eDiagnosis a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:diagnose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "newState",
          "package": "ideas",
          "signature": "Diagnosis a -\u003e Maybe (State a)",
          "source": "src/Ideas-Service-Diagnose.html#newState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "newState",
          "normalized": "Diagnosis a-\u003eMaybe(State a)",
          "package": "ideas",
          "partial": "State",
          "signature": "Diagnosis a-\u003eMaybe(State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:newState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Diagnose",
          "name": "restartIfNeeded",
          "package": "ideas",
          "signature": "State a -\u003e State a",
          "source": "src/Ideas-Service-Diagnose.html#restartIfNeeded",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Diagnose",
          "module": "Ideas.Service.Diagnose",
          "name": "restartIfNeeded",
          "normalized": "State a-\u003eState a",
          "package": "ideas",
          "partial": "If Needed",
          "signature": "State a-\u003eState a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Diagnose.html#v:restartIfNeeded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "DomainReasoner",
          "package": "ideas",
          "source": "src/Ideas-Service-DomainReasoner.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "DomainReasoner",
          "package": "ideas",
          "partial": "Domain Reasoner",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "DomainReasoner",
          "package": "ideas",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "DomainReasoner",
          "package": "ideas",
          "partial": "Domain Reasoner",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#t:DomainReasoner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "DR",
          "package": "ideas",
          "signature": "DR",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "DR",
          "package": "ideas",
          "partial": "DR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:DR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "aliases",
          "package": "ideas",
          "signature": "[(Id, Id)]",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "aliases",
          "normalized": "[(Id,Id)]",
          "package": "ideas",
          "signature": "[(Id,Id)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:aliases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "defaultScript",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e Id -\u003e IO Script",
          "source": "src/Ideas-Service-DomainReasoner.html#defaultScript",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "defaultScript",
          "normalized": "DomainReasoner-\u003eId-\u003eIO Script",
          "package": "ideas",
          "partial": "Script",
          "signature": "DomainReasoner-\u003eId-\u003eIO Script",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:defaultScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "exercises",
          "package": "ideas",
          "signature": "[Some Exercise]",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "exercises",
          "normalized": "[Some Exercise]",
          "package": "ideas",
          "signature": "[Some Exercise]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:exercises"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "exercisesSorted",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e [Some Exercise]",
          "source": "src/Ideas-Service-DomainReasoner.html#exercisesSorted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "exercisesSorted",
          "normalized": "DomainReasoner-\u003e[Some Exercise]",
          "package": "ideas",
          "partial": "Sorted",
          "signature": "DomainReasoner-\u003e[Some Exercise]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:exercisesSorted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "findExercise",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e Id -\u003e m (Some Exercise)",
          "source": "src/Ideas-Service-DomainReasoner.html#findExercise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "findExercise",
          "normalized": "DomainReasoner-\u003eId-\u003ea(Some Exercise)",
          "package": "ideas",
          "partial": "Exercise",
          "signature": "DomainReasoner-\u003eId-\u003em(Some Exercise)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:findExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "findService",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e Id -\u003e m Service",
          "source": "src/Ideas-Service-DomainReasoner.html#findService",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "findService",
          "normalized": "DomainReasoner-\u003eId-\u003ea Service",
          "package": "ideas",
          "partial": "Service",
          "signature": "DomainReasoner-\u003eId-\u003em Service",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:findService"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "fullVersion",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "fullVersion",
          "package": "ideas",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:fullVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "reasonerId",
          "package": "ideas",
          "signature": "Id",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "reasonerId",
          "package": "ideas",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:reasonerId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "scripts",
          "package": "ideas",
          "signature": "[(Id, FilePath)]",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "scripts",
          "normalized": "[(Id,FilePath)]",
          "package": "ideas",
          "signature": "[(Id,FilePath)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:scripts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "services",
          "package": "ideas",
          "signature": "[Service]",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "services",
          "normalized": "[Service]",
          "package": "ideas",
          "signature": "[Service]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:services"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "servicesSorted",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e [Service]",
          "source": "src/Ideas-Service-DomainReasoner.html#servicesSorted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "servicesSorted",
          "normalized": "DomainReasoner-\u003e[Service]",
          "package": "ideas",
          "partial": "Sorted",
          "signature": "DomainReasoner-\u003e[Service]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:servicesSorted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "testSuite",
          "package": "ideas",
          "signature": "TestSuite",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "testSuite",
          "package": "ideas",
          "partial": "Suite",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:testSuite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "version",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "version",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.DomainReasoner",
          "name": "views",
          "package": "ideas",
          "signature": "[ViewPackage]",
          "source": "src/Ideas-Service-DomainReasoner.html#DomainReasoner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service DomainReasoner",
          "module": "Ideas.Service.DomainReasoner",
          "name": "views",
          "normalized": "[ViewPackage]",
          "package": "ideas",
          "signature": "[ViewPackage]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-DomainReasoner.html#v:views"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAnalysis of a feedbackscript\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "Analysis",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html",
          "type": "module"
        },
        "index": {
          "description": "Analysis of feedbackscript",
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "Analysis",
          "package": "ideas",
          "partial": "Analysis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "Message",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#Message",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "Message",
          "package": "ideas",
          "partial": "Message",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#t:Message"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "FeedbackUndefined",
          "package": "ideas",
          "signature": "FeedbackUndefined Id",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#Message",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "FeedbackUndefined",
          "package": "ideas",
          "partial": "Feedback Undefined",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:FeedbackUndefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "NoTextForRule",
          "package": "ideas",
          "signature": "NoTextForRule Id Id",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#Message",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "NoTextForRule",
          "package": "ideas",
          "partial": "No Text For Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:NoTextForRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownAttribute",
          "package": "ideas",
          "signature": "UnknownAttribute Id",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#Message",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownAttribute",
          "package": "ideas",
          "partial": "Unknown Attribute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:UnknownAttribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownCondAttr",
          "package": "ideas",
          "signature": "UnknownCondAttr Id",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#Message",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownCondAttr",
          "package": "ideas",
          "partial": "Unknown Cond Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:UnknownCondAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownExercise",
          "package": "ideas",
          "signature": "UnknownExercise Id",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#Message",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownExercise",
          "package": "ideas",
          "partial": "Unknown Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:UnknownExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownFeedback",
          "package": "ideas",
          "signature": "UnknownFeedback Id",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#Message",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "UnknownFeedback",
          "package": "ideas",
          "partial": "Unknown Feedback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:UnknownFeedback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "analyzeScript",
          "package": "ideas",
          "signature": "[Some Exercise] -\u003e Script -\u003e [Message]",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#analyzeScript",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "analyzeScript",
          "normalized": "[Some Exercise]-\u003eScript-\u003e[Message]",
          "package": "ideas",
          "partial": "Script",
          "signature": "[Some Exercise]-\u003eScript-\u003e[Message]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:analyzeScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "makeScriptFor",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e a -\u003e IO ()",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#makeScriptFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "makeScriptFor",
          "normalized": "DomainReasoner-\u003ea-\u003eIO()",
          "package": "ideas",
          "partial": "Script For",
          "signature": "DomainReasoner-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:makeScriptFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "parseAndAnalyzeScript",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e FilePath -\u003e IO ()",
          "source": "src/Ideas-Service-FeedbackScript-Analysis.html#parseAndAnalyzeScript",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Analysis",
          "module": "Ideas.Service.FeedbackScript.Analysis",
          "name": "parseAndAnalyzeScript",
          "normalized": "DomainReasoner-\u003eFilePath-\u003eIO()",
          "package": "ideas",
          "partial": "And Analyze Script",
          "signature": "DomainReasoner-\u003eFilePath-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Analysis.html#v:parseAndAnalyzeScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple parser for feedback scripts\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "Parser",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "Simple parser for feedback scripts",
          "hierarchy": "Ideas Service FeedbackScript Parser",
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "Parser",
          "package": "ideas",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "Script",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Script",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Parser",
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "Script",
          "package": "ideas",
          "partial": "Script",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Parser.html#t:Script"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "parseScript",
          "package": "ideas",
          "signature": "FilePath -\u003e IO Script",
          "source": "src/Ideas-Service-FeedbackScript-Parser.html#parseScript",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Parser",
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "parseScript",
          "normalized": "FilePath-\u003eIO Script",
          "package": "ideas",
          "partial": "Script",
          "signature": "FilePath-\u003eIO Script",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Parser.html#v:parseScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "parseScriptSafe",
          "package": "ideas",
          "signature": "FilePath -\u003e IO Script",
          "source": "src/Ideas-Service-FeedbackScript-Parser.html#parseScriptSafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Parser",
          "module": "Ideas.Service.FeedbackScript.Parser",
          "name": "parseScriptSafe",
          "normalized": "FilePath-\u003eIO Script",
          "package": "ideas",
          "partial": "Script Safe",
          "signature": "FilePath-\u003eIO Script",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Parser.html#v:parseScriptSafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRun a feedbackscript\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Run",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Run.html",
          "type": "module"
        },
        "index": {
          "description": "Run feedbackscript",
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Run",
          "package": "ideas",
          "partial": "Run",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Environment",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Environment",
          "package": "ideas",
          "partial": "Environment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#t:Environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Script",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Script",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Script",
          "package": "ideas",
          "partial": "Script",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#t:Script"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Env",
          "package": "ideas",
          "signature": "Env",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "Env",
          "package": "ideas",
          "partial": "Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:Env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "actives",
          "package": "ideas",
          "signature": "Maybe [LabelInfo]",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "actives",
          "normalized": "Maybe[LabelInfo]",
          "package": "ideas",
          "signature": "Maybe[LabelInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:actives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "after",
          "package": "ideas",
          "signature": "Maybe Term",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "after",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:after"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "afterText",
          "package": "ideas",
          "signature": "Maybe String",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "afterText",
          "package": "ideas",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:afterText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "attributeIds",
          "package": "ideas",
          "signature": "[Id]",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#attributeIds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "attributeIds",
          "normalized": "[Id]",
          "package": "ideas",
          "partial": "Ids",
          "signature": "[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:attributeIds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "before",
          "package": "ideas",
          "signature": "Maybe Term",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "before",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:before"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "conditionIds",
          "package": "ideas",
          "signature": "[Id]",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#conditionIds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "conditionIds",
          "normalized": "[Id]",
          "package": "ideas",
          "partial": "Ids",
          "signature": "[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:conditionIds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "diffPair",
          "package": "ideas",
          "signature": "Maybe (String, String)",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "diffPair",
          "normalized": "Maybe(String,String)",
          "package": "ideas",
          "partial": "Pair",
          "signature": "Maybe(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:diffPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "eval",
          "package": "ideas",
          "signature": "Environment a -\u003e Script -\u003e Either Id Text -\u003e Maybe Text",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#eval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "eval",
          "normalized": "Environment a-\u003eScript-\u003eEither Id Text-\u003eMaybe Text",
          "package": "ideas",
          "signature": "Environment a-\u003eScript-\u003eEither Id Text-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:eval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "expected",
          "package": "ideas",
          "signature": "Maybe (Rule (Context a))",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "expected",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:expected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackDiagnosis",
          "package": "ideas",
          "signature": "Diagnosis a -\u003e Environment a -\u003e Script -\u003e Text",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#feedbackDiagnosis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackDiagnosis",
          "normalized": "Diagnosis a-\u003eEnvironment a-\u003eScript-\u003eText",
          "package": "ideas",
          "partial": "Diagnosis",
          "signature": "Diagnosis a-\u003eEnvironment a-\u003eScript-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:feedbackDiagnosis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackHint",
          "package": "ideas",
          "signature": "Id -\u003e Environment a -\u003e Script -\u003e Text",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#feedbackHint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackHint",
          "normalized": "Id-\u003eEnvironment a-\u003eScript-\u003eText",
          "package": "ideas",
          "partial": "Hint",
          "signature": "Id-\u003eEnvironment a-\u003eScript-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:feedbackHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackHints",
          "package": "ideas",
          "signature": "Id -\u003e [((Rule (Context a), b, c), State a)] -\u003e State a -\u003e Script -\u003e [Text]",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#feedbackHints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackHints",
          "normalized": "Id-\u003e[((Rule(Context a),b,c),State a)]-\u003eState a-\u003eScript-\u003e[Text]",
          "package": "ideas",
          "partial": "Hints",
          "signature": "Id-\u003e[((Rule(Context a),b,c),State a)]-\u003eState a-\u003eScript-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:feedbackHints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackIds",
          "package": "ideas",
          "signature": "[Id]",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#feedbackIds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "feedbackIds",
          "normalized": "[Id]",
          "package": "ideas",
          "partial": "Ids",
          "signature": "[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:feedbackIds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "newEnvironment",
          "package": "ideas",
          "signature": "State a -\u003e Environment a",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#newEnvironment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "newEnvironment",
          "normalized": "State a-\u003eEnvironment a",
          "package": "ideas",
          "partial": "Environment",
          "signature": "State a-\u003eEnvironment a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:newEnvironment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "oldReady",
          "package": "ideas",
          "signature": "Bool",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "oldReady",
          "package": "ideas",
          "partial": "Ready",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:oldReady"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "recognized",
          "package": "ideas",
          "signature": "Maybe (Rule (Context a))",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#Environment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "recognized",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:recognized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "ruleToString",
          "package": "ideas",
          "signature": "Environment a -\u003e Script -\u003e Rule b -\u003e String",
          "source": "src/Ideas-Service-FeedbackScript-Run.html#ruleToString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Run",
          "module": "Ideas.Service.FeedbackScript.Run",
          "name": "ruleToString",
          "normalized": "Environment a-\u003eScript-\u003eRule b-\u003eString",
          "package": "ideas",
          "partial": "To String",
          "signature": "Environment a-\u003eScript-\u003eRule b-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Run.html#v:ruleToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstract syntax for feedback scripts, and pretty-printer (Show instance)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Syntax",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html",
          "type": "module"
        },
        "index": {
          "description": "Abstract syntax for feedback scripts and pretty-printer Show instance",
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Syntax",
          "package": "ideas",
          "partial": "Syntax",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Condition",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Condition",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Condition",
          "package": "ideas",
          "partial": "Condition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#t:Condition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Decl",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Decl",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Decl",
          "package": "ideas",
          "partial": "Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#t:Decl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "DeclType",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#DeclType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "DeclType",
          "package": "ideas",
          "partial": "Decl Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#t:DeclType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Script",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Script",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Script",
          "package": "ideas",
          "partial": "Script",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#t:Script"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Text",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Text",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Text",
          "package": "ideas",
          "partial": "Text",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#t:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": ":\u003c\u003e:",
          "package": "ideas",
          "signature": "Text :\u003c\u003e: Text",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": ":\u003c\u003e:",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v::-60--62-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "CondConst",
          "package": "ideas",
          "signature": "CondConst Bool",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Condition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "CondConst",
          "package": "ideas",
          "partial": "Cond Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:CondConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "CondNot",
          "package": "ideas",
          "signature": "CondNot Condition",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Condition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "CondNot",
          "package": "ideas",
          "partial": "Cond Not",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:CondNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "CondRef",
          "package": "ideas",
          "signature": "CondRef Id",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Condition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "CondRef",
          "package": "ideas",
          "partial": "Cond Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:CondRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Feedback",
          "package": "ideas",
          "signature": "Feedback",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#DeclType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Feedback",
          "package": "ideas",
          "partial": "Feedback",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:Feedback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Guarded",
          "package": "ideas",
          "signature": "Guarded DeclType [Id] [(Condition, Text)]",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Guarded",
          "normalized": "Guarded DeclType[Id][(Condition,Text)]",
          "package": "ideas",
          "partial": "Guarded",
          "signature": "Guarded DeclType[Id][(Condition,Text)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:Guarded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Include",
          "package": "ideas",
          "signature": "Include [FilePath]",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Include",
          "normalized": "Include[FilePath]",
          "package": "ideas",
          "partial": "Include",
          "signature": "Include[FilePath]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:Include"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "NameSpace",
          "package": "ideas",
          "signature": "NameSpace [Id]",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "NameSpace",
          "normalized": "NameSpace[Id]",
          "package": "ideas",
          "partial": "Name Space",
          "signature": "NameSpace[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:NameSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "RecognizedIs",
          "package": "ideas",
          "signature": "RecognizedIs Id",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Condition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "RecognizedIs",
          "package": "ideas",
          "partial": "Recognized Is",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:RecognizedIs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Simple",
          "package": "ideas",
          "signature": "Simple DeclType [Id] Text",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Simple",
          "normalized": "Simple DeclType[Id]Text",
          "package": "ideas",
          "partial": "Simple",
          "signature": "Simple DeclType[Id]Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:Simple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "StringDecl",
          "package": "ideas",
          "signature": "StringDecl",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#DeclType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "StringDecl",
          "package": "ideas",
          "partial": "String Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:StringDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Supports",
          "package": "ideas",
          "signature": "Supports [Id]",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "Supports",
          "normalized": "Supports[Id]",
          "package": "ideas",
          "partial": "Supports",
          "signature": "Supports[Id]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:Supports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextEmpty",
          "package": "ideas",
          "signature": "TextEmpty",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextEmpty",
          "package": "ideas",
          "partial": "Text Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:TextEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextForId",
          "package": "ideas",
          "signature": "TextForId",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#DeclType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextForId",
          "package": "ideas",
          "partial": "Text For Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:TextForId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextRef",
          "package": "ideas",
          "signature": "TextRef Id",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextRef",
          "package": "ideas",
          "partial": "Text Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:TextRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextString",
          "package": "ideas",
          "signature": "TextString String",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextString",
          "package": "ideas",
          "partial": "Text String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:TextString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextTerm",
          "package": "ideas",
          "signature": "TextTerm Term",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#Text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "TextTerm",
          "package": "ideas",
          "partial": "Text Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:TextTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "feedbackDecl",
          "package": "ideas",
          "signature": "a -\u003e Text -\u003e Decl",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#feedbackDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "feedbackDecl",
          "normalized": "a-\u003eText-\u003eDecl",
          "package": "ideas",
          "partial": "Decl",
          "signature": "a-\u003eText-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:feedbackDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "includes",
          "package": "ideas",
          "signature": "Script -\u003e [FilePath]",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#includes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "includes",
          "normalized": "Script-\u003e[FilePath]",
          "package": "ideas",
          "signature": "Script-\u003e[FilePath]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:includes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "makeScript",
          "package": "ideas",
          "signature": "[Decl] -\u003e Script",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#makeScript",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "makeScript",
          "normalized": "[Decl]-\u003eScript",
          "package": "ideas",
          "partial": "Script",
          "signature": "[Decl]-\u003eScript",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:makeScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "makeText",
          "package": "ideas",
          "signature": "String -\u003e Text",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#makeText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "makeText",
          "normalized": "String-\u003eText",
          "package": "ideas",
          "partial": "Text",
          "signature": "String-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:makeText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "scriptDecls",
          "package": "ideas",
          "signature": "Script -\u003e [Decl]",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#scriptDecls",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "scriptDecls",
          "normalized": "Script-\u003e[Decl]",
          "package": "ideas",
          "partial": "Decls",
          "signature": "Script-\u003e[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:scriptDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "textForIdDecl",
          "package": "ideas",
          "signature": "a -\u003e Text -\u003e Decl",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#textForIdDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "textForIdDecl",
          "normalized": "a-\u003eText-\u003eDecl",
          "package": "ideas",
          "partial": "For Id Decl",
          "signature": "a-\u003eText-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:textForIdDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "textItems",
          "package": "ideas",
          "signature": "Text -\u003e [Text]",
          "source": "src/Ideas-Service-FeedbackScript-Syntax.html#textItems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackScript Syntax",
          "module": "Ideas.Service.FeedbackScript.Syntax",
          "name": "textItems",
          "normalized": "Text-\u003e[Text]",
          "package": "ideas",
          "partial": "Items",
          "signature": "Text-\u003e[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackScript-Syntax.html#v:textItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "FeedbackText",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackText.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "FeedbackText",
          "package": "ideas",
          "partial": "Feedback Text",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "Message",
          "package": "ideas",
          "source": "src/Ideas-Service-FeedbackText.html#Message",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "Message",
          "package": "ideas",
          "partial": "Message",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#t:Message"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "accept",
          "package": "ideas",
          "signature": "Message -\u003e Maybe Bool",
          "source": "src/Ideas-Service-FeedbackText.html#accept",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "accept",
          "normalized": "Message-\u003eMaybe Bool",
          "package": "ideas",
          "signature": "Message-\u003eMaybe Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#v:accept"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "derivationtext",
          "package": "ideas",
          "signature": "Script -\u003e State a -\u003e Either String (Derivation String (Context a))",
          "source": "src/Ideas-Service-FeedbackText.html#derivationtext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "derivationtext",
          "normalized": "Script-\u003eState a-\u003eEither String(Derivation String(Context a))",
          "package": "ideas",
          "signature": "Script-\u003eState a-\u003eEither String(Derivation String(Context a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#v:derivationtext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "feedbacktext",
          "package": "ideas",
          "signature": "Script -\u003e State a -\u003e Context a -\u003e (Message, State a)",
          "source": "src/Ideas-Service-FeedbackText.html#feedbacktext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "feedbacktext",
          "normalized": "Script-\u003eState a-\u003eContext a-\u003e(Message,State a)",
          "package": "ideas",
          "signature": "Script-\u003eState a-\u003eContext a-\u003e(Message,State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#v:feedbacktext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "onefirsttext",
          "package": "ideas",
          "signature": "Script -\u003e State a -\u003e Maybe String -\u003e (Message, Maybe (State a))",
          "source": "src/Ideas-Service-FeedbackText.html#onefirsttext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "onefirsttext",
          "normalized": "Script-\u003eState a-\u003eMaybe String-\u003e(Message,Maybe(State a))",
          "package": "ideas",
          "signature": "Script-\u003eState a-\u003eMaybe String-\u003e(Message,Maybe(State a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#v:onefirsttext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "submittext",
          "package": "ideas",
          "signature": "Script -\u003e State a -\u003e String -\u003e (Message, State a)",
          "source": "src/Ideas-Service-FeedbackText.html#submittext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "submittext",
          "normalized": "Script-\u003eState a-\u003eString-\u003e(Message,State a)",
          "package": "ideas",
          "signature": "Script-\u003eState a-\u003eString-\u003e(Message,State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#v:submittext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.FeedbackText",
          "name": "text",
          "package": "ideas",
          "signature": "Message -\u003e Text",
          "source": "src/Ideas-Service-FeedbackText.html#text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service FeedbackText",
          "module": "Ideas.Service.FeedbackText",
          "name": "text",
          "normalized": "Message-\u003eText",
          "package": "ideas",
          "signature": "Message-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-FeedbackText.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "ProblemDecomposition",
          "package": "ideas",
          "source": "src/Ideas-Service-ProblemDecomposition.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Service ProblemDecomposition",
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "ProblemDecomposition",
          "package": "ideas",
          "partial": "Problem Decomposition",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ProblemDecomposition.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "Reply",
          "package": "ideas",
          "source": "src/Ideas-Service-ProblemDecomposition.html#Reply",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service ProblemDecomposition",
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "Reply",
          "package": "ideas",
          "partial": "Reply",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ProblemDecomposition.html#t:Reply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "Incorrect",
          "package": "ideas",
          "signature": "Incorrect Bool Id (State a) Environment",
          "source": "src/Ideas-Service-ProblemDecomposition.html#Reply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service ProblemDecomposition",
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "Incorrect",
          "package": "ideas",
          "partial": "Incorrect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ProblemDecomposition.html#v:Incorrect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "Ok",
          "package": "ideas",
          "signature": "Ok Id (State a)",
          "source": "src/Ideas-Service-ProblemDecomposition.html#Reply",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service ProblemDecomposition",
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "Ok",
          "package": "ideas",
          "partial": "Ok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ProblemDecomposition.html#v:Ok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "problemDecomposition",
          "package": "ideas",
          "signature": "Maybe Id -\u003e State a -\u003e Maybe (Answer a) -\u003e Either String (Reply a)",
          "source": "src/Ideas-Service-ProblemDecomposition.html#problemDecomposition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service ProblemDecomposition",
          "module": "Ideas.Service.ProblemDecomposition",
          "name": "problemDecomposition",
          "normalized": "Maybe Id-\u003eState a-\u003eMaybe(Answer a)-\u003eEither String(Reply a)",
          "package": "ideas",
          "partial": "Decomposition",
          "signature": "Maybe Id-\u003eState a-\u003eMaybe(Answer a)-\u003eEither String(Reply a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ProblemDecomposition.html#v:problemDecomposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "Request",
          "package": "ideas",
          "source": "src/Ideas-Service-Request.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "Request",
          "package": "ideas",
          "partial": "Request",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "DataFormat",
          "package": "ideas",
          "source": "src/Ideas-Service-Request.html#DataFormat",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "DataFormat",
          "package": "ideas",
          "partial": "Data Format",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#t:DataFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "Encoding",
          "package": "ideas",
          "source": "src/Ideas-Service-Request.html#Encoding",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "Encoding",
          "package": "ideas",
          "partial": "Encoding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#t:Encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "Request",
          "package": "ideas",
          "source": "src/Ideas-Service-Request.html#Request",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "Request",
          "package": "ideas",
          "partial": "Request",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#t:Request"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "HTMLEncoding",
          "package": "ideas",
          "signature": "HTMLEncoding",
          "source": "src/Ideas-Service-Request.html#Encoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "HTMLEncoding",
          "package": "ideas",
          "partial": "HTMLEncoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:HTMLEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "JSON",
          "package": "ideas",
          "signature": "JSON",
          "source": "src/Ideas-Service-Request.html#DataFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "JSON",
          "package": "ideas",
          "partial": "JSON",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:JSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "OpenMath",
          "package": "ideas",
          "signature": "OpenMath",
          "source": "src/Ideas-Service-Request.html#Encoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "OpenMath",
          "package": "ideas",
          "partial": "Open Math",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:OpenMath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "Request",
          "package": "ideas",
          "signature": "Request",
          "source": "src/Ideas-Service-Request.html#Request",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "Request",
          "package": "ideas",
          "partial": "Request",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:Request"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "StringEncoding",
          "package": "ideas",
          "signature": "StringEncoding",
          "source": "src/Ideas-Service-Request.html#Encoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "StringEncoding",
          "package": "ideas",
          "partial": "String Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:StringEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "XML",
          "package": "ideas",
          "signature": "XML",
          "source": "src/Ideas-Service-Request.html#DataFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "XML",
          "package": "ideas",
          "partial": "XML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:XML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "dataformat",
          "package": "ideas",
          "signature": "DataFormat",
          "source": "src/Ideas-Service-Request.html#Request",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "dataformat",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:dataformat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "discoverDataFormat",
          "package": "ideas",
          "signature": "String -\u003e m DataFormat",
          "source": "src/Ideas-Service-Request.html#discoverDataFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "discoverDataFormat",
          "normalized": "String-\u003ea DataFormat",
          "package": "ideas",
          "partial": "Data Format",
          "signature": "String-\u003em DataFormat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:discoverDataFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "encoding",
          "package": "ideas",
          "signature": "Maybe Encoding",
          "source": "src/Ideas-Service-Request.html#Request",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "encoding",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "exerciseId",
          "package": "ideas",
          "signature": "Maybe Id",
          "source": "src/Ideas-Service-Request.html#Request",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "exerciseId",
          "package": "ideas",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:exerciseId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "readEncoding",
          "package": "ideas",
          "signature": "String -\u003e m Encoding",
          "source": "src/Ideas-Service-Request.html#readEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "readEncoding",
          "normalized": "String-\u003ea Encoding",
          "package": "ideas",
          "partial": "Encoding",
          "signature": "String-\u003em Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:readEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "service",
          "package": "ideas",
          "signature": "String",
          "source": "src/Ideas-Service-Request.html#Request",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "service",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:service"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Request",
          "name": "source",
          "package": "ideas",
          "signature": "Maybe String",
          "source": "src/Ideas-Service-Request.html#Request",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Request",
          "module": "Ideas.Service.Request",
          "name": "source",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Request.html#v:source"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ServiceList",
          "name": "ServiceList",
          "package": "ideas",
          "source": "src/Ideas-Service-ServiceList.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Service ServiceList",
          "module": "Ideas.Service.ServiceList",
          "name": "ServiceList",
          "package": "ideas",
          "partial": "Service List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ServiceList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ServiceList",
          "name": "metaServiceList",
          "package": "ideas",
          "signature": "DomainReasoner -\u003e [Service]",
          "source": "src/Ideas-Service-ServiceList.html#metaServiceList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service ServiceList",
          "module": "Ideas.Service.ServiceList",
          "name": "metaServiceList",
          "normalized": "DomainReasoner-\u003e[Service]",
          "package": "ideas",
          "partial": "Service List",
          "signature": "DomainReasoner-\u003e[Service]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ServiceList.html#v:metaServiceList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.ServiceList",
          "name": "serviceList",
          "package": "ideas",
          "signature": "[Service]",
          "source": "src/Ideas-Service-ServiceList.html#serviceList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service ServiceList",
          "module": "Ideas.Service.ServiceList",
          "name": "serviceList",
          "normalized": "[Service]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Service]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-ServiceList.html#v:serviceList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe information maintained for a learner trying to complete a\n derivation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Service.State",
          "name": "State",
          "package": "ideas",
          "source": "src/Ideas-Service-State.html",
          "type": "module"
        },
        "index": {
          "description": "The information maintained for learner trying to complete derivation",
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "State",
          "package": "ideas",
          "partial": "State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "State",
          "package": "ideas",
          "source": "src/Ideas-Service-State.html#State",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "State",
          "package": "ideas",
          "partial": "State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#t:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "emptyState",
          "package": "ideas",
          "signature": "Exercise a -\u003e a -\u003e State a",
          "source": "src/Ideas-Service-State.html#emptyState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "emptyState",
          "normalized": "Exercise a-\u003ea-\u003eState a",
          "package": "ideas",
          "partial": "State",
          "signature": "Exercise a-\u003ea-\u003eState a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:emptyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "emptyStateContext",
          "package": "ideas",
          "signature": "Exercise a -\u003e Context a -\u003e State a",
          "source": "src/Ideas-Service-State.html#emptyStateContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "emptyStateContext",
          "normalized": "Exercise a-\u003eContext a-\u003eState a",
          "package": "ideas",
          "partial": "State Context",
          "signature": "Exercise a-\u003eContext a-\u003eState a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:emptyStateContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "exercise",
          "package": "ideas",
          "signature": "State a -\u003e Exercise a",
          "source": "src/Ideas-Service-State.html#exercise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "exercise",
          "normalized": "State a-\u003eExercise a",
          "package": "ideas",
          "signature": "State a-\u003eExercise a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:exercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "makeNoState",
          "package": "ideas",
          "signature": "Exercise a -\u003e Context a -\u003e State a",
          "source": "src/Ideas-Service-State.html#makeNoState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "makeNoState",
          "normalized": "Exercise a-\u003eContext a-\u003eState a",
          "package": "ideas",
          "partial": "No State",
          "signature": "Exercise a-\u003eContext a-\u003eState a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:makeNoState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "makeState",
          "package": "ideas",
          "signature": "Exercise a -\u003e [Prefix (Context a)] -\u003e Context a -\u003e State a",
          "source": "src/Ideas-Service-State.html#makeState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "makeState",
          "normalized": "Exercise a-\u003e[Prefix(Context a)]-\u003eContext a-\u003eState a",
          "package": "ideas",
          "partial": "State",
          "signature": "Exercise a-\u003e[Prefix(Context a)]-\u003eContext a-\u003eState a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:makeState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "stateContext",
          "package": "ideas",
          "signature": "State a -\u003e Context a",
          "source": "src/Ideas-Service-State.html#stateContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "stateContext",
          "normalized": "State a-\u003eContext a",
          "package": "ideas",
          "partial": "Context",
          "signature": "State a-\u003eContext a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:stateContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "stateLabels",
          "package": "ideas",
          "signature": "State a -\u003e [[LabelInfo]]",
          "source": "src/Ideas-Service-State.html#stateLabels",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "stateLabels",
          "normalized": "State a-\u003e[[LabelInfo]]",
          "package": "ideas",
          "partial": "Labels",
          "signature": "State a-\u003e[[LabelInfo]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:stateLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "statePrefixes",
          "package": "ideas",
          "signature": "State a -\u003e [Prefix (Context a)]",
          "source": "src/Ideas-Service-State.html#statePrefixes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "statePrefixes",
          "normalized": "State a-\u003e[Prefix(Context a)]",
          "package": "ideas",
          "partial": "Prefixes",
          "signature": "State a-\u003e[Prefix(Context a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:statePrefixes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.State",
          "name": "stateTerm",
          "package": "ideas",
          "signature": "State a -\u003e a",
          "source": "src/Ideas-Service-State.html#stateTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service State",
          "module": "Ideas.Service.State",
          "name": "stateTerm",
          "normalized": "State a-\u003ea",
          "package": "ideas",
          "partial": "Term",
          "signature": "State a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-State.html#v:stateTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDiagnose a term submitted by a student. Deprecated (see diagnose service).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Service.Submit",
          "name": "Submit",
          "package": "ideas",
          "source": "src/Ideas-Service-Submit.html",
          "type": "module"
        },
        "index": {
          "description": "Diagnose term submitted by student Deprecated see diagnose service",
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "Submit",
          "package": "ideas",
          "partial": "Submit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Submit",
          "name": "Result",
          "package": "ideas",
          "source": "src/Ideas-Service-Submit.html#Result",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "Result",
          "package": "ideas",
          "partial": "Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#t:Result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Submit",
          "name": "Buggy",
          "package": "ideas",
          "signature": "Buggy [Rule (Context a)]",
          "source": "src/Ideas-Service-Submit.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "Buggy",
          "normalized": "Buggy[Rule(Context a)]",
          "package": "ideas",
          "partial": "Buggy",
          "signature": "Buggy[Rule(Context a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#v:Buggy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Submit",
          "name": "Detour",
          "package": "ideas",
          "signature": "Detour [Rule (Context a)] (State a)",
          "source": "src/Ideas-Service-Submit.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "Detour",
          "normalized": "Detour[Rule(Context a)](State a)",
          "package": "ideas",
          "partial": "Detour",
          "signature": "Detour[Rule(Context a)](State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#v:Detour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Submit",
          "name": "NotEquivalent",
          "package": "ideas",
          "signature": "NotEquivalent",
          "source": "src/Ideas-Service-Submit.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "NotEquivalent",
          "package": "ideas",
          "partial": "Not Equivalent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#v:NotEquivalent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Submit",
          "name": "Ok",
          "package": "ideas",
          "signature": "Ok [Rule (Context a)] (State a)",
          "source": "src/Ideas-Service-Submit.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "Ok",
          "normalized": "Ok[Rule(Context a)](State a)",
          "package": "ideas",
          "partial": "Ok",
          "signature": "Ok[Rule(Context a)](State a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#v:Ok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Submit",
          "name": "Unknown",
          "package": "ideas",
          "signature": "Unknown (State a)",
          "source": "src/Ideas-Service-Submit.html#Result",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "Unknown",
          "package": "ideas",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Submit",
          "name": "submit",
          "package": "ideas",
          "signature": "State a -\u003e Context a -\u003e Result a",
          "source": "src/Ideas-Service-Submit.html#submit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Submit",
          "module": "Ideas.Service.Submit",
          "name": "submit",
          "normalized": "State a-\u003eContext a-\u003eResult a",
          "package": "ideas",
          "signature": "State a-\u003eContext a-\u003eResult a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Submit.html#v:submit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Types",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Types",
          "package": "ideas",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Const",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Const",
          "package": "ideas",
          "partial": "Const",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Equal",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#Equal",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Equal",
          "package": "ideas",
          "partial": "Equal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:Equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Service",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#Service",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Service",
          "package": "ideas",
          "partial": "Service",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:Service"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "ShowF",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#ShowF",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "ShowF",
          "package": "ideas",
          "partial": "Show",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:ShowF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Type",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#Type",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Type",
          "package": "ideas",
          "partial": "Type",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "TypeRep",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "TypeRep",
          "package": "ideas",
          "partial": "Type Rep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:TypeRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Typed",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#Typed",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Typed",
          "package": "ideas",
          "partial": "Typed",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:Typed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "TypedValue",
          "package": "ideas",
          "source": "src/Ideas-Service-Types.html#TypedValue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "TypedValue",
          "package": "ideas",
          "partial": "Typed Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#t:TypedValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": ":|:",
          "package": "ideas",
          "signature": "TypeRep f t1 -\u003e TypeRep f t2 -\u003e TypeRep f (Either t1 t2)",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": ":|:",
          "normalized": "TypeRep a b-\u003eTypeRep a b-\u003eTypeRep a(Either b b)",
          "package": "ideas",
          "signature": "TypeRep f t-\u003eTypeRep f t-\u003eTypeRep f(Either t t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v::-124-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": ":-\u003e",
          "package": "ideas",
          "signature": "TypeRep f t1 -\u003e TypeRep f t2 -\u003e TypeRep f (t1 -\u003e t2)",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": ":-\u003e",
          "normalized": "TypeRep a b-\u003eTypeRep a b-\u003eTypeRep a(b-\u003eb)",
          "package": "ideas",
          "signature": "TypeRep f t-\u003eTypeRep f t-\u003eTypeRep f(t-\u003et)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v::-45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": ":::",
          "package": "ideas",
          "signature": "t -\u003e f t -\u003e TypedValue f",
          "source": "src/Ideas-Service-Types.html#TypedValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": ":::",
          "normalized": "a-\u003eb a-\u003eTypedValue b",
          "package": "ideas",
          "signature": "t-\u003ef t-\u003eTypedValue f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v::::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Bool",
          "package": "ideas",
          "signature": "Const a Bool",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Bool",
          "package": "ideas",
          "partial": "Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Const",
          "package": "ideas",
          "signature": "f t -\u003e TypeRep f t",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Const",
          "normalized": "a b-\u003eTypeRep a b",
          "package": "ideas",
          "partial": "Const",
          "signature": "f t-\u003eTypeRep f t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Context",
          "package": "ideas",
          "signature": "Const a (Context a)",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Context",
          "package": "ideas",
          "partial": "Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Environment",
          "package": "ideas",
          "signature": "Const a Environment",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Environment",
          "package": "ideas",
          "partial": "Environment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Environment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Exercise",
          "package": "ideas",
          "signature": "Const a (Exercise a)",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Exercise",
          "package": "ideas",
          "partial": "Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Exercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Id",
          "package": "ideas",
          "signature": "Const a Id",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Id",
          "package": "ideas",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Int",
          "package": "ideas",
          "signature": "Const a Int",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Int",
          "package": "ideas",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Iso",
          "package": "ideas",
          "signature": "Isomorphism t1 t2 -\u003e TypeRep f t1 -\u003e TypeRep f t2",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Iso",
          "normalized": "Isomorphism a a-\u003eTypeRep b a-\u003eTypeRep b a",
          "package": "ideas",
          "partial": "Iso",
          "signature": "Isomorphism t t-\u003eTypeRep f t-\u003eTypeRep f t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "List",
          "package": "ideas",
          "signature": "TypeRep f t -\u003e TypeRep f [t]",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "List",
          "normalized": "TypeRep a b-\u003eTypeRep a[b]",
          "package": "ideas",
          "partial": "List",
          "signature": "TypeRep f t-\u003eTypeRep f[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Location",
          "package": "ideas",
          "signature": "Const a Location",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Location",
          "package": "ideas",
          "partial": "Location",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Location"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Pair",
          "package": "ideas",
          "signature": "TypeRep f t1 -\u003e TypeRep f t2 -\u003e TypeRep f (t1, t2)",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Pair",
          "normalized": "TypeRep a b-\u003eTypeRep a b-\u003eTypeRep a(b,b)",
          "package": "ideas",
          "partial": "Pair",
          "signature": "TypeRep f t-\u003eTypeRep f t-\u003eTypeRep f(t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Rule",
          "package": "ideas",
          "signature": "Const a (Rule (Context a))",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Rule",
          "package": "ideas",
          "partial": "Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Script",
          "package": "ideas",
          "signature": "Const a Script",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Script",
          "package": "ideas",
          "partial": "Script",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Script"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Service",
          "package": "ideas",
          "signature": "Const a Service",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Service",
          "package": "ideas",
          "partial": "Service",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Service"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "SomeExercise",
          "package": "ideas",
          "signature": "Const a (Some Exercise)",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "SomeExercise",
          "package": "ideas",
          "partial": "Some Exercise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:SomeExercise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "State",
          "package": "ideas",
          "signature": "Const a (State a)",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "State",
          "package": "ideas",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "StdGen",
          "package": "ideas",
          "signature": "Const a StdGen",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "StdGen",
          "package": "ideas",
          "partial": "Std Gen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:StdGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "StratCfg",
          "package": "ideas",
          "signature": "Const a StrategyConfiguration",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "StratCfg",
          "package": "ideas",
          "partial": "Strat Cfg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:StratCfg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Strategy",
          "package": "ideas",
          "signature": "Const a (Strategy (Context a))",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Strategy",
          "package": "ideas",
          "partial": "Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Strategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "String",
          "package": "ideas",
          "signature": "Const a String",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "String",
          "package": "ideas",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Tag",
          "package": "ideas",
          "signature": "String -\u003e TypeRep f t1 -\u003e TypeRep f t1",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Tag",
          "normalized": "String-\u003eTypeRep a b-\u003eTypeRep a b",
          "package": "ideas",
          "partial": "Tag",
          "signature": "String-\u003eTypeRep f t-\u003eTypeRep f t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Tag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Text",
          "package": "ideas",
          "signature": "Const a Text",
          "source": "src/Ideas-Service-Types.html#Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Text",
          "package": "ideas",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "Unit",
          "package": "ideas",
          "signature": "TypeRep f ()",
          "source": "src/Ideas-Service-Types.html#TypeRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "Unit",
          "normalized": "TypeRep a()",
          "package": "ideas",
          "partial": "Unit",
          "signature": "TypeRep f()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:Unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "deprecate",
          "package": "ideas",
          "signature": "Service -\u003e Service",
          "source": "src/Ideas-Service-Types.html#deprecate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "deprecate",
          "normalized": "Service-\u003eService",
          "package": "ideas",
          "signature": "Service-\u003eService",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:deprecate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "equal",
          "package": "ideas",
          "signature": "f a -\u003e f b -\u003e Maybe (a -\u003e b)",
          "source": "src/Ideas-Service-Types.html#equal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "equal",
          "normalized": "a b-\u003ea c-\u003eMaybe(b-\u003ec)",
          "package": "ideas",
          "signature": "f a-\u003ef b-\u003eMaybe(a-\u003eb)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "equalM",
          "package": "ideas",
          "signature": "Type a t1 -\u003e Type a t2 -\u003e m (t1 -\u003e t2)",
          "source": "src/Ideas-Service-Types.html#equalM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "equalM",
          "normalized": "Type a b-\u003eType a b-\u003ec(b-\u003eb)",
          "package": "ideas",
          "signature": "Type a t-\u003eType a t-\u003em(t-\u003et)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:equalM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "makeService",
          "package": "ideas",
          "signature": "String -\u003e String -\u003e (forall a.  TypedValue (Type a)) -\u003e Service",
          "source": "src/Ideas-Service-Types.html#makeService",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "makeService",
          "normalized": "String-\u003eString-\u003e(a b TypedValue(Type c))-\u003eService",
          "package": "ideas",
          "partial": "Service",
          "signature": "String-\u003eString-\u003e(forall a. TypedValue(Type a))-\u003eService",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:makeService"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "serviceDeprecated",
          "package": "ideas",
          "signature": "Service -\u003e Bool",
          "source": "src/Ideas-Service-Types.html#serviceDeprecated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "serviceDeprecated",
          "normalized": "Service-\u003eBool",
          "package": "ideas",
          "partial": "Deprecated",
          "signature": "Service-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:serviceDeprecated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "serviceFunction",
          "package": "ideas",
          "signature": "Service -\u003e forall a.  TypedValue (Type a)",
          "source": "src/Ideas-Service-Types.html#serviceFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "serviceFunction",
          "normalized": "Service-\u003ea b TypedValue(Type c)",
          "package": "ideas",
          "partial": "Function",
          "signature": "Service-\u003eforall a. TypedValue(Type a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:serviceFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "showF",
          "package": "ideas",
          "signature": "f a -\u003e String",
          "source": "src/Ideas-Service-Types.html#showF",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "showF",
          "normalized": "a b-\u003eString",
          "package": "ideas",
          "signature": "f a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:showF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "typeOf",
          "package": "ideas",
          "signature": "t -\u003e Type a t",
          "source": "src/Ideas-Service-Types.html#typeOf",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "typeOf",
          "normalized": "a-\u003eType b a",
          "package": "ideas",
          "partial": "Of",
          "signature": "t-\u003eType a t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:typeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "typed",
          "package": "ideas",
          "signature": "Type a t",
          "source": "src/Ideas-Service-Types.html#typed",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "typed",
          "package": "ideas",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:typed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Service.Types",
          "name": "typedList",
          "package": "ideas",
          "signature": "Type a [t]",
          "source": "src/Ideas-Service-Types.html#typedList",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Service Types",
          "module": "Ideas.Service.Types",
          "name": "typedList",
          "normalized": "Type a[b]",
          "package": "ideas",
          "partial": "List",
          "signature": "Type a[t]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Service-Types.html#v:typedList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA minimal interface for constructing simple HTML pages\n See http:\u003cem/\u003ewww.w3.org\u003cem\u003eTR\u003c/em\u003ehtml4/\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.HTML",
          "name": "HTML",
          "package": "ideas",
          "source": "src/Ideas-Text-HTML.html",
          "type": "module"
        },
        "index": {
          "description": "minimal interface for constructing simple HTML pages See http www.w3.org TR html4",
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "HTML",
          "package": "ideas",
          "partial": "HTML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "HTMLBuilder",
          "package": "ideas",
          "source": "src/Ideas-Text-HTML.html#HTMLBuilder",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "HTMLBuilder",
          "package": "ideas",
          "partial": "HTMLBuilder",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#t:HTMLBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "HTMLPage",
          "package": "ideas",
          "source": "src/Ideas-Text-HTML.html#HTMLPage",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "HTMLPage",
          "package": "ideas",
          "partial": "HTMLPage",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#t:HTMLPage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "addCSS",
          "package": "ideas",
          "signature": "FilePath -\u003e HTMLPage -\u003e HTMLPage",
          "source": "src/Ideas-Text-HTML.html#addCSS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "addCSS",
          "normalized": "FilePath-\u003eHTMLPage-\u003eHTMLPage",
          "package": "ideas",
          "partial": "CSS",
          "signature": "FilePath-\u003eHTMLPage-\u003eHTMLPage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:addCSS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "addScript",
          "package": "ideas",
          "signature": "FilePath -\u003e HTMLPage -\u003e HTMLPage",
          "source": "src/Ideas-Text-HTML.html#addScript",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "addScript",
          "normalized": "FilePath-\u003eHTMLPage-\u003eHTMLPage",
          "package": "ideas",
          "partial": "Script",
          "signature": "FilePath-\u003eHTMLPage-\u003eHTMLPage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:addScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "big",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#big",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "big",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:big"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders as bold text style.\n\u003c/p\u003e",
          "module": "Ideas.Text.HTML",
          "name": "bold",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#bold",
          "type": "function"
        },
        "index": {
          "description": "Renders as bold text style",
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "bold",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:bold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "br",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Text-HTML.html#br",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "br",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:br"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "bullet",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Text-HTML.html#bullet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "bullet",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:bullet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "classA",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#classA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "classA",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:classA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "divClass",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#divClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "divClass",
          "normalized": "String-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Class",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:divClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "h1",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#h1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "h1",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:h1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "h2",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#h2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "h2",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:h2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "h3",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#h3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "h3",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:h3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "h4",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#h4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "h4",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:h4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "h5",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#h5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "h5",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:h5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "h6",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#h6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "h6",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:h6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "highlightXML",
          "package": "ideas",
          "signature": "Bool -\u003e XML -\u003e HTMLBuilder",
          "source": "src/Ideas-Text-HTML.html#highlightXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "highlightXML",
          "normalized": "Bool-\u003eXML-\u003eHTMLBuilder",
          "package": "ideas",
          "partial": "XML",
          "signature": "Bool-\u003eXML-\u003eHTMLBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:highlightXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "hr",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Text-HTML.html#hr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "hr",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:hr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "htmlPage",
          "package": "ideas",
          "signature": "String -\u003e HTMLBuilder -\u003e HTMLPage",
          "source": "src/Ideas-Text-HTML.html#htmlPage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "htmlPage",
          "normalized": "String-\u003eHTMLBuilder-\u003eHTMLPage",
          "package": "ideas",
          "partial": "Page",
          "signature": "String-\u003eHTMLBuilder-\u003eHTMLPage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:htmlPage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "idA",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#idA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "idA",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:idA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "image",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#image",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "image",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:image"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders as italic text style.\n\u003c/p\u003e",
          "module": "Ideas.Text.HTML",
          "name": "italic",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#italic",
          "type": "function"
        },
        "index": {
          "description": "Renders as italic text style",
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "italic",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:italic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "keyValueTable",
          "package": "ideas",
          "signature": "[(String, a)] -\u003e a",
          "source": "src/Ideas-Text-HTML.html#keyValueTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "keyValueTable",
          "normalized": "[(String,a)]-\u003ea",
          "package": "ideas",
          "partial": "Value Table",
          "signature": "[(String,a)]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:keyValueTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "link",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#link",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "link",
          "normalized": "String-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:link"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "para",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#para",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "para",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:para"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "pre",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#pre",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "pre",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:pre"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "preText",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#preText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "preText",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "partial": "Text",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:preText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "showHTML",
          "package": "ideas",
          "signature": "HTMLPage -\u003e String",
          "source": "src/Ideas-Text-HTML.html#showHTML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "showHTML",
          "normalized": "HTMLPage-\u003eString",
          "package": "ideas",
          "partial": "HTML",
          "signature": "HTMLPage-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:showHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "small",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#small",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "small",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:small"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "space",
          "package": "ideas",
          "signature": "a",
          "source": "src/Ideas-Text-HTML.html#space",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "space",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "spaces",
          "package": "ideas",
          "signature": "Int -\u003e a",
          "source": "src/Ideas-Text-HTML.html#spaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "spaces",
          "normalized": "Int-\u003ea",
          "package": "ideas",
          "signature": "Int-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:spaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "spanClass",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#spanClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "spanClass",
          "normalized": "String-\u003ea-\u003ea",
          "package": "ideas",
          "partial": "Class",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:spanClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "string",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-XML.html#string",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "string",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "styleA",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#styleA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "styleA",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:styleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst argument indicates whether the table has a header or not\n\u003c/p\u003e",
          "module": "Ideas.Text.HTML",
          "name": "table",
          "package": "ideas",
          "signature": "Bool -\u003e [[a]] -\u003e a",
          "source": "src/Ideas-Text-HTML.html#table",
          "type": "function"
        },
        "index": {
          "description": "First argument indicates whether the table has header or not",
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "table",
          "normalized": "Bool-\u003e[[a]]-\u003ea",
          "package": "ideas",
          "signature": "Bool-\u003e[[a]]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "text",
          "package": "ideas",
          "signature": "s -\u003e a",
          "source": "src/Ideas-Text-XML.html#text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "text",
          "normalized": "a-\u003eb",
          "package": "ideas",
          "signature": "s-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "titleA",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#titleA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "titleA",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:titleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRenders as teletype or monospaced Ideas.Text.\n\u003c/p\u003e",
          "module": "Ideas.Text.HTML",
          "name": "tt",
          "package": "ideas",
          "signature": "a -\u003e a",
          "source": "src/Ideas-Text-HTML.html#tt",
          "type": "function"
        },
        "index": {
          "description": "Renders as teletype or monospaced Ideas.Text",
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "tt",
          "normalized": "a-\u003ea",
          "package": "ideas",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:tt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "ttText",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-HTML.html#ttText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "ttText",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "partial": "Text",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:ttText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.HTML",
          "name": "ul",
          "package": "ideas",
          "signature": "[a] -\u003e a",
          "source": "src/Ideas-Text-HTML.html#ul",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text HTML",
          "module": "Ideas.Text.HTML",
          "name": "ul",
          "normalized": "[a]-\u003ea",
          "package": "ideas",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-HTML.html#v:ul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for JavaScript Object Notation (JSON) and remote procedure calls using\n JSON. JSON is a lightweight alternative for XML.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.JSON",
          "name": "JSON",
          "package": "ideas",
          "source": "src/Ideas-Text-JSON.html",
          "type": "module"
        },
        "index": {
          "description": "Support for JavaScript Object Notation JSON and remote procedure calls using JSON JSON is lightweight alternative for XML",
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "JSON",
          "package": "ideas",
          "partial": "JSON",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "InJSON",
          "package": "ideas",
          "source": "src/Ideas-Text-JSON.html#InJSON",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "InJSON",
          "package": "ideas",
          "partial": "In JSON",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#t:InJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "JSON",
          "package": "ideas",
          "source": "src/Ideas-Text-JSON.html#JSON",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "JSON",
          "package": "ideas",
          "partial": "JSON",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#t:JSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "Key",
          "package": "ideas",
          "source": "src/Ideas-Text-JSON.html#Key",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "Key",
          "package": "ideas",
          "partial": "Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "Number",
          "package": "ideas",
          "source": "src/Ideas-Text-JSON.html#Number",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "Number",
          "package": "ideas",
          "partial": "Number",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#t:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "RPCHandler",
          "package": "ideas",
          "source": "src/Ideas-Text-JSON.html#RPCHandler",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "RPCHandler",
          "package": "ideas",
          "partial": "RPCHandler",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#t:RPCHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "Array",
          "package": "ideas",
          "signature": "Array [JSON]",
          "source": "src/Ideas-Text-JSON.html#JSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "Array",
          "normalized": "Array[JSON]",
          "package": "ideas",
          "partial": "Array",
          "signature": "Array[JSON]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "Boolean",
          "package": "ideas",
          "signature": "Boolean Bool",
          "source": "src/Ideas-Text-JSON.html#JSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "Boolean",
          "package": "ideas",
          "partial": "Boolean",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:Boolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "D",
          "package": "ideas",
          "signature": "D Double",
          "source": "src/Ideas-Text-JSON.html#Number",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "D",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "I",
          "package": "ideas",
          "signature": "I Integer",
          "source": "src/Ideas-Text-JSON.html#Number",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "I",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "Null",
          "package": "ideas",
          "signature": "Null",
          "source": "src/Ideas-Text-JSON.html#JSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "Null",
          "package": "ideas",
          "partial": "Null",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:Null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "Number",
          "package": "ideas",
          "signature": "Number Number",
          "source": "src/Ideas-Text-JSON.html#JSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "Number",
          "package": "ideas",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "Object",
          "package": "ideas",
          "signature": "Object [(Key, JSON)]",
          "source": "src/Ideas-Text-JSON.html#JSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "Object",
          "normalized": "Object[(Key,JSON)]",
          "package": "ideas",
          "partial": "Object",
          "signature": "Object[(Key,JSON)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:Object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "String",
          "package": "ideas",
          "signature": "String String",
          "source": "src/Ideas-Text-JSON.html#JSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "String",
          "package": "ideas",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "fromJSON",
          "package": "ideas",
          "signature": "JSON -\u003e m a",
          "source": "src/Ideas-Text-JSON.html#fromJSON",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "fromJSON",
          "normalized": "JSON-\u003ea b",
          "package": "ideas",
          "partial": "JSON",
          "signature": "JSON-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:fromJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "jsonRPC",
          "package": "ideas",
          "signature": "JSON -\u003e RPCHandler m -\u003e m RPCResponse",
          "source": "src/Ideas-Text-JSON.html#jsonRPC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "jsonRPC",
          "normalized": "JSON-\u003eRPCHandler a-\u003ea RPCResponse",
          "package": "ideas",
          "partial": "RPC",
          "signature": "JSON-\u003eRPCHandler m-\u003em RPCResponse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:jsonRPC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "listFromJSON",
          "package": "ideas",
          "signature": "JSON -\u003e m [a]",
          "source": "src/Ideas-Text-JSON.html#listFromJSON",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "listFromJSON",
          "normalized": "JSON-\u003ea[b]",
          "package": "ideas",
          "partial": "From JSON",
          "signature": "JSON-\u003em[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:listFromJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "listToJSON",
          "package": "ideas",
          "signature": "[a] -\u003e JSON",
          "source": "src/Ideas-Text-JSON.html#listToJSON",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "listToJSON",
          "normalized": "[a]-\u003eJSON",
          "package": "ideas",
          "partial": "To JSON",
          "signature": "[a]-\u003eJSON",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:listToJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "lookupM",
          "package": "ideas",
          "signature": "String -\u003e JSON -\u003e m JSON",
          "source": "src/Ideas-Text-JSON.html#lookupM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "lookupM",
          "normalized": "String-\u003eJSON-\u003ea JSON",
          "package": "ideas",
          "signature": "String-\u003eJSON-\u003em JSON",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:lookupM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "parseJSON",
          "package": "ideas",
          "signature": "String -\u003e Either String JSON",
          "source": "src/Ideas-Text-JSON.html#parseJSON",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "parseJSON",
          "normalized": "String-\u003eEither String JSON",
          "package": "ideas",
          "partial": "JSON",
          "signature": "String-\u003eEither String JSON",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:parseJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "propEncoding",
          "package": "ideas",
          "signature": "Property",
          "source": "src/Ideas-Text-JSON.html#propEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "propEncoding",
          "package": "ideas",
          "partial": "Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:propEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "showCompact",
          "package": "ideas",
          "signature": "JSON -\u003e String",
          "source": "src/Ideas-Text-JSON.html#showCompact",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "showCompact",
          "normalized": "JSON-\u003eString",
          "package": "ideas",
          "partial": "Compact",
          "signature": "JSON-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:showCompact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "showPretty",
          "package": "ideas",
          "signature": "JSON -\u003e String",
          "source": "src/Ideas-Text-JSON.html#showPretty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "showPretty",
          "normalized": "JSON-\u003eString",
          "package": "ideas",
          "partial": "Pretty",
          "signature": "JSON-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:showPretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.JSON",
          "name": "toJSON",
          "package": "ideas",
          "signature": "a -\u003e JSON",
          "source": "src/Ideas-Text-JSON.html#toJSON",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text JSON",
          "module": "Ideas.Text.JSON",
          "name": "toJSON",
          "normalized": "a-\u003eJSON",
          "package": "ideas",
          "partial": "JSON",
          "signature": "a-\u003eJSON",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-JSON.html#v:toJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "Arith1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "Arith1",
          "package": "ideas",
          "partial": "Arith",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA unary operator which represents the absolute value of its argument. The\nargument should be numerically valued. In the complex case this is often\nreferred to as the modulus. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "absSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#absSymbol",
          "type": "function"
        },
        "index": {
          "description": "unary operator which represents the absolute value of its argument The argument should be numerically valued In the complex case this is often referred to as the modulus",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "absSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:absSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in arith1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "arith1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#arith1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in arith1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "arith1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:arith1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents a (binary) division function denoting the first\nargument right-divided by the second, i.e. divide(a,b)=a*inverse(b). It is the\ninverse of the multiplication function defined by the symbol times in this CD.\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "divideSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#divideSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents binary division function denoting the first argument right-divided by the second i.e divide inverse It is the inverse of the multiplication function defined by the symbol times in this CD",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "divideSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:divideSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe symbol to represent the n-ary function to return the gcd (greatest\ncommon divisor) of its arguments. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "gcdSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#gcdSymbol",
          "type": "function"
        },
        "index": {
          "description": "The symbol to represent the n-ary function to return the gcd greatest common divisor of its arguments",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "gcdSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:gcdSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe symbol to represent the n-ary function to return the least common\nmultiple of its arguments. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "lcmSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#lcmSymbol",
          "type": "function"
        },
        "index": {
          "description": "The symbol to represent the n-ary function to return the least common multiple of its arguments",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "lcmSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:lcmSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe symbol representing a binary minus function. This is equivalent to\nadding the additive inverse. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "minusSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#minusSymbol",
          "type": "function"
        },
        "index": {
          "description": "The symbol representing binary minus function This is equivalent to adding the additive inverse",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "minusSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:minusSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe symbol representing an n-ary commutative function plus. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "plusSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#plusSymbol",
          "type": "function"
        },
        "index": {
          "description": "The symbol representing an n-ary commutative function plus",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "plusSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:plusSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents a power function. The first argument is raised to\nthe power of the second argument. When the second argument is not an integer,\npowering is defined in terms of exponentials and logarithms for the complex\nand real numbers. This operator can represent general powering. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "powerSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#powerSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents power function The first argument is raised to the power of the second argument When the second argument is not an integer powering is defined in terms of exponentials and logarithms for the complex and real numbers This operator can represent general powering",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "powerSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:powerSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn operator taking two arguments, the first being the range of\nmultiplication e.g. an integral interval, the second being the function to be\nmultiplied. Note that the product may be over an infinite interval. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "productSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#productSymbol",
          "type": "function"
        },
        "index": {
          "description": "An operator taking two arguments the first being the range of multiplication e.g an integral interval the second being the function to be multiplied Note that the product may be over an infinite interval",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "productSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:productSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binary operator which represents its first argument \u003ca\u003elowered\u003c/a\u003e to its\nn'th root where n is the second argument. This is the inverse of the operation\nrepresented by the power symbol defined in this CD. Care should be taken as to\nthe precise meaning of this operator, in particular which root is represented,\nhowever it is here to represent the general notion of taking n'th roots. As\ninferred by the signature relevant to this symbol, the function represented by\nthis symbol is the single valued function, the specific root returned is the\none indicated by the first CMP. Note also that the converse of the second CMP\nis not valid in general. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "rootSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#rootSymbol",
          "type": "function"
        },
        "index": {
          "description": "binary operator which represents its first argument lowered to its th root where is the second argument This is the inverse of the operation represented by the power symbol defined in this CD Care should be taken as to the precise meaning of this operator in particular which root is represented however it is here to represent the general notion of taking th roots As inferred by the signature relevant to this symbol the function represented by this symbol is the single valued function the specific root returned is the one indicated by the first CMP Note also that the converse of the second CMP is not valid in general",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "rootSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:rootSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn operator taking two arguments, the first being the range of summation,\ne.g. an integral interval, the second being the function to be summed. Note\nthat the sum may be over an infinite interval. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "sumSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#sumSymbol",
          "type": "function"
        },
        "index": {
          "description": "An operator taking two arguments the first being the range of summation e.g an integral interval the second being the function to be summed Note that the sum may be over an infinite interval",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "sumSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:sumSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe symbol representing an n-ary multiplication function. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "timesSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#timesSymbol",
          "type": "function"
        },
        "index": {
          "description": "The symbol representing an n-ary multiplication function",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "timesSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:timesSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol denotes unary minus, i.e. the additive inverse. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "unaryMinusSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Arith1.html#unaryMinusSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol denotes unary minus i.e the additive inverse",
          "hierarchy": "Ideas Text OpenMath Dictionary Arith1",
          "module": "Ideas.Text.OpenMath.Dictionary.Arith1",
          "name": "unaryMinusSymbol",
          "package": "ideas",
          "partial": "Minus Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Arith1.html#v:unaryMinusSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "Calculus1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Calculus1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Calculus1",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "Calculus1",
          "package": "ideas",
          "partial": "Calculus",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Calculus1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in calculus1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "calculus1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Calculus1.html#calculus1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in calculus1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Calculus1",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "calculus1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Calculus1.html#v:calculus1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to represent definite integration of unary functions.\nIt takes two arguments; the first being the range (e.g. a set) of integration,\nand the second the function. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "defintSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Calculus1.html#defintSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to represent definite integration of unary functions It takes two arguments the first being the range e.g set of integration and the second the function",
          "hierarchy": "Ideas Text OpenMath Dictionary Calculus1",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "defintSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Calculus1.html#v:defintSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to express ordinary differentiation of a unary\nfunction. The single argument is the unary function. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "diffSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Calculus1.html#diffSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to express ordinary differentiation of unary function The single argument is the unary function",
          "hierarchy": "Ideas Text OpenMath Dictionary Calculus1",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "diffSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Calculus1.html#v:diffSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to represent indefinite integration of unary\nfunctions. The argument is the unary function. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "intSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Calculus1.html#intSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to represent indefinite integration of unary functions The argument is the unary function",
          "hierarchy": "Ideas Text OpenMath Dictionary Calculus1",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "intSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Calculus1.html#v:intSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to express the nth-iterated ordinary differentiation\nof a unary function. The first argument is n, and the second the unary\nfunction. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "nthdiffSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Calculus1.html#nthdiffSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to express the nth-iterated ordinary differentiation of unary function The first argument is and the second the unary function",
          "hierarchy": "Ideas Text OpenMath Dictionary Calculus1",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "nthdiffSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Calculus1.html#v:nthdiffSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to express partial differentiation of a function of\nmore than one variable. It has two arguments, the first is a list of integers\nwhich index the variables of the function, the second is the function. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "partialdiffSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Calculus1.html#partialdiffSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to express partial differentiation of function of more than one variable It has two arguments the first is list of integers which index the variables of the function the second is the function",
          "hierarchy": "Ideas Text OpenMath Dictionary Calculus1",
          "module": "Ideas.Text.OpenMath.Dictionary.Calculus1",
          "name": "partialdiffSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Calculus1.html#v:partialdiffSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "Fns1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "Fns1",
          "package": "ideas",
          "partial": "Fns",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol denotes the domain of a given function, which is the set of\nvalues it is defined over. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "domainSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#domainSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol denotes the domain of given function which is the set of values it is defined over",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "domainSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:domainSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe domainofapplication element denotes the domain over which a given\nfunction is being applied. It is intended in MathML to be a more general\nalternative to specification of this domain using such quantifier elements as\nbvar, lowlimit or condition. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "domainofapplicationSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#domainofapplicationSymbol",
          "type": "function"
        },
        "index": {
          "description": "The domainofapplication element denotes the domain over which given function is being applied It is intended in MathML to be more general alternative to specification of this domain using such quantifier elements as bvar lowlimit or condition",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "domainofapplicationSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:domainofapplicationSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in fns1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "fns1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#fns1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in fns1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "fns1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:fns1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity function, it takes one argument and returns the same value.\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "identitySymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#identitySymbol",
          "type": "function"
        },
        "index": {
          "description": "The identity function it takes one argument and returns the same value",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "identitySymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:identitySymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol denotes the image of a given function, which is the set of\nvalues the domain of the given function maps to. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "imageSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#imageSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol denotes the image of given function which is the set of values the domain of the given function maps to",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "imageSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:imageSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to describe the inverse of its argument (a function).\nThis inverse may only be partially defined because the function may not have\nbeen surjective. If the function is not surjective the inverse function is\nill-defined without further stipulations. No assumptions are made on the\nsemantics of this inverse. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "inverseSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#inverseSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to describe the inverse of its argument function This inverse may only be partially defined because the function may not have been surjective If the function is not surjective the inverse function is ill-defined without further stipulations No assumptions are made on the semantics of this inverse",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "inverseSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:inverseSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to represent anonymous functions as lambda expansions.\nIt is used in a binder that takes two further arguments, the first of which is\na list of variables, and the second of which is an expression, and it forms\nthe function which is the lambda extraction of the expression \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "lambdaSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#lambdaSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to represent anonymous functions as lambda expansions It is used in binder that takes two further arguments the first of which is list of variables and the second of which is an expression and it forms the function which is the lambda extraction of the expression",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "lambdaSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:lambdaSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the function which forms the left-composition of\nits two (function) arguments. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "leftComposeSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#leftComposeSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the function which forms the left-composition of its two function arguments",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "leftComposeSymbol",
          "package": "ideas",
          "partial": "Compose Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:leftComposeSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to describe the left inverse of its argument (a\nfunction). This inverse may only be partially defined because the function may\nnot have been surjective. If the function is not surjective the left inverse\nfunction is ill-defined without further stipulations. No other assumptions are\nmade on the semantics of this left inverse. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "leftInverseSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#leftInverseSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to describe the left inverse of its argument function This inverse may only be partially defined because the function may not have been surjective If the function is not surjective the left inverse function is ill-defined without further stipulations No other assumptions are made on the semantics of this left inverse",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "leftInverseSymbol",
          "package": "ideas",
          "partial": "Inverse Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:leftInverseSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol denotes the range of a function, that is a set that the\nfunction will map to. The single argument should be the function whos range is\nbeing queried. It should be noted that this is not necessarily equal to the\nimage, it is merely required to contain the image. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "rangeSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#rangeSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol denotes the range of function that is set that the function will map to The single argument should be the function whos range is being queried It should be noted that this is not necessarily equal to the image it is merely required to contain the image",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "rangeSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:rangeSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to describe the right inverse of its argument (a\nfunction). This inverse may only be partially defined because the function may\nnot have been surjective. If the function is not surjective the right inverse\nfunction is ill-defined without further stipulations. No other assumptions are\nmade on the semantics of this right inverse. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "rightInverseSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Fns1.html#rightInverseSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to describe the right inverse of its argument function This inverse may only be partially defined because the function may not have been surjective If the function is not surjective the right inverse function is ill-defined without further stipulations No other assumptions are made on the semantics of this right inverse",
          "hierarchy": "Ideas Text OpenMath Dictionary Fns1",
          "module": "Ideas.Text.OpenMath.Dictionary.Fns1",
          "name": "rightInverseSymbol",
          "package": "ideas",
          "partial": "Inverse Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Fns1.html#v:rightInverseSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "Linalg2",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Linalg2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Linalg2",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "Linalg2",
          "package": "ideas",
          "partial": "Linalg",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Linalg2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in linalg2 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "linalg2List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Linalg2.html#linalg2List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in linalg2 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Linalg2",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "linalg2List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Linalg2.html#v:linalg2List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is an n-ary matrix constructor which requires matrixrow's as\narguments. It is used to represent matrices. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "matrixSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Linalg2.html#matrixSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is an n-ary matrix constructor which requires matrixrow as arguments It is used to represent matrices",
          "hierarchy": "Ideas Text OpenMath Dictionary Linalg2",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "matrixSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Linalg2.html#v:matrixSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is an n-ary constructor used to represent rows of matrices.\nIts arguments should be members of a ring. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "matrixrowSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Linalg2.html#matrixrowSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is an n-ary constructor used to represent rows of matrices Its arguments should be members of ring",
          "hierarchy": "Ideas Text OpenMath Dictionary Linalg2",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "matrixrowSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Linalg2.html#v:matrixrowSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents an n-ary function used to construct (or describe)\nvectors. Vectors in this CD are considered to be row vectors and must\ntherefore be transposed to be considered as column vectors. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "vectorSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Linalg2.html#vectorSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents an n-ary function used to construct or describe vectors Vectors in this CD are considered to be row vectors and must therefore be transposed to be considered as column vectors",
          "hierarchy": "Ideas Text OpenMath Dictionary Linalg2",
          "module": "Ideas.Text.OpenMath.Dictionary.Linalg2",
          "name": "vectorSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Linalg2.html#v:vectorSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "List1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-List1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary List1",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "List1",
          "package": "ideas",
          "partial": "List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-List1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in list1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "list1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-List1.html#list1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in list1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary List1",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "list1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-List1.html#v:list1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol denotes the list construct which is an n-ary function. The\nlist entries must be given explicitly. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "listSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-List1.html#listSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol denotes the list construct which is an n-ary function The list entries must be given explicitly",
          "hierarchy": "Ideas Text OpenMath Dictionary List1",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "listSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-List1.html#v:listSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents a mapping function which may be used to construct\nlists, it takes as arguments a function from X to Y and a list over X in that\norder. The value that is returned is a list of values in Y. The argument list\nmay be a set or an integer_interval. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "mapSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-List1.html#mapSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents mapping function which may be used to construct lists it takes as arguments function from to and list over in that order The value that is returned is list of values in The argument list may be set or an integer interval",
          "hierarchy": "Ideas Text OpenMath Dictionary List1",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "mapSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-List1.html#v:mapSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the suchthat function which may be used to\nconstruct lists, it takes two arguments. The first argument should be the set\nwhich contains the elements of the list, the second argument should be a\npredicate, that is a function from the set to the booleans which describes if\nan element is to be in the list returned. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "suchthatSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-List1.html#suchthatSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the suchthat function which may be used to construct lists it takes two arguments The first argument should be the set which contains the elements of the list the second argument should be predicate that is function from the set to the booleans which describes if an element is to be in the list returned",
          "hierarchy": "Ideas Text OpenMath Dictionary List1",
          "module": "Ideas.Text.OpenMath.Dictionary.List1",
          "name": "suchthatSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-List1.html#v:suchthatSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "Logic1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "Logic1",
          "package": "ideas",
          "partial": "Logic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the logical and function which is an n-ary function\ntaking boolean arguments and returning a boolean value. It is true if all\narguments are true or false otherwise. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "andSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#andSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the logical and function which is an n-ary function taking boolean arguments and returning boolean value It is true if all arguments are true or false otherwise",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "andSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:andSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to show that two boolean expressions are logically\nequivalent, that is have the same boolean value for any inputs. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "equivalentSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#equivalentSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to show that two boolean expressions are logically equivalent that is have the same boolean value for any inputs",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "equivalentSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:equivalentSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the boolean value false. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "falseSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#falseSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the boolean value false",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "falseSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:falseSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the logical implies function which takes two\nboolean expressions as arguments. It evaluates to false if the first argument\nis true and the second argument is false, otherwise it evaluates to true. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "impliesSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#impliesSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the logical implies function which takes two boolean expressions as arguments It evaluates to false if the first argument is true and the second argument is false otherwise it evaluates to true",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "impliesSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:impliesSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in logic1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "logic1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#logic1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in logic1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "logic1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:logic1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the logical not function which takes one boolean\nargument, and returns the opposite boolean value. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "notSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#notSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the logical not function which takes one boolean argument and returns the opposite boolean value",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "notSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:notSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the logical or function which is an n-ary function\ntaking boolean arguments and returning a boolean value. It is true if any of\nthe arguments are true or false otherwise. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "orSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#orSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the logical or function which is an n-ary function taking boolean arguments and returning boolean value It is true if any of the arguments are true or false otherwise",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "orSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:orSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the boolean value true. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "trueSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#trueSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the boolean value true",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "trueSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:trueSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the logical xor function which is an n-ary function\ntaking boolean arguments and returning a boolean value. It is true if there\nare an odd number of true arguments or false otherwise. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "xorSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Logic1.html#xorSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the logical xor function which is an n-ary function taking boolean arguments and returning boolean value It is true if there are an odd number of true arguments or false otherwise",
          "hierarchy": "Ideas Text OpenMath Dictionary Logic1",
          "module": "Ideas.Text.OpenMath.Dictionary.Logic1",
          "name": "xorSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Logic1.html#v:xorSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "Nums1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "Nums1",
          "package": "ideas",
          "partial": "Nums",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the constructor function for integers, specifying\nthe base. It takes two arguments, the first is a positive integer to denote\nthe base to which the number is represented, the second argument is a string\nwhich contains an optional sign and the digits of the integer, using 0-9a-z\n(as a consequence of this no radix greater than 35 is supported). Base 16 and\nbase 10 are already covered in the encodings of integers. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "basedIntegerSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#basedIntegerSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the constructor function for integers specifying the base It takes two arguments the first is positive integer to denote the base to which the number is represented the second argument is string which contains an optional sign and the digits of the integer using a-z as consequence of this no radix greater than is supported Base and base are already covered in the encodings of integers",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "basedIntegerSymbol",
          "package": "ideas",
          "partial": "Integer Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:basedIntegerSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the base of the natural logarithm, approximately\n2.718. See Abramowitz and Stegun, Handbook of Mathematical Functions, section\n4.1. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "eSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#eSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the base of the natural logarithm approximately See Abramowitz and Stegun Handbook of Mathematical Functions section",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "eSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:eSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA symbol to convey the notion of the gamma constant as defined in\nAbramowitz and Stegun, Handbook of Mathematical Functions, section 6.1.3. It\nis the limit of 1 + 1\u003cem\u003e2 + 1\u003c/em\u003e3 + ... + 1/m - ln m as m tends to infinity, this\nis approximately 0.5772 15664. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "gammaSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#gammaSymbol",
          "type": "function"
        },
        "index": {
          "description": "symbol to convey the notion of the gamma constant as defined in Abramowitz and Stegun Handbook of Mathematical Functions section It is the limit of ln as tends to infinity this is approximately",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "gammaSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:gammaSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the square root of -1. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "iSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#iSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the square root of",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "iSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:iSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA symbol to represent the notion of infinity. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "infinitySymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#infinitySymbol",
          "type": "function"
        },
        "index": {
          "description": "symbol to represent the notion of infinity",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "infinitySymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:infinitySymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA symbol to convey the notion of not-a-number. The result of an ill-posed\nfloating computation. See IEEE standard for floating point representations. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "naNSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#naNSymbol",
          "type": "function"
        },
        "index": {
          "description": "symbol to convey the notion of not-a-number The result of an ill-posed floating computation See IEEE standard for floating point representations",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "naNSymbol",
          "package": "ideas",
          "partial": "NSymbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:naNSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in nums1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "nums1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#nums1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in nums1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "nums1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:nums1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA symbol to convey the notion of pi, approximately 3.142. The ratio of the\ncircumference of a circle to its diameter. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "piSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#piSymbol",
          "type": "function"
        },
        "index": {
          "description": "symbol to convey the notion of pi approximately The ratio of the circumference of circle to its diameter",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "piSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:piSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the constructor function for rational numbers. It\ntakes two arguments, the first is an integer p to denote the numerator and the\nsecond a nonzero integer q to denote the denominator of the rational p/q. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "rationalSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Nums1.html#rationalSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the constructor function for rational numbers It takes two arguments the first is an integer to denote the numerator and the second nonzero integer to denote the denominator of the rational",
          "hierarchy": "Ideas Text OpenMath Dictionary Nums1",
          "module": "Ideas.Text.OpenMath.Dictionary.Nums1",
          "name": "rationalSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Nums1.html#v:rationalSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "Quant1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Quant1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Quant1",
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "Quant1",
          "package": "ideas",
          "partial": "Quant",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Quant1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the existential (\u003ca\u003ethere exists\u003c/a\u003e) quantifier which\ntakes two arguments. It must be placed within an OMBIND element. The first\nargument is the bound variables (placed within an OMBVAR element), and the\nsecond is an expression. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "existsSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Quant1.html#existsSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the existential there exists quantifier which takes two arguments It must be placed within an OMBIND element The first argument is the bound variables placed within an OMBVAR element and the second is an expression",
          "hierarchy": "Ideas Text OpenMath Dictionary Quant1",
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "existsSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Quant1.html#v:existsSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the universal (\u003ca\u003efor all\u003c/a\u003e) quantifier which takes\ntwo arguments. It must be placed within an OMBIND element. The first argument\nis the bound variables (placed within an OMBVAR element), and the second is an\nexpression. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "forallSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Quant1.html#forallSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the universal for all quantifier which takes two arguments It must be placed within an OMBIND element The first argument is the bound variables placed within an OMBVAR element and the second is an expression",
          "hierarchy": "Ideas Text OpenMath Dictionary Quant1",
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "forallSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Quant1.html#v:forallSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in quant1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "quant1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Quant1.html#quant1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in quant1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Quant1",
          "module": "Ideas.Text.OpenMath.Dictionary.Quant1",
          "name": "quant1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Quant1.html#v:quant1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "Relation1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "Relation1",
          "package": "ideas",
          "partial": "Relation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol is used to denote the approximate equality of its two\narguments. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "approxSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#approxSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol is used to denote the approximate equality of its two arguments",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "approxSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:approxSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the binary equality function. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "eqSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#eqSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the binary equality function",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "eqSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:eqSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the binary greater than or equal to function which\nreturns true if the first argument is greater than or equal to the second, it\nreturns false otherwise. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "geqSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#geqSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the binary greater than or equal to function which returns true if the first argument is greater than or equal to the second it returns false otherwise",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "geqSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:geqSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the binary greater than function which returns true\nif the first argument is greater than the second, it returns false otherwise.\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "gtSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#gtSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the binary greater than function which returns true if the first argument is greater than the second it returns false otherwise",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "gtSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:gtSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the binary less than or equal to function which\nreturns true if the first argument is less than or equal to the second, it\nreturns false otherwise. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "leqSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#leqSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the binary less than or equal to function which returns true if the first argument is less than or equal to the second it returns false otherwise",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "leqSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:leqSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the binary less than function which returns true if\nthe first argument is less than the second, it returns false otherwise. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "ltSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#ltSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the binary less than function which returns true if the first argument is less than the second it returns false otherwise",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "ltSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:ltSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the binary inequality function. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "neqSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#neqSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the binary inequality function",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "neqSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:neqSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in relation1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "relation1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Relation1.html#relation1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in relation1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Relation1",
          "module": "Ideas.Text.OpenMath.Dictionary.Relation1",
          "name": "relation1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Relation1.html#v:relation1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "Transc1",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "Transc1",
          "package": "ideas",
          "partial": "Transc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arccos function. This is the inverse of the cos\nfunction as described in Abramowitz and Stegun, section 4.4. It takes one\nargument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccosSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arccosSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arccos function This is the inverse of the cos function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccosSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arccosSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arccosh function as described in Abramowitz and\nStegun, section 4.6. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccoshSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arccoshSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arccosh function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccoshSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arccoshSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arccot function as described in Abramowitz and\nStegun, section 4.4. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccotSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arccotSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arccot function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccotSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arccotSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arccoth function as described in Abramowitz and\nStegun, section 4.6. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccothSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arccothSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arccoth function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccothSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arccothSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arccsc function as described in Abramowitz and\nStegun, section 4.4. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccscSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arccscSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arccsc function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccscSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arccscSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arccsch function as described in Abramowitz and\nStegun, section 4.6. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccschSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arccschSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arccsch function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arccschSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arccschSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arcsec function as described in Abramowitz and\nStegun, section 4.4. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsecSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arcsecSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arcsec function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsecSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arcsecSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arcsech function as described in Abramowitz and\nStegun, section 4.6. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsechSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arcsechSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arcsech function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsechSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arcsechSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arcsin function. This is the inverse of the sin\nfunction as described in Abramowitz and Stegun, section 4.4. It takes one\nargument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsinSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arcsinSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arcsin function This is the inverse of the sin function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsinSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arcsinSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arcsinh function as described in Abramowitz and\nStegun, section 4.6. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsinhSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arcsinhSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arcsinh function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arcsinhSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arcsinhSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arctan function. This is the inverse of the tan\nfunction as described in Abramowitz and Stegun, section 4.4. It takes one\nargument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arctanSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arctanSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arctan function This is the inverse of the tan function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arctanSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arctanSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the arctanh function as described in Abramowitz and\nStegun, section 4.6. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arctanhSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#arctanhSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the arctanh function as described in Abramowitz and Stegun section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "arctanhSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:arctanhSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the cos function as described in Abramowitz and\nStegun, section 4.3. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cosSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#cosSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the cos function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cosSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:cosSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the cosh function as described in Abramowitz and\nStegun, section 4.5. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "coshSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#coshSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the cosh function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "coshSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:coshSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the cot function as described in Abramowitz and\nStegun, section 4.3. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cotSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#cotSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the cot function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cotSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:cotSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the coth function as described in Abramowitz and\nStegun, section 4.5. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cothSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#cothSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the coth function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cothSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:cothSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the csc function as described in Abramowitz and\nStegun, section 4.3. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cscSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#cscSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the csc function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cscSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:cscSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the csch function as described in Abramowitz and\nStegun, section 4.5. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cschSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#cschSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the csch function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "cschSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:cschSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the exponentiation function as described in\nAbramowitz and Stegun, section 4.2. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "expSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#expSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the exponentiation function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "expSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:expSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the ln function (natural logarithm) as described in\nAbramowitz and Stegun, section 4.1. It takes one argument. Note the\ndescription in the CMP/FMP of the branch cut. If signed zeros are in use, the\ninequality needs to be non-strict. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "lnSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#lnSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the ln function natural logarithm as described in Abramowitz and Stegun section It takes one argument Note the description in the CMP FMP of the branch cut If signed zeros are in use the inequality needs to be non-strict",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "lnSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:lnSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents a binary log function; the first argument is the\nbase, to which the second argument is log'ed. It is defined in Abramowitz and\nStegun, Handbook of Mathematical Functions, section 4.1 \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "logSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#logSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents binary log function the first argument is the base to which the second argument is log ed It is defined in Abramowitz and Stegun Handbook of Mathematical Functions section",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "logSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:logSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the sec function as described in Abramowitz and\nStegun, section 4.3. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "secSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#secSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the sec function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "secSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:secSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the sech function as described in Abramowitz and\nStegun, section 4.5. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "sechSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#sechSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the sech function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "sechSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:sechSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the sin function as described in Abramowitz and\nStegun, section 4.3. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "sinSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#sinSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the sin function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "sinSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:sinSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the sinh function as described in Abramowitz and\nStegun, section 4.5. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "sinhSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#sinhSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the sinh function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "sinhSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:sinhSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the tan function as described in Abramowitz and\nStegun, section 4.3. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "tanSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#tanSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the tan function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "tanSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:tanSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis symbol represents the tanh function as described in Abramowitz and\nStegun, section 4.5. It takes one argument. \n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "tanhSymbol",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#tanhSymbol",
          "type": "function"
        },
        "index": {
          "description": "This symbol represents the tanh function as described in Abramowitz and Stegun section It takes one argument",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "tanhSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:tanhSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of symbols defined in transc1 dictionary\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "transc1List",
          "package": "ideas",
          "signature": "[Symbol]",
          "source": "src/Ideas-Text-OpenMath-Dictionary-Transc1.html#transc1List",
          "type": "function"
        },
        "index": {
          "description": "List of symbols defined in transc1 dictionary",
          "hierarchy": "Ideas Text OpenMath Dictionary Transc1",
          "module": "Ideas.Text.OpenMath.Dictionary.Transc1",
          "name": "transc1List",
          "normalized": "[Symbol]",
          "package": "ideas",
          "partial": "List",
          "signature": "[Symbol]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Dictionary-Transc1.html#v:transc1List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFormal mathematical properties (FMP)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "FMP",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-FMP.html",
          "type": "module"
        },
        "index": {
          "description": "Formal mathematical properties FMP",
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "FMP",
          "package": "ideas",
          "partial": "FMP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "FMP",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-FMP.html#FMP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "FMP",
          "package": "ideas",
          "partial": "FMP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#t:FMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "FMP",
          "package": "ideas",
          "signature": "FMP",
          "source": "src/Ideas-Text-OpenMath-FMP.html#FMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "FMP",
          "package": "ideas",
          "partial": "FMP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:FMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents a common misconception. In certain (most) situations,\n the two objects are not the same.\n\u003c/p\u003e",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "buggyFMP",
          "package": "ideas",
          "signature": "OMOBJ -\u003e OMOBJ -\u003e FMP",
          "source": "src/Ideas-Text-OpenMath-FMP.html#buggyFMP",
          "type": "function"
        },
        "index": {
          "description": "Represents common misconception In certain most situations the two objects are not the same",
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "buggyFMP",
          "normalized": "OMOBJ-\u003eOMOBJ-\u003eFMP",
          "package": "ideas",
          "partial": "FMP",
          "signature": "OMOBJ-\u003eOMOBJ-\u003eFMP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:buggyFMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "eqFMP",
          "package": "ideas",
          "signature": "OMOBJ -\u003e OMOBJ -\u003e FMP",
          "source": "src/Ideas-Text-OpenMath-FMP.html#eqFMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "eqFMP",
          "normalized": "OMOBJ-\u003eOMOBJ-\u003eFMP",
          "package": "ideas",
          "partial": "FMP",
          "signature": "OMOBJ-\u003eOMOBJ-\u003eFMP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:eqFMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "leftHandSide",
          "package": "ideas",
          "signature": "OMOBJ",
          "source": "src/Ideas-Text-OpenMath-FMP.html#FMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "leftHandSide",
          "package": "ideas",
          "partial": "Hand Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:leftHandSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "metaVariables",
          "package": "ideas",
          "signature": "[String]",
          "source": "src/Ideas-Text-OpenMath-FMP.html#FMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "metaVariables",
          "normalized": "[String]",
          "package": "ideas",
          "partial": "Variables",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:metaVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "quantor",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-FMP.html#FMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "quantor",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:quantor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "relation",
          "package": "ideas",
          "signature": "Symbol",
          "source": "src/Ideas-Text-OpenMath-FMP.html#FMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "relation",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:relation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "rightHandSide",
          "package": "ideas",
          "signature": "OMOBJ",
          "source": "src/Ideas-Text-OpenMath-FMP.html#FMP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "rightHandSide",
          "package": "ideas",
          "partial": "Hand Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:rightHandSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "toObject",
          "package": "ideas",
          "signature": "FMP -\u003e OMOBJ",
          "source": "src/Ideas-Text-OpenMath-FMP.html#toObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath FMP",
          "module": "Ideas.Text.OpenMath.FMP",
          "name": "toObject",
          "normalized": "FMP-\u003eOMOBJ",
          "package": "ideas",
          "partial": "Object",
          "signature": "FMP-\u003eOMOBJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-FMP.html#v:toObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "Object",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Object.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "Object",
          "package": "ideas",
          "partial": "Object",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMOBJ",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Object.html#OMOBJ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMOBJ",
          "package": "ideas",
          "partial": "OMOBJ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#t:OMOBJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMA",
          "package": "ideas",
          "signature": "OMA [OMOBJ]",
          "source": "src/Ideas-Text-OpenMath-Object.html#OMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMA",
          "normalized": "OMA[OMOBJ]",
          "package": "ideas",
          "partial": "OMA",
          "signature": "OMA[OMOBJ]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:OMA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMBIND",
          "package": "ideas",
          "signature": "OMBIND OMOBJ [String] OMOBJ",
          "source": "src/Ideas-Text-OpenMath-Object.html#OMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMBIND",
          "normalized": "OMBIND OMOBJ[String]OMOBJ",
          "package": "ideas",
          "partial": "OMBIND",
          "signature": "OMBIND OMOBJ[String]OMOBJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:OMBIND"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMF",
          "package": "ideas",
          "signature": "OMF Double",
          "source": "src/Ideas-Text-OpenMath-Object.html#OMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMF",
          "package": "ideas",
          "partial": "OMF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:OMF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMI",
          "package": "ideas",
          "signature": "OMI Integer",
          "source": "src/Ideas-Text-OpenMath-Object.html#OMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMI",
          "package": "ideas",
          "partial": "OMI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:OMI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMS",
          "package": "ideas",
          "signature": "OMS Symbol",
          "source": "src/Ideas-Text-OpenMath-Object.html#OMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMS",
          "package": "ideas",
          "partial": "OMS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:OMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMV",
          "package": "ideas",
          "signature": "OMV String",
          "source": "src/Ideas-Text-OpenMath-Object.html#OMOBJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "OMV",
          "package": "ideas",
          "partial": "OMV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:OMV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "getOMVs",
          "package": "ideas",
          "signature": "OMOBJ -\u003e [String]",
          "source": "src/Ideas-Text-OpenMath-Object.html#getOMVs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "getOMVs",
          "normalized": "OMOBJ-\u003e[String]",
          "package": "ideas",
          "partial": "OMVs",
          "signature": "OMOBJ-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:getOMVs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "omobj2xml",
          "package": "ideas",
          "signature": "OMOBJ -\u003e XML",
          "source": "src/Ideas-Text-OpenMath-Object.html#omobj2xml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "omobj2xml",
          "normalized": "OMOBJ-\u003eXML",
          "package": "ideas",
          "signature": "OMOBJ-\u003eXML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:omobj2xml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Object",
          "name": "xml2omobj",
          "package": "ideas",
          "signature": "XML -\u003e Either String OMOBJ",
          "source": "src/Ideas-Text-OpenMath-Object.html#xml2omobj",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Object",
          "module": "Ideas.Text.OpenMath.Object",
          "name": "xml2omobj",
          "normalized": "XML-\u003eEither String OMOBJ",
          "package": "ideas",
          "signature": "XML-\u003eEither String OMOBJ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Object.html#v:xml2omobj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "Symbol",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Symbol.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Symbol",
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "Symbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Symbol.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "Symbol",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Symbol.html#Symbol",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Symbol",
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "Symbol",
          "package": "ideas",
          "partial": "Symbol",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Symbol.html#t:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "dictionary",
          "package": "ideas",
          "signature": "Symbol -\u003e Maybe String",
          "source": "src/Ideas-Text-OpenMath-Symbol.html#dictionary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Symbol",
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "dictionary",
          "normalized": "Symbol-\u003eMaybe String",
          "package": "ideas",
          "signature": "Symbol-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Symbol.html#v:dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "extraSymbol",
          "package": "ideas",
          "signature": "String -\u003e Symbol",
          "source": "src/Ideas-Text-OpenMath-Symbol.html#extraSymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Symbol",
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "extraSymbol",
          "normalized": "String-\u003eSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "signature": "String-\u003eSymbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Symbol.html#v:extraSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "makeSymbol",
          "package": "ideas",
          "signature": "String -\u003e String -\u003e Symbol",
          "source": "src/Ideas-Text-OpenMath-Symbol.html#makeSymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Symbol",
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "makeSymbol",
          "normalized": "String-\u003eString-\u003eSymbol",
          "package": "ideas",
          "partial": "Symbol",
          "signature": "String-\u003eString-\u003eSymbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Symbol.html#v:makeSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "showSymbol",
          "package": "ideas",
          "signature": "Symbol -\u003e String",
          "source": "src/Ideas-Text-OpenMath-Symbol.html#showSymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Symbol",
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "showSymbol",
          "normalized": "Symbol-\u003eString",
          "package": "ideas",
          "partial": "Symbol",
          "signature": "Symbol-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Symbol.html#v:showSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "symbolName",
          "package": "ideas",
          "signature": "Symbol -\u003e String",
          "source": "src/Ideas-Text-OpenMath-Symbol.html#symbolName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Symbol",
          "module": "Ideas.Text.OpenMath.Symbol",
          "name": "symbolName",
          "normalized": "Symbol-\u003eString",
          "package": "ideas",
          "partial": "Name",
          "signature": "Symbol-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Symbol.html#v:symbolName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Tests",
          "name": "Tests",
          "package": "ideas",
          "source": "src/Ideas-Text-OpenMath-Tests.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Tests",
          "module": "Ideas.Text.OpenMath.Tests",
          "name": "Tests",
          "package": "ideas",
          "partial": "Tests",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Tests.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.OpenMath.Tests",
          "name": "propEncoding",
          "package": "ideas",
          "signature": "Property",
          "source": "src/Ideas-Text-OpenMath-Tests.html#propEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text OpenMath Tests",
          "module": "Ideas.Text.OpenMath.Tests",
          "name": "propEncoding",
          "package": "ideas",
          "partial": "Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-OpenMath-Tests.html#v:propEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtility functions for parsing with Parsec library\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.Parsing",
          "name": "Parsing",
          "package": "ideas",
          "source": "src/Ideas-Text-Parsing.html",
          "type": "module"
        },
        "index": {
          "description": "Utility functions for parsing with Parsec library",
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "Parsing",
          "package": "ideas",
          "partial": "Parsing",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "UnbalancedError",
          "package": "ideas",
          "source": "src/Ideas-Text-Parsing.html#UnbalancedError",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "UnbalancedError",
          "package": "ideas",
          "partial": "Unbalanced Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#t:UnbalancedError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence actions, discarding the value of the first argument.\n\u003c/p\u003e",
          "module": "Ideas.Text.Parsing",
          "name": "(*\u003e)",
          "package": "ideas",
          "signature": "forall a b.  f a -\u003e f b -\u003e f b",
          "type": "function"
        },
        "index": {
          "description": "Sequence actions discarding the value of the first argument",
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "(*\u003e) *\u003e",
          "normalized": "a b c d b-\u003ed e-\u003ed e",
          "package": "ideas",
          "signature": "forall a b. f a-\u003ef b-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace all locations in the input with the same value.\n The default definition is \u003ccode\u003e\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but this may be\n overridden with a more efficient version.\n\u003c/p\u003e",
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c$)",
          "package": "ideas",
          "signature": "forall a b.  a -\u003e f b -\u003e f a",
          "type": "function"
        },
        "index": {
          "description": "Replace all locations in the input with the same value The default definition is fmap const but this may be overridden with more efficient version",
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c$) \u003c$",
          "normalized": "a b c b-\u003ed e-\u003ed b",
          "package": "ideas",
          "signature": "forall a b. a-\u003ef b-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:-60--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence actions, discarding the value of the second argument.\n\u003c/p\u003e",
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c*)",
          "package": "ideas",
          "signature": "forall a b.  f a -\u003e f b -\u003e f a",
          "type": "function"
        },
        "index": {
          "description": "Sequence actions discarding the value of the second argument",
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c*) \u003c*",
          "normalized": "a b c d b-\u003ed e-\u003ed b",
          "package": "ideas",
          "signature": "forall a b. f a-\u003ef b-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:-60--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequential application.\n\u003c/p\u003e",
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c*\u003e)",
          "package": "ideas",
          "signature": "forall a b.  f (a -\u003e b) -\u003e f a -\u003e f b",
          "type": "function"
        },
        "index": {
          "description": "Sequential application",
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a b c d(b-\u003ee)-\u003ed b-\u003ed e",
          "package": "ideas",
          "signature": "forall a b. f(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c..\u003e)",
          "package": "ideas",
          "signature": "Char -\u003e Char -\u003e Parser Char",
          "source": "src/Ideas-Text-Parsing.html#%3C..%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "(\u003c..\u003e) \u003c..\u003e",
          "normalized": "Char-\u003eChar-\u003eParser Char",
          "package": "ideas",
          "signature": "Char-\u003eChar-\u003eParser Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:-60-..-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "NotClosed",
          "package": "ideas",
          "signature": "NotClosed SourcePos Char",
          "source": "src/Ideas-Text-Parsing.html#UnbalancedError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "NotClosed",
          "package": "ideas",
          "partial": "Not Closed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:NotClosed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "NotOpened",
          "package": "ideas",
          "signature": "NotOpened SourcePos Char",
          "source": "src/Ideas-Text-Parsing.html#UnbalancedError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "NotOpened",
          "package": "ideas",
          "partial": "Not Opened",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:NotOpened"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "balanced",
          "package": "ideas",
          "signature": "[(Char, Char)] -\u003e String -\u003e Maybe UnbalancedError",
          "source": "src/Ideas-Text-Parsing.html#balanced",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "balanced",
          "normalized": "[(Char,Char)]-\u003eString-\u003eMaybe UnbalancedError",
          "package": "ideas",
          "signature": "[(Char,Char)]-\u003eString-\u003eMaybe UnbalancedError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:balanced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "complete",
          "package": "ideas",
          "signature": "Parser a -\u003e Parser a",
          "source": "src/Ideas-Text-Parsing.html#complete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "complete",
          "normalized": "Parser a-\u003eParser a",
          "package": "ideas",
          "signature": "Parser a-\u003eParser a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:complete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "float",
          "package": "ideas",
          "signature": "Parser Double",
          "source": "src/Ideas-Text-Parsing.html#float",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "float",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "naturalOrFloat",
          "package": "ideas",
          "signature": "Parser (Either Integer Double)",
          "source": "src/Ideas-Text-Parsing.html#naturalOrFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "naturalOrFloat",
          "package": "ideas",
          "partial": "Or Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:naturalOrFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "parseSimple",
          "package": "ideas",
          "signature": "Parser a -\u003e String -\u003e Either String a",
          "source": "src/Ideas-Text-Parsing.html#parseSimple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "parseSimple",
          "normalized": "Parser a-\u003eString-\u003eEither String a",
          "package": "ideas",
          "partial": "Simple",
          "signature": "Parser a-\u003eString-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:parseSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "ranges",
          "package": "ideas",
          "signature": "[(Char, Char)] -\u003e Parser Char",
          "source": "src/Ideas-Text-Parsing.html#ranges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "ranges",
          "normalized": "[(Char,Char)]-\u003eParser Char",
          "package": "ideas",
          "signature": "[(Char,Char)]-\u003eParser Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:ranges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "skip",
          "package": "ideas",
          "signature": "Parser a -\u003e Parser ()",
          "source": "src/Ideas-Text-Parsing.html#skip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "skip",
          "normalized": "Parser a-\u003eParser()",
          "package": "ideas",
          "signature": "Parser a-\u003eParser()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:skip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.Parsing",
          "name": "stopOn",
          "package": "ideas",
          "signature": "[String] -\u003e Parser String",
          "source": "src/Ideas-Text-Parsing.html#stopOn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text Parsing",
          "module": "Ideas.Text.Parsing",
          "name": "stopOn",
          "normalized": "[String]-\u003eParser String",
          "package": "ideas",
          "partial": "On",
          "signature": "[String]-\u003eParser String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-Parsing.html#v:stopOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for the UTF8 encoding\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "UTF8",
          "package": "ideas",
          "source": "src/Ideas-Text-UTF8.html",
          "type": "module"
        },
        "index": {
          "description": "Support for the UTF8 encoding",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "UTF8",
          "package": "ideas",
          "partial": "UTF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether all characters are in the range 0-255\n\u003c/p\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "allBytes",
          "package": "ideas",
          "signature": "String -\u003e Bool",
          "source": "src/Ideas-Text-UTF8.html#allBytes",
          "type": "function"
        },
        "index": {
          "description": "Test whether all characters are in the range",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "allBytes",
          "normalized": "String-\u003eBool",
          "package": "ideas",
          "partial": "Bytes",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#v:allBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecode an UTF8 format string to unicode points\n\u003c/p\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "decode",
          "package": "ideas",
          "signature": "String -\u003e String",
          "source": "src/Ideas-Text-UTF8.html#decode",
          "type": "function"
        },
        "index": {
          "description": "Decode an UTF8 format string to unicode points",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "decode",
          "normalized": "String-\u003eString",
          "package": "ideas",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecode an UTF8 format string to unicode points (monadic)\n\u003c/p\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "decodeM",
          "package": "ideas",
          "signature": "String -\u003e m String",
          "source": "src/Ideas-Text-UTF8.html#decodeM",
          "type": "function"
        },
        "index": {
          "description": "Decode an UTF8 format string to unicode points monadic",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "decodeM",
          "normalized": "String-\u003ea String",
          "package": "ideas",
          "signature": "String-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#v:decodeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncode a string to UTF8 format\n\u003c/p\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "encode",
          "package": "ideas",
          "signature": "String -\u003e String",
          "source": "src/Ideas-Text-UTF8.html#encode",
          "type": "function"
        },
        "index": {
          "description": "Encode string to UTF8 format",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "encode",
          "normalized": "String-\u003eString",
          "package": "ideas",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncode a string to UTF8 format (monadic)\n\u003c/p\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "encodeM",
          "package": "ideas",
          "signature": "String -\u003e m String",
          "source": "src/Ideas-Text-UTF8.html#encodeM",
          "type": "function"
        },
        "index": {
          "description": "Encode string to UTF8 format monadic",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "encodeM",
          "normalized": "String-\u003ea String",
          "package": "ideas",
          "signature": "String-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#v:encodeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether the argument is a proper UTF8 string\n\u003c/p\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "isUTF8",
          "package": "ideas",
          "signature": "String -\u003e Bool",
          "source": "src/Ideas-Text-UTF8.html#isUTF8",
          "type": "function"
        },
        "index": {
          "description": "Test whether the argument is proper UTF8 string",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "isUTF8",
          "normalized": "String-\u003eBool",
          "package": "ideas",
          "partial": "UTF",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#v:isUTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuickCheck internal encoding/decoding functions\n\u003c/p\u003e",
          "module": "Ideas.Text.UTF8",
          "name": "propEncoding",
          "package": "ideas",
          "signature": "Property",
          "source": "src/Ideas-Text-UTF8.html#propEncoding",
          "type": "function"
        },
        "index": {
          "description": "QuickCheck internal encoding decoding functions",
          "hierarchy": "Ideas Text UTF8",
          "module": "Ideas.Text.UTF8",
          "name": "propEncoding",
          "package": "ideas",
          "partial": "Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-UTF8.html#v:propEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDatatype for representing XML documents\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.XML.Document",
          "name": "Document",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html",
          "type": "module"
        },
        "index": {
          "description": "Datatype for representing XML documents",
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Document",
          "package": "ideas",
          "partial": "Document",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "AttDef",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#AttDef",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "AttDef",
          "package": "ideas",
          "partial": "Att Def",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:AttDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "AttType",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "AttType",
          "package": "ideas",
          "partial": "Att Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:AttType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "AttValue",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#AttValue",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "AttValue",
          "package": "ideas",
          "partial": "Att Value",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:AttValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Attribute",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Attribute",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Attribute",
          "package": "ideas",
          "partial": "Attribute",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Attribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Attributes",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Attributes",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Attributes",
          "package": "ideas",
          "partial": "Attributes",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "CP",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#CP",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "CP",
          "package": "ideas",
          "partial": "CP",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:CP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Conditional",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Conditional",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Conditional",
          "package": "ideas",
          "partial": "Conditional",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Conditional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Content",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Content",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Content",
          "package": "ideas",
          "partial": "Content",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "ContentSpec",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#ContentSpec",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "ContentSpec",
          "package": "ideas",
          "partial": "Content Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:ContentSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "DTD",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#DTD",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "DTD",
          "package": "ideas",
          "partial": "DTD",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:DTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "DefaultDecl",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#DefaultDecl",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "DefaultDecl",
          "package": "ideas",
          "partial": "Default Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:DefaultDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "DocTypeDecl",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#DocTypeDecl",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "DocTypeDecl",
          "package": "ideas",
          "partial": "Doc Type Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:DocTypeDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Element",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Element",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Element",
          "package": "ideas",
          "partial": "Element",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "EntityDef",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#EntityDef",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "EntityDef",
          "package": "ideas",
          "partial": "Entity Def",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:EntityDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "EntityValue",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#EntityValue",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "EntityValue",
          "package": "ideas",
          "partial": "Entity Value",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:EntityValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "External",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#External",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "External",
          "package": "ideas",
          "partial": "External",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:External"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "ExternalID",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#ExternalID",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "ExternalID",
          "package": "ideas",
          "partial": "External ID",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:ExternalID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Name",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Name",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Name",
          "package": "ideas",
          "partial": "Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Parameter",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Parameter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Parameter",
          "package": "ideas",
          "partial": "Parameter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "PublicID",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#PublicID",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "PublicID",
          "package": "ideas",
          "partial": "Public ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:PublicID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Reference",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#Reference",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Reference",
          "package": "ideas",
          "partial": "Reference",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:Reference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "TextDecl",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#TextDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "TextDecl",
          "package": "ideas",
          "partial": "Text Decl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:TextDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "XML",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#XML",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "XML",
          "package": "ideas",
          "partial": "XML",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:XML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "XMLDoc",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "XMLDoc",
          "package": "ideas",
          "partial": "XMLDoc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#t:XMLDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": ":=",
          "package": "ideas",
          "signature": "Name := AttValue",
          "source": "src/Ideas-Text-XML-Document.html#Attribute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": ":=",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v::-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Any",
          "package": "ideas",
          "signature": "Any",
          "source": "src/Ideas-Text-XML-Document.html#ContentSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Any",
          "package": "ideas",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "AttListDecl",
          "package": "ideas",
          "signature": "AttListDecl Name [AttDef]",
          "source": "src/Ideas-Text-XML-Document.html#DocTypeDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "AttListDecl",
          "normalized": "AttListDecl Name[AttDef]",
          "package": "ideas",
          "partial": "Att List Decl",
          "signature": "AttListDecl Name[AttDef]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:AttListDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "CDATA",
          "package": "ideas",
          "signature": "CDATA String",
          "source": "src/Ideas-Text-XML-Document.html#XML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "CDATA",
          "package": "ideas",
          "partial": "CDATA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:CDATA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "CPName",
          "package": "ideas",
          "signature": "CPName Name",
          "source": "src/Ideas-Text-XML-Document.html#CP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "CPName",
          "package": "ideas",
          "partial": "CPName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:CPName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "CharData",
          "package": "ideas",
          "signature": "CharData String",
          "source": "src/Ideas-Text-XML-Document.html#XML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "CharData",
          "package": "ideas",
          "partial": "Char Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:CharData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "CharRef",
          "package": "ideas",
          "signature": "CharRef Int",
          "source": "src/Ideas-Text-XML-Document.html#Reference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "CharRef",
          "package": "ideas",
          "partial": "Char Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:CharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Children",
          "package": "ideas",
          "signature": "Children CP",
          "source": "src/Ideas-Text-XML-Document.html#ContentSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Children",
          "package": "ideas",
          "partial": "Children",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Children"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Choice",
          "package": "ideas",
          "signature": "Choice [CP]",
          "source": "src/Ideas-Text-XML-Document.html#CP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Choice",
          "normalized": "Choice[CP]",
          "package": "ideas",
          "partial": "Choice",
          "signature": "Choice[CP]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "DTD",
          "package": "ideas",
          "signature": "DTD Name (Maybe ExternalID) [DocTypeDecl]",
          "source": "src/Ideas-Text-XML-Document.html#DTD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "DTD",
          "normalized": "DTD Name(Maybe ExternalID)[DocTypeDecl]",
          "package": "ideas",
          "partial": "DTD",
          "signature": "DTD Name(Maybe ExternalID)[DocTypeDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:DTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "DTDConditional",
          "package": "ideas",
          "signature": "DTDConditional Conditional",
          "source": "src/Ideas-Text-XML-Document.html#DocTypeDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "DTDConditional",
          "package": "ideas",
          "partial": "DTDConditional",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:DTDConditional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "DTDParameter",
          "package": "ideas",
          "signature": "DTDParameter Parameter",
          "source": "src/Ideas-Text-XML-Document.html#DocTypeDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "DTDParameter",
          "package": "ideas",
          "partial": "DTDParameter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:DTDParameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Element",
          "package": "ideas",
          "signature": "Element",
          "source": "src/Ideas-Text-XML-Document.html#Element",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Element",
          "package": "ideas",
          "partial": "Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "ElementDecl",
          "package": "ideas",
          "signature": "ElementDecl Name ContentSpec",
          "source": "src/Ideas-Text-XML-Document.html#DocTypeDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "ElementDecl",
          "package": "ideas",
          "partial": "Element Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:ElementDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Empty",
          "package": "ideas",
          "signature": "Empty",
          "source": "src/Ideas-Text-XML-Document.html#ContentSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Empty",
          "package": "ideas",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "EntitiesType",
          "package": "ideas",
          "signature": "EntitiesType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "EntitiesType",
          "package": "ideas",
          "partial": "Entities Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:EntitiesType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "EntityDecl",
          "package": "ideas",
          "signature": "EntityDecl Bool Name EntityDef",
          "source": "src/Ideas-Text-XML-Document.html#DocTypeDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "EntityDecl",
          "package": "ideas",
          "partial": "Entity Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:EntityDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "EntityRef",
          "package": "ideas",
          "signature": "EntityRef String",
          "source": "src/Ideas-Text-XML-Document.html#Reference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "EntityRef",
          "package": "ideas",
          "partial": "Entity Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:EntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "EntityType",
          "package": "ideas",
          "signature": "EntityType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "EntityType",
          "package": "ideas",
          "partial": "Entity Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:EntityType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "EnumerationType",
          "package": "ideas",
          "signature": "EnumerationType [String]",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "EnumerationType",
          "normalized": "EnumerationType[String]",
          "package": "ideas",
          "partial": "Enumeration Type",
          "signature": "EnumerationType[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:EnumerationType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Fixed",
          "package": "ideas",
          "signature": "Fixed AttValue",
          "source": "src/Ideas-Text-XML-Document.html#DefaultDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Fixed",
          "package": "ideas",
          "partial": "Fixed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Fixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "IdRefType",
          "package": "ideas",
          "signature": "IdRefType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "IdRefType",
          "package": "ideas",
          "partial": "Id Ref Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:IdRefType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "IdRefsType",
          "package": "ideas",
          "signature": "IdRefsType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "IdRefsType",
          "package": "ideas",
          "partial": "Id Refs Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:IdRefsType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "IdType",
          "package": "ideas",
          "signature": "IdType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "IdType",
          "package": "ideas",
          "partial": "Id Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:IdType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Ignore",
          "package": "ideas",
          "signature": "Ignore [String]",
          "source": "src/Ideas-Text-XML-Document.html#Conditional",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Ignore",
          "normalized": "Ignore[String]",
          "package": "ideas",
          "partial": "Ignore",
          "signature": "Ignore[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Ignore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Implied",
          "package": "ideas",
          "signature": "Implied",
          "source": "src/Ideas-Text-XML-Document.html#DefaultDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Implied",
          "package": "ideas",
          "partial": "Implied",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Implied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Include",
          "package": "ideas",
          "signature": "Include [DocTypeDecl]",
          "source": "src/Ideas-Text-XML-Document.html#Conditional",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Include",
          "normalized": "Include[DocTypeDecl]",
          "package": "ideas",
          "partial": "Include",
          "signature": "Include[DocTypeDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Include"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Mixed",
          "package": "ideas",
          "signature": "Mixed Bool [Name]",
          "source": "src/Ideas-Text-XML-Document.html#ContentSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Mixed",
          "normalized": "Mixed Bool[Name]",
          "package": "ideas",
          "partial": "Mixed",
          "signature": "Mixed Bool[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Mixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "NmTokenType",
          "package": "ideas",
          "signature": "NmTokenType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "NmTokenType",
          "package": "ideas",
          "partial": "Nm Token Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:NmTokenType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "NmTokensType",
          "package": "ideas",
          "signature": "NmTokensType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "NmTokensType",
          "package": "ideas",
          "partial": "Nm Tokens Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:NmTokensType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "NotationDecl",
          "package": "ideas",
          "signature": "NotationDecl Name (Either ExternalID PublicID)",
          "source": "src/Ideas-Text-XML-Document.html#DocTypeDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "NotationDecl",
          "package": "ideas",
          "partial": "Notation Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:NotationDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "NotationType",
          "package": "ideas",
          "signature": "NotationType [String]",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "NotationType",
          "normalized": "NotationType[String]",
          "package": "ideas",
          "partial": "Notation Type",
          "signature": "NotationType[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:NotationType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Parameter",
          "package": "ideas",
          "signature": "Parameter String",
          "source": "src/Ideas-Text-XML-Document.html#Parameter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Parameter",
          "package": "ideas",
          "partial": "Parameter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Parameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Plus",
          "package": "ideas",
          "signature": "Plus CP",
          "source": "src/Ideas-Text-XML-Document.html#CP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Plus",
          "package": "ideas",
          "partial": "Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Public",
          "package": "ideas",
          "signature": "Public String String",
          "source": "src/Ideas-Text-XML-Document.html#ExternalID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Public",
          "package": "ideas",
          "partial": "Public",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Public"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "QuestionMark",
          "package": "ideas",
          "signature": "QuestionMark CP",
          "source": "src/Ideas-Text-XML-Document.html#CP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "QuestionMark",
          "package": "ideas",
          "partial": "Question Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:QuestionMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Reference",
          "package": "ideas",
          "signature": "Reference Reference",
          "source": "src/Ideas-Text-XML-Document.html#XML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Reference",
          "package": "ideas",
          "partial": "Reference",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Reference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Required",
          "package": "ideas",
          "signature": "Required",
          "source": "src/Ideas-Text-XML-Document.html#DefaultDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Required",
          "package": "ideas",
          "partial": "Required",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Required"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Sequence",
          "package": "ideas",
          "signature": "Sequence [CP]",
          "source": "src/Ideas-Text-XML-Document.html#CP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Sequence",
          "normalized": "Sequence[CP]",
          "package": "ideas",
          "partial": "Sequence",
          "signature": "Sequence[CP]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Star",
          "package": "ideas",
          "signature": "Star CP",
          "source": "src/Ideas-Text-XML-Document.html#CP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Star",
          "package": "ideas",
          "partial": "Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "StringType",
          "package": "ideas",
          "signature": "StringType",
          "source": "src/Ideas-Text-XML-Document.html#AttType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "StringType",
          "package": "ideas",
          "partial": "String Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:StringType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "System",
          "package": "ideas",
          "signature": "System String",
          "source": "src/Ideas-Text-XML-Document.html#ExternalID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "System",
          "package": "ideas",
          "partial": "System",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:System"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Tagged",
          "package": "ideas",
          "signature": "Tagged Element",
          "source": "src/Ideas-Text-XML-Document.html#XML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Tagged",
          "package": "ideas",
          "partial": "Tagged",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Tagged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "Value",
          "package": "ideas",
          "signature": "Value AttValue",
          "source": "src/Ideas-Text-XML-Document.html#DefaultDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "Value",
          "package": "ideas",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "XMLDoc",
          "package": "ideas",
          "signature": "XMLDoc",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "XMLDoc",
          "package": "ideas",
          "partial": "XMLDoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:XMLDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "attributes",
          "package": "ideas",
          "signature": "Attributes",
          "source": "src/Ideas-Text-XML-Document.html#Element",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "attributes",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "content",
          "package": "ideas",
          "signature": "Content",
          "source": "src/Ideas-Text-XML-Document.html#Element",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "content",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "dtd",
          "package": "ideas",
          "signature": "Maybe DTD",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "dtd",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:dtd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "encoding",
          "package": "ideas",
          "signature": "Maybe String",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "encoding",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "externals",
          "package": "ideas",
          "signature": "[(String, External)]",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "externals",
          "normalized": "[(String,External)]",
          "package": "ideas",
          "signature": "[(String,External)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:externals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "name",
          "package": "ideas",
          "signature": "Name",
          "source": "src/Ideas-Text-XML-Document.html#Element",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "name",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "root",
          "package": "ideas",
          "signature": "Element",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "root",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "standalone",
          "package": "ideas",
          "signature": "Maybe Bool",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "standalone",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:standalone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Document",
          "name": "versionInfo",
          "package": "ideas",
          "signature": "Maybe String",
          "source": "src/Ideas-Text-XML-Document.html#XMLDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Document",
          "module": "Ideas.Text.XML.Document",
          "name": "versionInfo",
          "package": "ideas",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Document.html#v:versionInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCollection of common operation on XML documents\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.XML.Interface",
          "name": "Interface",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Interface.html",
          "type": "module"
        },
        "index": {
          "description": "Collection of common operation on XML documents",
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "Interface",
          "package": "ideas",
          "partial": "Interface",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Interface",
          "name": "Attribute",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Interface.html#Attribute",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "Attribute",
          "package": "ideas",
          "partial": "Attribute",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#t:Attribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Interface",
          "name": "Attributes",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Interface.html#Attributes",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "Attributes",
          "package": "ideas",
          "partial": "Attributes",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#t:Attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Interface",
          "name": "Content",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Interface.html#Content",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "Content",
          "package": "ideas",
          "partial": "Content",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#t:Content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Interface",
          "name": "Element",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Interface.html#Element",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "Element",
          "package": "ideas",
          "partial": "Element",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#t:Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": ":=",
          "package": "ideas",
          "signature": "Name := String",
          "source": "src/Ideas-Text-XML-Interface.html#Attribute",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v::-61-\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v::-61-\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": ":=",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v::-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "Element",
          "package": "ideas",
          "signature": "Element",
          "source": "src/Ideas-Text-XML-Interface.html#Element",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:Element\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:Element\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "Element",
          "package": "ideas",
          "partial": "Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "attributes",
          "package": "ideas",
          "signature": "Attributes",
          "source": "src/Ideas-Text-XML-Interface.html#Element",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:attributes\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:attributes\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "attributes",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "children",
          "package": "ideas",
          "signature": "Element -\u003e [Element]",
          "source": "src/Ideas-Text-XML-Interface.html#children",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:children\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:children\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "children",
          "normalized": "Element-\u003e[Element]",
          "package": "ideas",
          "signature": "Element-\u003e[Element]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:children"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "content",
          "package": "ideas",
          "signature": "Content",
          "source": "src/Ideas-Text-XML-Interface.html#Element",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:content\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:content\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "content",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "findAttribute",
          "package": "ideas",
          "signature": "String -\u003e Element -\u003e m String",
          "source": "src/Ideas-Text-XML-Interface.html#findAttribute",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:findAttribute\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:findAttribute\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "findAttribute",
          "normalized": "String-\u003eElement-\u003ea String",
          "package": "ideas",
          "partial": "Attribute",
          "signature": "String-\u003eElement-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:findAttribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "findChild",
          "package": "ideas",
          "signature": "String -\u003e Element -\u003e m Element",
          "source": "src/Ideas-Text-XML-Interface.html#findChild",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:findChild\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:findChild\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "findChild",
          "normalized": "String-\u003eElement-\u003ea Element",
          "package": "ideas",
          "partial": "Child",
          "signature": "String-\u003eElement-\u003em Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:findChild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "getData",
          "package": "ideas",
          "signature": "Element -\u003e String",
          "source": "src/Ideas-Text-XML-Interface.html#getData",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:getData\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:getData\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "getData",
          "normalized": "Element-\u003eString",
          "package": "ideas",
          "partial": "Data",
          "signature": "Element-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:getData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Ideas.Text.XML.Interface\",\"Ideas.Text.XML\"]",
          "name": "name",
          "package": "ideas",
          "signature": "Name",
          "source": "src/Ideas-Text-XML-Interface.html#Element",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:name\",\"http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:name\"]"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "name",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Interface",
          "name": "normalize",
          "package": "ideas",
          "signature": "XMLDoc -\u003e Element",
          "source": "src/Ideas-Text-XML-Interface.html#normalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "normalize",
          "normalized": "XMLDoc-\u003eElement",
          "package": "ideas",
          "signature": "XMLDoc-\u003eElement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Interface",
          "name": "parseXML",
          "package": "ideas",
          "signature": "String -\u003e Either String Element",
          "source": "src/Ideas-Text-XML-Interface.html#parseXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Interface",
          "module": "Ideas.Text.XML.Interface",
          "name": "parseXML",
          "normalized": "String-\u003eEither String Element",
          "package": "ideas",
          "partial": "XML",
          "signature": "String-\u003eEither String Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Interface.html#v:parseXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA parser for XML documents, directly derived from the specification:\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.XML.Parser",
          "name": "Parser",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "parser for XML documents directly derived from the specification",
          "hierarchy": "Ideas Text XML Parser",
          "module": "Ideas.Text.XML.Parser",
          "name": "Parser",
          "package": "ideas",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Parser",
          "name": "document",
          "package": "ideas",
          "signature": "Parser XMLDoc",
          "source": "src/Ideas-Text-XML-Parser.html#document",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Parser",
          "module": "Ideas.Text.XML.Parser",
          "name": "document",
          "package": "ideas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Parser.html#v:document"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Parser",
          "name": "extParsedEnt",
          "package": "ideas",
          "signature": "Parser (Maybe TextDecl, Content)",
          "source": "src/Ideas-Text-XML-Parser.html#extParsedEnt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Parser",
          "module": "Ideas.Text.XML.Parser",
          "name": "extParsedEnt",
          "normalized": "Parser(Maybe TextDecl,Content)",
          "package": "ideas",
          "partial": "Parsed Ent",
          "signature": "Parser(Maybe TextDecl,Content)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Parser.html#v:extParsedEnt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Parser",
          "name": "extSubset",
          "package": "ideas",
          "signature": "Parser (Maybe TextDecl, [DocTypeDecl])",
          "source": "src/Ideas-Text-XML-Parser.html#extSubset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Parser",
          "module": "Ideas.Text.XML.Parser",
          "name": "extSubset",
          "normalized": "Parser(Maybe TextDecl,[DocTypeDecl])",
          "package": "ideas",
          "partial": "Subset",
          "signature": "Parser(Maybe TextDecl,[DocTypeDecl])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Parser.html#v:extSubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for Unicode\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.XML.Unicode",
          "name": "Unicode",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Unicode.html",
          "type": "module"
        },
        "index": {
          "description": "Support for Unicode",
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "Unicode",
          "package": "ideas",
          "partial": "Unicode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "combiningCharMap",
          "package": "ideas",
          "signature": "[(Char, Char)]",
          "source": "src/Ideas-Text-XML-Unicode.html#combiningCharMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "combiningCharMap",
          "normalized": "[(Char,Char)]",
          "package": "ideas",
          "partial": "Char Map",
          "signature": "[(Char,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:combiningCharMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "decoding",
          "package": "ideas",
          "signature": "String -\u003e m String",
          "source": "src/Ideas-Text-XML-Unicode.html#decoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "decoding",
          "normalized": "String-\u003ea String",
          "package": "ideas",
          "signature": "String-\u003em String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:decoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "digitMap",
          "package": "ideas",
          "signature": "[(Char, Char)]",
          "source": "src/Ideas-Text-XML-Unicode.html#digitMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "digitMap",
          "normalized": "[(Char,Char)]",
          "package": "ideas",
          "partial": "Map",
          "signature": "[(Char,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:digitMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "extenderMap",
          "package": "ideas",
          "signature": "[(Char, Char)]",
          "source": "src/Ideas-Text-XML-Unicode.html#extenderMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "extenderMap",
          "normalized": "[(Char,Char)]",
          "package": "ideas",
          "partial": "Map",
          "signature": "[(Char,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:extenderMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "isCombiningChar",
          "package": "ideas",
          "signature": "Char -\u003e Bool",
          "source": "src/Ideas-Text-XML-Unicode.html#isCombiningChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "isCombiningChar",
          "normalized": "Char-\u003eBool",
          "package": "ideas",
          "partial": "Combining Char",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:isCombiningChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "isDigit",
          "package": "ideas",
          "signature": "Char -\u003e Bool",
          "source": "src/Ideas-Text-XML-Unicode.html#isDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "isDigit",
          "normalized": "Char-\u003eBool",
          "package": "ideas",
          "partial": "Digit",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:isDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "isExtender",
          "package": "ideas",
          "signature": "Char -\u003e Bool",
          "source": "src/Ideas-Text-XML-Unicode.html#isExtender",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "isExtender",
          "normalized": "Char-\u003eBool",
          "package": "ideas",
          "partial": "Extender",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:isExtender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "isLetter",
          "package": "ideas",
          "signature": "Char -\u003e Bool",
          "source": "src/Ideas-Text-XML-Unicode.html#isLetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "isLetter",
          "normalized": "Char-\u003eBool",
          "package": "ideas",
          "partial": "Letter",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:isLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML.Unicode",
          "name": "letterMap",
          "package": "ideas",
          "signature": "[(Char, Char)]",
          "source": "src/Ideas-Text-XML-Unicode.html#letterMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML Unicode",
          "module": "Ideas.Text.XML.Unicode",
          "name": "letterMap",
          "normalized": "[(Char,Char)]",
          "package": "ideas",
          "partial": "Map",
          "signature": "[(Char,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML-Unicode.html#v:letterMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA datatype, parser, and pretty printer for XML documents. Re-exports\n functions defined elsewhere.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Ideas.Text.XML",
          "name": "XML",
          "package": "ideas",
          "source": "src/Ideas-Text-XML.html",
          "type": "module"
        },
        "index": {
          "description": "datatype parser and pretty printer for XML documents Re-exports functions defined elsewhere",
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "XML",
          "package": "ideas",
          "partial": "XML",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "Attr",
          "package": "ideas",
          "source": "src/Ideas-Text-XML.html#Attr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "Attr",
          "package": "ideas",
          "partial": "Attr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:Attr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "AttrList",
          "package": "ideas",
          "source": "src/Ideas-Text-XML.html#AttrList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "AttrList",
          "package": "ideas",
          "partial": "Attr List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:AttrList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "Attribute",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Interface.html#Attribute",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "Attribute",
          "package": "ideas",
          "partial": "Attribute",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:Attribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "BuildXML",
          "package": "ideas",
          "source": "src/Ideas-Text-XML.html#BuildXML",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "BuildXML",
          "package": "ideas",
          "partial": "Build XML",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:BuildXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "Element",
          "package": "ideas",
          "source": "src/Ideas-Text-XML-Interface.html#Element",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "Element",
          "package": "ideas",
          "partial": "Element",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "InXML",
          "package": "ideas",
          "source": "src/Ideas-Text-XML.html#InXML",
          "type": "class"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "InXML",
          "package": "ideas",
          "partial": "In XML",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:InXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "XML",
          "package": "ideas",
          "source": "src/Ideas-Text-XML.html#XML",
          "type": "type"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "XML",
          "package": "ideas",
          "partial": "XML",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:XML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "XMLBuilder",
          "package": "ideas",
          "source": "src/Ideas-Text-XML.html#XMLBuilder",
          "type": "data"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "XMLBuilder",
          "package": "ideas",
          "partial": "XMLBuilder",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#t:XMLBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "(.=.)",
          "package": "ideas",
          "signature": "String -\u003e String -\u003e a",
          "source": "src/Ideas-Text-XML.html#.%3D.",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "(.=.) .=.",
          "normalized": "String-\u003eString-\u003ea",
          "package": "ideas",
          "signature": "String-\u003eString-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:.-61-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "builder",
          "package": "ideas",
          "signature": "Element -\u003e a",
          "source": "src/Ideas-Text-XML.html#builder",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "builder",
          "normalized": "Element-\u003ea",
          "package": "ideas",
          "signature": "Element-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:builder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "compactXML",
          "package": "ideas",
          "signature": "XML -\u003e String",
          "source": "src/Ideas-Text-XML.html#compactXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "compactXML",
          "normalized": "XML-\u003eString",
          "package": "ideas",
          "partial": "XML",
          "signature": "XML-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:compactXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "element",
          "package": "ideas",
          "signature": "String -\u003e [a] -\u003e a",
          "source": "src/Ideas-Text-XML.html#element",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "element",
          "normalized": "String-\u003e[a]-\u003ea",
          "package": "ideas",
          "signature": "String-\u003e[a]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "emptyTag",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-XML.html#emptyTag",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "emptyTag",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "partial": "Tag",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:emptyTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "fromBuilder",
          "package": "ideas",
          "signature": "XMLBuilder -\u003e Maybe Element",
          "source": "src/Ideas-Text-XML.html#fromBuilder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "fromBuilder",
          "normalized": "XMLBuilder-\u003eMaybe Element",
          "package": "ideas",
          "partial": "Builder",
          "signature": "XMLBuilder-\u003eMaybe Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:fromBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "fromXML",
          "package": "ideas",
          "signature": "XML -\u003e m a",
          "source": "src/Ideas-Text-XML.html#fromXML",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "fromXML",
          "normalized": "XML-\u003ea b",
          "package": "ideas",
          "partial": "XML",
          "signature": "XML-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:fromXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "listFromXML",
          "package": "ideas",
          "signature": "XML -\u003e m [a]",
          "source": "src/Ideas-Text-XML.html#listFromXML",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "listFromXML",
          "normalized": "XML-\u003ea[b]",
          "package": "ideas",
          "partial": "From XML",
          "signature": "XML-\u003em[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:listFromXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "listToXML",
          "package": "ideas",
          "signature": "[a] -\u003e XML",
          "source": "src/Ideas-Text-XML.html#listToXML",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "listToXML",
          "normalized": "[a]-\u003eXML",
          "package": "ideas",
          "partial": "To XML",
          "signature": "[a]-\u003eXML",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:listToXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "makeXML",
          "package": "ideas",
          "signature": "String -\u003e XMLBuilder -\u003e XML",
          "source": "src/Ideas-Text-XML.html#makeXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "makeXML",
          "normalized": "String-\u003eXMLBuilder-\u003eXML",
          "package": "ideas",
          "partial": "XML",
          "signature": "String-\u003eXMLBuilder-\u003eXML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:makeXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "munless",
          "package": "ideas",
          "signature": "Bool -\u003e a -\u003e a",
          "source": "src/Ideas-Text-XML.html#munless",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "munless",
          "normalized": "Bool-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "Bool-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:munless"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "mwhen",
          "package": "ideas",
          "signature": "Bool -\u003e a -\u003e a",
          "source": "src/Ideas-Text-XML.html#mwhen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "mwhen",
          "normalized": "Bool-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "Bool-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:mwhen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "parseXML",
          "package": "ideas",
          "signature": "String -\u003e Either String XML",
          "source": "src/Ideas-Text-XML.html#parseXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "parseXML",
          "normalized": "String-\u003eEither String XML",
          "package": "ideas",
          "partial": "XML",
          "signature": "String-\u003eEither String XML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:parseXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "showXML",
          "package": "ideas",
          "signature": "XML -\u003e String",
          "source": "src/Ideas-Text-XML.html#showXML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "showXML",
          "normalized": "XML-\u003eString",
          "package": "ideas",
          "partial": "XML",
          "signature": "XML-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:showXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "string",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-XML.html#string",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "string",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "tag",
          "package": "ideas",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Ideas-Text-XML.html#tag",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "tag",
          "normalized": "String-\u003ea-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:tag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "text",
          "package": "ideas",
          "signature": "s -\u003e a",
          "source": "src/Ideas-Text-XML.html#text",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "text",
          "normalized": "a-\u003eb",
          "package": "ideas",
          "signature": "s-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "toXML",
          "package": "ideas",
          "signature": "a -\u003e XML",
          "source": "src/Ideas-Text-XML.html#toXML",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "toXML",
          "normalized": "a-\u003eXML",
          "package": "ideas",
          "partial": "XML",
          "signature": "a-\u003eXML",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:toXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Ideas.Text.XML",
          "name": "unescaped",
          "package": "ideas",
          "signature": "String -\u003e a",
          "source": "src/Ideas-Text-XML.html#unescaped",
          "type": "method"
        },
        "index": {
          "hierarchy": "Ideas Text XML",
          "module": "Ideas.Text.XML",
          "name": "unescaped",
          "normalized": "String-\u003ea",
          "package": "ideas",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ideas/docs/Ideas-Text-XML.html#v:unescaped"
      }
    }
  ]
]