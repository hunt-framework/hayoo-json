[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "TV"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSome common interaction vocabulary \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV.Common",
          "name": "Common",
          "package": "TV",
          "source": "src/Interface-TV-Common.html",
          "type": "module"
        },
        "index": {
          "description": "Some common interaction vocabulary",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "Common",
          "package": "TV",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInputs that work over all \u003ccode\u003eCommonInsOuts\u003c/code\u003e typecons.\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "CInput",
          "package": "TV",
          "source": "src/Interface-TV-Common.html#CInput",
          "type": "type"
        },
        "index": {
          "description": "Inputs that work over all CommonInsOuts typecons",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "CInput",
          "package": "TV",
          "partial": "CInput",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#t:CInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eCInput\u003c/a\u003e\u003c/code\u003e with initial value\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "CInputI",
          "package": "TV",
          "source": "src/Interface-TV-Common.html#CInputI",
          "type": "type"
        },
        "index": {
          "description": "CInput with initial value",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "CInputI",
          "package": "TV",
          "partial": "CInput",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#t:CInputI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutputs that work over all \u003ccode\u003e\u003ca\u003eCommonOuts\u003c/a\u003e\u003c/code\u003e typecons.\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "COutput",
          "package": "TV",
          "source": "src/Interface-TV-Common.html#COutput",
          "type": "type"
        },
        "index": {
          "description": "Outputs that work over all CommonOuts typecons",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "COutput",
          "package": "TV",
          "partial": "COutput",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#t:COutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient type synonym for TVs that work over all \u003ccode\u003eCommonInsOuts\u003c/code\u003e typecons.\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "CTV",
          "package": "TV",
          "source": "src/Interface-TV-Common.html#CTV",
          "type": "type"
        },
        "index": {
          "description": "Convenient type synonym for TVs that work over all CommonInsOuts typecons",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "CTV",
          "package": "TV",
          "partial": "CTV",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#t:CTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class captures some useful operations available in some input\n types, and allows definition of some \"\u003ccode\u003eCommon\u003c/code\u003e\" \u003ccode\u003e\u003ca\u003eInput\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "CommonIns",
          "package": "TV",
          "source": "src/Interface-TV-Common.html#CommonIns",
          "type": "class"
        },
        "index": {
          "description": "This class captures some useful operations available in some input types and allows definition of some Common Input",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "CommonIns",
          "package": "TV",
          "partial": "Common Ins",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#t:CommonIns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class captures some useful operations available in some arrows\n and allows definition of some \"\u003ccode\u003eCommon\u003c/code\u003e\" \u003ccode\u003e\u003ca\u003eInput\u003c/a\u003e\u003c/code\u003es, \u003ccode\u003e\u003ca\u003eOutput\u003c/a\u003e\u003c/code\u003es, and\n TVs.\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "CommonOuts",
          "package": "TV",
          "source": "src/Interface-TV-Common.html#CommonOuts",
          "type": "class"
        },
        "index": {
          "description": "This class captures some useful operations available in some arrows and allows definition of some Common Input Output and TVs",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "CommonOuts",
          "package": "TV",
          "partial": "Common Outs",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#t:CommonOuts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBool input with default\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "boolIn",
          "package": "TV",
          "signature": "CInputI Bool",
          "source": "src/Interface-TV-Common.html#boolIn",
          "type": "function"
        },
        "index": {
          "description": "Bool input with default",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "boolIn",
          "package": "TV",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:boolIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput a bool\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "boolOut",
          "package": "TV",
          "signature": "COutput Bool",
          "source": "src/Interface-TV-Common.html#boolOut",
          "type": "function"
        },
        "index": {
          "description": "Output bool",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "boolOut",
          "package": "TV",
          "partial": "Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:boolOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput a bool\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "getBool",
          "package": "TV",
          "signature": "Bool -\u003e src Bool",
          "source": "src/Interface-TV-Common.html#getBool",
          "type": "method"
        },
        "index": {
          "description": "Input bool",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "getBool",
          "normalized": "Bool-\u003ea Bool",
          "package": "TV",
          "partial": "Bool",
          "signature": "Bool-\u003esrc Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:getBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead-based input.  Initial value is also used as a default for\n failed parse.  Define as \u003ccode\u003e\u003ca\u003egetReadF\u003c/a\u003e\u003c/code\u003e when \u003ccode\u003esrc\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e.\n Requires \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e as well as \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e, for displaying the initial value.\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "getRead",
          "package": "TV",
          "signature": "a -\u003e src a",
          "source": "src/Interface-TV-Common.html#getRead",
          "type": "method"
        },
        "index": {
          "description": "Read-based input Initial value is also used as default for failed parse Define as getReadF when src is Functor Requires Show as well as Read for displaying the initial value",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "getRead",
          "normalized": "a-\u003eb a",
          "package": "TV",
          "partial": "Read",
          "signature": "a-\u003esrc a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:getRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003egetRead\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "getReadF",
          "package": "TV",
          "signature": "a -\u003e src a",
          "source": "src/Interface-TV-Common.html#getReadF",
          "type": "function"
        },
        "index": {
          "description": "getRead for Functor",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "getReadF",
          "normalized": "a-\u003eb a",
          "package": "TV",
          "partial": "Read",
          "signature": "a-\u003esrc a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:getReadF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput a string (with default)\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "getString",
          "package": "TV",
          "signature": "String -\u003e src String",
          "source": "src/Interface-TV-Common.html#getString",
          "type": "method"
        },
        "index": {
          "description": "Input string with default",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "getString",
          "normalized": "String-\u003ea String",
          "package": "TV",
          "partial": "String",
          "signature": "String-\u003esrc String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:getString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eOutput\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003einteract\u003c/a\u003e\u003c/code\u003e.  Well, not quite, since the IO\n version uses \u003ccode\u003e\u003ca\u003egetLine\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003egetContents\u003c/a\u003e\u003c/code\u003e.  See also\n \u003ccode\u003e\u003ca\u003einteractOut\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "interactLine",
          "package": "TV",
          "signature": "String -\u003e COutput (String -\u003e String)",
          "source": "src/Interface-TV-Common.html#interactLine",
          "type": "function"
        },
        "index": {
          "description": "Output version of interact Well not quite since the IO version uses getLine instead of getContents See also interactOut",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "interactLine",
          "normalized": "String-\u003eCOutput(String-\u003eString)",
          "package": "TV",
          "partial": "Line",
          "signature": "String-\u003eCOutput(String-\u003eString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:interactLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead+Show of \u003ccode\u003e\u003ca\u003einteractLine\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "interactLineRS",
          "package": "TV",
          "signature": "a-\u003e Output src snk (a -\u003e b)",
          "type": "function"
        },
        "index": {
          "description": "Read Show of interactLine",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "interactLineRS",
          "normalized": "a-\u003eOutput b c(a-\u003ed)",
          "package": "TV",
          "partial": "Line RS",
          "signature": "a-\u003eOutput src snk(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:interactLineRS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput a bool\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "putBool",
          "package": "TV",
          "signature": "snk Bool",
          "source": "src/Interface-TV-Common.html#putBool",
          "type": "method"
        },
        "index": {
          "description": "Output bool",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "putBool",
          "package": "TV",
          "partial": "Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:putBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShows based outout.  Define as \u003ccode\u003e\u003ca\u003eputShowC\u003c/a\u003e\u003c/code\u003e when \u003ccode\u003esnk\u003c/code\u003e is a\n \u003ccode\u003e\u003ca\u003eContraFunctor\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "putShow",
          "package": "TV",
          "signature": "snk a",
          "source": "src/Interface-TV-Common.html#putShow",
          "type": "method"
        },
        "index": {
          "description": "Shows based outout Define as putShowC when snk is ContraFunctor",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "putShow",
          "package": "TV",
          "partial": "Show",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:putShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Common",
          "name": "putShowC",
          "package": "TV",
          "signature": "snk a",
          "source": "src/Interface-TV-Common.html#putShowC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "putShowC",
          "package": "TV",
          "partial": "Show",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:putShowC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput a string\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "putString",
          "package": "TV",
          "signature": "snk String",
          "source": "src/Interface-TV-Common.html#putString",
          "type": "method"
        },
        "index": {
          "description": "Output string",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "putString",
          "package": "TV",
          "partial": "String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:putString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead with default value.  If the input doesn't parse as a value of\n the expected type, or it's ambiguous, yield the default value.\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "readD",
          "package": "TV",
          "signature": "a -\u003e String -\u003e a",
          "source": "src/Interface-TV-Common.html#readD",
          "type": "function"
        },
        "index": {
          "description": "Read with default value If the input doesn parse as value of the expected type or it ambiguous yield the default value",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "readD",
          "normalized": "a-\u003eString-\u003ea",
          "package": "TV",
          "signature": "a-\u003eString-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:readD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput a readable value.  Use default when read fails.\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "readIn",
          "package": "TV",
          "signature": "CInputI a",
          "source": "src/Interface-TV-Common.html#readIn",
          "type": "function"
        },
        "index": {
          "description": "Input readable value Use default when read fails",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "readIn",
          "package": "TV",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:readIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandy Read+Show wrapper\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "readShow",
          "package": "TV",
          "signature": "Output src snk (String -\u003e String)-\u003e a-\u003e Output src snk (a -\u003e b)",
          "type": "function"
        },
        "index": {
          "description": "Handy Read Show wrapper",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "readShow",
          "normalized": "Output a b(String-\u003eString)-\u003ec-\u003eOutput a b(c-\u003ed)",
          "package": "TV",
          "partial": "Show",
          "signature": "Output src snk(String-\u003eString)-\u003ea-\u003eOutput src snk(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:readShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput a showable value\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "showOut",
          "package": "TV",
          "signature": "COutput a",
          "source": "src/Interface-TV-Common.html#showOut",
          "type": "function"
        },
        "index": {
          "description": "Output showable value",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "showOut",
          "package": "TV",
          "partial": "Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:showOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eString input with default\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "stringIn",
          "package": "TV",
          "signature": "CInputI String",
          "source": "src/Interface-TV-Common.html#stringIn",
          "type": "function"
        },
        "index": {
          "description": "String input with default",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "stringIn",
          "package": "TV",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:stringIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput a string\n\u003c/p\u003e",
          "module": "Interface.TV.Common",
          "name": "stringOut",
          "package": "TV",
          "signature": "COutput String",
          "source": "src/Interface-TV-Common.html#stringOut",
          "type": "function"
        },
        "index": {
          "description": "Output string",
          "hierarchy": "Interface TV Common",
          "module": "Interface.TV.Common",
          "name": "stringOut",
          "package": "TV",
          "partial": "Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Common.html#v:stringOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDefault inputs and outputs\n\u003c/p\u003e\u003cp\u003eTODO: Provide \u003ccode\u003e[a]\u003c/code\u003e instances for DefaultIn and DefaultOut using the\n trick for Show \u003ccode\u003e[a]\u003c/code\u003e.  See \u003ca\u003eInterface.TV.DefaultsList\u003c/a\u003e for a first\n attempt.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV.Defaults",
          "name": "Defaults",
          "package": "TV",
          "source": "src/Interface-TV-Defaults.html",
          "type": "module"
        },
        "index": {
          "description": "Default inputs and outputs TODO Provide instances for DefaultIn and DefaultOut using the trick for Show See Interface.TV.DefaultsList for first attempt",
          "hierarchy": "Interface TV Defaults",
          "module": "Interface.TV.Defaults",
          "name": "Defaults",
          "package": "TV",
          "partial": "Defaults",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Defaults.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of types that provide a default input\n\u003c/p\u003e",
          "module": "Interface.TV.Defaults",
          "name": "DefaultIn",
          "package": "TV",
          "source": "src/Interface-TV-Defaults.html#DefaultIn",
          "type": "class"
        },
        "index": {
          "description": "Class of types that provide default input",
          "hierarchy": "Interface TV Defaults",
          "module": "Interface.TV.Defaults",
          "name": "DefaultIn",
          "package": "TV",
          "partial": "Default In",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Defaults.html#t:DefaultIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of types that provide a default output\n\u003c/p\u003e",
          "module": "Interface.TV.Defaults",
          "name": "DefaultOut",
          "package": "TV",
          "source": "src/Interface-TV-Defaults.html#DefaultOut",
          "type": "class"
        },
        "index": {
          "description": "Class of types that provide default output",
          "hierarchy": "Interface TV Defaults",
          "module": "Interface.TV.Defaults",
          "name": "DefaultOut",
          "package": "TV",
          "partial": "Default Out",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Defaults.html#t:DefaultOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default input for a type\n\u003c/p\u003e",
          "module": "Interface.TV.Defaults",
          "name": "defaultIn",
          "package": "TV",
          "signature": "Input src a",
          "source": "src/Interface-TV-Defaults.html#defaultIn",
          "type": "method"
        },
        "index": {
          "description": "The default input for type",
          "hierarchy": "Interface TV Defaults",
          "module": "Interface.TV.Defaults",
          "name": "defaultIn",
          "package": "TV",
          "partial": "In",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Defaults.html#v:defaultIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default output for a type\n\u003c/p\u003e",
          "module": "Interface.TV.Defaults",
          "name": "defaultOut",
          "package": "TV",
          "signature": "Output src snk a",
          "source": "src/Interface-TV-Defaults.html#defaultOut",
          "type": "method"
        },
        "index": {
          "description": "The default output for type",
          "hierarchy": "Interface TV Defaults",
          "module": "Interface.TV.Defaults",
          "name": "defaultOut",
          "package": "TV",
          "partial": "Out",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Defaults.html#v:defaultOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMake IO play with TV\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV.IO",
          "name": "IO",
          "package": "TV",
          "source": "src/Interface-TV-IO.html",
          "type": "module"
        },
        "index": {
          "description": "Make IO play with TV",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "IO",
          "package": "TV",
          "partial": "IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eInput\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003egetContents\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "contentsIn",
          "package": "TV",
          "signature": "Input IO String",
          "source": "src/Interface-TV-IO.html#contentsIn",
          "type": "function"
        },
        "index": {
          "description": "Input version of getContents",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "contentsIn",
          "package": "TV",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:contentsIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eInput\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003ereadFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "fileIn",
          "package": "TV",
          "signature": "FilePath -\u003e Input IO String",
          "source": "src/Interface-TV-IO.html#fileIn",
          "type": "function"
        },
        "index": {
          "description": "Input version of readFile",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "fileIn",
          "normalized": "FilePath-\u003eInput IO String",
          "package": "TV",
          "partial": "In",
          "signature": "FilePath-\u003eInput IO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:fileIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eOutput\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003ewriteFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "fileOut",
          "package": "TV",
          "signature": "FilePath -\u003e Output IO OI String",
          "source": "src/Interface-TV-IO.html#fileOut",
          "type": "function"
        },
        "index": {
          "description": "Output version of writeFile",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "fileOut",
          "normalized": "FilePath-\u003eOutput IO OI String",
          "package": "TV",
          "partial": "Out",
          "signature": "FilePath-\u003eOutput IO OI String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:fileOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity function, with \u003ccode\u003e\u003ca\u003efileIn\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003estringOut\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "fromFile",
          "package": "TV",
          "signature": "FilePath -\u003e TV IO OI (String -\u003e String)",
          "source": "src/Interface-TV-IO.html#fromFile",
          "type": "function"
        },
        "index": {
          "description": "Identity function with fileIn and stringOut",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "fromFile",
          "normalized": "FilePath-\u003eTV IO OI(String-\u003eString)",
          "package": "TV",
          "partial": "File",
          "signature": "FilePath-\u003eTV IO OI(String-\u003eString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:fromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent of \u003ccode\u003e\u003ca\u003einteract\u003c/a\u003e\u003c/code\u003e.  See also \u003ccode\u003e\u003ca\u003einteractLine\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "interactOut",
          "package": "TV",
          "signature": "Output IO OI (String -\u003e String)",
          "source": "src/Interface-TV-IO.html#interactOut",
          "type": "function"
        },
        "index": {
          "description": "Equivalent of interact See also interactLine",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "interactOut",
          "normalized": "Output IO OI(String-\u003eString)",
          "package": "TV",
          "partial": "Out",
          "signature": "Output IO OI(String-\u003eString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:interactOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead+Show of \u003ccode\u003e\u003ca\u003einteract\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "interactRS",
          "package": "TV",
          "signature": "a-\u003e Output IO OI (a -\u003e b)",
          "type": "function"
        },
        "index": {
          "description": "Read Show of interact",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "interactRS",
          "normalized": "a-\u003eOutput IO OI(a-\u003eb)",
          "package": "TV",
          "partial": "RS",
          "signature": "a-\u003eOutput IO OI(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:interactRS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-disambiguating alias for \u003ccode\u003e\u003ca\u003erunTV\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "runIO",
          "package": "TV",
          "signature": "RunTV IO OI",
          "source": "src/Interface-TV-IO.html#runIO",
          "type": "function"
        },
        "index": {
          "description": "Type-disambiguating alias for runTV",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "runIO",
          "package": "TV",
          "partial": "IO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:runIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity function, with stringIn' and \u003ccode\u003e\u003ca\u003efileOut\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.IO",
          "name": "toFile",
          "package": "TV",
          "signature": "FilePath -\u003e TV IO OI (String -\u003e String)",
          "source": "src/Interface-TV-IO.html#toFile",
          "type": "function"
        },
        "index": {
          "description": "Identity function with stringIn and fileOut",
          "hierarchy": "Interface TV IO",
          "module": "Interface.TV.IO",
          "name": "toFile",
          "normalized": "FilePath-\u003eTV IO OI(String-\u003eString)",
          "package": "TV",
          "partial": "File",
          "signature": "FilePath-\u003eTV IO OI(String-\u003eString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-IO.html#v:toFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInputs -- means of obtaining values\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV.Input",
          "name": "Input",
          "package": "TV",
          "source": "src/Interface-TV-Input.html",
          "type": "module"
        },
        "index": {
          "description": "Inputs means of obtaining values",
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "Input",
          "package": "TV",
          "partial": "Input",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003eInput\u003c/em\u003e describes a way to obtain a functional value from a user.\n Used in \u003ccode\u003eOutput\u003c/code\u003e for making function visualizations.\n The constructors: primitive, pairing, and title.\n\u003c/p\u003e",
          "module": "Interface.TV.Input",
          "name": "Input",
          "package": "TV",
          "source": "src/Interface-TV-Input.html#Input",
          "type": "data"
        },
        "index": {
          "description": "An Input describes way to obtain functional value from user Used in Output for making function visualizations The constructors primitive pairing and title",
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "Input",
          "package": "TV",
          "partial": "Input",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#t:Input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Input",
          "name": "IPair",
          "package": "TV",
          "signature": "Input src a -\u003e Input src b -\u003e Input src (a, b)",
          "source": "src/Interface-TV-Input.html#Input",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "IPair",
          "normalized": "Input a b-\u003eInput a c-\u003eInput a(b,c)",
          "package": "TV",
          "partial": "IPair",
          "signature": "Input src a-\u003eInput src b-\u003eInput src(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:IPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Input",
          "name": "IPrim",
          "package": "TV",
          "signature": "src a -\u003e Input src a",
          "source": "src/Interface-TV-Input.html#Input",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "IPrim",
          "normalized": "a b-\u003eInput a b",
          "package": "TV",
          "partial": "IPrim",
          "signature": "src a-\u003eInput src a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:IPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Input",
          "name": "ITitle",
          "package": "TV",
          "signature": "String -\u003e Input src a -\u003e Input src a",
          "source": "src/Interface-TV-Input.html#Input",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "ITitle",
          "normalized": "String-\u003eInput a b-\u003eInput a b",
          "package": "TV",
          "partial": "ITitle",
          "signature": "String-\u003eInput src a-\u003eInput src a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:ITitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDissect a pair-valued input into two inputs.  Loses outer \u003ccode\u003e\u003ca\u003eiTitle\u003c/a\u003e\u003c/code\u003es.\n Must be a (possibly titled) pair-style input.\n\u003c/p\u003e",
          "module": "Interface.TV.Input",
          "name": "asIPair",
          "package": "TV",
          "signature": "Input src (a, b) -\u003e (Input src a, Input src b)",
          "source": "src/Interface-TV-Input.html#asIPair",
          "type": "function"
        },
        "index": {
          "description": "Dissect pair-valued input into two inputs Loses outer iTitle Must be possibly titled pair-style input",
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "asIPair",
          "normalized": "Input a(b,c)-\u003e(Input a b,Input a c)",
          "package": "TV",
          "partial": "IPair",
          "signature": "Input src(a,b)-\u003e(Input src a,Input src b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:asIPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput a pair\n\u003c/p\u003e",
          "module": "Interface.TV.Input",
          "name": "iPair",
          "package": "TV",
          "signature": "Input src a -\u003e Input src b -\u003e Input src (a, b)",
          "source": "src/Interface-TV-Input.html#iPair",
          "type": "function"
        },
        "index": {
          "description": "Input pair",
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "iPair",
          "normalized": "Input a b-\u003eInput a c-\u003eInput a(b,c)",
          "package": "TV",
          "partial": "Pair",
          "signature": "Input src a-\u003eInput src b-\u003eInput src(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:iPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput primitive\n\u003c/p\u003e",
          "module": "Interface.TV.Input",
          "name": "iPrim",
          "package": "TV",
          "signature": "src a -\u003e Input src a",
          "source": "src/Interface-TV-Input.html#iPrim",
          "type": "function"
        },
        "index": {
          "description": "Input primitive",
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "iPrim",
          "normalized": "a b-\u003eInput a b",
          "package": "TV",
          "partial": "Prim",
          "signature": "src a-\u003eInput src a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:iPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTitle (label) an input\n\u003c/p\u003e",
          "module": "Interface.TV.Input",
          "name": "iTitle",
          "package": "TV",
          "signature": "String -\u003e Input src a -\u003e Input src a",
          "source": "src/Interface-TV-Input.html#iTitle",
          "type": "function"
        },
        "index": {
          "description": "Title label an input",
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "iTitle",
          "normalized": "String-\u003eInput a b-\u003eInput a b",
          "package": "TV",
          "partial": "Title",
          "signature": "String-\u003eInput src a-\u003eInput src a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:iTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Input",
          "name": "input",
          "package": "TV",
          "signature": "Input src t -\u003e src t",
          "source": "src/Interface-TV-Input.html#input",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Input",
          "module": "Interface.TV.Input",
          "name": "input",
          "normalized": "Input a b-\u003ea b",
          "package": "TV",
          "signature": "Input src t-\u003esrc t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Input.html#v:input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eOutput\u003c/a\u003e\u003c/code\u003e transformations, as a deep arrow.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV.OFun",
          "name": "OFun",
          "package": "TV",
          "source": "src/Interface-TV-OFun.html",
          "type": "module"
        },
        "index": {
          "description": "Output transformations as deep arrow",
          "hierarchy": "Interface TV OFun",
          "module": "Interface.TV.OFun",
          "name": "OFun",
          "package": "TV",
          "partial": "OFun",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-OFun.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput functions as a \u003ccode\u003e\u003ca\u003eDeepArrow\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.OFun",
          "name": "OFun",
          "package": "TV",
          "source": "src/Interface-TV-OFun.html#OFun",
          "type": "data"
        },
        "index": {
          "description": "Output functions as DeepArrow",
          "hierarchy": "Interface TV OFun",
          "module": "Interface.TV.OFun",
          "name": "OFun",
          "package": "TV",
          "partial": "OFun",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-OFun.html#t:OFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput functions.\n\u003c/p\u003e",
          "module": "Interface.TV.OFun",
          "name": "OX",
          "package": "TV",
          "source": "src/Interface-TV-OFun.html#OX",
          "type": "type"
        },
        "index": {
          "description": "Output functions",
          "hierarchy": "Interface TV OFun",
          "module": "Interface.TV.OFun",
          "name": "OX",
          "package": "TV",
          "partial": "OX",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-OFun.html#t:OX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003ewrapF\u003c/code\u003e, but for outputs and reversed orientation.\n Specialization of \u003ccode\u003ewrapAO\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Interface.TV.OFun",
          "name": "wrapO",
          "package": "TV",
          "signature": "(b' -\u003e b) -\u003e (a -\u003e a') -\u003e OX dom ran (a -\u003e b) (a' -\u003e b')",
          "source": "src/Interface-TV-OFun.html#wrapO",
          "type": "function"
        },
        "index": {
          "description": "Like wrapF but for outputs and reversed orientation Specialization of wrapAO",
          "hierarchy": "Interface TV OFun",
          "module": "Interface.TV.OFun",
          "name": "wrapO",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003eOX e f(c-\u003eb)(d-\u003ea)",
          "package": "TV",
          "signature": "(b'-\u003eb)-\u003e(a-\u003ea')-\u003eOX dom ran(a-\u003eb)(a'-\u003eb')",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-OFun.html#v:wrapO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOutputs (interfaces) -- means of presenting values\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV.Output",
          "name": "Output",
          "package": "TV",
          "source": "src/Interface-TV-Output.html",
          "type": "module"
        },
        "index": {
          "description": "Outputs interfaces means of presenting values",
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "Output",
          "package": "TV",
          "partial": "Output",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003eOutput\u003c/em\u003e describes a way to present a functional value, perhaps\n interactively.  It is the user-interface half of a tangible value.\n The constructors: primitive, function, pairing, and title.\n\u003c/p\u003e",
          "module": "Interface.TV.Output",
          "name": "Output",
          "package": "TV",
          "source": "src/Interface-TV-Output.html#Output",
          "type": "data"
        },
        "index": {
          "description": "An Output describes way to present functional value perhaps interactively It is the user-interface half of tangible value The constructors primitive function pairing and title",
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "Output",
          "package": "TV",
          "partial": "Output",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#t:Output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Output",
          "name": "OLambda",
          "package": "TV",
          "signature": "Input src a -\u003e Output src snk b -\u003e Output src snk (a -\u003e b)",
          "source": "src/Interface-TV-Output.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "OLambda",
          "normalized": "Input a b-\u003eOutput a c d-\u003eOutput a c(b-\u003ed)",
          "package": "TV",
          "partial": "OLambda",
          "signature": "Input src a-\u003eOutput src snk b-\u003eOutput src snk(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:OLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Output",
          "name": "OPair",
          "package": "TV",
          "signature": "Output src snk a -\u003e Output src snk b -\u003e Output src snk (a, b)",
          "source": "src/Interface-TV-Output.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "OPair",
          "normalized": "Output a b c-\u003eOutput a b d-\u003eOutput a b(c,d)",
          "package": "TV",
          "partial": "OPair",
          "signature": "Output src snk a-\u003eOutput src snk b-\u003eOutput src snk(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:OPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Output",
          "name": "OPrim",
          "package": "TV",
          "signature": "snk a -\u003e Output src snk a",
          "source": "src/Interface-TV-Output.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "OPrim",
          "normalized": "a b-\u003eOutput c a b",
          "package": "TV",
          "partial": "OPrim",
          "signature": "snk a-\u003eOutput src snk a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:OPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Output",
          "name": "OTitle",
          "package": "TV",
          "signature": "String -\u003e Output src snk a -\u003e Output src snk a",
          "source": "src/Interface-TV-Output.html#Output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "OTitle",
          "normalized": "String-\u003eOutput a b c-\u003eOutput a b c",
          "package": "TV",
          "partial": "OTitle",
          "signature": "String-\u003eOutput src snk a-\u003eOutput src snk a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:OTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDissect a function-valued output into input & output.  Loses outer \u003ccode\u003e\u003ca\u003eoTitle\u003c/a\u003e\u003c/code\u003es.\n Must be a (possibly titled) pair-style input.\n\u003c/p\u003e",
          "module": "Interface.TV.Output",
          "name": "asOLambda",
          "package": "TV",
          "signature": "Output src snk (a -\u003e b) -\u003e (Input src a, Output src snk b)",
          "source": "src/Interface-TV-Output.html#asOLambda",
          "type": "function"
        },
        "index": {
          "description": "Dissect function-valued output into input output Loses outer oTitle Must be possibly titled pair-style input",
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "asOLambda",
          "normalized": "Output a b(c-\u003ed)-\u003e(Input a c,Output a b d)",
          "package": "TV",
          "partial": "OLambda",
          "signature": "Output src snk(a-\u003eb)-\u003e(Input src a,Output src snk b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:asOLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Output",
          "name": "asOPair",
          "package": "TV",
          "signature": "Output src snk (a, b) -\u003e (Output src snk a, Output src snk b)",
          "source": "src/Interface-TV-Output.html#asOPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "asOPair",
          "normalized": "Output a b(c,d)-\u003e(Output a b c,Output a b d)",
          "package": "TV",
          "partial": "OPair",
          "signature": "Output src snk(a,b)-\u003e(Output src snk a,Output src snk b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:asOPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVisualize a function.  Akin to \u003cem\u003elambda\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Output",
          "name": "oLambda",
          "package": "TV",
          "signature": "Input src a -\u003e Output src snk b -\u003e Output src snk (a -\u003e b)",
          "source": "src/Interface-TV-Output.html#oLambda",
          "type": "function"
        },
        "index": {
          "description": "Visualize function Akin to lambda",
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "oLambda",
          "normalized": "Input a b-\u003eOutput a c d-\u003eOutput a c(b-\u003ed)",
          "package": "TV",
          "partial": "Lambda",
          "signature": "Input src a-\u003eOutput src snk b-\u003eOutput src snk(a-\u003eb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:oLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVisualize a pair\n\u003c/p\u003e",
          "module": "Interface.TV.Output",
          "name": "oPair",
          "package": "TV",
          "signature": "Output src snk a -\u003e Output src snk b -\u003e Output src snk (a, b)",
          "source": "src/Interface-TV-Output.html#oPair",
          "type": "function"
        },
        "index": {
          "description": "Visualize pair",
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "oPair",
          "normalized": "Output a b c-\u003eOutput a b d-\u003eOutput a b(c,d)",
          "package": "TV",
          "partial": "Pair",
          "signature": "Output src snk a-\u003eOutput src snk b-\u003eOutput src snk(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:oPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput primitive\n\u003c/p\u003e",
          "module": "Interface.TV.Output",
          "name": "oPrim",
          "package": "TV",
          "signature": "snk a -\u003e Output src snk a",
          "source": "src/Interface-TV-Output.html#oPrim",
          "type": "function"
        },
        "index": {
          "description": "Output primitive",
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "oPrim",
          "normalized": "a b-\u003eOutput c a b",
          "package": "TV",
          "partial": "Prim",
          "signature": "snk a-\u003eOutput src snk a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:oPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTitle (label) an output\n\u003c/p\u003e",
          "module": "Interface.TV.Output",
          "name": "oTitle",
          "package": "TV",
          "signature": "String -\u003e Output src snk a -\u003e Output src snk a",
          "source": "src/Interface-TV-Output.html#oTitle",
          "type": "function"
        },
        "index": {
          "description": "Title label an output",
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "oTitle",
          "normalized": "String-\u003eOutput a b c-\u003eOutput a b c",
          "package": "TV",
          "partial": "Title",
          "signature": "String-\u003eOutput src snk a-\u003eOutput src snk a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:oTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Interface.TV.Output",
          "name": "output",
          "package": "TV",
          "signature": "Output src snk t -\u003e snk t",
          "source": "src/Interface-TV-Output.html#output",
          "type": "function"
        },
        "index": {
          "hierarchy": "Interface TV Output",
          "module": "Interface.TV.Output",
          "name": "output",
          "normalized": "Output a b c-\u003eb c",
          "package": "TV",
          "signature": "Output src snk t-\u003esnk t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Output.html#v:output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTangible values -- interface (output) and value, combined & separable\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV.Tangible",
          "name": "Tangible",
          "package": "TV",
          "source": "src/Interface-TV-Tangible.html",
          "type": "module"
        },
        "index": {
          "description": "Tangible values interface output and value combined separable",
          "hierarchy": "Interface TV Tangible",
          "module": "Interface.TV.Tangible",
          "name": "Tangible",
          "package": "TV",
          "partial": "Tangible",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Tangible.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUseful to define disambiguating type-specializations of \u003ccode\u003e\u003ca\u003erunTV\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Tangible",
          "name": "RunTV",
          "package": "TV",
          "source": "src/Interface-TV-Tangible.html#RunTV",
          "type": "type"
        },
        "index": {
          "description": "Useful to define disambiguating type-specializations of runTV",
          "hierarchy": "Interface TV Tangible",
          "module": "Interface.TV.Tangible",
          "name": "RunTV",
          "package": "TV",
          "partial": "Run TV",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Tangible.html#t:RunTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTangible values (TVs).\n\u003c/p\u003e",
          "module": "Interface.TV.Tangible",
          "name": "TV",
          "package": "TV",
          "source": "src/Interface-TV-Tangible.html#TV",
          "type": "type"
        },
        "index": {
          "description": "Tangible values TVs",
          "hierarchy": "Interface TV Tangible",
          "module": "Interface.TV.Tangible",
          "name": "TV",
          "package": "TV",
          "partial": "TV",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Tangible.html#t:TV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrow on \u003ccode\u003e\u003ca\u003eTV\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Interface.TV.Tangible",
          "name": "TVFun",
          "package": "TV",
          "source": "src/Interface-TV-Tangible.html#TVFun",
          "type": "type"
        },
        "index": {
          "description": "Arrow on TV",
          "hierarchy": "Interface TV Tangible",
          "module": "Interface.TV.Tangible",
          "name": "TVFun",
          "package": "TV",
          "partial": "TVFun",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Tangible.html#t:TVFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eTV\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Tangible",
          "name": "runTV",
          "package": "TV",
          "signature": "RunTV src snk",
          "source": "src/Interface-TV-Tangible.html#runTV",
          "type": "function"
        },
        "index": {
          "description": "Run TV",
          "hierarchy": "Interface TV Tangible",
          "module": "Interface.TV.Tangible",
          "name": "runTV",
          "package": "TV",
          "partial": "TV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Tangible.html#v:runTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a \u003ccode\u003e\u003ca\u003eTV\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Tangible",
          "name": "tv",
          "package": "TV",
          "signature": "Output src snk a -\u003e a -\u003e TV src snk a",
          "source": "src/Interface-TV-Tangible.html#tv",
          "type": "function"
        },
        "index": {
          "description": "Make TV",
          "hierarchy": "Interface TV Tangible",
          "module": "Interface.TV.Tangible",
          "name": "tv",
          "normalized": "Output a b c-\u003ec-\u003eTV a b c",
          "package": "TV",
          "signature": "Output src snk a-\u003ea-\u003eTV src snk a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Tangible.html#v:tv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDissect a \u003ccode\u003e\u003ca\u003eTV\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Interface.TV.Tangible",
          "name": "unTv",
          "package": "TV",
          "signature": "TV src snk a -\u003e (Output src snk a, a)",
          "source": "src/Interface-TV-Tangible.html#unTv",
          "type": "function"
        },
        "index": {
          "description": "Dissect TV",
          "hierarchy": "Interface TV Tangible",
          "module": "Interface.TV.Tangible",
          "name": "unTv",
          "normalized": "TV a b c-\u003e(Output a b c,c)",
          "package": "TV",
          "partial": "Tv",
          "signature": "TV src snk a-\u003e(Output src snk a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV-Tangible.html#v:unTv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePackage up the various TV modules into one.  Also re-exports\n DeepArrow modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Interface.TV",
          "name": "TV",
          "package": "TV",
          "source": "src/Interface-TV.html",
          "type": "module"
        },
        "index": {
          "description": "Package up the various TV modules into one Also re-exports DeepArrow modules",
          "hierarchy": "Interface TV",
          "module": "Interface.TV",
          "name": "TV",
          "package": "TV",
          "partial": "TV",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/TV/docs/Interface-TV.html#"
      }
    }
  ]
]