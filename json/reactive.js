[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "reactive"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAdd bounds to an ordered type\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.AddBounds",
          "name": "AddBounds",
          "package": "reactive",
          "source": "src/Data-AddBounds.html",
          "type": "module"
        },
        "index": {
          "description": "Add bounds to an ordered type",
          "hierarchy": "Data AddBounds",
          "module": "Data.AddBounds",
          "name": "AddBounds",
          "package": "reactive",
          "partial": "Add Bounds",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-AddBounds.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap a type into one having new least and greatest elements,\n preserving the existing ordering.\n\u003c/p\u003e",
          "module": "Data.AddBounds",
          "name": "AddBounds",
          "package": "reactive",
          "source": "src/Data-AddBounds.html#AddBounds",
          "type": "data"
        },
        "index": {
          "description": "Wrap type into one having new least and greatest elements preserving the existing ordering",
          "hierarchy": "Data AddBounds",
          "module": "Data.AddBounds",
          "name": "AddBounds",
          "package": "reactive",
          "partial": "Add Bounds",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-AddBounds.html#t:AddBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AddBounds",
          "name": "MaxBound",
          "package": "reactive",
          "signature": "MaxBound",
          "source": "src/Data-AddBounds.html#AddBounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AddBounds",
          "module": "Data.AddBounds",
          "name": "MaxBound",
          "package": "reactive",
          "partial": "Max Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-AddBounds.html#v:MaxBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AddBounds",
          "name": "MinBound",
          "package": "reactive",
          "signature": "MinBound",
          "source": "src/Data-AddBounds.html#AddBounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AddBounds",
          "module": "Data.AddBounds",
          "name": "MinBound",
          "package": "reactive",
          "partial": "Min Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-AddBounds.html#v:MinBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AddBounds",
          "name": "NoBound",
          "package": "reactive",
          "signature": "NoBound a",
          "source": "src/Data-AddBounds.html#AddBounds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data AddBounds",
          "module": "Data.AddBounds",
          "name": "NoBound",
          "package": "reactive",
          "partial": "No Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-AddBounds.html#v:NoBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMax monoid\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Max",
          "name": "Max",
          "package": "reactive",
          "source": "src/Data-Max.html",
          "type": "module"
        },
        "index": {
          "description": "Max monoid",
          "hierarchy": "Data Max",
          "module": "Data.Max",
          "name": "Max",
          "package": "reactive",
          "partial": "Max",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Max.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered monoid under \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Max",
          "name": "Max",
          "package": "reactive",
          "source": "src/Data-Max.html#Max",
          "type": "newtype"
        },
        "index": {
          "description": "Ordered monoid under max",
          "hierarchy": "Data Max",
          "module": "Data.Max",
          "name": "Max",
          "package": "reactive",
          "partial": "Max",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Max.html#t:Max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Max",
          "name": "Max",
          "package": "reactive",
          "signature": "Max",
          "source": "src/Data-Max.html#Max",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Max",
          "module": "Data.Max",
          "name": "Max",
          "package": "reactive",
          "partial": "Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Max.html#v:Max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Max",
          "name": "getMax",
          "package": "reactive",
          "signature": "a",
          "source": "src/Data-Max.html#Max",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Max",
          "module": "Data.Max",
          "name": "getMax",
          "package": "reactive",
          "partial": "Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Max.html#v:getMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMin monoid\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Min",
          "name": "Min",
          "package": "reactive",
          "source": "src/Data-Min.html",
          "type": "module"
        },
        "index": {
          "description": "Min monoid",
          "hierarchy": "Data Min",
          "module": "Data.Min",
          "name": "Min",
          "package": "reactive",
          "partial": "Min",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Min.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered monoid under \u003ccode\u003e\u003ca\u003emin\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Min",
          "name": "Min",
          "package": "reactive",
          "source": "src/Data-Min.html#Min",
          "type": "newtype"
        },
        "index": {
          "description": "Ordered monoid under min",
          "hierarchy": "Data Min",
          "module": "Data.Min",
          "name": "Min",
          "package": "reactive",
          "partial": "Min",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Min.html#t:Min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Min",
          "name": "Min",
          "package": "reactive",
          "signature": "Min",
          "source": "src/Data-Min.html#Min",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Min",
          "module": "Data.Min",
          "name": "Min",
          "package": "reactive",
          "partial": "Min",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Min.html#v:Min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Min",
          "name": "getMin",
          "package": "reactive",
          "signature": "a",
          "source": "src/Data-Min.html#Min",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Min",
          "module": "Data.Min",
          "name": "getMin",
          "package": "reactive",
          "partial": "Min",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-Min.html#v:getMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWriter monad as a pair.  Until it's in Control.Monad.Instances.\n\u003c/p\u003e\u003cp\u003eUse \u003ccode\u003eimport Data.PairMonad ()\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.PairMonad",
          "name": "PairMonad",
          "package": "reactive",
          "source": "src/Data-PairMonad.html",
          "type": "module"
        },
        "index": {
          "description": "Writer monad as pair Until it in Control.Monad.Instances Use import Data.PairMonad",
          "hierarchy": "Data PairMonad",
          "module": "Data.PairMonad",
          "name": "PairMonad",
          "package": "reactive",
          "partial": "Pair Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/Data-PairMonad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReactive behaviors (continuous time)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Behavior",
          "name": "Behavior",
          "package": "reactive",
          "source": "src/FRP-Reactive-Behavior.html",
          "type": "module"
        },
        "index": {
          "description": "Reactive behaviors continuous time",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "Behavior",
          "package": "reactive",
          "partial": "Behavior",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTime-specialized behaviors.\n Note: The signatures of all of the behavior functions can be generalized.  Is\n the interface generality worth the complexity?\n\u003c/p\u003e",
          "module": "FRP.Reactive.Behavior",
          "name": "Behavior",
          "package": "reactive",
          "source": "src/FRP-Reactive-Behavior.html#Behavior",
          "type": "type"
        },
        "index": {
          "description": "Time-specialized behaviors Note The signatures of all of the behavior functions can be generalized Is the interface generality worth the complexity",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "Behavior",
          "package": "reactive",
          "partial": "Behavior",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#t:Behavior"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive behaviors.  They can be understood in terms of a simple\n model (denotational semantics) as functions of time, namely \u003ccode\u003eat ::\n BehaviorG t a -\u003e (t -\u003e a)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe semantics of \u003ccode\u003e\u003ca\u003eBehaviorG\u003c/a\u003e\u003c/code\u003e instances are given by corresponding\n instances for the semantic model (functions).  See\n \u003ca\u003ehttp://conal.net/blog/posts/simplifying-semantics-with-type-class-morphisms/\u003c/a\u003e.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (fmap f r) == fmap f (at r)\u003c/code\u003e, i.e., \u003ccode\u003efmap f r \u003ccode\u003eat\u003c/code\u003e\n   t == f (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (pure a) == pure a\u003c/code\u003e, and \u003ccode\u003eat (s \u003c*\u003e r) == at s\n   \u003c*\u003e at t\u003c/code\u003e.  That is, \u003ccode\u003epure a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003e(s \u003c*\u003e r) \u003ccode\u003eat\u003c/code\u003e t\n   == (s \u003ccode\u003eat\u003c/code\u003e t) (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (return a) == return a\u003c/code\u003e, and \u003ccode\u003eat (join rr) == join (at\n   . at rr)\u003c/code\u003e.  That is, \u003ccode\u003ereturn a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003ejoin rr \u003ccode\u003eat\u003c/code\u003e t ==\n   (rr \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003eat\u003c/code\u003e t\u003c/code\u003e.  As always, \u003ccode\u003e(r \u003e\u003e= f) == join (fmap f r)\u003c/code\u003e.\n   \u003ccode\u003eat (r \u003e\u003e= f) == at r \u003e\u003e= at . f\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e: a typical lifted monoid.  If \u003ccode\u003eo\u003c/code\u003e is a monoid, then\n   \u003ccode\u003eReactive o\u003c/code\u003e is a monoid, with \u003ccode\u003emempty == pure mempty\u003c/code\u003e, and \u003ccode\u003emappend\n   == liftA2 mappend\u003c/code\u003e.  That is, \u003ccode\u003emempty \u003ccode\u003eat\u003c/code\u003e t == mempty\u003c/code\u003e, and \u003ccode\u003e(r\n   \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e s) \u003ccode\u003eat\u003c/code\u003e t == (r \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e (s \u003ccode\u003eat\u003c/code\u003e t).\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive.Behavior",
          "name": "BehaviorG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Behavior.html#BehaviorG",
          "type": "data"
        },
        "index": {
          "description": "Reactive behaviors They can be understood in terms of simple model denotational semantics as functions of time namely at BehaviorG The semantics of BehaviorG instances are given by corresponding instances for the semantic model functions See http conal.net blog posts simplifying-semantics-with-type-class-morphisms Functor at fmap fmap at i.e fmap at at Applicative at pure pure and at at at That is pure at and at at at Monad at return return and at join rr join at at rr That is return at and join rr at rr at at As always join fmap at at at Monoid typical lifted monoid If is monoid then Reactive is monoid with mempty pure mempty and mappend liftA2 mappend That is mempty at mempty and mappend at at mappend at",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "BehaviorG",
          "package": "reactive",
          "partial": "Behavior",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#t:BehaviorG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Behavior",
          "name": "Behaviour",
          "package": "reactive",
          "source": "src/FRP-Reactive-Behavior.html#Behaviour",
          "type": "type"
        },
        "index": {
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "Behaviour",
          "package": "reactive",
          "partial": "Behaviour",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#t:Behaviour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBehavior from an initial value and an updater event.  See also\n \u003ccode\u003eaccumE\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumB :: a -\u003e Event (a -\u003e a) -\u003e Behavior a\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "accumB",
          "package": "reactive",
          "signature": "a -\u003e EventI t (a -\u003e a) -\u003e BehaviorI t a",
          "source": "src/FRP-Reactive-Behavior.html#accumB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:accumB\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:accumB\"]"
        },
        "index": {
          "description": "Behavior from an initial value and an updater event See also accumE accumB Event Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "accumB",
          "normalized": "a-\u003eEventI b(a-\u003ea)-\u003eBehaviorI b a",
          "package": "reactive",
          "signature": "a-\u003eEventI t(a-\u003ea)-\u003eBehaviorI t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:accumB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount occurrences of an event.  See also \u003ccode\u003ecountE\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e countB :: Num n =\u003e Event a -\u003e Behavior n\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "countB",
          "package": "reactive",
          "signature": "EventI t a -\u003e BehaviorI t n",
          "source": "src/FRP-Reactive-Behavior.html#countB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:countB\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:countB\"]"
        },
        "index": {
          "description": "Count occurrences of an event See also countE countB Num Event Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "countB",
          "normalized": "EventI a b-\u003eBehaviorI a c",
          "package": "reactive",
          "signature": "EventI t a-\u003eBehaviorI t n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:countB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlip-flopping behavior.  Turns true whenever first event occurs and\n false whenever the second event occurs.\n\u003c/p\u003e\u003cpre\u003e flipFlop :: Event a -\u003e Event b -\u003e Behavior Bool\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "flipFlop",
          "package": "reactive",
          "signature": "EventI t a -\u003e EventI t b -\u003e BehaviorI t Bool",
          "source": "src/FRP-Reactive-Behavior.html#flipFlop",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:flipFlop\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:flipFlop\"]"
        },
        "index": {
          "description": "Flip-flopping behavior Turns true whenever first event occurs and false whenever the second event occurs flipFlop Event Event Behavior Bool",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "flipFlop",
          "normalized": "EventI a b-\u003eEventI a c-\u003eBehaviorI a Bool",
          "package": "reactive",
          "partial": "Flop",
          "signature": "EventI t a-\u003eEventI t b-\u003eBehaviorI t Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:flipFlop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEuler integral.\n\u003c/p\u003e\u003cpre\u003e integral :: (VectorSpace v, Scalar v ~ TimeT) =\u003e\n             Event () -\u003e Behavior v -\u003e Behavior v\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "integral",
          "package": "reactive",
          "signature": "EventI t a -\u003e BehaviorI t v -\u003e BehaviorI t v",
          "source": "src/FRP-Reactive-Behavior.html#integral",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:integral\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:integral\"]"
        },
        "index": {
          "description": "Euler integral integral VectorSpace Scalar TimeT Event Behavior Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "integral",
          "normalized": "EventI a b-\u003eBehaviorI a c-\u003eBehaviorI a c",
          "package": "reactive",
          "signature": "EventI t a-\u003eBehaviorI t v-\u003eBehaviorI t v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart out blank (\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e), latching onto each new \u003ccode\u003ea\u003c/code\u003e, and blanking\n on each \u003ccode\u003eb\u003c/code\u003e.  If you just want to latch and not blank, then use\n \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e for the second event.\n\u003c/p\u003e\u003cpre\u003e maybeB :: Event a -\u003e Event b -\u003e Behavior (Maybe a)\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "maybeB",
          "package": "reactive",
          "signature": "EventI t a -\u003e EventI t b -\u003e BehaviorI t (Maybe a)",
          "source": "src/FRP-Reactive-Behavior.html#maybeB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:maybeB\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:maybeB\"]"
        },
        "index": {
          "description": "Start out blank Nothing latching onto each new and blanking on each If you just want to latch and not blank then use mempty for the second event maybeB Event Event Behavior Maybe",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "maybeB",
          "normalized": "EventI a b-\u003eEventI a c-\u003eBehaviorI a(Maybe b)",
          "package": "reactive",
          "signature": "EventI t a-\u003eEventI t b-\u003eBehaviorI t(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:maybeB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccumulate values from a monoid-valued event.  Specialization of\n \u003ccode\u003e\u003ca\u003escanlB\u003c/a\u003e\u003c/code\u003e, using \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e.  See also \u003ccode\u003emonoidE\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e monoidB :: Monoid a =\u003e Event (Behavior a) -\u003e Behavior a\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "monoidB",
          "package": "reactive",
          "signature": "EventG tr (BehaviorG tr tf a) -\u003e BehaviorG tr tf a",
          "source": "src/FRP-Reactive-Behavior.html#monoidB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:monoidB\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:monoidB\"]"
        },
        "index": {
          "description": "Accumulate values from monoid-valued event Specialization of scanlB using mappend and mempty See also monoidE monoidB Monoid Event Behavior Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "monoidB",
          "normalized": "EventG a(BehaviorG a b c)-\u003eBehaviorG a b c",
          "package": "reactive",
          "signature": "EventG tr(BehaviorG tr tf a)-\u003eBehaviorG tr tf a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:monoidB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e for behaviors.  See also \u003ccode\u003escanlE\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e scanlB :: forall a. (Behavior a -\u003e Behavior a -\u003e Behavior a) -\u003e Behavior a\n        -\u003e Event (Behavior a) -\u003e Behavior a\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "scanlB",
          "package": "reactive",
          "signature": "(b -\u003e BehaviorG tr tf a -\u003e BehaviorG tr tf a) -\u003e BehaviorG tr tf a -\u003e EventG tr b -\u003e BehaviorG tr tf a",
          "source": "src/FRP-Reactive-Behavior.html#scanlB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:scanlB\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:scanlB\"]"
        },
        "index": {
          "description": "Like scanl for behaviors See also scanlE scanlB forall Behavior Behavior Behavior Behavior Event Behavior Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "scanlB",
          "normalized": "(a-\u003eBehaviorG b c d-\u003eBehaviorG b c d)-\u003eBehaviorG b c d-\u003eEventG b a-\u003eBehaviorG b c d",
          "package": "reactive",
          "signature": "(b-\u003eBehaviorG tr tf a-\u003eBehaviorG tr tf a)-\u003eBehaviorG tr tf a-\u003eEventG tr b-\u003eBehaviorG tr tf a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:scanlB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSnapshot a behavior whenever an event occurs.  See also\n \u003ccode\u003e\u003ca\u003esnapshotWith\u003c/a\u003e\u003c/code\u003e.  Take careful note of the order of arguments and\n results.\n\u003c/p\u003e\u003cpre\u003e snapshot :: Behavior b -\u003e Event a -\u003e Event (a,b)\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "snapshot",
          "package": "reactive",
          "signature": "BehaviorI t b -\u003e EventI t a -\u003e EventI t (a, b)",
          "source": "src/FRP-Reactive-Behavior.html#snapshot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:snapshot\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:snapshot\"]"
        },
        "index": {
          "description": "Snapshot behavior whenever an event occurs See also snapshotWith Take careful note of the order of arguments and results snapshot Behavior Event Event",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "snapshot",
          "normalized": "BehaviorI a b-\u003eEventI a c-\u003eEventI a(c,b)",
          "package": "reactive",
          "signature": "BehaviorI t b-\u003eEventI t a-\u003eEventI t(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:snapshot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSnapshots a behavior whenever an event occurs and combines the values\n using the combining function passed.  Take careful note of the order of\n arguments and results.\n\u003c/p\u003e\u003cpre\u003e snapshotWith :: (a -\u003e b -\u003e c) -\u003e Behavior b -\u003e Event a -\u003e Event c\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "snapshotWith",
          "package": "reactive",
          "signature": "(a -\u003e b -\u003e c) -\u003e BehaviorI t b -\u003e EventI t a -\u003e EventI t c",
          "source": "src/FRP-Reactive-Behavior.html#snapshotWith",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:snapshotWith\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:snapshotWith\"]"
        },
        "index": {
          "description": "Snapshots behavior whenever an event occurs and combines the values using the combining function passed Take careful note of the order of arguments and results snapshotWith Behavior Event Event",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "snapshotWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eBehaviorI d b-\u003eEventI d a-\u003eEventI d c",
          "package": "reactive",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eBehaviorI t b-\u003eEventI t a-\u003eEventI t c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:snapshotWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003esnapshot\u003c/a\u003e\u003c/code\u003e but discarding event data (often \u003ccode\u003ea\u003c/code\u003e is '()').\n\u003c/p\u003e\u003cpre\u003e snapshot_ :: Behavior b -\u003e Event a -\u003e Event b\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "snapshot_",
          "package": "reactive",
          "signature": "BehaviorI t b -\u003e EventI t a -\u003e EventI t b",
          "source": "src/FRP-Reactive-Behavior.html#snapshot_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:snapshot_\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:snapshot_\"]"
        },
        "index": {
          "description": "Like snapshot but discarding event data often is snapshot Behavior Event Event",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "snapshot_",
          "normalized": "BehaviorI a b-\u003eEventI a c-\u003eEventI a b",
          "package": "reactive",
          "signature": "BehaviorI t b-\u003eEventI t a-\u003eEventI t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:snapshot_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiscretely changing behavior, based on an initial value and a\n new-value event.\n\u003c/p\u003e\u003cpre\u003estepper :: a -\u003e Event a -\u003e Behavior a\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "stepper",
          "package": "reactive",
          "signature": "a -\u003e EventI t a -\u003e BehaviorI t a",
          "source": "src/FRP-Reactive-Behavior.html#stepper",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:stepper\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:stepper\"]"
        },
        "index": {
          "description": "Discretely changing behavior based on an initial value and new-value event stepper Event Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "stepper",
          "normalized": "a-\u003eEventI b a-\u003eBehaviorI b a",
          "package": "reactive",
          "signature": "a-\u003eEventI t a-\u003eBehaviorI t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:stepper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e for behaviors.\n\u003c/p\u003e\u003cpre\u003e sumB :: AdditiveGroup a =\u003e Event a -\u003e Behavior a\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "sumB",
          "package": "reactive",
          "signature": "EventI t a -\u003e BehaviorI t a",
          "source": "src/FRP-Reactive-Behavior.html#sumB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:sumB\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:sumB\"]"
        },
        "index": {
          "description": "Like sum for behaviors sumB AdditiveGroup Event Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "sumB",
          "normalized": "EventI a b-\u003eBehaviorI a b",
          "package": "reactive",
          "signature": "EventI t a-\u003eBehaviorI t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:sumB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch between behaviors.\n\u003c/p\u003e\u003cpre\u003e switcher :: Behavior a -\u003e Event (Behavior a) -\u003e Behavior a\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "switcher",
          "package": "reactive",
          "signature": "BehaviorG tr tf a -\u003e EventG tr (BehaviorG tr tf a) -\u003e BehaviorG tr tf a",
          "source": "src/FRP-Reactive-Behavior.html#switcher",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:switcher\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:switcher\"]"
        },
        "index": {
          "description": "Switch between behaviors switcher Behavior Event Behavior Behavior",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "switcher",
          "normalized": "BehaviorG a b c-\u003eEventG a(BehaviorG a b c)-\u003eBehaviorG a b c",
          "package": "reactive",
          "signature": "BehaviorG tr tf a-\u003eEventG tr(BehaviorG tr tf a)-\u003eBehaviorG tr tf a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:switcher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity generalized behavior.  Has value \u003ccode\u003et\u003c/code\u003e at time \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e time :: Behavior TimeT\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "time",
          "package": "reactive",
          "signature": "BehaviorI t t",
          "source": "src/FRP-Reactive-Behavior.html#time",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:time\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:time\"]"
        },
        "index": {
          "description": "The identity generalized behavior Has value at time time Behavior TimeT",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "time",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter an event according to whether a reactive boolean is true.\n\u003c/p\u003e\u003cpre\u003e whenE :: Behavior Bool -\u003e Event a -\u003e Event a\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Behavior\",\"FRP.Reactive\"]",
          "name": "whenE",
          "package": "reactive",
          "signature": "BehaviorI t Bool -\u003e EventI t a -\u003e EventI t a",
          "source": "src/FRP-Reactive-Behavior.html#whenE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:whenE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:whenE\"]"
        },
        "index": {
          "description": "Filter an event according to whether reactive boolean is true whenE Behavior Bool Event Event",
          "hierarchy": "FRP Reactive Behavior",
          "module": "FRP.Reactive.Behavior",
          "name": "whenE",
          "normalized": "BehaviorI a Bool-\u003eEventI a b-\u003eEventI a b",
          "package": "reactive",
          "signature": "BehaviorI t Bool-\u003eEventI t a-\u003eEventI t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Behavior.html#v:whenE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions, with constant functions optimized, with instances for many\n standard classes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Fun",
          "name": "Fun",
          "package": "reactive",
          "source": "src/FRP-Reactive-Fun.html",
          "type": "module"
        },
        "index": {
          "description": "Functions with constant functions optimized with instances for many standard classes",
          "hierarchy": "FRP Reactive Fun",
          "module": "FRP.Reactive.Fun",
          "name": "Fun",
          "package": "reactive",
          "partial": "Fun",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Fun.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant-optimized functions\n\u003c/p\u003e",
          "module": "FRP.Reactive.Fun",
          "name": "Fun",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Fun.html#Fun",
          "type": "data"
        },
        "index": {
          "description": "Constant-optimized functions",
          "hierarchy": "FRP Reactive Fun",
          "module": "FRP.Reactive.Fun",
          "name": "Fun",
          "package": "reactive",
          "partial": "Fun",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Fun.html#t:Fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eFun\u003c/a\u003e\u003c/code\u003e as a function\n\u003c/p\u003e",
          "module": "FRP.Reactive.Fun",
          "name": "apply",
          "package": "reactive",
          "signature": "Fun t a -\u003e t -\u003e a",
          "source": "src/FRP-Reactive-Fun.html#apply",
          "type": "function"
        },
        "index": {
          "description": "Fun as function",
          "hierarchy": "FRP Reactive Fun",
          "module": "FRP.Reactive.Fun",
          "name": "apply",
          "normalized": "Fun a b-\u003ea-\u003eb",
          "package": "reactive",
          "signature": "Fun t a-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Fun.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Fun",
          "name": "batch",
          "package": "reactive",
          "signature": "TestBatch",
          "source": "src/FRP-Reactive-Fun.html#batch",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Fun",
          "module": "FRP.Reactive.Fun",
          "name": "batch",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Fun.html#v:batch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Fun",
          "name": "fun",
          "package": "reactive",
          "signature": "(t -\u003e a) -\u003e Fun t a",
          "source": "src/FRP-Reactive-Fun.html#fun",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Fun",
          "module": "FRP.Reactive.Fun",
          "name": "fun",
          "normalized": "(a-\u003eb)-\u003eFun a b",
          "package": "reactive",
          "signature": "(t-\u003ea)-\u003eFun t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Fun.html#v:fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple formulation of functional \u003cem\u003efutures\u003c/em\u003e, roughly as\n described at \u003ca\u003ehttp://en.wikipedia.org/wiki/Futures_and_promises\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eA \u003cem\u003efuture\u003c/em\u003e is a value with an associated time of \u003cem\u003earrival\u003c/em\u003e.  Typically,\n neither the time nor the value can be known until the arrival time.\n\u003c/p\u003e\u003cp\u003ePrimitive futures can be things like /the value of the next key you\n press\u003cem\u003e, or \u003c/em\u003ethe value of LambdaPix stock at noon next Monday/.\n\u003c/p\u003e\u003cp\u003eComposition is via standard type classes: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003eApplicative\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e.  Some comments on the \u003ccode\u003e\u003ca\u003eFuture\u003c/a\u003e\u003c/code\u003e instances of\n these classes:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Monoid: \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e is a future that never arrives (infinite time and\n   undefined value), and \u003ccode\u003ea \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e is the earlier of \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e,\n   preferring \u003ccode\u003ea\u003c/code\u003e when simultaneous.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: apply a function to a future argument.  The (future)\n result arrives simultaneously with the argument.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eApplicative\u003c/code\u003e: \u003ccode\u003epure\u003c/code\u003e gives value arriving negative infinity.\n '(\u003c*\u003e)' applies a future function to a future argument, yielding a\n future result that arrives once \u003cem\u003eboth\u003c/em\u003e function and argument have\n arrived (coinciding with the later of the two times).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e is the same as \u003ccode\u003epure\u003c/code\u003e (as usual).  \u003ccode\u003e(\u003e\u003e=)\u003c/code\u003e cascades\n futures.  \u003ccode\u003ejoin\u003c/code\u003e resolves a future future value into a future value.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFutures are parametric over \u003cem\u003etime\u003c/em\u003e as well as \u003cem\u003evalue\u003c/em\u003e types.  The time\n parameter can be any ordered type and is particularly useful with time\n types that have rich partial information structure, such as /improving\n values/.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Future",
          "name": "Future",
          "package": "reactive",
          "source": "src/FRP-Reactive-Future.html",
          "type": "module"
        },
        "index": {
          "description": "simple formulation of functional futures roughly as described at http en.wikipedia.org wiki Futures and promises future is value with an associated time of arrival Typically neither the time nor the value can be known until the arrival time Primitive futures can be things like the value of the next key you press or the value of LambdaPix stock at noon next Monday Composition is via standard type classes Functor Applicative Monad and Monoid Some comments on the Future instances of these classes Monoid mempty is future that never arrives infinite time and undefined value and mappend is the earlier of and preferring when simultaneous Functor apply function to future argument The future result arrives simultaneously with the argument Applicative pure gives value arriving negative infinity applies future function to future argument yielding future result that arrives once both function and argument have arrived coinciding with the later of the two times Monad return is the same as pure as usual cascades futures join resolves future future value into future value Futures are parametric over time as well as value types The time parameter can be any ordered type and is particularly useful with time types that have rich partial information structure such as improving values",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "Future",
          "package": "reactive",
          "partial": "Future",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA future value of type \u003ccode\u003ea\u003c/code\u003e with time type \u003ccode\u003et\u003c/code\u003e.  Simply a\n time/value pair.  Particularly useful with time types that have\n non-flat structure.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Future",
          "name": "FutureG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Future.html#FutureG",
          "type": "newtype"
        },
        "index": {
          "description": "future value of type with time type Simply time value pair Particularly useful with time types that have non-flat structure",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "FutureG",
          "package": "reactive",
          "partial": "Future",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#t:FutureG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTime used in futures.  The parameter \u003ccode\u003et\u003c/code\u003e can be any \u003ccode\u003eOrd\u003c/code\u003e and\n \u003ccode\u003eBounded\u003c/code\u003e type.  Pure values have time \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e, while\n never-occurring futures have time 'maxBound.'\n type Time t = Max (AddBounds t)\n\u003c/p\u003e",
          "module": "FRP.Reactive.Future",
          "name": "Time",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Future.html#Time",
          "type": "type"
        },
        "index": {
          "description": "Time used in futures The parameter can be any Ord and Bounded type Pure values have time minBound while never-occurring futures have time maxBound type Time Max AddBounds",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "Time",
          "package": "reactive",
          "partial": "Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#t:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"FRP.Reactive.Future\",\"FRP.Reactive.Internal.Future\"]",
          "name": "Future",
          "package": "reactive",
          "signature": "Future",
          "source": "src/FRP-Reactive-Internal-Future.html#FutureG",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:Future\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#v:Future\"]"
        },
        "index": {
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "Future",
          "package": "reactive",
          "partial": "Future",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:Future"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Future",
          "name": "batch",
          "package": "reactive",
          "signature": "TestBatch",
          "source": "src/FRP-Reactive-Future.html#batch",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "batch",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:batch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a finite time\n\u003c/p\u003e",
          "module": "FRP.Reactive.Future",
          "name": "ftime",
          "package": "reactive",
          "signature": "t -\u003e Time t",
          "source": "src/FRP-Reactive-Future.html#ftime",
          "type": "function"
        },
        "index": {
          "description": "Make finite time",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "ftime",
          "normalized": "a-\u003eTime a",
          "package": "reactive",
          "signature": "t-\u003eTime t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:ftime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA future's time\n\u003c/p\u003e",
          "module": "FRP.Reactive.Future",
          "name": "futTime",
          "package": "reactive",
          "signature": "FutureG t a -\u003e Time t",
          "source": "src/FRP-Reactive-Future.html#futTime",
          "type": "function"
        },
        "index": {
          "description": "future time",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "futTime",
          "normalized": "FutureG a b-\u003eTime a",
          "package": "reactive",
          "partial": "Time",
          "signature": "FutureG t a-\u003eTime t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:futTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA future's value\n\u003c/p\u003e",
          "module": "FRP.Reactive.Future",
          "name": "futVal",
          "package": "reactive",
          "signature": "FutureG t a -\u003e a",
          "source": "src/FRP-Reactive-Future.html#futVal",
          "type": "function"
        },
        "index": {
          "description": "future value",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "futVal",
          "normalized": "FutureG a b-\u003eb",
          "package": "reactive",
          "partial": "Val",
          "signature": "FutureG t a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:futVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA future value with given time & value\n\u003c/p\u003e",
          "module": "FRP.Reactive.Future",
          "name": "future",
          "package": "reactive",
          "signature": "t -\u003e a -\u003e FutureG t a",
          "source": "src/FRP-Reactive-Future.html#future",
          "type": "function"
        },
        "index": {
          "description": "future value with given time value",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "future",
          "normalized": "a-\u003eb-\u003eFutureG a b",
          "package": "reactive",
          "signature": "t-\u003ea-\u003eFutureG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:future"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a unary function within the \u003ccode\u003e\u003ca\u003eFutureG\u003c/a\u003e\u003c/code\u003e representation.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Future\",\"FRP.Reactive.Internal.Future\"]",
          "name": "inFuture",
          "package": "reactive",
          "signature": "((Time t, a) -\u003e (Time t', b)) -\u003e FutureG t a -\u003e FutureG t' b",
          "source": "src/FRP-Reactive-Internal-Future.html#inFuture",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:inFuture\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#v:inFuture\"]"
        },
        "index": {
          "description": "Apply unary function within the FutureG representation",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "inFuture",
          "normalized": "((Time a,b)-\u003e(Time c,d))-\u003eFutureG a b-\u003eFutureG c d",
          "package": "reactive",
          "partial": "Future",
          "signature": "((Time t,a)-\u003e(Time t',b))-\u003eFutureG t a-\u003eFutureG t' b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:inFuture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a binary function within the \u003ccode\u003e\u003ca\u003eFutureG\u003c/a\u003e\u003c/code\u003e representation.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Future\",\"FRP.Reactive.Internal.Future\"]",
          "name": "inFuture2",
          "package": "reactive",
          "signature": "((Time t, a) -\u003e (Time t', b) -\u003e (Time t', c)) -\u003e FutureG t a -\u003e FutureG t' b -\u003e FutureG t' c",
          "source": "src/FRP-Reactive-Internal-Future.html#inFuture2",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:inFuture2\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#v:inFuture2\"]"
        },
        "index": {
          "description": "Apply binary function within the FutureG representation",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "inFuture2",
          "normalized": "((Time a,b)-\u003e(Time c,d)-\u003e(Time c,e))-\u003eFutureG a b-\u003eFutureG c d-\u003eFutureG c e",
          "package": "reactive",
          "partial": "Future",
          "signature": "((Time t,a)-\u003e(Time t',b)-\u003e(Time t',c))-\u003eFutureG t a-\u003eFutureG t' b-\u003eFutureG t' c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:inFuture2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"FRP.Reactive.Future\",\"FRP.Reactive.Internal.Future\"]",
          "name": "isNeverF",
          "package": "reactive",
          "signature": "FutureG t t1 -\u003e Bool",
          "source": "src/FRP-Reactive-Internal-Future.html#isNeverF",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:isNeverF\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#v:isNeverF\"]"
        },
        "index": {
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "isNeverF",
          "normalized": "FutureG a a-\u003eBool",
          "package": "reactive",
          "partial": "Never",
          "signature": "FutureG t t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:isNeverF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"FRP.Reactive.Future\",\"FRP.Reactive.Internal.Future\"]",
          "name": "unFuture",
          "package": "reactive",
          "signature": "(Time t, a)",
          "source": "src/FRP-Reactive-Internal-Future.html#FutureG",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:unFuture\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#v:unFuture\"]"
        },
        "index": {
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "unFuture",
          "normalized": "(Time a,b)",
          "package": "reactive",
          "partial": "Future",
          "signature": "(Time t,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:unFuture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess time of future\n\u003c/p\u003e",
          "module": "FRP.Reactive.Future",
          "name": "withTimeF",
          "package": "reactive",
          "signature": "FutureG t a -\u003e FutureG t (Time t, a)",
          "source": "src/FRP-Reactive-Future.html#withTimeF",
          "type": "function"
        },
        "index": {
          "description": "Access time of future",
          "hierarchy": "FRP Reactive Future",
          "module": "FRP.Reactive.Future",
          "name": "withTimeF",
          "normalized": "FutureG a b-\u003eFutureG a(Time a,b)",
          "package": "reactive",
          "partial": "Time",
          "signature": "FutureG t a-\u003eFutureG t(Time t,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Future.html#v:withTimeF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImproving values -- efficient version\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Improving",
          "name": "Improving",
          "package": "reactive",
          "source": "src/FRP-Reactive-Improving.html",
          "type": "module"
        },
        "index": {
          "description": "Improving values efficient version",
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "Improving",
          "package": "reactive",
          "partial": "Improving",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn improving value.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Improving",
          "name": "Improving",
          "package": "reactive",
          "source": "src/FRP-Reactive-Improving.html#Improving",
          "type": "data"
        },
        "index": {
          "description": "An improving value",
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "Improving",
          "package": "reactive",
          "partial": "Improving",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#t:Improving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Improving",
          "name": "Imp",
          "package": "reactive",
          "signature": "Imp",
          "source": "src/FRP-Reactive-Improving.html#Improving",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "Imp",
          "package": "reactive",
          "partial": "Imp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:Imp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value known to be \u003ccode\u003e\u003e x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Improving",
          "name": "after",
          "package": "reactive",
          "signature": "a -\u003e Improving a",
          "source": "src/FRP-Reactive-Improving.html#after",
          "type": "function"
        },
        "index": {
          "description": "value known to be",
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "after",
          "normalized": "a-\u003eImproving a",
          "package": "reactive",
          "signature": "a-\u003eImproving a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:after"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Improving",
          "name": "batch",
          "package": "reactive",
          "signature": "TestBatch",
          "source": "src/FRP-Reactive-Improving.html#batch",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "batch",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:batch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value known to be \u003ccode\u003e\u003c x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Improving",
          "name": "before",
          "package": "reactive",
          "signature": "a -\u003e Improving a",
          "source": "src/FRP-Reactive-Improving.html#before",
          "type": "function"
        },
        "index": {
          "description": "value known to be",
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "before",
          "normalized": "a-\u003eImproving a",
          "package": "reactive",
          "signature": "a-\u003eImproving a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:before"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Improving",
          "name": "compareI",
          "package": "reactive",
          "signature": "a -\u003e Ordering",
          "source": "src/FRP-Reactive-Improving.html#Improving",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "compareI",
          "normalized": "a-\u003eOrdering",
          "package": "reactive",
          "signature": "a-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:compareI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Improving",
          "name": "exact",
          "package": "reactive",
          "signature": "a",
          "source": "src/FRP-Reactive-Improving.html#Improving",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "exact",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:exact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA known improving value (which doesn't really improve)\n\u003c/p\u003e",
          "module": "FRP.Reactive.Improving",
          "name": "exactly",
          "package": "reactive",
          "signature": "a -\u003e Improving a",
          "source": "src/FRP-Reactive-Improving.html#exactly",
          "type": "function"
        },
        "index": {
          "description": "known improving value which doesn really improve",
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "exactly",
          "normalized": "a-\u003eImproving a",
          "package": "reactive",
          "signature": "a-\u003eImproving a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:exactly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEfficient combination of \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e and '(\u003e=)'\n\u003c/p\u003e",
          "module": "FRP.Reactive.Improving",
          "name": "maxI",
          "package": "reactive",
          "signature": "Improving a -\u003e Improving a -\u003e (Improving a, Bool)",
          "source": "src/FRP-Reactive-Improving.html#maxI",
          "type": "function"
        },
        "index": {
          "description": "Efficient combination of max and",
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "maxI",
          "normalized": "Improving a-\u003eImproving a-\u003e(Improving a,Bool)",
          "package": "reactive",
          "signature": "Improving a-\u003eImproving a-\u003e(Improving a,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:maxI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEfficient combination of \u003ccode\u003e\u003ca\u003emin\u003c/a\u003e\u003c/code\u003e and '(\u003c=)'\n\u003c/p\u003e",
          "module": "FRP.Reactive.Improving",
          "name": "minI",
          "package": "reactive",
          "signature": "Improving a -\u003e Improving a -\u003e (Improving a, Bool)",
          "source": "src/FRP-Reactive-Improving.html#minI",
          "type": "function"
        },
        "index": {
          "description": "Efficient combination of min and",
          "hierarchy": "FRP Reactive Improving",
          "module": "FRP.Reactive.Improving",
          "name": "minI",
          "normalized": "Improving a-\u003eImproving a-\u003e(Improving a,Bool)",
          "package": "reactive",
          "signature": "Improving a-\u003eImproving a-\u003e(Improving a,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Improving.html#v:minI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation of reactive behaviors\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "Behavior",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Behavior.html",
          "type": "module"
        },
        "index": {
          "description": "Representation of reactive behaviors",
          "hierarchy": "FRP Reactive Internal Behavior",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "Behavior",
          "package": "reactive",
          "partial": "Behavior",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Behavior.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive behaviors.  They can be understood in terms of a simple\n model (denotational semantics) as functions of time, namely \u003ccode\u003eat ::\n BehaviorG t a -\u003e (t -\u003e a)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe semantics of \u003ccode\u003e\u003ca\u003eBehaviorG\u003c/a\u003e\u003c/code\u003e instances are given by corresponding\n instances for the semantic model (functions).  See\n \u003ca\u003ehttp://conal.net/blog/posts/simplifying-semantics-with-type-class-morphisms/\u003c/a\u003e.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (fmap f r) == fmap f (at r)\u003c/code\u003e, i.e., \u003ccode\u003efmap f r \u003ccode\u003eat\u003c/code\u003e\n   t == f (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (pure a) == pure a\u003c/code\u003e, and \u003ccode\u003eat (s \u003c*\u003e r) == at s\n   \u003c*\u003e at t\u003c/code\u003e.  That is, \u003ccode\u003epure a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003e(s \u003c*\u003e r) \u003ccode\u003eat\u003c/code\u003e t\n   == (s \u003ccode\u003eat\u003c/code\u003e t) (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (return a) == return a\u003c/code\u003e, and \u003ccode\u003eat (join rr) == join (at\n   . at rr)\u003c/code\u003e.  That is, \u003ccode\u003ereturn a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003ejoin rr \u003ccode\u003eat\u003c/code\u003e t ==\n   (rr \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003eat\u003c/code\u003e t\u003c/code\u003e.  As always, \u003ccode\u003e(r \u003e\u003e= f) == join (fmap f r)\u003c/code\u003e.\n   \u003ccode\u003eat (r \u003e\u003e= f) == at r \u003e\u003e= at . f\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e: a typical lifted monoid.  If \u003ccode\u003eo\u003c/code\u003e is a monoid, then\n   \u003ccode\u003eReactive o\u003c/code\u003e is a monoid, with \u003ccode\u003emempty == pure mempty\u003c/code\u003e, and \u003ccode\u003emappend\n   == liftA2 mappend\u003c/code\u003e.  That is, \u003ccode\u003emempty \u003ccode\u003eat\u003c/code\u003e t == mempty\u003c/code\u003e, and \u003ccode\u003e(r\n   \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e s) \u003ccode\u003eat\u003c/code\u003e t == (r \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e (s \u003ccode\u003eat\u003c/code\u003e t).\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "BehaviorG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Behavior.html#BehaviorG",
          "type": "newtype"
        },
        "index": {
          "description": "Reactive behaviors They can be understood in terms of simple model denotational semantics as functions of time namely at BehaviorG The semantics of BehaviorG instances are given by corresponding instances for the semantic model functions See http conal.net blog posts simplifying-semantics-with-type-class-morphisms Functor at fmap fmap at i.e fmap at at Applicative at pure pure and at at at That is pure at and at at at Monad at return return and at join rr join at at rr That is return at and join rr at rr at at As always join fmap at at at Monoid typical lifted monoid If is monoid then Reactive is monoid with mempty pure mempty and mappend liftA2 mappend That is mempty at mempty and mappend at at mappend at",
          "hierarchy": "FRP Reactive Internal Behavior",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "BehaviorG",
          "package": "reactive",
          "partial": "Behavior",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Behavior.html#t:BehaviorG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "Beh",
          "package": "reactive",
          "signature": "Beh",
          "source": "src/FRP-Reactive-Internal-Behavior.html#BehaviorG",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Behavior",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "Beh",
          "package": "reactive",
          "partial": "Beh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Behavior.html#v:Beh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap a reactive time fun as a behavior.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "beh",
          "package": "reactive",
          "signature": "ReactiveG tr (Fun tf a) -\u003e BehaviorG tr tf a",
          "source": "src/FRP-Reactive-Internal-Behavior.html#beh",
          "type": "function"
        },
        "index": {
          "description": "Wrap reactive time fun as behavior",
          "hierarchy": "FRP Reactive Internal Behavior",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "beh",
          "normalized": "ReactiveG a(Fun b c)-\u003eBehaviorG a b c",
          "package": "reactive",
          "signature": "ReactiveG tr(Fun tf a)-\u003eBehaviorG tr tf a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Behavior.html#v:beh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "unBeh",
          "package": "reactive",
          "signature": "(ReactiveG tr :. Fun tf) a",
          "source": "src/FRP-Reactive-Internal-Behavior.html#BehaviorG",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Behavior",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "unBeh",
          "package": "reactive",
          "partial": "Beh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Behavior.html#v:unBeh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnwrap a behavior.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "unb",
          "package": "reactive",
          "signature": "BehaviorG tr tf a -\u003e ReactiveG tr (Fun tf a)",
          "source": "src/FRP-Reactive-Internal-Behavior.html#unb",
          "type": "function"
        },
        "index": {
          "description": "Unwrap behavior",
          "hierarchy": "FRP Reactive Internal Behavior",
          "module": "FRP.Reactive.Internal.Behavior",
          "name": "unb",
          "normalized": "BehaviorG a b c-\u003eReactiveG a(Fun b c)",
          "package": "reactive",
          "signature": "BehaviorG tr tf a-\u003eReactiveG tr(Fun tf a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Behavior.html#v:unb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnbounded channels.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "Chan",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Chan.html",
          "type": "module"
        },
        "index": {
          "description": "Unbounded channels",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "Chan",
          "package": "reactive",
          "partial": "Chan",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e is an abstract type representing an unbounded FIFO channel.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "Chan",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Chan.html#Chan",
          "type": "data"
        },
        "index": {
          "description": "Chan is an abstract type representing an unbounded FIFO channel",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "Chan",
          "package": "reactive",
          "partial": "Chan",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#t:Chan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDuplicate a \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e: the duplicate channel begins empty, but data written to\n either channel from then on will be available from both.  Hence this creates\n a kind of broadcast channel, where data written by anyone is seen by\n everyone else.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "dupChan",
          "package": "reactive",
          "signature": "Chan a -\u003e IO (Chan a)",
          "source": "src/FRP-Reactive-Internal-Chan.html#dupChan",
          "type": "function"
        },
        "index": {
          "description": "Duplicate Chan the duplicate channel begins empty but data written to either channel from then on will be available from both Hence this creates kind of broadcast channel where data written by anyone is seen by everyone else",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "dupChan",
          "normalized": "Chan a-\u003eIO(Chan a)",
          "package": "reactive",
          "partial": "Chan",
          "signature": "Chan a-\u003eIO(Chan a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:dupChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a lazy list representing the contents of the supplied\n \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e, much like \u003ccode\u003eSystem.IO.hGetContents\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "getChanContents",
          "package": "reactive",
          "signature": "Chan a -\u003e IO [a]",
          "source": "src/FRP-Reactive-Internal-Chan.html#getChanContents",
          "type": "function"
        },
        "index": {
          "description": "Return lazy list representing the contents of the supplied Chan much like System.IO.hGetContents",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "getChanContents",
          "normalized": "Chan a-\u003eIO[a]",
          "package": "reactive",
          "partial": "Chan Contents",
          "signature": "Chan a-\u003eIO[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:getChanContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the supplied \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e is empty.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "isEmptyChan",
          "package": "reactive",
          "signature": "Chan a -\u003e IO Bool",
          "source": "src/FRP-Reactive-Internal-Chan.html#isEmptyChan",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the supplied Chan is empty",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "isEmptyChan",
          "normalized": "Chan a-\u003eIO Bool",
          "package": "reactive",
          "partial": "Empty Chan",
          "signature": "Chan a-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:isEmptyChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild and returns a new instance of \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "newChan",
          "package": "reactive",
          "signature": "IO (Chan a)",
          "source": "src/FRP-Reactive-Internal-Chan.html#newChan",
          "type": "function"
        },
        "index": {
          "description": "Build and returns new instance of Chan",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "newChan",
          "package": "reactive",
          "partial": "Chan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:newChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the next value from the \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "readChan",
          "package": "reactive",
          "signature": "Chan a -\u003e IO a",
          "source": "src/FRP-Reactive-Internal-Chan.html#readChan",
          "type": "function"
        },
        "index": {
          "description": "Read the next value from the Chan",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "readChan",
          "normalized": "Chan a-\u003eIO a",
          "package": "reactive",
          "partial": "Chan",
          "signature": "Chan a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:readChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut a data item back onto a channel, where it will be the next item read.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "unGetChan",
          "package": "reactive",
          "signature": "Chan a -\u003e a -\u003e IO ()",
          "source": "src/FRP-Reactive-Internal-Chan.html#unGetChan",
          "type": "function"
        },
        "index": {
          "description": "Put data item back onto channel where it will be the next item read",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "unGetChan",
          "normalized": "Chan a-\u003ea-\u003eIO()",
          "package": "reactive",
          "partial": "Get Chan",
          "signature": "Chan a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:unGetChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA weak channel writer.  Sustained by the read head.  Thus channel\n consumers keep channel producers alive.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "weakChanWriter",
          "package": "reactive",
          "signature": "Chan a -\u003e IO (IO (Maybe (a -\u003e IO ())))",
          "source": "src/FRP-Reactive-Internal-Chan.html#weakChanWriter",
          "type": "function"
        },
        "index": {
          "description": "weak channel writer Sustained by the read head Thus channel consumers keep channel producers alive",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "weakChanWriter",
          "normalized": "Chan a-\u003eIO(IO(Maybe(a-\u003eIO())))",
          "package": "reactive",
          "partial": "Chan Writer",
          "signature": "Chan a-\u003eIO(IO(Maybe(a-\u003eIO())))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:weakChanWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a value to a \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "writeChan",
          "package": "reactive",
          "signature": "Chan a -\u003e a -\u003e IO ()",
          "source": "src/FRP-Reactive-Internal-Chan.html#writeChan",
          "type": "function"
        },
        "index": {
          "description": "Write value to Chan",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "writeChan",
          "normalized": "Chan a-\u003ea-\u003eIO()",
          "package": "reactive",
          "partial": "Chan",
          "signature": "Chan a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:writeChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite an entire list of items to a \u003ccode\u003e\u003ca\u003eChan\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "writeList2Chan",
          "package": "reactive",
          "signature": "Chan a -\u003e [a] -\u003e IO ()",
          "source": "src/FRP-Reactive-Internal-Chan.html#writeList2Chan",
          "type": "function"
        },
        "index": {
          "description": "Write an entire list of items to Chan",
          "hierarchy": "FRP Reactive Internal Chan",
          "module": "FRP.Reactive.Internal.Chan",
          "name": "writeList2Chan",
          "normalized": "Chan a-\u003e[a]-\u003eIO()",
          "package": "reactive",
          "partial": "List Chan",
          "signature": "Chan a-\u003e[a]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Chan.html#v:writeList2Chan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSerializing clocks\n\u003c/p\u003e\u003cp\u003eThanks to Luke Palmer for help with this module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "Clock",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Clock.html",
          "type": "module"
        },
        "index": {
          "description": "Serializing clocks Thanks to Luke Palmer for help with this module",
          "hierarchy": "FRP Reactive Internal Clock",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "Clock",
          "package": "reactive",
          "partial": "Clock",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Clock.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWaits a specified duration and then execute an action\n type Delay t = t -\u003e forall a. IO a -\u003e IO a\n\u003c/p\u003e\u003cp\u003eWaits until just after a specified time and then execute an action,\n passing in the actual time.\n type Schedule t = t -\u003e Sink (Sink t)\n\u003c/p\u003e\u003cp\u003eA serializing clock.  Can (a) produce a time and (b) serialize an\n action.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "Clock",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Clock.html#Clock",
          "type": "data"
        },
        "index": {
          "description": "Waits specified duration and then execute an action type Delay forall IO IO Waits until just after specified time and then execute an action passing in the actual time type Schedule Sink Sink serializing clock Can produce time and serialize an action",
          "hierarchy": "FRP Reactive Internal Clock",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "Clock",
          "package": "reactive",
          "partial": "Clock",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Clock.html#t:Clock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Clock",
          "name": "Clock",
          "package": "reactive",
          "signature": "Clock",
          "source": "src/FRP-Reactive-Internal-Clock.html#Clock",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Clock",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "Clock",
          "package": "reactive",
          "partial": "Clock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Clock.html#v:Clock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Clock",
          "name": "cGetTime",
          "package": "reactive",
          "signature": "IO t",
          "source": "src/FRP-Reactive-Internal-Clock.html#Clock",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Clock",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "cGetTime",
          "package": "reactive",
          "partial": "Get Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Clock.html#v:cGetTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Clock",
          "name": "cSerialize",
          "package": "reactive",
          "signature": "Serial",
          "source": "src/FRP-Reactive-Internal-Clock.html#Clock",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Clock",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "cSerialize",
          "package": "reactive",
          "partial": "Serialize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Clock.html#v:cSerialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a clock\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Internal.Clock\",\"FRP.Reactive.LegacyAdapters\"]",
          "name": "makeClock",
          "package": "reactive",
          "signature": "IO (Clock TimeT)",
          "source": "src/FRP-Reactive-Internal-Clock.html#makeClock",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Clock.html#v:makeClock\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#v:makeClock\"]"
        },
        "index": {
          "description": "Make clock",
          "hierarchy": "FRP Reactive Internal Clock",
          "module": "FRP.Reactive.Internal.Clock",
          "name": "makeClock",
          "package": "reactive",
          "partial": "Clock",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Clock.html#v:makeClock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstant-optimized representation of functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "Fun",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Fun.html",
          "type": "module"
        },
        "index": {
          "description": "Constant-optimized representation of functions",
          "hierarchy": "FRP Reactive Internal Fun",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "Fun",
          "package": "reactive",
          "partial": "Fun",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Fun.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstant-optimized functions\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "Fun",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Fun.html#Fun",
          "type": "data"
        },
        "index": {
          "description": "Constant-optimized functions",
          "hierarchy": "FRP Reactive Internal Fun",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "Fun",
          "package": "reactive",
          "partial": "Fun",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Fun.html#t:Fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-constant function\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "Fun",
          "package": "reactive",
          "signature": "Fun (t -\u003e a)",
          "source": "src/FRP-Reactive-Internal-Fun.html#Fun",
          "type": "function"
        },
        "index": {
          "description": "non-constant function",
          "hierarchy": "FRP Reactive Internal Fun",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "Fun",
          "normalized": "Fun(a-\u003eb)",
          "package": "reactive",
          "partial": "Fun",
          "signature": "Fun(t-\u003ea)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Fun.html#v:Fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant function\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "K",
          "package": "reactive",
          "signature": "K a",
          "source": "src/FRP-Reactive-Internal-Fun.html#Fun",
          "type": "function"
        },
        "index": {
          "description": "constant function",
          "hierarchy": "FRP Reactive Internal Fun",
          "module": "FRP.Reactive.Internal.Fun",
          "name": "K",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Fun.html#v:K"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation of future values\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Future",
          "name": "Future",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Future.html",
          "type": "module"
        },
        "index": {
          "description": "Representation of future values",
          "hierarchy": "FRP Reactive Internal Future",
          "module": "FRP.Reactive.Internal.Future",
          "name": "Future",
          "package": "reactive",
          "partial": "Future",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA future value of type \u003ccode\u003ea\u003c/code\u003e with time type \u003ccode\u003et\u003c/code\u003e.  Simply a\n time/value pair.  Particularly useful with time types that have\n non-flat structure.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Future",
          "name": "FutureG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Future.html#FutureG",
          "type": "newtype"
        },
        "index": {
          "description": "future value of type with time type Simply time value pair Particularly useful with time types that have non-flat structure",
          "hierarchy": "FRP Reactive Internal Future",
          "module": "FRP.Reactive.Internal.Future",
          "name": "FutureG",
          "package": "reactive",
          "partial": "Future",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#t:FutureG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTime used in futures.  The parameter \u003ccode\u003et\u003c/code\u003e can be any \u003ccode\u003eOrd\u003c/code\u003e and\n \u003ccode\u003eBounded\u003c/code\u003e type.  Pure values have time \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e, while\n never-occurring futures have time 'maxBound.'\n type Time t = Max (AddBounds t)\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Future",
          "name": "Time",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Future.html#Time",
          "type": "type"
        },
        "index": {
          "description": "Time used in futures The parameter can be any Ord and Bounded type Pure values have time minBound while never-occurring futures have time maxBound type Time Max AddBounds",
          "hierarchy": "FRP Reactive Internal Future",
          "module": "FRP.Reactive.Internal.Future",
          "name": "Time",
          "package": "reactive",
          "partial": "Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#t:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a future in the current thread.  Use the given time sink to sync\n time, i.e., to wait for an output time before performing the action.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Future",
          "name": "runF",
          "package": "reactive",
          "signature": "Sink t -\u003e FutureG t (IO a) -\u003e IO a",
          "source": "src/FRP-Reactive-Internal-Future.html#runF",
          "type": "function"
        },
        "index": {
          "description": "Run future in the current thread Use the given time sink to sync time i.e to wait for an output time before performing the action",
          "hierarchy": "FRP Reactive Internal Future",
          "module": "FRP.Reactive.Internal.Future",
          "name": "runF",
          "normalized": "Sink a-\u003eFutureG a(IO b)-\u003eIO b",
          "package": "reactive",
          "signature": "Sink t-\u003eFutureG t(IO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Future.html#v:runF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWrite-once variables.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "IVar",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-IVar.html",
          "type": "module"
        },
        "index": {
          "description": "Write-once variables",
          "hierarchy": "FRP Reactive Internal IVar",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "IVar",
          "package": "reactive",
          "partial": "IVar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-IVar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.IVar",
          "name": "IVar",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-IVar.html#IVar",
          "type": "data"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal IVar",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "IVar",
          "package": "reactive",
          "partial": "IVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-IVar.html#t:IVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.IVar",
          "name": "newIVar",
          "package": "reactive",
          "signature": "IO (IVar a)",
          "source": "src/FRP-Reactive-Internal-IVar.html#newIVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal IVar",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "newIVar",
          "package": "reactive",
          "partial": "IVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-IVar.html#v:newIVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the value in the IVar.  The *value* will block\n until the variable becomes filled.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "readIVar",
          "package": "reactive",
          "signature": "IVar a -\u003e a",
          "source": "src/FRP-Reactive-Internal-IVar.html#readIVar",
          "type": "function"
        },
        "index": {
          "description": "Returns the value in the IVar The value will block until the variable becomes filled",
          "hierarchy": "FRP Reactive Internal IVar",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "readIVar",
          "normalized": "IVar a-\u003ea",
          "package": "reactive",
          "partial": "IVar",
          "signature": "IVar a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-IVar.html#v:readIVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns Nothing if the IVar has no value yet, otherwise\n returns the value.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "tryReadIVar",
          "package": "reactive",
          "signature": "IVar a -\u003e IO (Maybe a)",
          "source": "src/FRP-Reactive-Internal-IVar.html#tryReadIVar",
          "type": "function"
        },
        "index": {
          "description": "Returns Nothing if the IVar has no value yet otherwise returns the value",
          "hierarchy": "FRP Reactive Internal IVar",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "tryReadIVar",
          "normalized": "IVar a-\u003eIO(Maybe a)",
          "package": "reactive",
          "partial": "Read IVar",
          "signature": "IVar a-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-IVar.html#v:tryReadIVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePuts the value of the IVar.  If it already has a value,\n block forever.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "writeIVar",
          "package": "reactive",
          "signature": "IVar a -\u003e a -\u003e IO ()",
          "source": "src/FRP-Reactive-Internal-IVar.html#writeIVar",
          "type": "function"
        },
        "index": {
          "description": "Puts the value of the IVar If it already has value block forever",
          "hierarchy": "FRP Reactive Internal IVar",
          "module": "FRP.Reactive.Internal.IVar",
          "name": "writeIVar",
          "normalized": "IVar a-\u003ea-\u003eIO()",
          "package": "reactive",
          "partial": "IVar",
          "signature": "IVar a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-IVar.html#v:writeIVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMisc Reactive internal defs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Misc",
          "name": "Misc",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Misc.html",
          "type": "module"
        },
        "index": {
          "description": "Misc Reactive internal defs",
          "hierarchy": "FRP Reactive Internal Misc",
          "module": "FRP.Reactive.Internal.Misc",
          "name": "Misc",
          "package": "reactive",
          "partial": "Misc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Misc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient alias for dropping parentheses.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Misc",
          "name": "Action",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Misc.html#Action",
          "type": "type"
        },
        "index": {
          "description": "Convenient alias for dropping parentheses",
          "hierarchy": "FRP Reactive Internal Misc",
          "module": "FRP.Reactive.Internal.Misc",
          "name": "Action",
          "package": "reactive",
          "partial": "Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Misc.html#t:Action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue consumer\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Misc",
          "name": "Sink",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Misc.html#Sink",
          "type": "type"
        },
        "index": {
          "description": "Value consumer",
          "hierarchy": "FRP Reactive Internal Misc",
          "module": "FRP.Reactive.Internal.Misc",
          "name": "Sink",
          "package": "reactive",
          "partial": "Sink",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Misc.html#t:Sink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation for \u003ccode\u003eReactive\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eEvent\u003c/a\u003e\u003c/code\u003e types.  Combined here,\n because they're mutually recursive.\n\u003c/p\u003e\u003cp\u003eThe representation used in this module is based on a close connection\n between these two types.  A reactive value is defined by an initial\n value and an event that yields future values; while an event is given\n as a future reactive value.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Reactive.html",
          "type": "module"
        },
        "index": {
          "description": "Representation for Reactive and Event types Combined here because they re mutually recursive The representation used in this module is based on close connection between these two types reactive value is defined by an initial value and an event that yields future values while an event is given as future reactive value",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "partial": "Reactive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvents.  Semantically: time-ordered list of future values.\n Instances: \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eMonoid\u003c/code\u003e: \u003ccode\u003emempty\u003c/code\u003e is the event that never occurs, and \u003ccode\u003ee \u003ccode\u003emappend\u003c/code\u003e\n   e'\u003c/code\u003e is the event that combines occurrences from \u003ccode\u003ee\u003c/code\u003e and \u003ccode\u003ee'\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003efmap f e\u003c/code\u003e is the event that occurs whenever \u003ccode\u003ee\u003c/code\u003e occurs,\n   and whose occurrence values come from applying \u003ccode\u003ef\u003c/code\u003e to the values from\n   \u003ccode\u003ee\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eApplicative\u003c/code\u003e: \u003ccode\u003epure a\u003c/code\u003e is an event with a single occurrence at time\n   -Infinity.  \u003ccode\u003eef \u003c*\u003e ex\u003c/code\u003e is an event whose occurrences are made from\n   the \u003cem\u003eproduct\u003c/em\u003e of the occurrences of \u003ccode\u003eef\u003c/code\u003e and \u003ccode\u003eex\u003c/code\u003e.  For every occurrence\n   \u003ccode\u003ef\u003c/code\u003e at time \u003ccode\u003etf\u003c/code\u003e of \u003ccode\u003eef\u003c/code\u003e and occurrence \u003ccode\u003ex\u003c/code\u003e at time \u003ccode\u003etx\u003c/code\u003e of \u003ccode\u003eex\u003c/code\u003e, \u003ccode\u003eef\n   \u003c*\u003e ex\u003c/code\u003e has an occurrence \u003ccode\u003ef x\u003c/code\u003e at time \u003ccode\u003etf \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e tx\u003c/code\u003e.  N.B.: I\n   don't expect this instance to be very useful.  If \u003ccode\u003eef\u003c/code\u003e has \u003ccode\u003enf\u003c/code\u003e\n   instances and \u003ccode\u003eex\u003c/code\u003e has \u003ccode\u003enx\u003c/code\u003e instances, then \u003ccode\u003eef \u003c*\u003e ex\u003c/code\u003e has \u003ccode\u003enf*nx\u003c/code\u003e\n   instances.  However, there are only \u003ccode\u003enf+nx\u003c/code\u003e possibilities for \u003ccode\u003etf\n   \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e tx\u003c/code\u003e, so many of the occurrences are simultaneous.  If you think\n   you want to use this instance, consider using \u003ccode\u003eReactive\u003c/code\u003e instead.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003ereturn a\u003c/code\u003e is the same as \u003ccode\u003epure a\u003c/code\u003e (as usual).  In \u003ccode\u003ee \u003e\u003e= f\u003c/code\u003e,\n   each occurrence of \u003ccode\u003ee\u003c/code\u003e leads, through \u003ccode\u003ef\u003c/code\u003e, to a new event.  Similarly\n   for \u003ccode\u003ejoin ee\u003c/code\u003e, which is somehow simpler for me to think about.  The\n   occurrences of \u003ccode\u003ee \u003e\u003e= f\u003c/code\u003e (or \u003ccode\u003ejoin ee\u003c/code\u003e) correspond to the union of the\n   occurrences (temporal interleaving) of all such events.  For example,\n   suppose we're playing Asteroids and tracking collisions.  Each collision\n   can break an asteroid into more of them, each of which has to be tracked\n   for more collisions.  Another example: A chat room has an \u003cem\u003eenter\u003c/em\u003e event,\n   whose occurrences contain new events like \u003cem\u003espeak\u003c/em\u003e.  An especially useful\n   monad-based function is \u003ccode\u003ejoinMaybes\u003c/code\u003e, which filters a Maybe-valued\n   event.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "EventG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Reactive.html#EventG",
          "type": "newtype"
        },
        "index": {
          "description": "Events Semantically time-ordered list of future values Instances Monoid mempty is the event that never occurs and mappend is the event that combines occurrences from and Functor fmap is the event that occurs whenever occurs and whose occurrence values come from applying to the values from Applicative pure is an event with single occurrence at time Infinity ef ex is an event whose occurrences are made from the product of the occurrences of ef and ex For every occurrence at time tf of ef and occurrence at time tx of ex ef ex has an occurrence at time tf max tx N.B don expect this instance to be very useful If ef has nf instances and ex has nx instances then ef ex has nf nx instances However there are only nf nx possibilities for tf max tx so many of the occurrences are simultaneous If you think you want to use this instance consider using Reactive instead Monad return is the same as pure as usual In each occurrence of leads through to new event Similarly for join ee which is somehow simpler for me to think about The occurrences of or join ee correspond to the union of the occurrences temporal interleaving of all such events For example suppose we re playing Asteroids and tracking collisions Each collision can break an asteroid into more of them each of which has to be tracked for more collisions Another example chat room has an enter event whose occurrences contain new events like speak An especially useful monad-based function is joinMaybes which filters Maybe-valued event",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "EventG",
          "package": "reactive",
          "partial": "Event",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#t:EventG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive value: a discretely changing value.  Reactive values can be\n understood in terms of (a) a simple denotational semantics of reactive\n values as functions of time, and (b) the corresponding instances for\n functions.  The semantics is given by the function \u003ccode\u003eat :: ReactiveG t a -\u003e\n (t -\u003e a)\u003c/code\u003e.  A reactive value may also be thought of (and in this module\n is implemented as) a current value and an event (stream of future values).\n\u003c/p\u003e\u003cp\u003eThe semantics of \u003ccode\u003e\u003ca\u003eReactiveG\u003c/a\u003e\u003c/code\u003e instances are given by corresponding\n instances for the semantic model (functions):\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (fmap f r) == fmap f (at r)\u003c/code\u003e, i.e., \u003ccode\u003efmap f r \u003ccode\u003eat\u003c/code\u003e\n   t == f (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eApplicative\u003c/code\u003e: \u003ccode\u003eat (pure a) == pure a\u003c/code\u003e, and \u003ccode\u003eat (s \u003c*\u003e r) == at s\n   \u003c*\u003e at t\u003c/code\u003e.  That is, \u003ccode\u003epure a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003e(s \u003c*\u003e r) \u003ccode\u003eat\u003c/code\u003e t\n   == (s \u003ccode\u003eat\u003c/code\u003e t) (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (return a) == return a\u003c/code\u003e, and \u003ccode\u003eat (join rr) == join (at\n   . at rr)\u003c/code\u003e.  That is, \u003ccode\u003ereturn a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003ejoin rr \u003ccode\u003eat\u003c/code\u003e t ==\n   (rr \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003eat\u003c/code\u003e t\u003c/code\u003e.  As always, \u003ccode\u003e(r \u003e\u003e= f) == join (fmap f r)\u003c/code\u003e.\n   \u003ccode\u003eat (r \u003e\u003e= f) == at r \u003e\u003e= at . f\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eMonoid\u003c/code\u003e: a typical lifted monoid.  If \u003ccode\u003eo\u003c/code\u003e is a monoid, then\n   \u003ccode\u003eReactive o\u003c/code\u003e is a monoid, with \u003ccode\u003emempty == pure mempty\u003c/code\u003e, and \u003ccode\u003emappend\n   == liftA2 mappend\u003c/code\u003e.  That is, \u003ccode\u003emempty \u003ccode\u003eat\u003c/code\u003e t == mempty\u003c/code\u003e, and \u003ccode\u003e(r\n   \u003ccode\u003emappend\u003c/code\u003e s) \u003ccode\u003eat\u003c/code\u003e t == (r \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003emappend\u003c/code\u003e (s \u003ccode\u003eat\u003c/code\u003e t).\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "ReactiveG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Reactive.html#ReactiveG",
          "type": "data"
        },
        "index": {
          "description": "Reactive value discretely changing value Reactive values can be understood in terms of simple denotational semantics of reactive values as functions of time and the corresponding instances for functions The semantics is given by the function at ReactiveG reactive value may also be thought of and in this module is implemented as current value and an event stream of future values The semantics of ReactiveG instances are given by corresponding instances for the semantic model functions Functor at fmap fmap at i.e fmap at at Applicative at pure pure and at at at That is pure at and at at at Monad at return return and at join rr join at at rr That is return at and join rr at rr at at As always join fmap at at at Monoid typical lifted monoid If is monoid then Reactive is monoid with mempty pure mempty and mappend liftA2 mappend That is mempty at mempty and mappend at at mappend at",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "ReactiveG",
          "package": "reactive",
          "partial": "Reactive",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#t:ReactiveG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "Event",
          "package": "reactive",
          "signature": "Event",
          "source": "src/FRP-Reactive-Internal-Reactive.html#EventG",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "Event",
          "package": "reactive",
          "partial": "Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "Stepper",
          "package": "reactive",
          "signature": "a Stepper (EventG t a)",
          "source": "src/FRP-Reactive-Internal-Reactive.html#ReactiveG",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "Stepper",
          "package": "reactive",
          "partial": "Stepper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:Stepper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "eFuture",
          "package": "reactive",
          "signature": "FutureG t (ReactiveG t a)",
          "source": "src/FRP-Reactive-Internal-Reactive.html#EventG",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "eFuture",
          "package": "reactive",
          "partial": "Future",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:eFuture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake the event into a list of futures\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "eFutures",
          "package": "reactive",
          "signature": "EventG t a -\u003e [FutureG t a]",
          "source": "src/FRP-Reactive-Internal-Reactive.html#eFutures",
          "type": "function"
        },
        "index": {
          "description": "Make the event into list of futures",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "eFutures",
          "normalized": "EventG a b-\u003e[FutureG a b]",
          "package": "reactive",
          "partial": "Futures",
          "signature": "EventG t a-\u003e[FutureG t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:eFutures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun an event in a new thread, using the given time sink to sync time.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "forkE",
          "package": "reactive",
          "signature": "Sink t -\u003e EventG t Action -\u003e IO ThreadId",
          "source": "src/FRP-Reactive-Internal-Reactive.html#forkE",
          "type": "function"
        },
        "index": {
          "description": "Run an event in new thread using the given time sink to sync time",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "forkE",
          "normalized": "Sink a-\u003eEventG a Action-\u003eIO ThreadId",
          "package": "reactive",
          "signature": "Sink t-\u003eEventG t Action-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:forkE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a reactive value in a new thread, using the given time sink to\n sync time.  The initial action happens in the current thread.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "forkR",
          "package": "reactive",
          "signature": "Sink t -\u003e ReactiveG t Action -\u003e IO ThreadId",
          "source": "src/FRP-Reactive-Internal-Reactive.html#forkR",
          "type": "function"
        },
        "index": {
          "description": "Run reactive value in new thread using the given time sink to sync time The initial action happens in the current thread",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "forkR",
          "normalized": "Sink a-\u003eReactiveG a Action-\u003eIO ThreadId",
          "package": "reactive",
          "signature": "Sink t-\u003eReactiveG t Action-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:forkR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a unary function inside an \u003ccode\u003e\u003ca\u003eEventG\u003c/a\u003e\u003c/code\u003e representation.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inEvent",
          "package": "reactive",
          "signature": "(FutureG s (ReactiveG s a) -\u003e FutureG t (ReactiveG t b)) -\u003e EventG s a -\u003e EventG t b",
          "source": "src/FRP-Reactive-Internal-Reactive.html#inEvent",
          "type": "function"
        },
        "index": {
          "description": "Apply unary function inside an EventG representation",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inEvent",
          "normalized": "(FutureG a(ReactiveG a b)-\u003eFutureG c(ReactiveG c d))-\u003eEventG a b-\u003eEventG c d",
          "package": "reactive",
          "partial": "Event",
          "signature": "(FutureG s(ReactiveG s a)-\u003eFutureG t(ReactiveG t b))-\u003eEventG s a-\u003eEventG t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:inEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a binary function inside an \u003ccode\u003e\u003ca\u003eEventG\u003c/a\u003e\u003c/code\u003e representation.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inEvent2",
          "package": "reactive",
          "signature": "(FutureG t (ReactiveG t a) -\u003e FutureG t (ReactiveG t b) -\u003e FutureG t (ReactiveG t c)) -\u003e EventG t a -\u003e EventG t b -\u003e EventG t c",
          "source": "src/FRP-Reactive-Internal-Reactive.html#inEvent2",
          "type": "function"
        },
        "index": {
          "description": "Apply binary function inside an EventG representation",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inEvent2",
          "normalized": "(FutureG a(ReactiveG a b)-\u003eFutureG a(ReactiveG a c)-\u003eFutureG a(ReactiveG a d))-\u003eEventG a b-\u003eEventG a c-\u003eEventG a d",
          "package": "reactive",
          "partial": "Event",
          "signature": "(FutureG t(ReactiveG t a)-\u003eFutureG t(ReactiveG t b)-\u003eFutureG t(ReactiveG t c))-\u003eEventG t a-\u003eEventG t b-\u003eEventG t c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:inEvent2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a unary function inside the future reactive inside a \u003ccode\u003eReactive\u003c/code\u003e\n representation.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inFutR",
          "package": "reactive",
          "signature": "(FutureG s (ReactiveG s b) -\u003e FutureG t (ReactiveG t b)) -\u003e ReactiveG s b -\u003e ReactiveG t b",
          "source": "src/FRP-Reactive-Internal-Reactive.html#inFutR",
          "type": "function"
        },
        "index": {
          "description": "Apply unary function inside the future reactive inside Reactive representation",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inFutR",
          "normalized": "(FutureG a(ReactiveG a b)-\u003eFutureG c(ReactiveG c b))-\u003eReactiveG a b-\u003eReactiveG c b",
          "package": "reactive",
          "partial": "Fut",
          "signature": "(FutureG s(ReactiveG s b)-\u003eFutureG t(ReactiveG t b))-\u003eReactiveG s b-\u003eReactiveG t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:inFutR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a unary function inside the \u003ccode\u003erEvent\u003c/code\u003e part of a \u003ccode\u003eReactive\u003c/code\u003e\n representation.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inREvent",
          "package": "reactive",
          "signature": "(EventG s a -\u003e EventG t a) -\u003e ReactiveG s a -\u003e ReactiveG t a",
          "source": "src/FRP-Reactive-Internal-Reactive.html#inREvent",
          "type": "function"
        },
        "index": {
          "description": "Apply unary function inside the rEvent part of Reactive representation",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "inREvent",
          "normalized": "(EventG a b-\u003eEventG c b)-\u003eReactiveG a b-\u003eReactiveG c b",
          "package": "reactive",
          "partial": "REvent",
          "signature": "(EventG s a-\u003eEventG t a)-\u003eReactiveG s a-\u003eReactiveG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:inREvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "isNeverE",
          "package": "reactive",
          "signature": "EventG t a -\u003e Bool",
          "source": "src/FRP-Reactive-Internal-Reactive.html#isNeverE",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "isNeverE",
          "normalized": "EventG a b-\u003eBool",
          "package": "reactive",
          "partial": "Never",
          "signature": "EventG t a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:isNeverE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun an event in the current thread.  Use the given time sink to sync\n time, i.e., to wait for an output time before performing the action.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "runE",
          "package": "reactive",
          "signature": "Sink t -\u003e Sink (EventG t Action)",
          "source": "src/FRP-Reactive-Internal-Reactive.html#runE",
          "type": "function"
        },
        "index": {
          "description": "Run an event in the current thread Use the given time sink to sync time i.e to wait for an output time before performing the action",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "runE",
          "normalized": "Sink a-\u003eSink(EventG a Action)",
          "package": "reactive",
          "signature": "Sink t-\u003eSink(EventG t Action)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:runE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a reactive value in the current thread, using the given time sink\n to sync time.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "runR",
          "package": "reactive",
          "signature": "Sink t -\u003e Sink (ReactiveG t Action)",
          "source": "src/FRP-Reactive-Internal-Reactive.html#runR",
          "type": "function"
        },
        "index": {
          "description": "Run reactive value in the current thread using the given time sink to sync time",
          "hierarchy": "FRP Reactive Internal Reactive",
          "module": "FRP.Reactive.Internal.Reactive",
          "name": "runR",
          "normalized": "Sink a-\u003eSink(ReactiveG a Action)",
          "package": "reactive",
          "signature": "Sink t-\u003eSink(ReactiveG t Action)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Reactive.html#v:runR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSerialize actions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "Serial",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Serial.html",
          "type": "module"
        },
        "index": {
          "description": "Serialize actions",
          "hierarchy": "FRP Reactive Internal Serial",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "Serial",
          "package": "reactive",
          "partial": "Serial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Serial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSerializer.  Turns actions into equivalent but serialized actions\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "Serial",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Serial.html#Serial",
          "type": "type"
        },
        "index": {
          "description": "Serializer Turns actions into equivalent but serialized actions",
          "hierarchy": "FRP Reactive Internal Serial",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "Serial",
          "package": "reactive",
          "partial": "Serial",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Serial.html#t:Serial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a locking serializer with a given lock\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "locking",
          "package": "reactive",
          "signature": "MVar () -\u003e Serial",
          "source": "src/FRP-Reactive-Internal-Serial.html#locking",
          "type": "function"
        },
        "index": {
          "description": "Make locking serializer with given lock",
          "hierarchy": "FRP Reactive Internal Serial",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "locking",
          "normalized": "MVar()-\u003eSerial",
          "package": "reactive",
          "signature": "MVar()-\u003eSerial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Serial.html#v:locking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a locking serializer\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "makeSerial",
          "package": "reactive",
          "signature": "IO Serial",
          "source": "src/FRP-Reactive-Internal-Serial.html#makeSerial",
          "type": "function"
        },
        "index": {
          "description": "Make locking serializer",
          "hierarchy": "FRP Reactive Internal Serial",
          "module": "FRP.Reactive.Internal.Serial",
          "name": "makeSerial",
          "package": "reactive",
          "partial": "Serial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Serial.html#v:makeSerial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTimed values.  A primitive interface for futures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Internal.TVal",
          "name": "TVal",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-TVal.html",
          "type": "module"
        },
        "index": {
          "description": "Timed values primitive interface for futures",
          "hierarchy": "FRP Reactive Internal TVal",
          "module": "FRP.Reactive.Internal.TVal",
          "name": "TVal",
          "package": "reactive",
          "partial": "TVal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-TVal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a '(:--\u003e)'.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.TVal",
          "name": ":+-\u003e",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-TVal.html#%3A%2B-%3E",
          "type": "type"
        },
        "index": {
          "description": "Make",
          "hierarchy": "FRP Reactive Internal TVal",
          "module": "FRP.Reactive.Internal.TVal",
          "name": ":+-\u003e",
          "package": "reactive",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-TVal.html#t::-43--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003ea\u003c/code\u003e that's fed by a \u003ccode\u003eb\u003c/code\u003e\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.TVal",
          "name": ":--\u003e",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-TVal.html#%3A--%3E",
          "type": "type"
        },
        "index": {
          "description": "An that fed by",
          "hierarchy": "FRP Reactive Internal TVal",
          "module": "FRP.Reactive.Internal.TVal",
          "name": ":--\u003e",
          "package": "reactive",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-TVal.html#t::-45--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a new event and a sink that writes to it.  Uses the given\n clock to serialize and time-stamp.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.TVal",
          "name": "makeEvent",
          "package": "reactive",
          "signature": "a :+-\u003e Event a",
          "source": "src/FRP-Reactive-Internal-TVal.html#makeEvent",
          "type": "function"
        },
        "index": {
          "description": "Make new event and sink that writes to it Uses the given clock to serialize and time-stamp",
          "hierarchy": "FRP Reactive Internal TVal",
          "module": "FRP.Reactive.Internal.TVal",
          "name": "makeEvent",
          "normalized": "a-\u003eEvent a",
          "package": "reactive",
          "partial": "Event",
          "signature": "a-\u003eEvent a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-TVal.html#v:makeEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Internal.Timing",
          "name": "Timing",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Timing.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "FRP Reactive Internal Timing",
          "module": "FRP.Reactive.Internal.Timing",
          "name": "Timing",
          "package": "reactive",
          "partial": "Timing",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Timing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute an action-valued event.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Internal.Timing\",\"FRP.Reactive.LegacyAdapters\"]",
          "name": "adaptE",
          "package": "reactive",
          "signature": "Sink (Event Action)",
          "source": "src/FRP-Reactive-Internal-Timing.html#adaptE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Timing.html#v:adaptE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#v:adaptE\"]"
        },
        "index": {
          "description": "Execute an action-valued event",
          "hierarchy": "FRP Reactive Internal Timing",
          "module": "FRP.Reactive.Internal.Timing",
          "name": "adaptE",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Timing.html#v:adaptE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake an action to be executed regularly, given a time-source and a\n action-behavior.  The generated action is optimized to do almost no\n work during known-constant phases of the given behavior.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Internal.Timing\",\"FRP.Reactive.LegacyAdapters\"]",
          "name": "mkUpdater",
          "package": "reactive",
          "signature": "IO TimeT -\u003e Behavior Action -\u003e IO Action",
          "source": "src/FRP-Reactive-Internal-Timing.html#mkUpdater",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Timing.html#v:mkUpdater\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#v:mkUpdater\"]"
        },
        "index": {
          "description": "Make an action to be executed regularly given time-source and action-behavior The generated action is optimized to do almost no work during known-constant phases of the given behavior",
          "hierarchy": "FRP Reactive Internal Timing",
          "module": "FRP.Reactive.Internal.Timing",
          "name": "mkUpdater",
          "normalized": "IO TimeT-\u003eBehavior Action-\u003eIO Action",
          "package": "reactive",
          "partial": "Updater",
          "signature": "IO TimeT-\u003eBehavior Action-\u003eIO Action",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Timing.html#v:mkUpdater"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSleep past a given time\n\u003c/p\u003e",
          "module": "FRP.Reactive.Internal.Timing",
          "name": "sleepPast",
          "package": "reactive",
          "signature": "IO TimeT -\u003e Sink TimeT",
          "source": "src/FRP-Reactive-Internal-Timing.html#sleepPast",
          "type": "function"
        },
        "index": {
          "description": "Sleep past given time",
          "hierarchy": "FRP Reactive Internal Timing",
          "module": "FRP.Reactive.Internal.Timing",
          "name": "sleepPast",
          "normalized": "IO TimeT-\u003eSink TimeT",
          "package": "reactive",
          "partial": "Past",
          "signature": "IO TimeT-\u003eSink TimeT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Internal-Timing.html#v:sleepPast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools for making Reactive adapters for imperative (\"legacy\")\n libraries.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "LegacyAdapters",
          "package": "reactive",
          "source": "src/FRP-Reactive-LegacyAdapters.html",
          "type": "module"
        },
        "index": {
          "description": "Tools for making Reactive adapters for imperative legacy libraries",
          "hierarchy": "FRP Reactive LegacyAdapters",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "LegacyAdapters",
          "package": "reactive",
          "partial": "Legacy Adapters",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient alias for dropping parentheses.\n\u003c/p\u003e",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "Action",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Misc.html#Action",
          "type": "type"
        },
        "index": {
          "description": "Convenient alias for dropping parentheses",
          "hierarchy": "FRP Reactive LegacyAdapters",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "Action",
          "package": "reactive",
          "partial": "Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#t:Action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWaits a specified duration and then execute an action\n type Delay t = t -\u003e forall a. IO a -\u003e IO a\n\u003c/p\u003e\u003cp\u003eWaits until just after a specified time and then execute an action,\n passing in the actual time.\n type Schedule t = t -\u003e Sink (Sink t)\n\u003c/p\u003e\u003cp\u003eA serializing clock.  Can (a) produce a time and (b) serialize an\n action.\n\u003c/p\u003e",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "Clock",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Clock.html#Clock",
          "type": "data"
        },
        "index": {
          "description": "Waits specified duration and then execute an action type Delay forall IO IO Waits until just after specified time and then execute an action passing in the actual time type Schedule Sink Sink serializing clock Can produce time and serialize an action",
          "hierarchy": "FRP Reactive LegacyAdapters",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "Clock",
          "package": "reactive",
          "partial": "Clock",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#t:Clock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue consumer\n\u003c/p\u003e",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "Sink",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Misc.html#Sink",
          "type": "type"
        },
        "index": {
          "description": "Value consumer",
          "hierarchy": "FRP Reactive LegacyAdapters",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "Sink",
          "package": "reactive",
          "partial": "Sink",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#t:Sink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "cGetTime",
          "package": "reactive",
          "signature": "Clock t -\u003e IO t",
          "source": "src/FRP-Reactive-Internal-Clock.html#cGetTime",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive LegacyAdapters",
          "module": "FRP.Reactive.LegacyAdapters",
          "name": "cGetTime",
          "normalized": "Clock a-\u003eIO a",
          "package": "reactive",
          "partial": "Get Time",
          "signature": "Clock t-\u003eIO t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-LegacyAdapters.html#v:cGetTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumeric class instances for behaviors\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Num",
          "name": "Num",
          "package": "reactive",
          "source": "src/FRP-Reactive-Num.html",
          "type": "module"
        },
        "index": {
          "description": "Numeric class instances for behaviors",
          "hierarchy": "FRP Reactive Num",
          "module": "FRP.Reactive.Num",
          "name": "Num",
          "package": "reactive",
          "partial": "Num",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Num.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctional \u003cem\u003eevents\u003c/em\u003e and \u003cem\u003ereactive values\u003c/em\u003e.  Semantically, an \u003ccode\u003e\u003ca\u003eEvent\u003c/a\u003e\u003c/code\u003e is\n stream of future values in time order.  A \u003ccode\u003eReactive\u003c/code\u003e value is a\n discretly time-varying value.\n\u003c/p\u003e\u003cp\u003eMany of the operations on events and reactive values are packaged as\n instances of the standard type classes \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis module focuses on representation and primitives defined in terms\n of the representation.  See also \u003ca\u003eFRP.Reactive.Reactive\u003c/a\u003e, which\n re-exports this module, plus extras that do not exploit the\n representation.  My intention for this separation is to ease\n experimentation with alternative representations.\n\u003c/p\u003e\u003cp\u003eAlthough the basic \u003ccode\u003eReactive\u003c/code\u003e type describes \u003cem\u003ediscretely\u003c/em\u003e-changing\n values, \u003cem\u003econtinuously\u003c/em\u003e-changing values can be modeled simply as\n reactive functions.  See \u003ca\u003eFRP.Reactive.Behavior\u003c/a\u003e for a convenient type\n composition of \u003ccode\u003eReactive\u003c/code\u003e and a constant-optimized representation of\n functions of time.  The exact packaging of discrete vs continuous will\n probably change with more experience.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "PrimReactive",
          "package": "reactive",
          "source": "src/FRP-Reactive-PrimReactive.html",
          "type": "module"
        },
        "index": {
          "description": "Functional events and reactive values Semantically an Event is stream of future values in time order Reactive value is discretly time-varying value Many of the operations on events and reactive values are packaged as instances of the standard type classes Monoid Functor Applicative and Monad This module focuses on representation and primitives defined in terms of the representation See also FRP.Reactive.Reactive which re-exports this module plus extras that do not exploit the representation My intention for this separation is to ease experimentation with alternative representations Although the basic Reactive type describes discretely changing values continuously changing values can be modeled simply as reactive functions See FRP.Reactive.Behavior for convenient type composition of Reactive and constant-optimized representation of functions of time The exact packaging of discrete vs continuous will probably change with more experience",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "PrimReactive",
          "package": "reactive",
          "partial": "Prim Reactive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvents.  Semantically: time-ordered list of future values.\n Instances: \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eMonoid\u003c/code\u003e: \u003ccode\u003emempty\u003c/code\u003e is the event that never occurs, and \u003ccode\u003ee \u003ccode\u003emappend\u003c/code\u003e\n   e'\u003c/code\u003e is the event that combines occurrences from \u003ccode\u003ee\u003c/code\u003e and \u003ccode\u003ee'\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003efmap f e\u003c/code\u003e is the event that occurs whenever \u003ccode\u003ee\u003c/code\u003e occurs,\n   and whose occurrence values come from applying \u003ccode\u003ef\u003c/code\u003e to the values from\n   \u003ccode\u003ee\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eApplicative\u003c/code\u003e: \u003ccode\u003epure a\u003c/code\u003e is an event with a single occurrence at time\n   -Infinity.  \u003ccode\u003eef \u003c*\u003e ex\u003c/code\u003e is an event whose occurrences are made from\n   the \u003cem\u003eproduct\u003c/em\u003e of the occurrences of \u003ccode\u003eef\u003c/code\u003e and \u003ccode\u003eex\u003c/code\u003e.  For every occurrence\n   \u003ccode\u003ef\u003c/code\u003e at time \u003ccode\u003etf\u003c/code\u003e of \u003ccode\u003eef\u003c/code\u003e and occurrence \u003ccode\u003ex\u003c/code\u003e at time \u003ccode\u003etx\u003c/code\u003e of \u003ccode\u003eex\u003c/code\u003e, \u003ccode\u003eef\n   \u003c*\u003e ex\u003c/code\u003e has an occurrence \u003ccode\u003ef x\u003c/code\u003e at time \u003ccode\u003etf \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e tx\u003c/code\u003e.  N.B.: I\n   don't expect this instance to be very useful.  If \u003ccode\u003eef\u003c/code\u003e has \u003ccode\u003enf\u003c/code\u003e\n   instances and \u003ccode\u003eex\u003c/code\u003e has \u003ccode\u003enx\u003c/code\u003e instances, then \u003ccode\u003eef \u003c*\u003e ex\u003c/code\u003e has \u003ccode\u003enf*nx\u003c/code\u003e\n   instances.  However, there are only \u003ccode\u003enf+nx\u003c/code\u003e possibilities for \u003ccode\u003etf\n   \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e tx\u003c/code\u003e, so many of the occurrences are simultaneous.  If you think\n   you want to use this instance, consider using \u003ccode\u003eReactive\u003c/code\u003e instead.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003ereturn a\u003c/code\u003e is the same as \u003ccode\u003epure a\u003c/code\u003e (as usual).  In \u003ccode\u003ee \u003e\u003e= f\u003c/code\u003e,\n   each occurrence of \u003ccode\u003ee\u003c/code\u003e leads, through \u003ccode\u003ef\u003c/code\u003e, to a new event.  Similarly\n   for \u003ccode\u003ejoin ee\u003c/code\u003e, which is somehow simpler for me to think about.  The\n   occurrences of \u003ccode\u003ee \u003e\u003e= f\u003c/code\u003e (or \u003ccode\u003ejoin ee\u003c/code\u003e) correspond to the union of the\n   occurrences (temporal interleaving) of all such events.  For example,\n   suppose we're playing Asteroids and tracking collisions.  Each collision\n   can break an asteroid into more of them, each of which has to be tracked\n   for more collisions.  Another example: A chat room has an \u003cem\u003eenter\u003c/em\u003e event,\n   whose occurrences contain new events like \u003cem\u003espeak\u003c/em\u003e.  An especially useful\n   monad-based function is \u003ccode\u003ejoinMaybes\u003c/code\u003e, which filters a Maybe-valued\n   event.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "EventG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Reactive.html#EventG",
          "type": "data"
        },
        "index": {
          "description": "Events Semantically time-ordered list of future values Instances Monoid mempty is the event that never occurs and mappend is the event that combines occurrences from and Functor fmap is the event that occurs whenever occurs and whose occurrence values come from applying to the values from Applicative pure is an event with single occurrence at time Infinity ef ex is an event whose occurrences are made from the product of the occurrences of ef and ex For every occurrence at time tf of ef and occurrence at time tx of ex ef ex has an occurrence at time tf max tx N.B don expect this instance to be very useful If ef has nf instances and ex has nx instances then ef ex has nf nx instances However there are only nf nx possibilities for tf max tx so many of the occurrences are simultaneous If you think you want to use this instance consider using Reactive instead Monad return is the same as pure as usual In each occurrence of leads through to new event Similarly for join ee which is somehow simpler for me to think about The occurrences of or join ee correspond to the union of the occurrences temporal interleaving of all such events For example suppose we re playing Asteroids and tracking collisions Each collision can break an asteroid into more of them each of which has to be tracked for more collisions Another example chat room has an enter event whose occurrences contain new events like speak An especially useful monad-based function is joinMaybes which filters Maybe-valued event",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "EventG",
          "package": "reactive",
          "partial": "Event",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#t:EventG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive value: a discretely changing value.  Reactive values can be\n understood in terms of (a) a simple denotational semantics of reactive\n values as functions of time, and (b) the corresponding instances for\n functions.  The semantics is given by the function \u003ccode\u003eat :: ReactiveG t a -\u003e\n (t -\u003e a)\u003c/code\u003e.  A reactive value may also be thought of (and in this module\n is implemented as) a current value and an event (stream of future values).\n\u003c/p\u003e\u003cp\u003eThe semantics of \u003ccode\u003e\u003ca\u003eReactiveG\u003c/a\u003e\u003c/code\u003e instances are given by corresponding\n instances for the semantic model (functions):\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (fmap f r) == fmap f (at r)\u003c/code\u003e, i.e., \u003ccode\u003efmap f r \u003ccode\u003eat\u003c/code\u003e\n   t == f (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eApplicative\u003c/code\u003e: \u003ccode\u003eat (pure a) == pure a\u003c/code\u003e, and \u003ccode\u003eat (s \u003c*\u003e r) == at s\n   \u003c*\u003e at t\u003c/code\u003e.  That is, \u003ccode\u003epure a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003e(s \u003c*\u003e r) \u003ccode\u003eat\u003c/code\u003e t\n   == (s \u003ccode\u003eat\u003c/code\u003e t) (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (return a) == return a\u003c/code\u003e, and \u003ccode\u003eat (join rr) == join (at\n   . at rr)\u003c/code\u003e.  That is, \u003ccode\u003ereturn a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003ejoin rr \u003ccode\u003eat\u003c/code\u003e t ==\n   (rr \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003eat\u003c/code\u003e t\u003c/code\u003e.  As always, \u003ccode\u003e(r \u003e\u003e= f) == join (fmap f r)\u003c/code\u003e.\n   \u003ccode\u003eat (r \u003e\u003e= f) == at r \u003e\u003e= at . f\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eMonoid\u003c/code\u003e: a typical lifted monoid.  If \u003ccode\u003eo\u003c/code\u003e is a monoid, then\n   \u003ccode\u003eReactive o\u003c/code\u003e is a monoid, with \u003ccode\u003emempty == pure mempty\u003c/code\u003e, and \u003ccode\u003emappend\n   == liftA2 mappend\u003c/code\u003e.  That is, \u003ccode\u003emempty \u003ccode\u003eat\u003c/code\u003e t == mempty\u003c/code\u003e, and \u003ccode\u003e(r\n   \u003ccode\u003emappend\u003c/code\u003e s) \u003ccode\u003eat\u003c/code\u003e t == (r \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003emappend\u003c/code\u003e (s \u003ccode\u003eat\u003c/code\u003e t).\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "ReactiveG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Reactive.html#ReactiveG",
          "type": "data"
        },
        "index": {
          "description": "Reactive value discretely changing value Reactive values can be understood in terms of simple denotational semantics of reactive values as functions of time and the corresponding instances for functions The semantics is given by the function at ReactiveG reactive value may also be thought of and in this module is implemented as current value and an event stream of future values The semantics of ReactiveG instances are given by corresponding instances for the semantic model functions Functor at fmap fmap at i.e fmap at at Applicative at pure pure and at at at That is pure at and at at at Monad at return return and at join rr join at at rr That is return at and join rr at rr at at As always join fmap at at at Monoid typical lifted monoid If is monoid then Reactive is monoid with mempty pure mempty and mappend liftA2 mappend That is mempty at mempty and mappend at at mappend at",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "ReactiveG",
          "package": "reactive",
          "partial": "Reactive",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#t:ReactiveG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccumulating event, starting from an initial value and a\n update-function event.  See also \u003ccode\u003e\u003ca\u003eaccumR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "accumE",
          "package": "reactive",
          "signature": "a -\u003e EventG t (a -\u003e a) -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#accumE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:accumE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:accumE\"]"
        },
        "index": {
          "description": "Accumulating event starting from an initial value and update-function event See also accumR",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "accumE",
          "normalized": "a-\u003eEventG b(a-\u003ea)-\u003eEventG b a",
          "package": "reactive",
          "signature": "a-\u003eEventG t(a-\u003ea)-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:accumE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive value from an initial value and an updater event.  See also\n \u003ccode\u003e\u003ca\u003eaccumE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "accumR",
          "package": "reactive",
          "signature": "a -\u003e EventG t (a -\u003e a) -\u003e ReactiveG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#accumR",
          "type": "function"
        },
        "index": {
          "description": "Reactive value from an initial value and an updater event See also accumE",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "accumR",
          "normalized": "a-\u003eEventG b(a-\u003ea)-\u003eReactiveG b a",
          "package": "reactive",
          "signature": "a-\u003eEventG t(a-\u003ea)-\u003eReactiveG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:accumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle-occurrence event at given time.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "atTimeG",
          "package": "reactive",
          "signature": "t -\u003e EventG t ()",
          "source": "src/FRP-Reactive-PrimReactive.html#atTimeG",
          "type": "function"
        },
        "index": {
          "description": "Single-occurrence event at given time",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "atTimeG",
          "normalized": "a-\u003eEventG a()",
          "package": "reactive",
          "partial": "Time",
          "signature": "t-\u003eEventG t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:atTimeG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvent at given times.  See also \u003ccode\u003e\u003ca\u003eatTimeG\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "atTimesG",
          "package": "reactive",
          "signature": "[t] -\u003e EventG t ()",
          "source": "src/FRP-Reactive-PrimReactive.html#atTimesG",
          "type": "function"
        },
        "index": {
          "description": "Event at given times See also atTimeG",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "atTimesG",
          "normalized": "[a]-\u003eEventG a()",
          "package": "reactive",
          "partial": "Times",
          "signature": "[t]-\u003eEventG t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:atTimesG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.PrimReactive",
          "name": "batch",
          "package": "reactive",
          "signature": "TestBatch",
          "source": "src/FRP-Reactive-PrimReactive.html#batch",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "batch",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:batch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a future representing the first occurrence of the event together\n with the event of all occurrences after that one.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "eventOcc",
          "package": "reactive",
          "signature": "EventG t a -\u003e FutureG t (a, EventG t a)",
          "source": "src/FRP-Reactive-PrimReactive.html#eventOcc",
          "type": "function"
        },
        "index": {
          "description": "Extract future representing the first occurrence of the event together with the event of all occurrences after that one",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "eventOcc",
          "normalized": "EventG a b-\u003eFutureG a(b,EventG a b)",
          "package": "reactive",
          "partial": "Occ",
          "signature": "EventG t a-\u003eFutureG t(a,EventG t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:eventOcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExperimental specialization of \u003ccode\u003e\u003ca\u003efilterMP\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "filterE",
          "package": "reactive",
          "signature": "(a -\u003e Bool) -\u003e EventG t a -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#filterE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:filterE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:filterE\"]"
        },
        "index": {
          "description": "Experimental specialization of filterMP",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "filterE",
          "normalized": "(a-\u003eBool)-\u003eEventG b a-\u003eEventG b a",
          "package": "reactive",
          "signature": "(a-\u003eBool)-\u003eEventG t a-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:filterE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePass through values satisfying \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "filterMP",
          "package": "reactive",
          "signature": "(a -\u003e Bool) -\u003e m a -\u003e m a",
          "source": "src/FRP-Reactive-PrimReactive.html#filterMP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:filterMP\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:filterMP\"]"
        },
        "index": {
          "description": "Pass through values satisfying",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "filterMP",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "reactive",
          "partial": "MP",
          "signature": "(a-\u003eBool)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:filterMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a temporally monotonic stream of futures to an event.  Like\n \u003ccode\u003e\u003ca\u003efuturesE\u003c/a\u003e\u003c/code\u003e but it can be lazier, because there's not empty case.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "futureStreamE",
          "package": "reactive",
          "signature": "Stream (FutureG t a) -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#futureStreamE",
          "type": "function"
        },
        "index": {
          "description": "Convert temporally monotonic stream of futures to an event Like futuresE but it can be lazier because there not empty case",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "futureStreamE",
          "normalized": "Stream(FutureG a b)-\u003eEventG a b",
          "package": "reactive",
          "partial": "Stream",
          "signature": "Stream(FutureG t a)-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:futureStreamE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a temporally monotonic list of futures to an event\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "futuresE",
          "package": "reactive",
          "signature": "[FutureG t a] -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#futuresE",
          "type": "function"
        },
        "index": {
          "description": "Convert temporally monotonic list of futures to an event",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "futuresE",
          "normalized": "[FutureG a b]-\u003eEventG a b",
          "package": "reactive",
          "signature": "[FutureG t a]-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:futuresE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.PrimReactive",
          "name": "infE",
          "package": "reactive",
          "signature": "EventG NumT NumT",
          "source": "src/FRP-Reactive-PrimReactive.html#infE",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "infE",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:infE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.PrimReactive",
          "name": "isMonotoneR",
          "package": "reactive",
          "signature": "ReactiveG t a -\u003e Bool",
          "source": "src/FRP-Reactive-PrimReactive.html#isMonotoneR",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "isMonotoneR",
          "normalized": "ReactiveG a b-\u003eBool",
          "package": "reactive",
          "partial": "Monotone",
          "signature": "ReactiveG t a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:isMonotoneR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePass through \u003ccode\u003eJust\u003c/code\u003e occurrences.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "joinMaybes",
          "package": "reactive",
          "signature": "m (Maybe a) -\u003e m a",
          "source": "src/FRP-Reactive-PrimReactive.html#joinMaybes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:joinMaybes\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:joinMaybes\"]"
        },
        "index": {
          "description": "Pass through Just occurrences",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "joinMaybes",
          "normalized": "a(Maybe b)-\u003ea b",
          "package": "reactive",
          "partial": "Maybes",
          "signature": "m(Maybe a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:joinMaybes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExperimental specialization of \u003ccode\u003e\u003ca\u003ejoinMaybes\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "justE",
          "package": "reactive",
          "signature": "EventG t (Maybe a) -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#justE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:justE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:justE\"]"
        },
        "index": {
          "description": "Experimental specialization of joinMaybes",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "justE",
          "normalized": "EventG a(Maybe b)-\u003eEventG a b",
          "package": "reactive",
          "signature": "EventG t(Maybe a)-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:justE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a temporally monotonic list of futures to an event.  See also\n the specialization \u003ccode\u003elistE\u003c/code\u003e\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "listEG",
          "package": "reactive",
          "signature": "[(t, a)] -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#listEG",
          "type": "function"
        },
        "index": {
          "description": "Convert temporally monotonic list of futures to an event See also the specialization listE",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "listEG",
          "normalized": "[(a,b)]-\u003eEventG a b",
          "package": "reactive",
          "partial": "EG",
          "signature": "[(t,a)]-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:listEG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.PrimReactive",
          "name": "monoid_E",
          "package": "reactive",
          "signature": "TestBatch",
          "source": "src/FRP-Reactive-PrimReactive.html#monoid_E",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "monoid_E",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:monoid_E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJust the first occurrence of an event.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "once",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#once",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:once\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:once\"]"
        },
        "index": {
          "description": "Just the first occurrence of an event",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "once",
          "normalized": "EventG a b-\u003eEventG a b",
          "package": "reactive",
          "signature": "EventG t a-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:once"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a given function inside the results of other functions.\n Equivalent to '(.)', but has a nicer reading when composed\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "result",
          "package": "reactive",
          "signature": "(b -\u003e b') -\u003e (a -\u003e b) -\u003e a -\u003e b'",
          "source": "src/FRP-Reactive-PrimReactive.html#result",
          "type": "function"
        },
        "index": {
          "description": "Apply given function inside the results of other functions Equivalent to but has nicer reading when composed",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "result",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ea)-\u003ec-\u003eb",
          "package": "reactive",
          "signature": "(b-\u003eb')-\u003e(a-\u003eb)-\u003ea-\u003eb'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:result"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSnapshot a reactive value whenever an event occurs and apply a\n combining function to the event and reactive's values.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "snapshotWith",
          "package": "reactive",
          "signature": "(a -\u003e b -\u003e c) -\u003e ReactiveG t b -\u003e EventG t a -\u003e EventG t c",
          "source": "src/FRP-Reactive-PrimReactive.html#snapshotWith",
          "type": "function"
        },
        "index": {
          "description": "Snapshot reactive value whenever an event occurs and apply combining function to the event and reactive values",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "snapshotWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eReactiveG d b-\u003eEventG d a-\u003eEventG d c",
          "package": "reactive",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eReactiveG t b-\u003eEventG t a-\u003eEventG t c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:snapshotWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive value from an initial value and a new-value event.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "stepper",
          "package": "reactive",
          "signature": "a -\u003e EventG t a -\u003e ReactiveG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#stepper",
          "type": "function"
        },
        "index": {
          "description": "Reactive value from an initial value and new-value event",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "stepper",
          "normalized": "a-\u003eEventG b a-\u003eReactiveG b a",
          "package": "reactive",
          "signature": "a-\u003eEventG t a-\u003eReactiveG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:stepper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch between reactive values.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "switcher",
          "package": "reactive",
          "signature": "ReactiveG t a -\u003e EventG t (ReactiveG t a) -\u003e ReactiveG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#switcher",
          "type": "function"
        },
        "index": {
          "description": "Switch between reactive values",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "switcher",
          "normalized": "ReactiveG a b-\u003eEventG a(ReactiveG a b)-\u003eReactiveG a b",
          "package": "reactive",
          "signature": "ReactiveG t a-\u003eEventG t(ReactiveG t a)-\u003eReactiveG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:switcher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTruncate first event at first occurrence of second event.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "untilE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t b -\u003e EventG t a",
          "source": "src/FRP-Reactive-PrimReactive.html#untilE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:untilE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:untilE\"]"
        },
        "index": {
          "description": "Truncate first event at first occurrence of second event",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "untilE",
          "normalized": "EventG a b-\u003eEventG a c-\u003eEventG a b",
          "package": "reactive",
          "signature": "EventG t a-\u003eEventG t b-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:untilE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the remainder with each event occurrence.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.PrimReactive\",\"FRP.Reactive\"]",
          "name": "withRestE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t (a, EventG t a)",
          "source": "src/FRP-Reactive-PrimReactive.html#withRestE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:withRestE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:withRestE\"]"
        },
        "index": {
          "description": "Access the remainder with each event occurrence",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "withRestE",
          "normalized": "EventG a b-\u003eEventG a(b,EventG a b)",
          "package": "reactive",
          "partial": "Rest",
          "signature": "EventG t a-\u003eEventG t(a,EventG t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:withRestE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess occurrence times in an event.  See also \u003ccode\u003e\u003ca\u003ewithTimeGR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "withTimeGE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t (a, Time t)",
          "source": "src/FRP-Reactive-PrimReactive.html#withTimeGE",
          "type": "function"
        },
        "index": {
          "description": "Access occurrence times in an event See also withTimeGR",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "withTimeGE",
          "normalized": "EventG a b-\u003eEventG a(b,Time a)",
          "package": "reactive",
          "partial": "Time GE",
          "signature": "EventG t a-\u003eEventG t(a,Time t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:withTimeGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess occurrence times in a reactive value.  See also \u003ccode\u003e\u003ca\u003ewithTimeGE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.PrimReactive",
          "name": "withTimeGR",
          "package": "reactive",
          "signature": "Time t -\u003e ReactiveG t a -\u003e ReactiveG t (a, Time t)",
          "source": "src/FRP-Reactive-PrimReactive.html#withTimeGR",
          "type": "function"
        },
        "index": {
          "description": "Access occurrence times in reactive value See also withTimeGE",
          "hierarchy": "FRP Reactive PrimReactive",
          "module": "FRP.Reactive.PrimReactive",
          "name": "withTimeGR",
          "normalized": "Time a-\u003eReactiveG a b-\u003eReactiveG a(b,Time a)",
          "package": "reactive",
          "partial": "Time GR",
          "signature": "Time t-\u003eReactiveG t a-\u003eReactiveG t(a,Time t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-PrimReactive.html#v:withTimeGR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple reactive values.  Adds some extra functionality on top of\n \u003ca\u003eFRP.Reactive.PrimReactive\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html",
          "type": "module"
        },
        "index": {
          "description": "Simple reactive values Adds some extra functionality on top of FRP.Reactive.PrimReactive",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "partial": "Reactive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvents, specialized to improving doubles for time\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "Event",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#Event",
          "type": "type"
        },
        "index": {
          "description": "Events specialized to improving doubles for time",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "Event",
          "package": "reactive",
          "partial": "Event",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#t:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of future values.  Specializes \u003ccode\u003e\u003ca\u003eFutureG\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "Future",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#Future",
          "type": "type"
        },
        "index": {
          "description": "Type of future values Specializes FutureG",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "Future",
          "package": "reactive",
          "partial": "Future",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#t:Future"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImproving times, as used for time values in \u003ccode\u003e\u003ca\u003eEvent\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eReactive\u003c/a\u003e\u003c/code\u003e,\n and \u003ccode\u003eReactiveB\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "ITime",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#ITime",
          "type": "type"
        },
        "index": {
          "description": "Improving times as used for time values in Event Reactive and ReactiveB",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "ITime",
          "package": "reactive",
          "partial": "ITime",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#t:ITime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Reactive",
          "name": "ImpBounds",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#ImpBounds",
          "type": "type"
        },
        "index": {
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "ImpBounds",
          "package": "reactive",
          "partial": "Imp Bounds",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#t:ImpBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive values, specialized to improving doubles for time\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#Reactive",
          "type": "type"
        },
        "index": {
          "description": "Reactive values specialized to improving doubles for time",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "partial": "Reactive",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#t:Reactive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of time values with additional min & max elements.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "TimeT",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#TimeT",
          "type": "type"
        },
        "index": {
          "description": "The type of time values with additional min max elements",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "TimeT",
          "package": "reactive",
          "partial": "Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#t:TimeT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle-occurrence event at given time.  See \u003ccode\u003e\u003ca\u003eatTimes\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eatTimeG\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "atTime",
          "package": "reactive",
          "signature": "TimeT -\u003e Event ()",
          "source": "src/FRP-Reactive-Reactive.html#atTime",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:atTime\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:atTime\"]"
        },
        "index": {
          "description": "Single-occurrence event at given time See atTimes and atTimeG",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "atTime",
          "normalized": "TimeT-\u003eEvent()",
          "package": "reactive",
          "partial": "Time",
          "signature": "TimeT-\u003eEvent()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:atTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvent occuring at given times.  See also \u003ccode\u003e\u003ca\u003eatTime\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eatTimeG\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "atTimes",
          "package": "reactive",
          "signature": "[TimeT] -\u003e Event ()",
          "source": "src/FRP-Reactive-Reactive.html#atTimes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:atTimes\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:atTimes\"]"
        },
        "index": {
          "description": "Event occuring at given times See also atTime and atTimeG",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "atTimes",
          "normalized": "[TimeT]-\u003eEvent()",
          "package": "reactive",
          "partial": "Times",
          "signature": "[TimeT]-\u003eEvent()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:atTimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Reactive",
          "name": "batch",
          "package": "reactive",
          "signature": "TestBatch",
          "source": "src/FRP-Reactive-Reactive.html#batch",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "batch",
          "package": "reactive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:batch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount occurrences of an event, remembering the occurrence values.\n See also \u003ccode\u003e\u003ca\u003ecountE_\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "countE",
          "package": "reactive",
          "signature": "EventG t b -\u003e EventG t (b, n)",
          "source": "src/FRP-Reactive-Reactive.html#countE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:countE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:countE\"]"
        },
        "index": {
          "description": "Count occurrences of an event remembering the occurrence values See also countE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "countE",
          "normalized": "EventG a b-\u003eEventG a(b,c)",
          "package": "reactive",
          "signature": "EventG t b-\u003eEventG t(b,n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:countE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount occurrences of an event, forgetting the occurrence values.  See\n also \u003ccode\u003e\u003ca\u003ecountE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "countE_",
          "package": "reactive",
          "signature": "EventG t b -\u003e EventG t n",
          "source": "src/FRP-Reactive-Reactive.html#countE_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:countE_\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:countE_\"]"
        },
        "index": {
          "description": "Count occurrences of an event forgetting the occurrence values See also countE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "countE_",
          "normalized": "EventG a b-\u003eEventG a c",
          "package": "reactive",
          "signature": "EventG t b-\u003eEventG t n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:countE_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount occurrences of an event.  See also \u003ccode\u003e\u003ca\u003ecountE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "countR",
          "package": "reactive",
          "signature": "EventG t a -\u003e ReactiveG t n",
          "source": "src/FRP-Reactive-Reactive.html#countR",
          "type": "function"
        },
        "index": {
          "description": "Count occurrences of an event See also countE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "countR",
          "normalized": "EventG a b-\u003eReactiveG a c",
          "package": "reactive",
          "signature": "EventG t a-\u003eReactiveG t n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:countR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDifference of successive event occurrences.  See \u003ccode\u003e\u003ca\u003ewithPrevE\u003c/a\u003e\u003c/code\u003e for a\n trick to supply an initial previous value.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "diffE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t (Diff a)",
          "source": "src/FRP-Reactive-Reactive.html#diffE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:diffE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:diffE\"]"
        },
        "index": {
          "description": "Difference of successive event occurrences See withPrevE for trick to supply an initial previous value",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "diffE",
          "normalized": "EventG a b-\u003eEventG a(Diff b)",
          "package": "reactive",
          "signature": "EventG t a-\u003eEventG t(Diff a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:diffE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two events into one.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "eitherE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t b -\u003e EventG t (Either a b)",
          "source": "src/FRP-Reactive-Reactive.html#eitherE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:eitherE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:eitherE\"]"
        },
        "index": {
          "description": "Combine two events into one",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "eitherE",
          "normalized": "EventG a b-\u003eEventG a c-\u003eEventG a(Either b c)",
          "package": "reactive",
          "signature": "EventG t a-\u003eEventG t b-\u003eEventG t(Either a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:eitherE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Reactive",
          "name": "exact",
          "package": "reactive",
          "signature": "Improving a -\u003e a",
          "source": "src/FRP-Reactive-Improving.html#exact",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "exact",
          "normalized": "Improving a-\u003ea",
          "package": "reactive",
          "signature": "Improving a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:exact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExact & finite content of an \u003ccode\u003e\u003ca\u003eImpBounds\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "exactNB",
          "package": "reactive",
          "signature": "ImpBounds t -\u003e t",
          "source": "src/FRP-Reactive-Reactive.html#exactNB",
          "type": "function"
        },
        "index": {
          "description": "Exact finite content of an ImpBounds",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "exactNB",
          "normalized": "ImpBounds a-\u003ea",
          "package": "reactive",
          "partial": "NB",
          "signature": "ImpBounds t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:exactNB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the first occurrence value of an event.  See also\n \u003ccode\u003e\u003ca\u003efirstRestE\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erestE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "firstE",
          "package": "reactive",
          "signature": "EventG t a -\u003e a",
          "source": "src/FRP-Reactive-Reactive.html#firstE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:firstE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:firstE\"]"
        },
        "index": {
          "description": "Extract the first occurrence value of an event See also firstRestE and restE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "firstE",
          "normalized": "EventG a b-\u003eb",
          "package": "reactive",
          "signature": "EventG t a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:firstE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecompose an event into its first occurrence value and a remainder\n event.  See also \u003ccode\u003e\u003ca\u003efirstE\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erestE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "firstRestE",
          "package": "reactive",
          "signature": "EventG t a -\u003e (a, EventG t a)",
          "source": "src/FRP-Reactive-Reactive.html#firstRestE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:firstRestE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:firstRestE\"]"
        },
        "index": {
          "description": "Decompose an event into its first occurrence value and remainder event See also firstE and restE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "firstRestE",
          "normalized": "EventG a b-\u003e(b,EventG a b)",
          "package": "reactive",
          "partial": "Rest",
          "signature": "EventG t a-\u003e(a,EventG t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:firstRestE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlip-flopping reactive value.  Turns true when \u003ccode\u003eea\u003c/code\u003e occurs and false\n when \u003ccode\u003eeb\u003c/code\u003e occurs.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "flipFlop",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t b -\u003e ReactiveG t Bool",
          "source": "src/FRP-Reactive-Reactive.html#flipFlop",
          "type": "function"
        },
        "index": {
          "description": "Flip-flopping reactive value Turns true when ea occurs and false when eb occurs",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "flipFlop",
          "normalized": "EventG a b-\u003eEventG a c-\u003eReactiveG a Bool",
          "package": "reactive",
          "partial": "Flop",
          "signature": "EventG t a-\u003eEventG t b-\u003eReactiveG t Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:flipFlop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEuler integral.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "integral",
          "package": "reactive",
          "signature": "t -\u003e Event t -\u003e Reactive v -\u003e Reactive v",
          "source": "src/FRP-Reactive-Reactive.html#integral",
          "type": "function"
        },
        "index": {
          "description": "Euler integral",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "integral",
          "normalized": "a-\u003eEvent a-\u003eReactive b-\u003eReactive b",
          "package": "reactive",
          "signature": "t-\u003eEvent t-\u003eReactive v-\u003eReactive v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a temporally monotonic list of timed values to an event.  See also\n the generalization \u003ccode\u003e\u003ca\u003elistEG\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "listE",
          "package": "reactive",
          "signature": "[(TimeT, a)] -\u003e Event a",
          "source": "src/FRP-Reactive-Reactive.html#listE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:listE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:listE\"]"
        },
        "index": {
          "description": "Convert temporally monotonic list of timed values to an event See also the generalization listEG",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "listE",
          "normalized": "[(TimeT,a)]-\u003eEvent a",
          "package": "reactive",
          "signature": "[(TimeT,a)]-\u003eEvent a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:listE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart out blank (\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e), latching onto each new \u003ccode\u003ea\u003c/code\u003e, and blanking\n on each \u003ccode\u003eb\u003c/code\u003e.  If you just want to latch and not blank, then use\n \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003elose\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "maybeR",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t b -\u003e ReactiveG t (Maybe a)",
          "source": "src/FRP-Reactive-Reactive.html#maybeR",
          "type": "function"
        },
        "index": {
          "description": "Start out blank Nothing latching onto each new and blanking on each If you just want to latch and not blank then use mempty for lose",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "maybeR",
          "normalized": "EventG a b-\u003eEventG a c-\u003eReactiveG a(Maybe b)",
          "package": "reactive",
          "signature": "EventG t a-\u003eEventG t b-\u003eReactiveG t(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:maybeR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMealy-style state machine, given initial value and transition\n function.  Carries along event data.  See also \u003ccode\u003e\u003ca\u003emealy_\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "mealy",
          "package": "reactive",
          "signature": "s -\u003e (s -\u003e s) -\u003e EventG t b -\u003e EventG t (b, s)",
          "source": "src/FRP-Reactive-Reactive.html#mealy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:mealy\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:mealy\"]"
        },
        "index": {
          "description": "Mealy-style state machine given initial value and transition function Carries along event data See also mealy",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "mealy",
          "normalized": "a-\u003e(a-\u003ea)-\u003eEventG b c-\u003eEventG b(c,a)",
          "package": "reactive",
          "signature": "s-\u003e(s-\u003es)-\u003eEventG t b-\u003eEventG t(b,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:mealy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMealy-style state machine, given initial value and transition\n function.  Forgetful version of \u003ccode\u003e\u003ca\u003emealy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "mealy_",
          "package": "reactive",
          "signature": "s -\u003e (s -\u003e s) -\u003e EventG t b -\u003e EventG t s",
          "source": "src/FRP-Reactive-Reactive.html#mealy_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:mealy_\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:mealy_\"]"
        },
        "index": {
          "description": "Mealy-style state machine given initial value and transition function Forgetful version of mealy",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "mealy_",
          "normalized": "a-\u003e(a-\u003ea)-\u003eEventG b c-\u003eEventG b a",
          "package": "reactive",
          "signature": "s-\u003e(s-\u003es)-\u003eEventG t b-\u003eEventG t s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:mealy_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccumulate values from a monoid-typed event.  Specialization of\n \u003ccode\u003e\u003ca\u003escanlE\u003c/a\u003e\u003c/code\u003e, using \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "monoidE",
          "package": "reactive",
          "signature": "EventG t o -\u003e EventG t o",
          "source": "src/FRP-Reactive-Reactive.html#monoidE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:monoidE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:monoidE\"]"
        },
        "index": {
          "description": "Accumulate values from monoid-typed event Specialization of scanlE using mappend and mempty",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "monoidE",
          "normalized": "EventG a b-\u003eEventG a b",
          "package": "reactive",
          "signature": "EventG t o-\u003eEventG t o",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:monoidE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccumulate values from a monoid-valued event.  Specialization of\n \u003ccode\u003e\u003ca\u003escanlE\u003c/a\u003e\u003c/code\u003e, using \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e.  See also \u003ccode\u003e\u003ca\u003emonoidE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "monoidR",
          "package": "reactive",
          "signature": "EventG t a -\u003e ReactiveG t a",
          "source": "src/FRP-Reactive-Reactive.html#monoidR",
          "type": "function"
        },
        "index": {
          "description": "Accumulate values from monoid-valued event Specialization of scanlE using mappend and mempty See also monoidE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "monoidR",
          "normalized": "EventG a b-\u003eReactiveG a b",
          "package": "reactive",
          "signature": "EventG t a-\u003eReactiveG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:monoidR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an event into a single-occurrence event, whose occurrence\n contains the remainder.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "onceRestE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t (a, EventG t a)",
          "source": "src/FRP-Reactive-Reactive.html#onceRestE",
          "type": "function"
        },
        "index": {
          "description": "Convert an event into single-occurrence event whose occurrence contains the remainder",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "onceRestE",
          "normalized": "EventG a b-\u003eEventG a(b,EventG a b)",
          "package": "reactive",
          "partial": "Rest",
          "signature": "EventG t a-\u003eEventG t(a,EventG t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:onceRestE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemaining part of an event.  See also \u003ccode\u003e\u003ca\u003ewithRestE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "remainderR",
          "package": "reactive",
          "signature": "EventG t a -\u003e ReactiveG t (EventG t a)",
          "source": "src/FRP-Reactive-Reactive.html#remainderR",
          "type": "function"
        },
        "index": {
          "description": "Remaining part of an event See also withRestE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "remainderR",
          "normalized": "EventG a b-\u003eReactiveG a(EventG a b)",
          "package": "reactive",
          "signature": "EventG t a-\u003eReactiveG t(EventG t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:remainderR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the remainder an event, after its first occurrence.  See also\n \u003ccode\u003e\u003ca\u003efirstRestE\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efirstE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "restE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t a",
          "source": "src/FRP-Reactive-Reactive.html#restE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:restE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:restE\"]"
        },
        "index": {
          "description": "Extract the remainder an event after its first occurrence See also firstRestE and firstE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "restE",
          "normalized": "EventG a b-\u003eEventG a b",
          "package": "reactive",
          "signature": "EventG t a-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:restE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e for events.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "scanlE",
          "package": "reactive",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e EventG t b -\u003e EventG t a",
          "source": "src/FRP-Reactive-Reactive.html#scanlE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:scanlE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:scanlE\"]"
        },
        "index": {
          "description": "Like scanl for events",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "scanlE",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eEventG c b-\u003eEventG c a",
          "package": "reactive",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eEventG t b-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:scanlE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e for reactive values.  See also \u003ccode\u003e\u003ca\u003escanlE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "scanlR",
          "package": "reactive",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e EventG t b -\u003e ReactiveG t a",
          "source": "src/FRP-Reactive-Reactive.html#scanlR",
          "type": "function"
        },
        "index": {
          "description": "Like scanl for reactive values See also scanlE",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "scanlR",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eEventG c b-\u003eReactiveG c a",
          "package": "reactive",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eEventG t b-\u003eReactiveG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:scanlR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTack remainders a second event onto values of a first event.  Occurs\n when the first event occurs.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "snapRemainderE",
          "package": "reactive",
          "signature": "EventG t b -\u003e EventG t a -\u003e EventG t (a, EventG t b)",
          "source": "src/FRP-Reactive-Reactive.html#snapRemainderE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:snapRemainderE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:snapRemainderE\"]"
        },
        "index": {
          "description": "Tack remainders second event onto values of first event Occurs when the first event occurs",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "snapRemainderE",
          "normalized": "EventG a b-\u003eEventG a c-\u003eEventG a(c,EventG a b)",
          "package": "reactive",
          "partial": "Remainder",
          "signature": "EventG t b-\u003eEventG t a-\u003eEventG t(a,EventG t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:snapRemainderE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSnapshot a reactive value whenever an event occurs.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "snapshot",
          "package": "reactive",
          "signature": "ReactiveG t b -\u003e EventG t a -\u003e EventG t (a, b)",
          "source": "src/FRP-Reactive-Reactive.html#snapshot",
          "type": "function"
        },
        "index": {
          "description": "Snapshot reactive value whenever an event occurs",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "snapshot",
          "normalized": "ReactiveG a b-\u003eEventG a c-\u003eEventG a(c,b)",
          "package": "reactive",
          "signature": "ReactiveG t b-\u003eEventG t a-\u003eEventG t(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:snapshot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003esnapshot\u003c/a\u003e\u003c/code\u003e but discarding event data (often \u003ccode\u003ea\u003c/code\u003e is '()').\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "snapshot_",
          "package": "reactive",
          "signature": "ReactiveG t b -\u003e EventG t a -\u003e EventG t b",
          "source": "src/FRP-Reactive-Reactive.html#snapshot_",
          "type": "function"
        },
        "index": {
          "description": "Like snapshot but discarding event data often is",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "snapshot_",
          "normalized": "ReactiveG a b-\u003eEventG a c-\u003eEventG a b",
          "package": "reactive",
          "signature": "ReactiveG t b-\u003eEventG t a-\u003eEventG t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:snapshot_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartition an event into segments.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "splitE",
          "package": "reactive",
          "signature": "EventG t b -\u003e EventG t a -\u003e EventG t (a, EventG t b)",
          "source": "src/FRP-Reactive-Reactive.html#splitE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:splitE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:splitE\"]"
        },
        "index": {
          "description": "Partition an event into segments",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "splitE",
          "normalized": "EventG a b-\u003eEventG a c-\u003eEventG a(c,EventG a b)",
          "package": "reactive",
          "signature": "EventG t b-\u003eEventG t a-\u003eEventG t(a,EventG t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:splitE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.Reactive",
          "name": "sumR",
          "package": "reactive",
          "signature": "EventG t v -\u003e ReactiveG t v",
          "source": "src/FRP-Reactive-Reactive.html#sumR",
          "type": "function"
        },
        "index": {
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "sumR",
          "normalized": "EventG a b-\u003eReactiveG a b",
          "package": "reactive",
          "signature": "EventG t v-\u003eReactiveG t v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:sumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch from one event to another, as they occur.  (Doesn't merge, as\n \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e does.)\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "switchE",
          "package": "reactive",
          "signature": "EventG t (EventG t a) -\u003e EventG t a",
          "source": "src/FRP-Reactive-Reactive.html#switchE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:switchE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:switchE\"]"
        },
        "index": {
          "description": "Switch from one event to another as they occur Doesn merge as join does",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "switchE",
          "normalized": "EventG a(EventG a b)-\u003eEventG a b",
          "package": "reactive",
          "signature": "EventG t(EventG t a)-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:switchE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrace the elements of a functor type.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "traceF",
          "package": "reactive",
          "signature": "(a -\u003e String) -\u003e f a -\u003e f a",
          "source": "src/FRP-Reactive-Reactive.html#traceF",
          "type": "function"
        },
        "index": {
          "description": "Trace the elements of functor type",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "traceF",
          "normalized": "(a-\u003eString)-\u003eb a-\u003eb a",
          "package": "reactive",
          "signature": "(a-\u003eString)-\u003ef a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:traceF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter an event according to whether a reactive boolean is true.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "whenE",
          "package": "reactive",
          "signature": "EventG t a -\u003e ReactiveG t Bool -\u003e EventG t a",
          "source": "src/FRP-Reactive-Reactive.html#whenE",
          "type": "function"
        },
        "index": {
          "description": "Filter an event according to whether reactive boolean is true",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "whenE",
          "normalized": "EventG a b-\u003eReactiveG a Bool-\u003eEventG a b",
          "package": "reactive",
          "signature": "EventG t a-\u003eReactiveG t Bool-\u003eEventG t a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:whenE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair each event value with the next one one.  The second result is\n the next one.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "withNextE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t (a, a)",
          "source": "src/FRP-Reactive-Reactive.html#withNextE",
          "type": "function"
        },
        "index": {
          "description": "Pair each event value with the next one one The second result is the next one",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "withNextE",
          "normalized": "EventG a b-\u003eEventG a(b,b)",
          "package": "reactive",
          "partial": "Next",
          "signature": "EventG t a-\u003eEventG t(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withNextE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ewithNextE\u003c/a\u003e\u003c/code\u003e, but allow a function to combine the values.\n Provided for convenience.\n\u003c/p\u003e",
          "module": "FRP.Reactive.Reactive",
          "name": "withNextEWith",
          "package": "reactive",
          "signature": "(a -\u003e a -\u003e b) -\u003e EventG t a -\u003e EventG t b",
          "source": "src/FRP-Reactive-Reactive.html#withNextEWith",
          "type": "function"
        },
        "index": {
          "description": "Same as withNextE but allow function to combine the values Provided for convenience",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "withNextEWith",
          "normalized": "(a-\u003ea-\u003eb)-\u003eEventG c a-\u003eEventG c b",
          "package": "reactive",
          "partial": "Next EWith",
          "signature": "(a-\u003ea-\u003eb)-\u003eEventG t a-\u003eEventG t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withNextEWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair each event value with the previous one.  The second result is\n the old one.  Nothing will come out for the first occurrence of \u003ccode\u003ee\u003c/code\u003e,\n but if you have an initial value \u003ccode\u003ea\u003c/code\u003e, you can do \u003ccode\u003ewithPrevE (pure a\n \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "withPrevE",
          "package": "reactive",
          "signature": "EventG t a -\u003e EventG t (a, a)",
          "source": "src/FRP-Reactive-Reactive.html#withPrevE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withPrevE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:withPrevE\"]"
        },
        "index": {
          "description": "Pair each event value with the previous one The second result is the old one Nothing will come out for the first occurrence of but if you have an initial value you can do withPrevE pure mappend",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "withPrevE",
          "normalized": "EventG a b-\u003eEventG a(b,b)",
          "package": "reactive",
          "partial": "Prev",
          "signature": "EventG t a-\u003eEventG t(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withPrevE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ewithPrevE\u003c/a\u003e\u003c/code\u003e, but allow a function to combine the values.\n Provided for convenience.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "withPrevEWith",
          "package": "reactive",
          "signature": "(a -\u003e a -\u003e b) -\u003e EventG t a -\u003e EventG t b",
          "source": "src/FRP-Reactive-Reactive.html#withPrevEWith",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withPrevEWith\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:withPrevEWith\"]"
        },
        "index": {
          "description": "Same as withPrevE but allow function to combine the values Provided for convenience",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "withPrevEWith",
          "normalized": "(a-\u003ea-\u003eb)-\u003eEventG c a-\u003eEventG c b",
          "package": "reactive",
          "partial": "Prev EWith",
          "signature": "(a-\u003ea-\u003eb)-\u003eEventG t a-\u003eEventG t b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withPrevEWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess occurrence times in an event.  See \u003ccode\u003e\u003ca\u003ewithTimeGE\u003c/a\u003e\u003c/code\u003e for more\n general notions of time.\n\u003c/p\u003e\u003cpre\u003e withTimeE :: Event a -\u003e Event (a, TimeT)\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "withTimeE",
          "package": "reactive",
          "signature": "EventG (ImpBounds t) d -\u003e EventG (ImpBounds t) (d, t)",
          "source": "src/FRP-Reactive-Reactive.html#withTimeE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withTimeE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:withTimeE\"]"
        },
        "index": {
          "description": "Access occurrence times in an event See withTimeGE for more general notions of time withTimeE Event Event TimeT",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "withTimeE",
          "normalized": "EventG(ImpBounds a)b-\u003eEventG(ImpBounds a)(b,a)",
          "package": "reactive",
          "partial": "Time",
          "signature": "EventG(ImpBounds t)d-\u003eEventG(ImpBounds t)(d,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withTimeE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess occurrence times in an event.  Discard the rest.  See also\n \u003ccode\u003e\u003ca\u003ewithTimeE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e withTimeE_ :: Event a -\u003e Event TimeT\n\u003c/pre\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "withTimeE_",
          "package": "reactive",
          "signature": "EventG (ImpBounds t) d -\u003e EventG (ImpBounds t) t",
          "source": "src/FRP-Reactive-Reactive.html#withTimeE_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withTimeE_\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:withTimeE_\"]"
        },
        "index": {
          "description": "Access occurrence times in an event Discard the rest See also withTimeE withTimeE Event Event TimeT",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "withTimeE_",
          "normalized": "EventG(ImpBounds a)b-\u003eEventG(ImpBounds a)a",
          "package": "reactive",
          "partial": "Time",
          "signature": "EventG(ImpBounds t)d-\u003eEventG(ImpBounds t)t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:withTimeE_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a pair-valued event, given a pair of initial values and a\n pair of events.  See also \u003ccode\u003epair\u003c/code\u003e on \u003ccode\u003e\u003ca\u003eReactive\u003c/a\u003e\u003c/code\u003e.  Not quite a \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e,\n because of the initial pair required.\n\u003c/p\u003e",
          "module": "[\"FRP.Reactive.Reactive\",\"FRP.Reactive\"]",
          "name": "zipE",
          "package": "reactive",
          "signature": "(c, d) -\u003e (EventG t c, EventG t d) -\u003e EventG t (c, d)",
          "source": "src/FRP-Reactive-Reactive.html#zipE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:zipE\",\"http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#v:zipE\"]"
        },
        "index": {
          "description": "Generate pair-valued event given pair of initial values and pair of events See also pair on Reactive Not quite zip because of the initial pair required",
          "hierarchy": "FRP Reactive Reactive",
          "module": "FRP.Reactive.Reactive",
          "name": "zipE",
          "normalized": "(a,b)-\u003e(EventG c a,EventG c b)-\u003eEventG c(a,b)",
          "package": "reactive",
          "signature": "(c,d)-\u003e(EventG t c,EventG t d)-\u003eEventG t(c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-Reactive.html#v:zipE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive.VectorSpace",
          "name": "VectorSpace",
          "package": "reactive",
          "source": "src/FRP-Reactive-VectorSpace.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "FRP Reactive VectorSpace",
          "module": "FRP.Reactive.VectorSpace",
          "name": "VectorSpace",
          "package": "reactive",
          "partial": "Vector Space",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive-VectorSpace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA library for programming with functional reactive behaviors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "FRP.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "source": "src/FRP-Reactive.html",
          "type": "module"
        },
        "index": {
          "description": "library for programming with functional reactive behaviors",
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "Reactive",
          "package": "reactive",
          "partial": "Reactive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTime-specialized behaviors.\n Note: The signatures of all of the behavior functions can be generalized.  Is\n the interface generality worth the complexity?\n\u003c/p\u003e",
          "module": "FRP.Reactive",
          "name": "Behavior",
          "package": "reactive",
          "source": "src/FRP-Reactive-Behavior.html#Behavior",
          "type": "type"
        },
        "index": {
          "description": "Time-specialized behaviors Note The signatures of all of the behavior functions can be generalized Is the interface generality worth the complexity",
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "Behavior",
          "package": "reactive",
          "partial": "Behavior",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#t:Behavior"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReactive behaviors.  They can be understood in terms of a simple\n model (denotational semantics) as functions of time, namely \u003ccode\u003eat ::\n BehaviorG t a -\u003e (t -\u003e a)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe semantics of \u003ccode\u003e\u003ca\u003eBehaviorG\u003c/a\u003e\u003c/code\u003e instances are given by corresponding\n instances for the semantic model (functions).  See\n \u003ca\u003ehttp://conal.net/blog/posts/simplifying-semantics-with-type-class-morphisms/\u003c/a\u003e.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (fmap f r) == fmap f (at r)\u003c/code\u003e, i.e., \u003ccode\u003efmap f r \u003ccode\u003eat\u003c/code\u003e\n   t == f (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (pure a) == pure a\u003c/code\u003e, and \u003ccode\u003eat (s \u003c*\u003e r) == at s\n   \u003c*\u003e at t\u003c/code\u003e.  That is, \u003ccode\u003epure a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003e(s \u003c*\u003e r) \u003ccode\u003eat\u003c/code\u003e t\n   == (s \u003ccode\u003eat\u003c/code\u003e t) (r \u003ccode\u003eat\u003c/code\u003e t)\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003eat (return a) == return a\u003c/code\u003e, and \u003ccode\u003eat (join rr) == join (at\n   . at rr)\u003c/code\u003e.  That is, \u003ccode\u003ereturn a \u003ccode\u003eat\u003c/code\u003e t == a\u003c/code\u003e, and \u003ccode\u003ejoin rr \u003ccode\u003eat\u003c/code\u003e t ==\n   (rr \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003eat\u003c/code\u003e t\u003c/code\u003e.  As always, \u003ccode\u003e(r \u003e\u003e= f) == join (fmap f r)\u003c/code\u003e.\n   \u003ccode\u003eat (r \u003e\u003e= f) == at r \u003e\u003e= at . f\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e: a typical lifted monoid.  If \u003ccode\u003eo\u003c/code\u003e is a monoid, then\n   \u003ccode\u003eReactive o\u003c/code\u003e is a monoid, with \u003ccode\u003emempty == pure mempty\u003c/code\u003e, and \u003ccode\u003emappend\n   == liftA2 mappend\u003c/code\u003e.  That is, \u003ccode\u003emempty \u003ccode\u003eat\u003c/code\u003e t == mempty\u003c/code\u003e, and \u003ccode\u003e(r\n   \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e s) \u003ccode\u003eat\u003c/code\u003e t == (r \u003ccode\u003eat\u003c/code\u003e t) \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e (s \u003ccode\u003eat\u003c/code\u003e t).\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive",
          "name": "BehaviorG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Behavior.html#BehaviorG",
          "type": "data"
        },
        "index": {
          "description": "Reactive behaviors They can be understood in terms of simple model denotational semantics as functions of time namely at BehaviorG The semantics of BehaviorG instances are given by corresponding instances for the semantic model functions See http conal.net blog posts simplifying-semantics-with-type-class-morphisms Functor at fmap fmap at i.e fmap at at Applicative at pure pure and at at at That is pure at and at at at Monad at return return and at join rr join at at rr That is return at and join rr at rr at at As always join fmap at at at Monoid typical lifted monoid If is monoid then Reactive is monoid with mempty pure mempty and mappend liftA2 mappend That is mempty at mempty and mappend at at mappend at",
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "BehaviorG",
          "package": "reactive",
          "partial": "Behavior",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#t:BehaviorG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "FRP.Reactive",
          "name": "Behaviour",
          "package": "reactive",
          "source": "src/FRP-Reactive-Behavior.html#Behaviour",
          "type": "type"
        },
        "index": {
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "Behaviour",
          "package": "reactive",
          "partial": "Behaviour",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#t:Behaviour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvents, specialized to improving doubles for time\n\u003c/p\u003e",
          "module": "FRP.Reactive",
          "name": "Event",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#Event",
          "type": "type"
        },
        "index": {
          "description": "Events specialized to improving doubles for time",
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "Event",
          "package": "reactive",
          "partial": "Event",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#t:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvents.  Semantically: time-ordered list of future values.\n Instances: \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eMonoid\u003c/code\u003e: \u003ccode\u003emempty\u003c/code\u003e is the event that never occurs, and \u003ccode\u003ee \u003ccode\u003emappend\u003c/code\u003e\n   e'\u003c/code\u003e is the event that combines occurrences from \u003ccode\u003ee\u003c/code\u003e and \u003ccode\u003ee'\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003efmap f e\u003c/code\u003e is the event that occurs whenever \u003ccode\u003ee\u003c/code\u003e occurs,\n   and whose occurrence values come from applying \u003ccode\u003ef\u003c/code\u003e to the values from\n   \u003ccode\u003ee\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eApplicative\u003c/code\u003e: \u003ccode\u003epure a\u003c/code\u003e is an event with a single occurrence at time\n   -Infinity.  \u003ccode\u003eef \u003c*\u003e ex\u003c/code\u003e is an event whose occurrences are made from\n   the \u003cem\u003eproduct\u003c/em\u003e of the occurrences of \u003ccode\u003eef\u003c/code\u003e and \u003ccode\u003eex\u003c/code\u003e.  For every occurrence\n   \u003ccode\u003ef\u003c/code\u003e at time \u003ccode\u003etf\u003c/code\u003e of \u003ccode\u003eef\u003c/code\u003e and occurrence \u003ccode\u003ex\u003c/code\u003e at time \u003ccode\u003etx\u003c/code\u003e of \u003ccode\u003eex\u003c/code\u003e, \u003ccode\u003eef\n   \u003c*\u003e ex\u003c/code\u003e has an occurrence \u003ccode\u003ef x\u003c/code\u003e at time \u003ccode\u003etf \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e tx\u003c/code\u003e.  N.B.: I\n   don't expect this instance to be very useful.  If \u003ccode\u003eef\u003c/code\u003e has \u003ccode\u003enf\u003c/code\u003e\n   instances and \u003ccode\u003eex\u003c/code\u003e has \u003ccode\u003enx\u003c/code\u003e instances, then \u003ccode\u003eef \u003c*\u003e ex\u003c/code\u003e has \u003ccode\u003enf*nx\u003c/code\u003e\n   instances.  However, there are only \u003ccode\u003enf+nx\u003c/code\u003e possibilities for \u003ccode\u003etf\n   \u003ccode\u003e\u003ca\u003emax\u003c/a\u003e\u003c/code\u003e tx\u003c/code\u003e, so many of the occurrences are simultaneous.  If you think\n   you want to use this instance, consider using \u003ccode\u003eReactive\u003c/code\u003e instead.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e: \u003ccode\u003ereturn a\u003c/code\u003e is the same as \u003ccode\u003epure a\u003c/code\u003e (as usual).  In \u003ccode\u003ee \u003e\u003e= f\u003c/code\u003e,\n   each occurrence of \u003ccode\u003ee\u003c/code\u003e leads, through \u003ccode\u003ef\u003c/code\u003e, to a new event.  Similarly\n   for \u003ccode\u003ejoin ee\u003c/code\u003e, which is somehow simpler for me to think about.  The\n   occurrences of \u003ccode\u003ee \u003e\u003e= f\u003c/code\u003e (or \u003ccode\u003ejoin ee\u003c/code\u003e) correspond to the union of the\n   occurrences (temporal interleaving) of all such events.  For example,\n   suppose we're playing Asteroids and tracking collisions.  Each collision\n   can break an asteroid into more of them, each of which has to be tracked\n   for more collisions.  Another example: A chat room has an \u003cem\u003eenter\u003c/em\u003e event,\n   whose occurrences contain new events like \u003cem\u003espeak\u003c/em\u003e.  An especially useful\n   monad-based function is \u003ccode\u003ejoinMaybes\u003c/code\u003e, which filters a Maybe-valued\n   event.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "FRP.Reactive",
          "name": "EventG",
          "package": "reactive",
          "source": "src/FRP-Reactive-Internal-Reactive.html#EventG",
          "type": "data"
        },
        "index": {
          "description": "Events Semantically time-ordered list of future values Instances Monoid mempty is the event that never occurs and mappend is the event that combines occurrences from and Functor fmap is the event that occurs whenever occurs and whose occurrence values come from applying to the values from Applicative pure is an event with single occurrence at time Infinity ef ex is an event whose occurrences are made from the product of the occurrences of ef and ex For every occurrence at time tf of ef and occurrence at time tx of ex ef ex has an occurrence at time tf max tx N.B don expect this instance to be very useful If ef has nf instances and ex has nx instances then ef ex has nf nx instances However there are only nf nx possibilities for tf max tx so many of the occurrences are simultaneous If you think you want to use this instance consider using Reactive instead Monad return is the same as pure as usual In each occurrence of leads through to new event Similarly for join ee which is somehow simpler for me to think about The occurrences of or join ee correspond to the union of the occurrences temporal interleaving of all such events For example suppose we re playing Asteroids and tracking collisions Each collision can break an asteroid into more of them each of which has to be tracked for more collisions Another example chat room has an enter event whose occurrences contain new events like speak An especially useful monad-based function is joinMaybes which filters Maybe-valued event",
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "EventG",
          "package": "reactive",
          "partial": "Event",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#t:EventG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImproving times, as used for time values in \u003ccode\u003e\u003ca\u003eEvent\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eReactive\u003c/a\u003e\u003c/code\u003e,\n and \u003ccode\u003eReactiveB\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "FRP.Reactive",
          "name": "ITime",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#ITime",
          "type": "type"
        },
        "index": {
          "description": "Improving times as used for time values in Event Reactive and ReactiveB",
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "ITime",
          "package": "reactive",
          "partial": "ITime",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#t:ITime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of time values with additional min & max elements.\n\u003c/p\u003e",
          "module": "FRP.Reactive",
          "name": "TimeT",
          "package": "reactive",
          "source": "src/FRP-Reactive-Reactive.html#TimeT",
          "type": "type"
        },
        "index": {
          "description": "The type of time values with additional min max elements",
          "hierarchy": "FRP Reactive",
          "module": "FRP.Reactive",
          "name": "TimeT",
          "package": "reactive",
          "partial": "Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/reactive/docs/FRP-Reactive.html#t:TimeT"
      }
    }
  ]
]