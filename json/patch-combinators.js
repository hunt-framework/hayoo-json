[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "patch-combinators"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePatch combinators: A library for patching functions and data structures\n\u003c/p\u003e\u003cp\u003eA patch can be, for example\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e a type constraint (an identity function with a specific type)\n\u003c/li\u003e\u003cli\u003e a surjective function extending the domain of a function (e.g. turning a\n   function on natural numbers into a function defined for any integer)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eA typical use-case is to constrain the types of a QuickCheck property. Let's\n say we have a property to check associativity of addition:\n\u003c/p\u003e\u003cpre\u003e prop_addAssoc :: (Num a, Ord a) =\u003e a -\u003e a -\u003e a -\u003e Bool\n prop_addAssoc a b c = (a + b) + c == a + (b + c)\n\u003c/pre\u003e\u003cp\u003eIn order to check that this property holds for \u003ccode\u003e\u003ca\u003eInt8\u003c/a\u003e\u003c/code\u003e, we just say:\n\u003c/p\u003e\u003cpre\u003e *Data.Patch\u003e quickCheck (prop_addAssoc -:: tI8 \u003e-\u003e id)\n\u003c/pre\u003e\u003cp\u003eNote that we only had to give a \u003cem\u003epartial\u003c/em\u003e type annotation since all arguments\n are required to have the same type.\n\u003c/p\u003e\u003cp\u003eSometimes properties are only defined for a sub-set of the possible\n arguments. Consider the following property of \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e prop_enum m n = enumFromTo 0 m !! n == n\n\u003c/pre\u003e\u003cp\u003eThis property is only valid when \u003ccode\u003em\u003c/code\u003e and \u003ccode\u003en\u003c/code\u003e are natural numbers and \u003ccode\u003en\u003c=m\u003c/code\u003e.\n Instead of rewriting the property to account for arbitrary integers, we can\n simply apply a patch:\n\u003c/p\u003e\u003cpre\u003e quickCheck (prop_enum -:: name (\\m -\u003e abs \u003e-\u003e (min (abs m) . abs) \u003e-\u003e id))\n\u003c/pre\u003e\u003cp\u003eHere \u003ccode\u003e\u003ca\u003ename\u003c/a\u003e\u003c/code\u003e allows us to bind the first argument generated by QuickCheck.\n The patch uses \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e to make sure that the values passed to the property are\n natural numbers, and \u003ccode\u003e\u003ccode\u003e\u003ca\u003emin\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e m)\u003c/code\u003e to ensure that the second argument\n does not exceed the first.\n\u003c/p\u003e\u003cp\u003eThe library has some similarities with Semantic editor combinators:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://conal.net/blog/posts/semantic-editor-combinators\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe main difference is that semantic editors are about locating and changing\n a small part of a data structure, while patches are about changing all parts\n of the structure. (For partial updates, use the \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e patch to leave\n sub-structures untouched.)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Patch",
          "name": "Patch",
          "package": "patch-combinators",
          "source": "src/Data-Patch.html",
          "type": "module"
        },
        "index": {
          "description": "Patch combinators library for patching functions and data structures patch can be for example type constraint an identity function with specific type surjective function extending the domain of function e.g turning function on natural numbers into function defined for any integer typical use-case is to constrain the types of QuickCheck property Let say we have property to check associativity of addition prop addAssoc Num Ord Bool prop addAssoc In order to check that this property holds for Int8 we just say Data.Patch quickCheck prop addAssoc tI8 id Note that we only had to give partial type annotation since all arguments are required to have the same type Sometimes properties are only defined for sub-set of the possible arguments Consider the following property of enumFromTo prop enum enumFromTo This property is only valid when and are natural numbers and Instead of rewriting the property to account for arbitrary integers we can simply apply patch quickCheck prop enum name abs min abs abs id Here name allows us to bind the first argument generated by QuickCheck The patch uses abs to make sure that the values passed to the property are natural numbers and min abs to ensure that the second argument does not exceed the first The library has some similarities with Semantic editor combinators http conal.net blog posts semantic-editor-combinators The main difference is that semantic editors are about locating and changing small part of data structure while patches are about changing all parts of the structure For partial updates use the id patch to leave sub-structures untouched",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "Patch",
          "package": "patch-combinators",
          "partial": "Patch",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "Patch",
          "package": "patch-combinators",
          "source": "src/Data-Patch.html#Patch",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "Patch",
          "package": "patch-combinators",
          "partial": "Patch",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#t:Patch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePatch application\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "(-::)",
          "package": "patch-combinators",
          "signature": "a -\u003e Patch a b -\u003e b",
          "source": "src/Data-Patch.html#-%3A%3A",
          "type": "function"
        },
        "index": {
          "description": "Patch application",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "(-::) -::",
          "normalized": "a-\u003ePatch a b-\u003eb",
          "package": "patch-combinators",
          "signature": "a-\u003ePatch a b-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:-45-::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction patch\n\u003c/p\u003e\u003cp\u003eThe first patch is applied to the argument and the second patch to the\n result.\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "(\u003e-\u003e)",
          "package": "patch-combinators",
          "signature": "Patch c a -\u003e Patch b d -\u003e Patch (a -\u003e b) (c -\u003e d)",
          "source": "src/Data-Patch.html#%3E-%3E",
          "type": "function"
        },
        "index": {
          "description": "Function patch The first patch is applied to the argument and the second patch to the result",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "(\u003e-\u003e) \u003e-\u003e",
          "normalized": "Patch a b-\u003ePatch c d-\u003ePatch(b-\u003ec)(a-\u003ed)",
          "package": "patch-combinators",
          "signature": "Patch c a-\u003ePatch b d-\u003ePatch(a-\u003eb)(c-\u003ed)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:-62--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA patch that depends on the first argument of the resuting function\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "name",
          "package": "patch-combinators",
          "signature": "(c -\u003e Patch (a -\u003e b) (c -\u003e d)) -\u003e Patch (a -\u003e b) (c -\u003e d)",
          "source": "src/Data-Patch.html#name",
          "type": "function"
        },
        "index": {
          "description": "patch that depends on the first argument of the resuting function",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "name",
          "normalized": "(a-\u003ePatch(b-\u003ec)(a-\u003ed))-\u003ePatch(b-\u003ec)(a-\u003ed)",
          "package": "patch-combinators",
          "signature": "(c-\u003ePatch(a-\u003eb)(c-\u003ed))-\u003ePatch(a-\u003eb)(c-\u003ed)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tBool",
          "package": "patch-combinators",
          "signature": "Patch Bool Bool",
          "source": "src/Data-Patch.html#tBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tBool",
          "package": "patch-combinators",
          "partial": "Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tComplex",
          "package": "patch-combinators",
          "signature": "Patch a a -\u003e Patch (Complex a) (Complex a)",
          "source": "src/Data-Patch.html#tComplex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tComplex",
          "normalized": "Patch a a-\u003ePatch(Complex a)(Complex a)",
          "package": "patch-combinators",
          "partial": "Complex",
          "signature": "Patch a a-\u003ePatch(Complex a)(Complex a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructor\n\u003c/p\u003e\u003cp\u003eExample use:\n\u003c/p\u003e\u003cpre\u003e Data.Patch\u003e let Just a = read \"Just 6\" -:: tCon tFloat\n Data.Patch\u003e a\n 6.0\n\u003c/pre\u003e",
          "module": "Data.Patch",
          "name": "tCon",
          "package": "patch-combinators",
          "signature": "Patch a a -\u003e Patch (c a) (c a)",
          "source": "src/Data-Patch.html#tCon",
          "type": "function"
        },
        "index": {
          "description": "Type constructor Example use Data.Patch let Just read Just tCon tFloat Data.Patch",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tCon",
          "normalized": "Patch a a-\u003ePatch(b a)(b a)",
          "package": "patch-combinators",
          "partial": "Con",
          "signature": "Patch a a-\u003ePatch(c a)(c a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tDouble",
          "package": "patch-combinators",
          "signature": "Patch Double Double",
          "source": "src/Data-Patch.html#tDouble",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tDouble",
          "package": "patch-combinators",
          "partial": "Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tFloat",
          "package": "patch-combinators",
          "signature": "Patch Float Float",
          "source": "src/Data-Patch.html#tFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tFloat",
          "package": "patch-combinators",
          "partial": "Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tI16",
          "package": "patch-combinators",
          "signature": "Patch Int16 Int16",
          "source": "src/Data-Patch.html#tI16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tI16",
          "package": "patch-combinators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tI16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tI32",
          "package": "patch-combinators",
          "signature": "Patch Int32 Int32",
          "source": "src/Data-Patch.html#tI32",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tI32",
          "package": "patch-combinators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tI32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tI8",
          "package": "patch-combinators",
          "signature": "Patch Int8 Int8",
          "source": "src/Data-Patch.html#tI8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tI8",
          "package": "patch-combinators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tI8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tInt",
          "package": "patch-combinators",
          "signature": "Patch Int Int",
          "source": "src/Data-Patch.html#tInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tInt",
          "package": "patch-combinators",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tInteger",
          "package": "patch-combinators",
          "signature": "Patch Integer Integer",
          "source": "src/Data-Patch.html#tInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tInteger",
          "package": "patch-combinators",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tW16",
          "package": "patch-combinators",
          "signature": "Patch Word16 Word16",
          "source": "src/Data-Patch.html#tW16",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tW16",
          "package": "patch-combinators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tW16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tW32",
          "package": "patch-combinators",
          "signature": "Patch Word32 Word32",
          "source": "src/Data-Patch.html#tW32",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tW32",
          "package": "patch-combinators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tW32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tW8",
          "package": "patch-combinators",
          "signature": "Patch Word8 Word8",
          "source": "src/Data-Patch.html#tW8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tW8",
          "package": "patch-combinators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tW8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Patch",
          "name": "tWord",
          "package": "patch-combinators",
          "signature": "Patch Word Word",
          "source": "src/Data-Patch.html#tWord",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tWord",
          "package": "patch-combinators",
          "partial": "Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePair patch (a specialized version of \u003ccode\u003e\u003ca\u003e***\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "tup2",
          "package": "patch-combinators",
          "signature": "Patch a1 b1 -\u003e Patch a2 b2 -\u003e Patch (a1, a2) (b1, b2)",
          "source": "src/Data-Patch.html#tup2",
          "type": "function"
        },
        "index": {
          "description": "Pair patch specialized version of",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tup2",
          "normalized": "Patch a b-\u003ePatch a b-\u003ePatch(a,a)(b,b)",
          "package": "patch-combinators",
          "signature": "Patch a b-\u003ePatch a b-\u003ePatch(a,a)(b,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tup2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003etup2\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "tup3",
          "package": "patch-combinators",
          "signature": "Patch a1 b1 -\u003e Patch a2 b2 -\u003e Patch a3 b3 -\u003e Patch (a1, a2, a3) (b1, b2, b3)",
          "source": "src/Data-Patch.html#tup3",
          "type": "function"
        },
        "index": {
          "description": "Analogous to tup2",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tup3",
          "normalized": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a)(b,b,b)",
          "package": "patch-combinators",
          "signature": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a)(b,b,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tup3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003etup2\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "tup4",
          "package": "patch-combinators",
          "signature": "Patch a1 b1 -\u003e Patch a2 b2 -\u003e Patch a3 b3 -\u003e Patch a4 b4 -\u003e Patch (a1, a2, a3, a4) (b1, b2, b3, b4)",
          "source": "src/Data-Patch.html#tup4",
          "type": "function"
        },
        "index": {
          "description": "Analogous to tup2",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tup4",
          "normalized": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a)(b,b,b,b)",
          "package": "patch-combinators",
          "signature": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a)(b,b,b,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tup4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003etup2\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "tup5",
          "package": "patch-combinators",
          "signature": "Patch a1 b1 -\u003e Patch a2 b2 -\u003e Patch a3 b3 -\u003e Patch a4 b4 -\u003e Patch a5 b5 -\u003e Patch (a1, a2, a3, a4, a5) (b1, b2, b3, b4, b5)",
          "source": "src/Data-Patch.html#tup5",
          "type": "function"
        },
        "index": {
          "description": "Analogous to tup2",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tup5",
          "normalized": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a,a)(b,b,b,b,b)",
          "package": "patch-combinators",
          "signature": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a,a)(b,b,b,b,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tup5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003etup2\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "tup6",
          "package": "patch-combinators",
          "signature": "Patch a1 b1 -\u003e Patch a2 b2 -\u003e Patch a3 b3 -\u003e Patch a4 b4 -\u003e Patch a5 b5 -\u003e Patch a6 b6 -\u003e Patch (a1, a2, a3, a4, a5, a6) (b1, b2, b3, b4, b5, b6)",
          "source": "src/Data-Patch.html#tup6",
          "type": "function"
        },
        "index": {
          "description": "Analogous to tup2",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tup6",
          "normalized": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a,a,a)(b,b,b,b,b,b)",
          "package": "patch-combinators",
          "signature": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a,a,a)(b,b,b,b,b,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tup6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnalogous to \u003ccode\u003e\u003ca\u003etup2\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Patch",
          "name": "tup7",
          "package": "patch-combinators",
          "signature": "Patch a1 b1 -\u003e Patch a2 b2 -\u003e Patch a3 b3 -\u003e Patch a4 b4 -\u003e Patch a5 b5 -\u003e Patch a6 b6 -\u003e Patch a7 b7 -\u003e Patch (a1, a2, a3, a4, a5, a6, a7) (b1, b2, b3, b4, b5, b6, b7)",
          "source": "src/Data-Patch.html#tup7",
          "type": "function"
        },
        "index": {
          "description": "Analogous to tup2",
          "hierarchy": "Data Patch",
          "module": "Data.Patch",
          "name": "tup7",
          "normalized": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a,a,a,a)(b,b,b,b,b,b,b)",
          "package": "patch-combinators",
          "signature": "Patch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch a b-\u003ePatch(a,a,a,a,a,a,a)(b,b,b,b,b,b,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/patch-combinators/docs/Data-Patch.html#v:tup7"
      }
    }
  ]
]