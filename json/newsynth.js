[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "newsynth"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides a replacement for Haskell's \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e. The\n problem is that Haskell's standard implementation of \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e\n depends on the \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e class, which limits its applicability.\n So we provide a new \u003ccode\u003e\u003ca\u003eArcTan2\u003c/a\u003e\u003c/code\u003e class with an \u003ccode\u003e\u003ca\u003earctan2\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e\u003cp\u003eUnlike Haskell's \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e, the \u003ccode\u003e\u003ca\u003earctan2\u003c/a\u003e\u003c/code\u003e function may not take\n signed zeros and signed infinities into account. But it works at\n fixed-precision types such as \u003ccode\u003eFixedPrec\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.ArcTan2",
          "name": "ArcTan2",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-ArcTan2.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides replacement for Haskell atan2 The problem is that Haskell standard implementation of atan2 depends on the RealFloat class which limits its applicability So we provide new ArcTan2 class with an arctan2 function Unlike Haskell atan2 the arctan2 function may not take signed zeros and signed infinities into account But it works at fixed-precision types such as FixedPrec",
          "hierarchy": "Quantum Synthesis ArcTan2",
          "module": "Quantum.Synthesis.ArcTan2",
          "name": "ArcTan2",
          "package": "newsynth",
          "partial": "Arc Tan",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-ArcTan2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe provide a replacement for Haskell's \u003ccode\u003e\u003ca\u003eatan2\u003c/a\u003e\u003c/code\u003e, because the\n latter depends on the \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e class, which limits its\n applicability.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.ArcTan2",
          "name": "ArcTan2",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-ArcTan2.html#ArcTan2",
          "type": "class"
        },
        "index": {
          "description": "We provide replacement for Haskell atan2 because the latter depends on the RealFloat class which limits its applicability",
          "hierarchy": "Quantum Synthesis ArcTan2",
          "module": "Quantum.Synthesis.ArcTan2",
          "name": "ArcTan2",
          "package": "newsynth",
          "partial": "Arc Tan",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-ArcTan2.html#t:ArcTan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.ArcTan2",
          "name": "arctan2",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Quantum-Synthesis-ArcTan2.html#arctan2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Quantum Synthesis ArcTan2",
          "module": "Quantum.Synthesis.ArcTan2",
          "name": "arctan2",
          "normalized": "a-\u003ea-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-ArcTan2.html#v:arctan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides an efficient symbolic representation of the\n Clifford group on one qubit. This group is generated by \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eH\u003c/em\u003e,\n and the scalar &#969; = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ei\u003c/em\u003e&#960;/4\u003c/sup\u003e. It has 192 elements. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Clifford",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Clifford.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides an efficient symbolic representation of the Clifford group on one qubit This group is generated by and the scalar It has elements",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Clifford",
          "package": "newsynth",
          "partial": "Clifford",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA axis is either \u003cem\u003eI\u003c/em\u003e, \u003cem\u003eH\u003c/em\u003e, or \u003cem\u003eSH\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Clifford.html#Axis",
          "type": "data"
        },
        "index": {
          "description": "axis is either or SH",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis",
          "package": "newsynth",
          "partial": "Axis",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#t:Axis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type representing single-qubit Clifford operators.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Clifford",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Clifford.html#Clifford",
          "type": "data"
        },
        "index": {
          "description": "type representing single-qubit Clifford operators",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Clifford",
          "package": "newsynth",
          "partial": "Clifford",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#t:Clifford"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for things that can be exactly converted to a\n Clifford operator. One particular instance of this is \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e, so\n that Clifford operators can be denoted, e.g.,\n\u003c/p\u003e\u003cpre\u003e to_clifford \"-iX\"\n\u003c/pre\u003e\u003cp\u003eThe valid characters for such string conversions are \u003ccode\u003e\"XYZHSEIWi-\"\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "ToClifford",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Clifford.html#ToClifford",
          "type": "class"
        },
        "index": {
          "description": "type class for things that can be exactly converted to Clifford operator One particular instance of this is String so that Clifford operators can be denoted e.g to clifford iX The valid characters for such string conversions are XYZHSEIWi",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "ToClifford",
          "package": "newsynth",
          "partial": "To Clifford",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#t:ToClifford"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis_H",
          "package": "newsynth",
          "signature": "Axis_H",
          "source": "src/Quantum-Synthesis-Clifford.html#Axis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis_H",
          "package": "newsynth",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:Axis_H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis_I",
          "package": "newsynth",
          "signature": "Axis_I",
          "source": "src/Quantum-Synthesis-Clifford.html#Axis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis_I",
          "package": "newsynth",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:Axis_I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis_SH",
          "package": "newsynth",
          "signature": "Axis_SH",
          "source": "src/Quantum-Synthesis-Clifford.html#Axis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "Axis_SH",
          "package": "newsynth",
          "partial": "Axis SH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:Axis_SH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Clifford operator \u003cem\u003eE\u003c/em\u003e = \u003cem\u003eH\u003c/em\u003e\u003cem\u003eS\u003c/em\u003e\u003csup\u003e3\u003c/sup\u003e&#969;\u003csup\u003e3\u003c/sup\u003e. This operator is\n uniquely determined by the properties \u003cem\u003eE\u003c/em\u003e&#179; = \u003cem\u003eI\u003c/em\u003e, \n \u003cem\u003eEXE\u003c/em\u003e&#8315;&#185; = \u003cem\u003eY\u003c/em\u003e, \u003cem\u003eEYE\u003c/em\u003e&#8315;&#185; = \u003cem\u003eZ\u003c/em\u003e, and \u003cem\u003eEZE\u003c/em\u003e&#8315;&#185; = \u003cem\u003eX\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"E.png\"/\u003e\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_E",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_E",
          "type": "function"
        },
        "index": {
          "description": "The Clifford operator This operator is uniquely determined by the properties EXE EYE and EZE",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_E",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Hadamard gate as a Clifford operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_H",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_H",
          "type": "function"
        },
        "index": {
          "description": "The Hadamard gate as Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_H",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Clifford operator \u003cem\u003eS\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_S",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_S",
          "type": "function"
        },
        "index": {
          "description": "The Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_S",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Clifford operator \u003cem\u003eSH\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_SH",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_SH",
          "type": "function"
        },
        "index": {
          "description": "The Clifford operator SH",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_SH",
          "package": "newsynth",
          "partial": "SH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_SH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Clifford operator &#969; = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ei\u003c/em\u003e&#960;/4\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_W",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_W",
          "type": "function"
        },
        "index": {
          "description": "The Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_W",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eX\u003c/em\u003e-gate as a Clifford operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_X",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_X",
          "type": "function"
        },
        "index": {
          "description": "The Pauli gate as Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_X",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eY\u003c/em\u003e-gate as a Clifford operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_Y",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_Y",
          "type": "function"
        },
        "index": {
          "description": "The Pauli gate as Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_Y",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eZ\u003c/em\u003e-gate as a Clifford operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_Z",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_Z",
          "type": "function"
        },
        "index": {
          "description": "The Pauli gate as Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_Z",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a Clifford operator \u003cem\u003eU\u003c/em\u003e, return (\u003cem\u003ea\u003c/em\u003e, \u003cem\u003eb\u003c/em\u003e, \u003cem\u003ec\u003c/em\u003e, \u003cem\u003ed\u003c/em\u003e) such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eU\u003c/em\u003e = \u003cem\u003eE\u003c/em\u003e\u003csup\u003e\u003cem\u003ea\u003c/em\u003e\u003c/sup\u003e\u003cem\u003eX\u003c/em\u003e\u003csup\u003e\u003cem\u003eb\u003c/em\u003e\u003c/sup\u003e\u003cem\u003eS\u003c/em\u003e\u003csup\u003e\u003cem\u003ec\u003c/em\u003e\u003c/sup\u003e&#969;\u003csup\u003e\u003cem\u003ed\u003c/em\u003e\u003c/sup\u003e,\n\u003c/li\u003e\u003cli\u003e \u003cem\u003ea\u003c/em\u003e &#8712; {0, 1, 2}, \u003cem\u003eb\u003c/em\u003e &#8712; {0, 1}, \u003cem\u003ec\u003c/em\u003e &#8712; {0, &#8230;, 3}, and \u003cem\u003ed\u003c/em\u003e &#8712; {0, &#8230;,\n 7}.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHere, \u003cem\u003eE\u003c/em\u003e = \u003cem\u003eH\u003c/em\u003e\u003cem\u003eS\u003c/em\u003e\u003csup\u003e3\u003c/sup\u003e&#969;\u003csup\u003e3\u003c/sup\u003e. Note that \u003cem\u003eE\u003c/em\u003e, \u003cem\u003eX\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, and &#969; have order\n 3, 2, 4, and 8, respectively. Moreover, each Clifford operator can\n be uniquely represented as above.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_decompose",
          "package": "newsynth",
          "signature": "a -\u003e (Int, Int, Int, Int)",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_decompose",
          "type": "function"
        },
        "index": {
          "description": "Given Clifford operator return such that and Here Note that and have order and respectively Moreover each Clifford operator can be uniquely represented as above",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_decompose",
          "normalized": "a-\u003e(Int,Int,Int,Int)",
          "package": "newsynth",
          "signature": "a-\u003e(Int,Int,Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_decompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a Clifford operator \u003cem\u003eU\u003c/em\u003e, return (\u003cem\u003eK\u003c/em\u003e, \u003cem\u003eb\u003c/em\u003e, \u003cem\u003ec\u003c/em\u003e, \u003cem\u003ed\u003c/em\u003e) such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eU\u003c/em\u003e = \u003cem\u003eK\u003c/em\u003e\u003cem\u003eX\u003c/em\u003e\u003csup\u003e\u003cem\u003eb\u003c/em\u003e\u003c/sup\u003e\u003cem\u003eS\u003c/em\u003e\u003csup\u003e\u003cem\u003ec\u003c/em\u003e\u003c/sup\u003e&#969;\u003csup\u003e\u003cem\u003ed\u003c/em\u003e\u003c/sup\u003e,\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eK\u003c/em\u003e &#8712; {\u003cem\u003eI\u003c/em\u003e, \u003cem\u003eH\u003c/em\u003e, \u003cem\u003eSH\u003c/em\u003e}, \u003cem\u003eb\u003c/em\u003e &#8712; {0, 1}, \u003cem\u003ec\u003c/em\u003e &#8712; {0, &#8230;, 3}, and \u003cem\u003ed\u003c/em\u003e &#8712; {0, &#8230;,\n 7}.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_decompose_coset",
          "package": "newsynth",
          "signature": "a -\u003e (Axis, Int, Int, Int)",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_decompose_coset",
          "type": "function"
        },
        "index": {
          "description": "Given Clifford operator return such that SH and",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_decompose_coset",
          "normalized": "a-\u003e(Axis,Int,Int,Int)",
          "package": "newsynth",
          "signature": "a-\u003e(Axis,Int,Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_decompose_coset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity Clifford operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_id",
          "package": "newsynth",
          "signature": "Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_id",
          "type": "function"
        },
        "index": {
          "description": "The identity Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_id",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClifford inverse.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_inv",
          "package": "newsynth",
          "signature": "a -\u003e Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_inv",
          "type": "function"
        },
        "index": {
          "description": "Clifford inverse",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_inv",
          "normalized": "a-\u003eClifford",
          "package": "newsynth",
          "signature": "a-\u003eClifford",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClifford multiplication.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_mult",
          "package": "newsynth",
          "signature": "Clifford -\u003e Clifford -\u003e Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_mult",
          "type": "function"
        },
        "index": {
          "description": "Clifford multiplication",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_mult",
          "normalized": "Clifford-\u003eClifford-\u003eClifford",
          "package": "newsynth",
          "signature": "Clifford-\u003eClifford-\u003eClifford",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_mult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a Clifford gate \u003cem\u003eC\u003c/em\u003e, return an axis \u003cem\u003eK\u003c/em\u003e &#8712; {\u003cem\u003eI\u003c/em\u003e, \u003cem\u003eH\u003c/em\u003e, \u003cem\u003eSH\u003c/em\u003e}\n and a Clifford gate \u003cem\u003eC'\u003c/em\u003e such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eC\u003c/em\u003e\u003cem\u003eT\u003c/em\u003e = \u003cem\u003eK\u003c/em\u003e\u003cem\u003eT\u003c/em\u003e\u003cem\u003eC\u003c/em\u003e'.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_tconj",
          "package": "newsynth",
          "signature": "Clifford -\u003e (Axis, Clifford)",
          "source": "src/Quantum-Synthesis-Clifford.html#clifford_tconj",
          "type": "function"
        },
        "index": {
          "description": "Given Clifford gate return an axis SH and Clifford gate such that",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "clifford_tconj",
          "normalized": "Clifford-\u003e(Axis,Clifford)",
          "package": "newsynth",
          "signature": "Clifford-\u003e(Axis,Clifford)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:clifford_tconj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert any suitable thing to a Clifford operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Clifford",
          "name": "to_clifford",
          "package": "newsynth",
          "signature": "a -\u003e Clifford",
          "source": "src/Quantum-Synthesis-Clifford.html#to_clifford",
          "type": "method"
        },
        "index": {
          "description": "Convert any suitable thing to Clifford operator",
          "hierarchy": "Quantum Synthesis Clifford",
          "module": "Quantum.Synthesis.Clifford",
          "name": "to_clifford",
          "normalized": "a-\u003eClifford",
          "package": "newsynth",
          "signature": "a-\u003eClifford",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Clifford.html#v:to_clifford"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides a representation of the single-qubit\n Clifford+\u003cem\u003eT\u003c/em\u003e operators, Matsumoto-Amano normal forms, and functions\n for the exact synthesis of single-qubit Clifford+\u003cem\u003eT\u003c/em\u003e operators.\n\u003c/p\u003e\u003cp\u003eMatsumoto-Amano normal forms and the Matsumoto-Amano exact\n synthesis algorithm are described in the paper:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Ken Matsumoto, Kazuyuki Amano. Representation of Quantum Circuits\n with Clifford and &#960;/8 Gates. \u003ca\u003ehttp://arxiv.org/abs/0806.3834\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "CliffordT",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-CliffordT.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides representation of the single-qubit Clifford operators Matsumoto-Amano normal forms and functions for the exact synthesis of single-qubit Clifford operators Matsumoto-Amano normal forms and the Matsumoto-Amano exact synthesis algorithm are described in the paper Ken Matsumoto Kazuyuki Amano Representation of Quantum Circuits with Clifford and Gates http arxiv.org abs",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "CliffordT",
          "package": "newsynth",
          "partial": "Clifford",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for all things that a list of gates can be converted\n to. For example, a list of gates can be converted to an element of\n \u003cem\u003eU\u003c/em\u003e(2) or an element of \u003cem\u003eSO\u003c/em\u003e(3), using various (exact or\n approximate) representations of the matrix entries.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "FromGates",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-CliffordT.html#FromGates",
          "type": "class"
        },
        "index": {
          "description": "type class for all things that list of gates can be converted to For example list of gates can be converted to an element of or an element of SO using various exact or approximate representations of the matrix entries",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "FromGates",
          "package": "newsynth",
          "partial": "From Gates",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#t:FromGates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn enumeration type to represent symbolic basic gates (\u003cem\u003eX\u003c/em\u003e, \u003cem\u003eY\u003c/em\u003e,\n \u003cem\u003eZ\u003c/em\u003e, \u003cem\u003eH\u003c/em\u003e, \u003cem\u003eS\u003c/em\u003e, \u003cem\u003eT\u003c/em\u003e, \u003cem\u003eW\u003c/em\u003e, \u003cem\u003eE\u003c/em\u003e).\n\u003c/p\u003e\u003cp\u003eNote: when we use a list of \u003ccode\u003e\u003ca\u003eGate\u003c/a\u003e\u003c/code\u003es to express a sequence of\n operators, the operators are meant to be applied right-to-left,\n i.e., as in the mathematical notation for matrix multiplication.\n This is the opposite of the quantum circuit notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Gate",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "data"
        },
        "index": {
          "description": "An enumeration type to represent symbolic basic gates Note when we use list of Gate to express sequence of operators the operators are meant to be applied right-to-left i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Gate",
          "package": "newsynth",
          "partial": "Gate",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#t:Gate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA representation of normal forms, optimized for right\n multiplication.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "NormalForm",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-CliffordT.html#NormalForm",
          "type": "data"
        },
        "index": {
          "description": "representation of normal forms optimized for right multiplication",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "NormalForm",
          "package": "newsynth",
          "partial": "Normal Form",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#t:NormalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyllables is a circuit of the form (&#949;|\u003cem\u003eT\u003c/em\u003e) (\u003cem\u003eHT\u003c/em\u003e|\u003cem\u003eSHT\u003c/em\u003e)\u003csup\u003e*\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Syllables",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-CliffordT.html#Syllables",
          "type": "data"
        },
        "index": {
          "description": "Syllables is circuit of the form HT SHT",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Syllables",
          "package": "newsynth",
          "partial": "Syllables",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#t:Syllables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for all things that can be exactly converted to a\n list of gates. These are the exact representations of the\n single-qubit Clifford+\u003cem\u003eT\u003c/em\u003e group.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "ToGates",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-CliffordT.html#ToGates",
          "type": "class"
        },
        "index": {
          "description": "type class for all things that can be exactly converted to list of gates These are the exact representations of the single-qubit Clifford group",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "ToGates",
          "package": "newsynth",
          "partial": "To Gates",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#t:ToGates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "E",
          "package": "newsynth",
          "signature": "E",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "E",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "H",
          "package": "newsynth",
          "signature": "H",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "H",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "NormalForm",
          "package": "newsynth",
          "signature": "NormalForm Syllables Clifford",
          "source": "src/Quantum-Synthesis-CliffordT.html#NormalForm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "NormalForm",
          "package": "newsynth",
          "partial": "Normal Form",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:NormalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "S",
          "package": "newsynth",
          "signature": "S",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "S",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sequence of the form &#8230;\u003cem\u003eHT\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "SApp_HT",
          "package": "newsynth",
          "signature": "SApp_HT Syllables",
          "source": "src/Quantum-Synthesis-CliffordT.html#Syllables",
          "type": "function"
        },
        "index": {
          "description": "sequence of the form HT",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "SApp_HT",
          "package": "newsynth",
          "partial": "SApp HT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:SApp_HT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA sequence of the form &#8230;\u003cem\u003eSHT\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "SApp_SHT",
          "package": "newsynth",
          "signature": "SApp_SHT Syllables",
          "source": "src/Quantum-Synthesis-CliffordT.html#Syllables",
          "type": "function"
        },
        "index": {
          "description": "sequence of the form SHT",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "SApp_SHT",
          "package": "newsynth",
          "partial": "SApp SHT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:SApp_SHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty sequence &#949;.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "S_I",
          "package": "newsynth",
          "signature": "S_I",
          "source": "src/Quantum-Synthesis-CliffordT.html#Syllables",
          "type": "function"
        },
        "index": {
          "description": "The empty sequence",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "S_I",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:S_I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sequence \u003cem\u003eT\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "S_T",
          "package": "newsynth",
          "signature": "S_T",
          "source": "src/Quantum-Synthesis-CliffordT.html#Syllables",
          "type": "function"
        },
        "index": {
          "description": "The sequence",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "S_T",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:S_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "T",
          "package": "newsynth",
          "signature": "T",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "T",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "W",
          "package": "newsynth",
          "signature": "W",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "W",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "X",
          "package": "newsynth",
          "signature": "X",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "X",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Y",
          "package": "newsynth",
          "signature": "Y",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Y",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Z",
          "package": "newsynth",
          "signature": "Z",
          "source": "src/Quantum-Synthesis-CliffordT.html#Gate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "Z",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a matrix in \u003cem\u003eSO\u003c/em\u003e(3) to a Clifford gate. Throw an error if\n the matrix isn't Clifford.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "clifford_of_so3",
          "package": "newsynth",
          "signature": "SO3 a -\u003e Clifford",
          "source": "src/Quantum-Synthesis-CliffordT.html#clifford_of_so3",
          "type": "function"
        },
        "index": {
          "description": "Convert matrix in SO to Clifford gate Throw an error if the matrix isn Clifford",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "clifford_of_so3",
          "normalized": "SO a-\u003eClifford",
          "package": "newsynth",
          "signature": "SO a-\u003eClifford",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:clifford_of_so3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncode a Clifford operator as an integer in the range 0&#8722;191.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "clifford_pack",
          "package": "newsynth",
          "signature": "Clifford -\u003e Integer",
          "source": "src/Quantum-Synthesis-CliffordT.html#clifford_pack",
          "type": "function"
        },
        "index": {
          "description": "Encode Clifford operator as an integer in the range",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "clifford_pack",
          "normalized": "Clifford-\u003eInteger",
          "package": "newsynth",
          "signature": "Clifford-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:clifford_pack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecode a Clifford operator from its integer encoding. This is the\n inverse of \u003ccode\u003e\u003ca\u003eclifford_pack\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "clifford_unpack",
          "package": "newsynth",
          "signature": "Integer -\u003e Clifford",
          "source": "src/Quantum-Synthesis-CliffordT.html#clifford_unpack",
          "type": "function"
        },
        "index": {
          "description": "Decode Clifford operator from its integer encoding This is the inverse of clifford pack",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "clifford_unpack",
          "normalized": "Integer-\u003eClifford",
          "package": "newsynth",
          "signature": "Integer-\u003eClifford",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:clifford_unpack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert any precise format to any format.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "convert",
          "package": "newsynth",
          "signature": "a -\u003e b",
          "source": "src/Quantum-Synthesis-CliffordT.html#convert",
          "type": "function"
        },
        "index": {
          "description": "Convert any precise format to any format",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "convert",
          "normalized": "a-\u003eb",
          "package": "newsynth",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of gates to any suitable type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "from_gates",
          "package": "newsynth",
          "signature": "[Gate] -\u003e a",
          "source": "src/Quantum-Synthesis-CliffordT.html#from_gates",
          "type": "method"
        },
        "index": {
          "description": "Convert list of gates to any suitable type",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "from_gates",
          "normalized": "[Gate]-\u003ea",
          "package": "newsynth",
          "signature": "[Gate]-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:from_gates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert a gate list.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "invert_gates",
          "package": "newsynth",
          "signature": "[Gate] -\u003e [Gate]",
          "source": "src/Quantum-Synthesis-CliffordT.html#invert_gates",
          "type": "function"
        },
        "index": {
          "description": "Invert gate list",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "invert_gates",
          "normalized": "[Gate]-\u003e[Gate]",
          "package": "newsynth",
          "signature": "[Gate]-\u003e[Gate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:invert_gates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity as a normal form.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "nf_id",
          "package": "newsynth",
          "signature": "NormalForm",
          "source": "src/Quantum-Synthesis-CliffordT.html#nf_id",
          "type": "function"
        },
        "index": {
          "description": "The identity as normal form",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "nf_id",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:nf_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert a normal form. The input can be any \u003ccode\u003e\u003ca\u003eToGates\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "nf_inv",
          "package": "newsynth",
          "signature": "a -\u003e NormalForm",
          "source": "src/Quantum-Synthesis-CliffordT.html#nf_inv",
          "type": "function"
        },
        "index": {
          "description": "Invert normal form The input can be any ToGates",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "nf_inv",
          "normalized": "a-\u003eNormalForm",
          "package": "newsynth",
          "signature": "a-\u003eNormalForm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:nf_inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply two normal forms. The right factor can be any\n \u003ccode\u003e\u003ca\u003eToGates\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "nf_mult",
          "package": "newsynth",
          "signature": "NormalForm -\u003e b -\u003e NormalForm",
          "source": "src/Quantum-Synthesis-CliffordT.html#nf_mult",
          "type": "function"
        },
        "index": {
          "description": "Multiply two normal forms The right factor can be any ToGates",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "nf_mult",
          "normalized": "NormalForm-\u003ea-\u003eNormalForm",
          "package": "newsynth",
          "signature": "NormalForm-\u003eb-\u003eNormalForm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:nf_mult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-multiply the given normal form by a gate.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalform_append",
          "package": "newsynth",
          "signature": "NormalForm -\u003e Gate -\u003e NormalForm",
          "source": "src/Quantum-Synthesis-CliffordT.html#normalform_append",
          "type": "function"
        },
        "index": {
          "description": "Right-multiply the given normal form by gate",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalform_append",
          "normalized": "NormalForm-\u003eGate-\u003eNormalForm",
          "package": "newsynth",
          "signature": "NormalForm-\u003eGate-\u003eNormalForm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:normalform_append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompactly encode a \u003ccode\u003e\u003ca\u003eNormalForm\u003c/a\u003e\u003c/code\u003e as an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalform_pack",
          "package": "newsynth",
          "signature": "NormalForm -\u003e Integer",
          "source": "src/Quantum-Synthesis-CliffordT.html#normalform_pack",
          "type": "function"
        },
        "index": {
          "description": "Compactly encode NormalForm as an Integer",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalform_pack",
          "normalized": "NormalForm-\u003eInteger",
          "package": "newsynth",
          "signature": "NormalForm-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:normalform_pack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecode a \u003ccode\u003e\u003ca\u003eNormalForm\u003c/a\u003e\u003c/code\u003e from its \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e encoding. This is the\n inverse of \u003ccode\u003e\u003ca\u003enormalform_pack\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalform_unpack",
          "package": "newsynth",
          "signature": "Integer -\u003e NormalForm",
          "source": "src/Quantum-Synthesis-CliffordT.html#normalform_unpack",
          "type": "function"
        },
        "index": {
          "description": "Decode NormalForm from its Integer encoding This is the inverse of normalform pack",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalform_unpack",
          "normalized": "Integer-\u003eNormalForm",
          "package": "newsynth",
          "signature": "Integer-\u003eNormalForm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:normalform_unpack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert any \u003ccode\u003e\u003ca\u003eToGates\u003c/a\u003e\u003c/code\u003e list to a \u003ccode\u003e\u003ca\u003eNormalForm\u003c/a\u003e\u003c/code\u003e, thereby normalizing it.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalize",
          "package": "newsynth",
          "signature": "a -\u003e NormalForm",
          "source": "src/Quantum-Synthesis-CliffordT.html#normalize",
          "type": "function"
        },
        "index": {
          "description": "Convert any ToGates list to NormalForm thereby normalizing it",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "normalize",
          "normalized": "a-\u003eNormalForm",
          "package": "newsynth",
          "signature": "a-\u003eNormalForm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:normalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe operator \u003cem\u003eE\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_E",
          "package": "newsynth",
          "signature": "SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_E",
          "type": "function"
        },
        "index": {
          "description": "The operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_E",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Hadamard operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_H",
          "package": "newsynth",
          "signature": "SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_H",
          "type": "function"
        },
        "index": {
          "description": "The Hadamard operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_H",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe operator \u003cem\u003eS\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_S",
          "package": "newsynth",
          "signature": "SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_S",
          "type": "function"
        },
        "index": {
          "description": "The operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_S",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eT\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_T",
          "package": "newsynth",
          "signature": "SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_T",
          "type": "function"
        },
        "index": {
          "description": "The operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_T",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eX\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_X",
          "package": "newsynth",
          "signature": "SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_X",
          "type": "function"
        },
        "index": {
          "description": "The Pauli operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_X",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eY\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_Y",
          "package": "newsynth",
          "signature": "SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_Y",
          "type": "function"
        },
        "index": {
          "description": "The Pauli operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_Y",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eZ\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_Z",
          "package": "newsynth",
          "signature": "SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_Z",
          "type": "function"
        },
        "index": {
          "description": "The Pauli operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_Z",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a Clifford operator to a matrix in \u003cem\u003eSO\u003c/em\u003e(3).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_of_clifford",
          "package": "newsynth",
          "signature": "a -\u003e SO3 b",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_of_clifford",
          "type": "function"
        },
        "index": {
          "description": "Convert Clifford operator to matrix in SO",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_of_clifford",
          "normalized": "a-\u003eSO b",
          "package": "newsynth",
          "signature": "a-\u003eSO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_of_clifford"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a symbolic gate to the corresponding Bloch sphere\n operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_of_gate",
          "package": "newsynth",
          "signature": "Gate -\u003e SO3 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_of_gate",
          "type": "function"
        },
        "index": {
          "description": "Convert symbolic gate to the corresponding Bloch sphere operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_of_gate",
          "normalized": "Gate-\u003eSO a",
          "package": "newsynth",
          "signature": "Gate-\u003eSO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_of_gate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from \u003cem\u003eU\u003c/em\u003e(2) to \u003cem\u003eSO\u003c/em\u003e(3).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_of_u2",
          "package": "newsynth",
          "signature": "U2 a -\u003e SO3 b",
          "source": "src/Quantum-Synthesis-CliffordT.html#so3_of_u2",
          "type": "function"
        },
        "index": {
          "description": "Conversion from to SO",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "so3_of_u2",
          "normalized": "U a-\u003eSO b",
          "package": "newsynth",
          "signature": "U a-\u003eSO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:so3_of_u2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput an exact matrix in \u003cem\u003eSO\u003c/em\u003e(3), and output the corresponding\n Clifford+\u003cem\u003eT\u003c/em\u003e normal form. It is an error if the given matrix is not\n an element of \u003cem\u003eSO\u003c/em\u003e(3), i.e., orthogonal with determinant 1.\n\u003c/p\u003e\u003cp\u003eThis implementation uses the Matsumoto-Amano algorithm.\n\u003c/p\u003e\u003cp\u003eNote: the list of gates will be returned in right-to-left order,\n i.e., as in the mathematical notation for matrix multiplication.\n This is the opposite of the quantum circuit notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "synthesis_bloch",
          "package": "newsynth",
          "signature": "SO3 DRootTwo -\u003e [Gate]",
          "source": "src/Quantum-Synthesis-CliffordT.html#synthesis_bloch",
          "type": "function"
        },
        "index": {
          "description": "Input an exact matrix in SO and output the corresponding Clifford normal form It is an error if the given matrix is not an element of SO i.e orthogonal with determinant This implementation uses the Matsumoto-Amano algorithm Note the list of gates will be returned in right-to-left order i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "synthesis_bloch",
          "normalized": "SO DRootTwo-\u003e[Gate]",
          "package": "newsynth",
          "signature": "SO DRootTwo-\u003e[Gate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:synthesis_bloch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput an exact matrix in \u003cem\u003eU\u003c/em\u003e(2), and output the corresponding\n Clifford+\u003cem\u003eT\u003c/em\u003e normal form. The behavior is undefined if the given\n matrix is not an element of \u003cem\u003eU\u003c/em\u003e(2), i.e., unitary with determinant\n 1.\n\u003c/p\u003e\u003cp\u003eWe use a variant of the Kliuchnikov-Maslov-Mosca algorithm, as\n implemented in \u003ca\u003eQuantum.Synthesis.MultiQubitSynthesis\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eNote: the list of gates will be returned in right-to-left order,\n i.e., as in the mathematical notation for matrix multiplication.\n This is the opposite of the quantum circuit notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "synthesis_u2",
          "package": "newsynth",
          "signature": "U2 DOmega -\u003e [Gate]",
          "source": "src/Quantum-Synthesis-CliffordT.html#synthesis_u2",
          "type": "function"
        },
        "index": {
          "description": "Input an exact matrix in and output the corresponding Clifford normal form The behavior is undefined if the given matrix is not an element of i.e unitary with determinant We use variant of the Kliuchnikov-Maslov-Mosca algorithm as implemented in Quantum.Synthesis.MultiQubitSynthesis Note the list of gates will be returned in right-to-left order i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "synthesis_u2",
          "normalized": "U DOmega-\u003e[Gate]",
          "package": "newsynth",
          "signature": "U DOmega-\u003e[Gate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:synthesis_u2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert any suitable thing to a list of gates.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "to_gates",
          "package": "newsynth",
          "signature": "a -\u003e [Gate]",
          "source": "src/Quantum-Synthesis-CliffordT.html#to_gates",
          "type": "method"
        },
        "index": {
          "description": "Convert any suitable thing to list of gates",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "to_gates",
          "normalized": "a-\u003e[Gate]",
          "package": "newsynth",
          "signature": "a-\u003e[Gate]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:to_gates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eE\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_E",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_E",
          "type": "function"
        },
        "index": {
          "description": "The operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_E",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Hadamard operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_H",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_H",
          "type": "function"
        },
        "index": {
          "description": "The Hadamard operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_H",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eS\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_S",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_S",
          "type": "function"
        },
        "index": {
          "description": "The operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_S",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eT\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_T",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_T",
          "type": "function"
        },
        "index": {
          "description": "The operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_T",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eW\u003c/em\u003e = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ei\u003c/em\u003e&#960;/4\u003c/sup\u003e global phase operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_W",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_W",
          "type": "function"
        },
        "index": {
          "description": "The global phase operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_W",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eX\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_X",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_X",
          "type": "function"
        },
        "index": {
          "description": "The Pauli operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_X",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eY\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_Y",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_Y",
          "type": "function"
        },
        "index": {
          "description": "The Pauli operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_Y",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Pauli \u003cem\u003eZ\u003c/em\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_Z",
          "package": "newsynth",
          "signature": "U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_Z",
          "type": "function"
        },
        "index": {
          "description": "The Pauli operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_Z",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a symbolic gate to the corresponding operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_of_gate",
          "package": "newsynth",
          "signature": "Gate -\u003e U2 a",
          "source": "src/Quantum-Synthesis-CliffordT.html#u2_of_gate",
          "type": "function"
        },
        "index": {
          "description": "Convert symbolic gate to the corresponding operator",
          "hierarchy": "Quantum Synthesis CliffordT",
          "module": "Quantum.Synthesis.CliffordT",
          "name": "u2_of_gate",
          "normalized": "Gate-\u003eU a",
          "package": "newsynth",
          "signature": "Gate-\u003eU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-CliffordT.html#v:u2_of_gate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides a type class for Euclidean domains. A\n Euclidean domain is a ring with a notion of division with\n remainder, and therefore greatest common divisors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides type class for Euclidean domains Euclidean domain is ring with notion of division with remainder and therefore greatest common divisors",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "newsynth",
          "partial": "Euclidean Domain",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for Euclidean domains. A Euclidean domain is a ring\n with a Euclidean function and a division with remainder.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#EuclideanDomain",
          "type": "class"
        },
        "index": {
          "description": "type class for Euclidean domains Euclidean domain is ring with Euclidean function and division with remainder",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "EuclideanDomain",
          "package": "newsynth",
          "partial": "Euclidean Domain",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#t:EuclideanDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e&#8800;0, return a quotient and remainder for\n division of \u003cem\u003ea\u003c/em\u003e by \u003cem\u003eb\u003c/em\u003e. Specifically, return (\u003cem\u003eq\u003c/em\u003e,\u003cem\u003er\u003c/em\u003e) such that\n \u003cem\u003ea\u003c/em\u003e = \u003cem\u003eqb\u003c/em\u003e + \u003cem\u003er\u003c/em\u003e, and such that \u003cem\u003er\u003c/em\u003e = 0 or \u003cem\u003erank\u003c/em\u003e(\u003cem\u003er\u003c/em\u003e) \u003c \u003cem\u003erank\u003c/em\u003e(\u003cem\u003eb\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "divmod",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e (a, a)",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#divmod",
          "type": "method"
        },
        "index": {
          "description": "Given and return quotient and remainder for division of by Specifically return such that qb and such that or rank rank",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "divmod",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:divmod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e are associates, i.e., differ at most by\n a multiplicative unit.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_associates",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#euclid_associates",
          "type": "function"
        },
        "index": {
          "description": "Check whether and are associates i.e differ at most by multiplicative unit",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_associates",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:euclid_associates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the quotient for the division of \u003cem\u003ex\u003c/em\u003e by \u003cem\u003ey\u003c/em\u003e, ignoring\n the remainder, if any. This is typically, but not always, used in\n situations where the remainder is known to be 0 ahead of time.\n Assumes that \u003cem\u003ey\u003c/em\u003e &#8800; 0.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_div",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#euclid_div",
          "type": "function"
        },
        "index": {
          "description": "Calculate the quotient for the division of by ignoring the remainder if any This is typically but not always used in situations where the remainder is known to be ahead of time Assumes that",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_div",
          "normalized": "a-\u003ea-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:euclid_div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether \u003cem\u003ea\u003c/em\u003e is a divisor of \u003cem\u003eb\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_divides",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#euclid_divides",
          "type": "function"
        },
        "index": {
          "description": "Check whether is divisor of",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_divides",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:euclid_divides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the greatest common divisor in any Euclidean domain.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_gcd",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#euclid_gcd",
          "type": "function"
        },
        "index": {
          "description": "Calculate the greatest common divisor in any Euclidean domain",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_gcd",
          "normalized": "a-\u003ea-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:euclid_gcd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the inverse of a unit in a Euclidean domain. If the given\n element is not a unit, return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_inverse",
          "package": "newsynth",
          "signature": "a -\u003e Maybe a",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#euclid_inverse",
          "type": "function"
        },
        "index": {
          "description": "Find the inverse of unit in Euclidean domain If the given element is not unit return Nothing",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_inverse",
          "normalized": "a-\u003eMaybe a",
          "package": "newsynth",
          "signature": "a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:euclid_inverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the remainder for the division of \u003cem\u003ex\u003c/em\u003e by \u003cem\u003ey\u003c/em\u003e. Assumes\n that \u003cem\u003ey\u003c/em\u003e &#8800; 0.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_mod",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#euclid_mod",
          "type": "function"
        },
        "index": {
          "description": "Calculate the remainder for the division of by Assumes that",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "euclid_mod",
          "normalized": "a-\u003ea-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:euclid_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform the extended Euclidean algorithm. On inputs \u003cem\u003ex\u003c/em\u003e and\n \u003cem\u003ey\u003c/em\u003e, this returns (\u003cem\u003ea\u003c/em\u003e,\u003cem\u003eb\u003c/em\u003e,\u003cem\u003es\u003c/em\u003e,\u003cem\u003et\u003c/em\u003e,\u003cem\u003ed\u003c/em\u003e) such that:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003ed\u003c/em\u003e = gcd(\u003cem\u003ex\u003c/em\u003e,\u003cem\u003ey\u003c/em\u003e),\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eax\u003c/em\u003e + \u003cem\u003eby\u003c/em\u003e = \u003cem\u003ed\u003c/em\u003e,\n\u003c/li\u003e\u003cli\u003e \u003cem\u003esx\u003c/em\u003e + \u003cem\u003ety\u003c/em\u003e = 0,\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eat\u003c/em\u003e - \u003cem\u003ebs\u003c/em\u003e = 1.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "extended_euclid",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e (a, a, a, a, a)",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#extended_euclid",
          "type": "function"
        },
        "index": {
          "description": "Perform the extended Euclidean algorithm On inputs and this returns such that gcd ax by sx ty at bs",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "extended_euclid",
          "normalized": "a-\u003ea-\u003e(a,a,a,a,a)",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003e(a,a,a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:extended_euclid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the inverse of \u003cem\u003ea\u003c/em\u003e in \u003cem\u003eR\u003c/em\u003e/(p), where \u003cem\u003eR\u003c/em\u003e is a Euclidean\n domain. Note: this works whenever \u003cem\u003ea\u003c/em\u003e and \u003cem\u003ep\u003c/em\u003e are relatively\n prime. If \u003cem\u003ea\u003c/em\u003e and \u003cem\u003ep\u003c/em\u003e are not relatively prime, return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "inv_mod",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e Maybe a",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#inv_mod",
          "type": "function"
        },
        "index": {
          "description": "Compute the inverse of in where is Euclidean domain Note this works whenever and are relatively prime If and are not relatively prime return Nothing",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "inv_mod",
          "normalized": "a-\u003ea-\u003eMaybe a",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:inv_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine whether an element of a Euclidean domain is a unit.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "is_unit",
          "package": "newsynth",
          "signature": "a -\u003e Bool",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#is_unit",
          "type": "function"
        },
        "index": {
          "description": "Determine whether an element of Euclidean domain is unit",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "is_unit",
          "normalized": "a-\u003eBool",
          "package": "newsynth",
          "signature": "a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:is_unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Euclidean function for the Euclidean domain. This is a\n function \u003cem\u003erank\u003c/em\u003e : \u003cem\u003eR\u003c/em\u003e\\{0} &#8594; &#8469; such that:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e for all nonzero \u003cem\u003ea\u003c/em\u003e, \u003cem\u003eb\u003c/em\u003e &#8712; \u003cem\u003eR\u003c/em\u003e, \u003cem\u003erank\u003c/em\u003e(\u003cem\u003ea\u003c/em\u003e) &#8804; \u003cem\u003erank\u003c/em\u003e(\u003cem\u003eab\u003c/em\u003e);\n\u003c/li\u003e\u003cli\u003e if \u003cem\u003eb\u003c/em\u003e &#8800; 0 and (\u003cem\u003eq\u003c/em\u003e,\u003cem\u003er\u003c/em\u003e) = \u003cem\u003ea\u003c/em\u003e \u003ccode\u003e\u003ca\u003edivmod\u003c/a\u003e\u003c/code\u003e \u003cem\u003eb\u003c/em\u003e, then either \u003cem\u003er\u003c/em\u003e =\n 0 or \u003cem\u003erank\u003c/em\u003e(\u003cem\u003er\u003c/em\u003e) \u003c \u003cem\u003erank\u003c/em\u003e(\u003cem\u003eb\u003c/em\u003e).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "rank",
          "package": "newsynth",
          "signature": "a -\u003e Integer",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#rank",
          "type": "method"
        },
        "index": {
          "description": "The Euclidean function for the Euclidean domain This is function rank such that for all nonzero rank rank ab if and divmod then either or rank rank",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "rank",
          "normalized": "a-\u003eInteger",
          "package": "newsynth",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:rank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor \u003cem\u003ey\u003c/em\u003e &#8800; 0, find the integer \u003cem\u003eq\u003c/em\u003e closest to \u003cem\u003ex\u003c/em\u003e / \u003cem\u003ey\u003c/em\u003e. This\n works regardless of whether \u003cem\u003ex\u003c/em\u003e and/or \u003cem\u003ey\u003c/em\u003e are positive or\n negative.  The distance \u003cem\u003eq\u003c/em\u003e &#8722; \u003cem\u003ex\u003c/em\u003e / \u003cem\u003ey\u003c/em\u003e is guaranteed to be in\n (-1/2, 1/2].\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "rounddiv",
          "package": "newsynth",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Quantum-Synthesis-EuclideanDomain.html#rounddiv",
          "type": "function"
        },
        "index": {
          "description": "For find the integer closest to This works regardless of whether and or are positive or negative The distance is guaranteed to be in",
          "hierarchy": "Quantum Synthesis EuclideanDomain",
          "module": "Quantum.Synthesis.EuclideanDomain",
          "name": "rounddiv",
          "normalized": "a-\u003ea-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EuclideanDomain.html#v:rounddiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for converting between matrices in\n \u003cem\u003eU\u003c/em\u003e(2) and their Euler angle representation.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.EulerAngles",
          "name": "EulerAngles",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-EulerAngles.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for converting between matrices in and their Euler angle representation",
          "hierarchy": "Quantum Synthesis EulerAngles",
          "module": "Quantum.Synthesis.EulerAngles",
          "name": "EulerAngles",
          "package": "newsynth",
          "partial": "Euler Angles",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EulerAngles.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecompose a unitary operator \u003cem\u003eU\u003c/em\u003e into Euler angles (&#945;, &#946;, &#947;, &#948;).\n These angles are computed so that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eU\u003c/em\u003e = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ei\u003c/em\u003e&#945;\u003c/sup\u003e R\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#946;) R\u003csub\u003e\u003cem\u003ex\u003c/em\u003e\u003c/sub\u003e(&#947;) R\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#948;).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Quantum.Synthesis.EulerAngles",
          "name": "euler_angles",
          "package": "newsynth",
          "signature": "Matrix Two Two (Cplx a) -\u003e (a, a, a, a)",
          "source": "src/Quantum-Synthesis-EulerAngles.html#euler_angles",
          "type": "function"
        },
        "index": {
          "description": "Decompose unitary operator into Euler angles These angles are computed so that",
          "hierarchy": "Quantum Synthesis EulerAngles",
          "module": "Quantum.Synthesis.EulerAngles",
          "name": "euler_angles",
          "normalized": "Matrix Two Two(Cplx a)-\u003e(a,a,a,a)",
          "package": "newsynth",
          "signature": "Matrix Two Two(Cplx a)-\u003e(a,a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EulerAngles.html#v:euler_angles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the operator\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003eU\u003c/em\u003e = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ei\u003c/em\u003e&#945;\u003c/sup\u003e R\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#946;) R\u003csub\u003e\u003cem\u003ex\u003c/em\u003e\u003c/sub\u003e(&#947;) R\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#948;).\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003efrom the given Euler angles.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.EulerAngles",
          "name": "matrix_of_euler_angles",
          "package": "newsynth",
          "signature": "(a, a, a, a) -\u003e Matrix Two Two (Cplx a)",
          "source": "src/Quantum-Synthesis-EulerAngles.html#matrix_of_euler_angles",
          "type": "function"
        },
        "index": {
          "description": "Compute the operator from the given Euler angles",
          "hierarchy": "Quantum Synthesis EulerAngles",
          "module": "Quantum.Synthesis.EulerAngles",
          "name": "matrix_of_euler_angles",
          "normalized": "(a,a,a,a)-\u003eMatrix Two Two(Cplx a)",
          "package": "newsynth",
          "signature": "(a,a,a,a)-\u003eMatrix Two Two(Cplx a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-EulerAngles.html#v:matrix_of_euler_angles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides some functionality for pretty-printing\n certain types to LaTeX format.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "LaTeX",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-LaTeX.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides some functionality for pretty-printing certain types to LaTeX format",
          "hierarchy": "Quantum Synthesis LaTeX",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "LaTeX",
          "package": "newsynth",
          "partial": "La Te",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-LaTeX.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for things that can be printed to LaTeX format. \n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003eshowlatex\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eshowlatex_p\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "ShowLaTeX",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-LaTeX.html#ShowLaTeX",
          "type": "class"
        },
        "index": {
          "description": "type class for things that can be printed to LaTeX format Minimal complete definition showlatex or showlatex",
          "hierarchy": "Quantum Synthesis LaTeX",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "ShowLaTeX",
          "package": "newsynth",
          "partial": "Show La Te",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-LaTeX.html#t:ShowLaTeX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint to LaTeX format.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "showlatex",
          "package": "newsynth",
          "signature": "a -\u003e String",
          "source": "src/Quantum-Synthesis-LaTeX.html#showlatex",
          "type": "method"
        },
        "index": {
          "description": "Print to LaTeX format",
          "hierarchy": "Quantum Synthesis LaTeX",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "showlatex",
          "normalized": "a-\u003eString",
          "package": "newsynth",
          "signature": "a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-LaTeX.html#v:showlatex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric showlatex-like method that factors out a common\n denominator exponent.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "showlatex_denomexp",
          "package": "newsynth",
          "signature": "a -\u003e String",
          "source": "src/Quantum-Synthesis-LaTeX.html#showlatex_denomexp",
          "type": "function"
        },
        "index": {
          "description": "Generic showlatex-like method that factors out common denominator exponent",
          "hierarchy": "Quantum Synthesis LaTeX",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "showlatex_denomexp",
          "normalized": "a-\u003eString",
          "package": "newsynth",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-LaTeX.html#v:showlatex_denomexp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint to LaTeX format, with precedence. Analogous to \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "showlatex_p",
          "package": "newsynth",
          "signature": "Int -\u003e a -\u003e ShowS",
          "source": "src/Quantum-Synthesis-LaTeX.html#showlatex_p",
          "type": "method"
        },
        "index": {
          "description": "Print to LaTeX format with precedence Analogous to showsPrec",
          "hierarchy": "Quantum Synthesis LaTeX",
          "module": "Quantum.Synthesis.LaTeX",
          "name": "showlatex_p",
          "normalized": "Int-\u003ea-\u003eShowS",
          "package": "newsynth",
          "signature": "Int-\u003ea-\u003eShowS",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-LaTeX.html#v:showlatex_p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides fixed but arbitrary sized vectors and\n matrices. The dimensions of the vectors and matrices are determined\n by the type, for example,\n\u003c/p\u003e\u003cpre\u003e Matrix Two Three Complex\n\u003c/pre\u003e\u003cp\u003efor complex 2&#215;3-matrices. The type system ensures that there are no\n run-time dimension errors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Matrix",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides fixed but arbitrary sized vectors and matrices The dimensions of the vectors and matrices are determined by the type for example Matrix Two Three Complex for complex matrices The type system ensures that there are no run-time dimension errors",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Matrix",
          "package": "newsynth",
          "partial": "Matrix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 8 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Eight",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Eight",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Eight",
          "package": "newsynth",
          "partial": "Eight",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Eight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 5 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Five",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Five",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Five",
          "package": "newsynth",
          "partial": "Five",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Five"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 4 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Four",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Four",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Four",
          "package": "newsynth",
          "partial": "Four",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Four"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix is a list of \u003cem\u003en\u003c/em\u003e columns, each of which is a\n list of \u003cem\u003em\u003c/em\u003e scalars.  The type of square matrices of any fixed\n dimension is an instance of the \u003ccode\u003e\u003ca\u003eRing\u003c/a\u003e\u003c/code\u003e class, and therefore the\n usual symbols, such as \"\u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e\" and \"\u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e\" can be used on\n them. However, the non-square matrices, the symbols \"\u003ccode\u003e\u003ca\u003e.+.\u003c/a\u003e\u003c/code\u003e\" and\n \"\u003ccode\u003e\u003ca\u003e.*.\u003c/a\u003e\u003c/code\u003e\" must be used.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Matrix",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Matrix",
          "type": "data"
        },
        "index": {
          "description": "An matrix is list of columns each of which is list of scalars The type of square matrices of any fixed dimension is an instance of the Ring class and therefore the usual symbols such as and can be used on them However the non-square matrices the symbols and must be used",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Matrix",
          "package": "newsynth",
          "partial": "Matrix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data type for the natural numbers. Specifically, if \u003cem\u003en\u003c/em\u003e is a\n type-level natural number, then\n\u003c/p\u003e\u003cpre\u003e NNat n\n\u003c/pre\u003e\u003cp\u003eis a singleton type containing only the natural number \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "NNat",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#NNat",
          "type": "data"
        },
        "index": {
          "description": "data type for the natural numbers Specifically if is type-level natural number then NNat is singleton type containing only the natural number",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "NNat",
          "package": "newsynth",
          "partial": "NNat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:NNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for the natural numbers. The members are exactly the\n type-level natural numbers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Nat",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Nat",
          "type": "class"
        },
        "index": {
          "description": "type class for the natural numbers The members are exactly the type-level natural numbers",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Nat",
          "package": "newsynth",
          "partial": "Nat",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 9 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Nine",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Nine",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Nine",
          "package": "newsynth",
          "partial": "Nine",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Nine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 1 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "One",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#One",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "One",
          "package": "newsynth",
          "partial": "One",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition of type-level natural numbers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Plus",
          "package": "newsynth",
          "signature": "Plus",
          "type": "function"
        },
        "index": {
          "description": "Addition of type-level natural numbers",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Plus",
          "package": "newsynth",
          "partial": "Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient abbreviation for the type of 3&#215;3-matrices.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "SO3",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#SO3",
          "type": "type"
        },
        "index": {
          "description": "convenient abbreviation for the type of matrices",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "SO3",
          "package": "newsynth",
          "partial": "SO",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:SO3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 7 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Seven",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Seven",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Seven",
          "package": "newsynth",
          "partial": "Seven",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Seven"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 6 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Six",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Six",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Six",
          "package": "newsynth",
          "partial": "Six",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Six"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-level representation of successor.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Succ",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Succ",
          "type": "data"
        },
        "index": {
          "description": "Type-level representation of successor",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Succ",
          "package": "newsynth",
          "partial": "Succ",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 10 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Ten",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Ten",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Ten",
          "package": "newsynth",
          "partial": "Ten",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Ten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe 10th successor of a natural number type. For example, the\n natural number 18 as a type is\n\u003c/p\u003e\u003cpre\u003e Ten_and Eight\n\u003c/pre\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Ten_and",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Ten_and",
          "type": "type"
        },
        "index": {
          "description": "The th successor of natural number type For example the natural number as type is Ten and Eight",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Ten_and",
          "package": "newsynth",
          "partial": "Ten",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Ten_and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 3 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Three",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Three",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Three",
          "package": "newsynth",
          "partial": "Three",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Three"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication of type-level natural numbers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Times",
          "package": "newsynth",
          "signature": "Times",
          "type": "function"
        },
        "index": {
          "description": "Multiplication of type-level natural numbers",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Times",
          "package": "newsynth",
          "partial": "Times",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Times"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe natural number 2 as a type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Two",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Two",
          "type": "type"
        },
        "index": {
          "description": "The natural number as type",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Two",
          "package": "newsynth",
          "partial": "Two",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Two"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient abbreviation for the type of 2&#215;2-matrices.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "U2",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#U2",
          "type": "type"
        },
        "index": {
          "description": "convenient abbreviation for the type of matrices",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "U2",
          "package": "newsynth",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:U2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eVector \u003cem\u003en\u003c/em\u003e \u003cem\u003ea\u003c/em\u003e\u003c/code\u003e is the type of lists of length \u003cem\u003en\u003c/em\u003e with elements\n from \u003cem\u003ea\u003c/em\u003e. We call this a \"vector\" rather than a tuple or list for\n two reasons: the vectors are homogeneous (all elements have the\n same type), and they are strict: if any one component is undefined,\n the whole vector is undefined.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Vector",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Vector",
          "type": "data"
        },
        "index": {
          "description": "Vector is the type of lists of length with elements from We call this vector rather than tuple or list for two reasons the vectors are homogeneous all elements have the same type and they are strict if any one component is undefined the whole vector is undefined",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Vector",
          "package": "newsynth",
          "partial": "Vector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-level representation of zero.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Zero",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Matrix.html#Zero",
          "type": "data"
        },
        "index": {
          "description": "Type-level representation of zero",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Zero",
          "package": "newsynth",
          "partial": "Zero",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#t:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication of \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices. We use a special symbol\n because \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices do not form a ring; only \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices\n form a ring (in which case the normal symbol \"\u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e\" also works).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "(.*.)",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Matrix n p a -\u003e Matrix m p a",
          "source": "src/Quantum-Synthesis-Matrix.html#.%2A.",
          "type": "function"
        },
        "index": {
          "description": "Multiplication of matrices We use special symbol because matrices do not form ring only matrices form ring in which case the normal symbol also works",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "(.*.) .*.",
          "normalized": "Matrix a b c-\u003eMatrix b d c-\u003eMatrix a d c",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003eMatrix n p a-\u003eMatrix m p a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:.-42-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddition of \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices. We use a special symbol because\n \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices do not form a ring; only \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices form a\n ring (in which case the normal symbol \"\u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e\" also works).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "(.+.)",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Matrix m n a -\u003e Matrix m n a",
          "source": "src/Quantum-Synthesis-Matrix.html#.%2B.",
          "type": "function"
        },
        "index": {
          "description": "Addition of matrices We use special symbol because matrices do not form ring only matrices form ring in which case the normal symbol also works",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "(.+.) .+.",
          "normalized": "Matrix a b c-\u003eMatrix a b c-\u003eMatrix a b c",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003eMatrix m n a-\u003eMatrix m n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:.-43-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtraction of \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices. We use a special symbol because\n \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices do not form a ring; only \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrices form a\n ring (in which case the normal symbol \"\u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e\" also works).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "(.-.)",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Matrix m n a -\u003e Matrix m n a",
          "source": "src/Quantum-Synthesis-Matrix.html#.-.",
          "type": "function"
        },
        "index": {
          "description": "Subtraction of matrices We use special symbol because matrices do not form ring only matrices form ring in which case the normal symbol also works",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "(.-.) .-.",
          "normalized": "Matrix a b c-\u003eMatrix a b c-\u003eMatrix a b c",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003eMatrix m n a-\u003eMatrix m n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:.-45-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Matrix",
          "name": "Cons",
          "package": "newsynth",
          "signature": "a -\u003e !(Vector n a) -\u003e Vector (Succ n) a",
          "source": "src/Quantum-Synthesis-Matrix.html#Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Cons",
          "normalized": "a-\u003e(Vector b a)-\u003eVector(Succ b)a",
          "package": "newsynth",
          "partial": "Cons",
          "signature": "a-\u003e(Vector n a)-\u003eVector(Succ n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Matrix",
          "name": "Matrix",
          "package": "newsynth",
          "signature": "Matrix !(Vector n (Vector m a))",
          "source": "src/Quantum-Synthesis-Matrix.html#Matrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Matrix",
          "package": "newsynth",
          "partial": "Matrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Matrix",
          "name": "Nil",
          "package": "newsynth",
          "signature": "Vector Zero a",
          "source": "src/Quantum-Synthesis-Matrix.html#Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Nil",
          "package": "newsynth",
          "partial": "Nil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:Nil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Matrix",
          "name": "Succ",
          "package": "newsynth",
          "signature": "NNat n -\u003e NNat (Succ n)",
          "source": "src/Quantum-Synthesis-Matrix.html#NNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Succ",
          "normalized": "NNat a-\u003eNNat(Succ a)",
          "package": "newsynth",
          "partial": "Succ",
          "signature": "NNat n-\u003eNNat(Succ n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Matrix",
          "name": "Zero",
          "package": "newsynth",
          "signature": "NNat Zero",
          "source": "src/Quantum-Synthesis-Matrix.html#NNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "Zero",
          "package": "newsynth",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the adjoint of an \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix. Unlike \u003ccode\u003e\u003ca\u003eadj\u003c/a\u003e\u003c/code\u003e, this can be\n applied to non-square matrices.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "adjoint",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Matrix n m a",
          "source": "src/Quantum-Synthesis-Matrix.html#adjoint",
          "type": "function"
        },
        "index": {
          "description": "Take the adjoint of an matrix Unlike adj this can be applied to non-square matrices",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "adjoint",
          "normalized": "Matrix a b c-\u003eMatrix b a c",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003eMatrix n m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:adjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eControlled-not gate.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "cnot",
          "package": "newsynth",
          "signature": "Matrix Four Four a",
          "source": "src/Quantum-Synthesis-Matrix.html#cnot",
          "type": "function"
        },
        "index": {
          "description": "Controlled-not gate",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "cnot",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:cnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience constructor for 3-dimensional column vectors.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "column3",
          "package": "newsynth",
          "signature": "(a, a, a) -\u003e Matrix Three One a",
          "source": "src/Quantum-Synthesis-Matrix.html#column3",
          "type": "function"
        },
        "index": {
          "description": "convenience constructor for dimensional column vectors",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "column3",
          "normalized": "(a,a,a)-\u003eMatrix Three One a",
          "package": "newsynth",
          "signature": "(a,a,a)-\u003eMatrix Three One a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:column3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience constructor for turning a vector into a column matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "column_matrix",
          "package": "newsynth",
          "signature": "Vector n a -\u003e Matrix n One a",
          "source": "src/Quantum-Synthesis-Matrix.html#column_matrix",
          "type": "function"
        },
        "index": {
          "description": "convenience constructor for turning vector into column matrix",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "column_matrix",
          "normalized": "Vector a b-\u003eMatrix a One b",
          "package": "newsynth",
          "signature": "Vector n a-\u003eMatrix n One a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:column_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a matrix into a list of columns.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "columns_of_matrix",
          "package": "newsynth",
          "signature": "Matrix n m a -\u003e [[a]]",
          "source": "src/Quantum-Synthesis-Matrix.html#columns_of_matrix",
          "type": "function"
        },
        "index": {
          "description": "Turn matrix into list of columns",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "columns_of_matrix",
          "normalized": "Matrix a b c-\u003e[[c]]",
          "package": "newsynth",
          "signature": "Matrix n m a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:columns_of_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHorizontally concatenate a vector of matrices.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "concat_horizontal",
          "package": "newsynth",
          "signature": "Vector p (Matrix m n a) -\u003e Matrix m (p `Times` n) a",
          "source": "src/Quantum-Synthesis-Matrix.html#concat_horizontal",
          "type": "function"
        },
        "index": {
          "description": "Horizontally concatenate vector of matrices",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "concat_horizontal",
          "normalized": "Vector a(Matrix b c d)-\u003eMatrix b(a Times c)d",
          "package": "newsynth",
          "signature": "Vector p(Matrix m n a)-\u003eMatrix m(p Times n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:concat_horizontal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVertically concatenate a vector of matrices.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "concat_vertical",
          "package": "newsynth",
          "signature": "Vector p (Matrix m n a) -\u003e Matrix (p `Times` m) n a",
          "source": "src/Quantum-Synthesis-Matrix.html#concat_vertical",
          "type": "function"
        },
        "index": {
          "description": "Vertically concatenate vector of matrices",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "concat_vertical",
          "normalized": "Vector a(Matrix b c d)-\u003eMatrix(a Times b)c d",
          "package": "newsynth",
          "signature": "Vector p(Matrix m n a)-\u003eMatrix(p Times m)n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:concat_vertical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eNNat\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "fromNNat",
          "package": "newsynth",
          "signature": "NNat n -\u003e Integer",
          "source": "src/Quantum-Synthesis-Matrix.html#fromNNat",
          "type": "function"
        },
        "index": {
          "description": "Convert an NNat to an Integer",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "fromNNat",
          "normalized": "NNat a-\u003eInteger",
          "package": "newsynth",
          "partial": "NNat",
          "signature": "NNat n-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:fromNNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience destructor for 3-dimensional column vectors. This\n is the inverse of \u003ccode\u003e\u003ca\u003ecolumn3\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "from_column3",
          "package": "newsynth",
          "signature": "Matrix Three One a -\u003e (a, a, a)",
          "source": "src/Quantum-Synthesis-Matrix.html#from_column3",
          "type": "function"
        },
        "index": {
          "description": "convenience destructor for dimensional column vectors This is the inverse of column3",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "from_column3",
          "normalized": "Matrix Three One a-\u003e(a,a,a)",
          "package": "newsynth",
          "signature": "Matrix Three One a-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:from_column3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience destructor for 2&#215;2-matrices. The result is by rows.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "from_matrix2x2",
          "package": "newsynth",
          "signature": "Matrix Two Two a -\u003e ((a, a), (a, a))",
          "source": "src/Quantum-Synthesis-Matrix.html#from_matrix2x2",
          "type": "function"
        },
        "index": {
          "description": "convenience destructor for matrices The result is by rows",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "from_matrix2x2",
          "normalized": "Matrix Two Two a-\u003e((a,a),(a,a))",
          "package": "newsynth",
          "signature": "Matrix Two Two a-\u003e((a,a),(a,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:from_matrix2x2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the square of the Hilbert-Schmidt norm of an\n \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix, defined by &#8214;\u003cem\u003eM\u003c/em\u003e&#8214;&#178; = tr \u003cem\u003eM\u003c/em\u003e\u003csup\u003e&#8224;\u003c/sup\u003e\u003cem\u003eM\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "hs_sqnorm",
          "package": "newsynth",
          "signature": "Matrix n m a -\u003e a",
          "source": "src/Quantum-Synthesis-Matrix.html#hs_sqnorm",
          "type": "function"
        },
        "index": {
          "description": "Return the square of the Hilbert-Schmidt norm of an matrix defined by tr",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "hs_sqnorm",
          "normalized": "Matrix a b c-\u003ec",
          "package": "newsynth",
          "signature": "Matrix n m a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:hs_sqnorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a fixed-length list to an ordinary list.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "list_of_vector",
          "package": "newsynth",
          "signature": "Vector n a -\u003e [a]",
          "source": "src/Quantum-Synthesis-Matrix.html#list_of_vector",
          "type": "function"
        },
        "index": {
          "description": "Convert fixed-length list to an ordinary list",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "list_of_vector",
          "normalized": "Vector a b-\u003e[b]",
          "package": "newsynth",
          "signature": "Vector n a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:list_of_vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym for \u003ccode\u003e\u003ca\u003ematrix_of_rows\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix",
          "package": "newsynth",
          "signature": "[[a]] -\u003e Matrix n m a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix",
          "type": "function"
        },
        "index": {
          "description": "synonym for matrix of rows",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix",
          "normalized": "[[a]]-\u003eMatrix b c a",
          "package": "newsynth",
          "signature": "[[a]]-\u003eMatrix n m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience constructor for 2&#215;2-matrices. The arguments are by\n rows.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix2x2",
          "package": "newsynth",
          "signature": "(a, a) -\u003e (a, a) -\u003e Matrix Two Two a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix2x2",
          "type": "function"
        },
        "index": {
          "description": "convenience constructor for matrices The arguments are by rows",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix2x2",
          "normalized": "(a,a)-\u003e(a,a)-\u003eMatrix Two Two a",
          "package": "newsynth",
          "signature": "(a,a)-\u003e(a,a)-\u003eMatrix Two Two a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix2x2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience constructor for 3&#215;3-matrices. The arguments are by\n rows.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix3x3",
          "package": "newsynth",
          "signature": "(a, a, a) -\u003e (a, a, a) -\u003e (a, a, a) -\u003e Matrix Three Three a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix3x3",
          "type": "function"
        },
        "index": {
          "description": "convenience constructor for matrices The arguments are by rows",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix3x3",
          "normalized": "(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)-\u003eMatrix Three Three a",
          "package": "newsynth",
          "signature": "(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)-\u003eMatrix Three Three a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix3x3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience constructor for 4&#215;4-matrices. The arguments are by\n rows.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix4x4",
          "package": "newsynth",
          "signature": "(a, a, a, a) -\u003e (a, a, a, a) -\u003e (a, a, a, a) -\u003e (a, a, a, a) -\u003e Matrix Four Four a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix4x4",
          "type": "function"
        },
        "index": {
          "description": "convenience constructor for matrices The arguments are by rows",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix4x4",
          "normalized": "(a,a,a,a)-\u003e(a,a,a,a)-\u003e(a,a,a,a)-\u003e(a,a,a,a)-\u003eMatrix Four Four a",
          "package": "newsynth",
          "signature": "(a,a,a,a)-\u003e(a,a,a,a)-\u003e(a,a,a,a)-\u003e(a,a,a,a)-\u003eMatrix Four Four a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix4x4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm a controlled gate.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_controlled",
          "package": "newsynth",
          "signature": "Matrix n n a -\u003e Matrix (n `Plus` n) (n `Plus` n) a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_controlled",
          "type": "function"
        },
        "index": {
          "description": "Form controlled gate",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_controlled",
          "normalized": "Matrix a a b-\u003eMatrix(a Plus a)(a Plus a)b",
          "package": "newsynth",
          "signature": "Matrix n n a-\u003eMatrix(n Plus n)(n Plus n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_controlled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of all the entries of a matrix, in some fixed but\n unspecified order.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_entries",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e [a]",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_entries",
          "type": "function"
        },
        "index": {
          "description": "Return list of all the entries of matrix in some fixed but unspecified order",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_entries",
          "normalized": "Matrix a b c-\u003e[c]",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_entries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the matrix whose \u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e-entry is (\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e). Here \u003cem\u003ei\u003c/em\u003e and\n \u003cem\u003ej\u003c/em\u003e are 0-based, i.e., the top left entry is (0,0).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_enum",
          "package": "newsynth",
          "signature": "Matrix m n (a, a)",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_enum",
          "type": "function"
        },
        "index": {
          "description": "Create the matrix whose entry is Here and are based i.e the top left entry is",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_enum",
          "normalized": "Matrix a b(c,c)",
          "package": "newsynth",
          "signature": "Matrix m n(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the element in the \u003cem\u003ei\u003c/em\u003eth row and \u003cem\u003ej\u003c/em\u003eth column of the\n matrix. Counting of rows and columns starts from 0. Throws an error\n if the index is out of range.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_index",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e i -\u003e i -\u003e a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_index",
          "type": "function"
        },
        "index": {
          "description": "Return the element in the th row and th column of the matrix Counting of rows and columns starts from Throws an error if the index is out of range",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_index",
          "normalized": "Matrix a b c-\u003ed-\u003ed-\u003ec",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003ei-\u003ei-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap some function over every element of a matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_map",
          "package": "newsynth",
          "signature": "(a -\u003e b) -\u003e Matrix m n a -\u003e Matrix m n b",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_map",
          "type": "function"
        },
        "index": {
          "description": "Map some function over every element of matrix",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_map",
          "normalized": "(a-\u003eb)-\u003eMatrix c d a-\u003eMatrix c d b",
          "package": "newsynth",
          "signature": "(a-\u003eb)-\u003eMatrix m n a-\u003eMatrix m n b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience constructor for matrices: turn a list of columns\n into a matrix. \n\u003c/p\u003e\u003cp\u003eNote: since the dimensions of the matrix are type-level integers,\n they cannot be inferred from the dimensions of the input; instead,\n they must be specified explicitly in the type. It is an error to\n apply this function to a list of the wrong dimension.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_of_columns",
          "package": "newsynth",
          "signature": "[[a]] -\u003e Matrix n m a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_of_columns",
          "type": "function"
        },
        "index": {
          "description": "convenience constructor for matrices turn list of columns into matrix Note since the dimensions of the matrix are type-level integers they cannot be inferred from the dimensions of the input instead they must be specified explicitly in the type It is an error to apply this function to list of the wrong dimension",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_of_columns",
          "normalized": "[[a]]-\u003eMatrix b c a",
          "package": "newsynth",
          "signature": "[[a]]-\u003eMatrix n m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_of_columns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the matrix whose \u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e-entry is \u003ccode\u003ef i j\u003c/code\u003e. Here \u003cem\u003ei\u003c/em\u003e and\n \u003cem\u003ej\u003c/em\u003e are 0-based, i.e., the top left entry is \u003ccode\u003ef 0 0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_of_function",
          "package": "newsynth",
          "signature": "(a -\u003e a -\u003e b) -\u003e Matrix m n b",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_of_function",
          "type": "function"
        },
        "index": {
          "description": "Create the matrix whose entry is Here and are based i.e the top left entry is",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_of_function",
          "normalized": "(a-\u003ea-\u003eb)-\u003eMatrix c d b",
          "package": "newsynth",
          "signature": "(a-\u003ea-\u003eb)-\u003eMatrix m n b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_of_function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenience constructor for matrices: turn a list of rows into\n a matrix.\n\u003c/p\u003e\u003cp\u003eNote: since the dimensions of the matrix are type-level integers,\n they cannot be inferred from the dimensions of the input; instead,\n they must be specified explicitly in the type. It is an error to\n apply this function to a list of the wrong dimension.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_of_rows",
          "package": "newsynth",
          "signature": "[[a]] -\u003e Matrix n m a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_of_rows",
          "type": "function"
        },
        "index": {
          "description": "convenience constructor for matrices turn list of rows into matrix Note since the dimensions of the matrix are type-level integers they cannot be inferred from the dimensions of the input instead they must be specified explicitly in the type It is an error to apply this function to list of the wrong dimension",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_of_rows",
          "normalized": "[[a]]-\u003eMatrix b c a",
          "package": "newsynth",
          "signature": "[[a]]-\u003eMatrix n m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_of_rows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion of \u003ccode\u003e\u003ca\u003esequence\u003c/a\u003e\u003c/code\u003e for matrices.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_sequence",
          "package": "newsynth",
          "signature": "Matrix n p (m a) -\u003e m (Matrix n p a)",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_sequence",
          "type": "function"
        },
        "index": {
          "description": "Version of sequence for matrices",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_sequence",
          "normalized": "Matrix a b(c d)-\u003ec(Matrix a b d)",
          "package": "newsynth",
          "signature": "Matrix n p(m a)-\u003em(Matrix n p a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the size (\u003cem\u003em\u003c/em\u003e, \u003cem\u003en\u003c/em\u003e) of a matrix, where \u003cem\u003em\u003c/em\u003e is the number\n of rows, and \u003cem\u003en\u003c/em\u003e is the number of columns. Since this information\n is contained in the type, the matrix argument is not evaluated and\n can be a dummy (undefined) argument.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_size",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e (Integer, Integer)",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_size",
          "type": "function"
        },
        "index": {
          "description": "Return the size of matrix where is the number of rows and is the number of columns Since this information is contained in the type the matrix argument is not evaluated and can be dummy undefined argument",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_size",
          "normalized": "Matrix a b c-\u003e(Integer,Integer)",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003e(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the transpose of an \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_transpose",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Matrix n m a",
          "source": "src/Quantum-Synthesis-Matrix.html#matrix_transpose",
          "type": "function"
        },
        "index": {
          "description": "Take the transpose of an matrix",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "matrix_transpose",
          "normalized": "Matrix a b c-\u003eMatrix b a c",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003eMatrix n m a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:matrix_transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a term-level integer corresponding to this type-level\n natural number. The argument is just a dummy argument and is not\n evaluated.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "nat",
          "package": "newsynth",
          "signature": "n -\u003e Integer",
          "source": "src/Quantum-Synthesis-Matrix.html#nat",
          "type": "method"
        },
        "index": {
          "description": "Return term-level integer corresponding to this type-level natural number The argument is just dummy argument and is not evaluated",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "nat",
          "normalized": "a-\u003eInteger",
          "package": "newsynth",
          "signature": "n-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a term-level natural number corresponding to this\n type-level natural number.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "nnat",
          "package": "newsynth",
          "signature": "NNat n",
          "source": "src/Quantum-Synthesis-Matrix.html#nnat",
          "type": "method"
        },
        "index": {
          "description": "Return term-level natural number corresponding to this type-level natural number",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "nnat",
          "package": "newsynth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:nnat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the 0 matrix of the given dimension.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "null_matrix",
          "package": "newsynth",
          "signature": "Matrix m n a",
          "source": "src/Quantum-Synthesis-Matrix.html#null_matrix",
          "type": "function"
        },
        "index": {
          "description": "Return the matrix of the given dimension",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "null_matrix",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:null_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm a diagonal block matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "oplus",
          "package": "newsynth",
          "signature": "Matrix p q a -\u003e Matrix m n a -\u003e Matrix (p `Plus` m) (q `Plus` n) a",
          "source": "src/Quantum-Synthesis-Matrix.html#oplus",
          "type": "function"
        },
        "index": {
          "description": "Form diagonal block matrix",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "oplus",
          "normalized": "Matrix a b c-\u003eMatrix d e c-\u003eMatrix(a Plus d)(b Plus e)c",
          "package": "newsynth",
          "signature": "Matrix p q a-\u003eMatrix m n a-\u003eMatrix(p Plus m)(q Plus n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:oplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a matrix into a list of rows.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "rows_of_matrix",
          "package": "newsynth",
          "signature": "Matrix n m a -\u003e [[a]]",
          "source": "src/Quantum-Synthesis-Matrix.html#rows_of_matrix",
          "type": "function"
        },
        "index": {
          "description": "Turn matrix into list of rows",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "rows_of_matrix",
          "normalized": "Matrix a b c-\u003e[[c]]",
          "package": "newsynth",
          "signature": "Matrix n m a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:rows_of_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication of a scalar and an \u003cem\u003em\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "scalarmult",
          "package": "newsynth",
          "signature": "a -\u003e Matrix m n a -\u003e Matrix m n a",
          "source": "src/Quantum-Synthesis-Matrix.html#scalarmult",
          "type": "function"
        },
        "index": {
          "description": "Multiplication of scalar and an matrix",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "scalarmult",
          "normalized": "a-\u003eMatrix b c a-\u003eMatrix b c a",
          "package": "newsynth",
          "signature": "a-\u003eMatrix m n a-\u003eMatrix m n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:scalarmult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStack matrices horizontally.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "stack_horizontal",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Matrix m p a -\u003e Matrix m (n `Plus` p) a",
          "source": "src/Quantum-Synthesis-Matrix.html#stack_horizontal",
          "type": "function"
        },
        "index": {
          "description": "Stack matrices horizontally",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "stack_horizontal",
          "normalized": "Matrix a b c-\u003eMatrix a d c-\u003eMatrix a(b Plus d)c",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003eMatrix m p a-\u003eMatrix m(n Plus p)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:stack_horizontal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStack matrices vertically.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "stack_vertical",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Matrix p n a -\u003e Matrix (m `Plus` p) n a",
          "source": "src/Quantum-Synthesis-Matrix.html#stack_vertical",
          "type": "function"
        },
        "index": {
          "description": "Stack matrices vertically",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "stack_vertical",
          "normalized": "Matrix a b c-\u003eMatrix d b c-\u003eMatrix(a Plus d)b c",
          "package": "newsynth",
          "signature": "Matrix m n a-\u003eMatrix p n a-\u003eMatrix(m Plus p)n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:stack_vertical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap gate.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "swap",
          "package": "newsynth",
          "signature": "Matrix Four Four a",
          "source": "src/Quantum-Synthesis-Matrix.html#swap",
          "type": "function"
        },
        "index": {
          "description": "Swap gate",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "swap",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKronecker tensor of two matrices.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tensor",
          "package": "newsynth",
          "signature": "Matrix p q a -\u003e Matrix m n a -\u003e Matrix (p `Times` m) (q `Times` n) a",
          "source": "src/Quantum-Synthesis-Matrix.html#tensor",
          "type": "function"
        },
        "index": {
          "description": "Kronecker tensor of two matrices",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tensor",
          "normalized": "Matrix a b c-\u003eMatrix d e c-\u003eMatrix(a Times d)(b Times e)c",
          "package": "newsynth",
          "signature": "Matrix p q a-\u003eMatrix m n a-\u003eMatrix(p Times m)(q Times n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:tensor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat a matrix horizontally, according to some vector of scalars.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tensor_horizontal",
          "package": "newsynth",
          "signature": "Vector p a -\u003e Matrix m n a -\u003e Matrix m (p `Times` n) a",
          "source": "src/Quantum-Synthesis-Matrix.html#tensor_horizontal",
          "type": "function"
        },
        "index": {
          "description": "Repeat matrix horizontally according to some vector of scalars",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tensor_horizontal",
          "normalized": "Vector a b-\u003eMatrix c d b-\u003eMatrix c(a Times d)b",
          "package": "newsynth",
          "signature": "Vector p a-\u003eMatrix m n a-\u003eMatrix m(p Times n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:tensor_horizontal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat a matrix vertically, according to some vector of scalars.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tensor_vertical",
          "package": "newsynth",
          "signature": "Vector p a -\u003e Matrix m n a -\u003e Matrix (p `Times` m) n a",
          "source": "src/Quantum-Synthesis-Matrix.html#tensor_vertical",
          "type": "function"
        },
        "index": {
          "description": "Repeat matrix vertically according to some vector of scalars",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tensor_vertical",
          "normalized": "Vector a b-\u003eMatrix c d b-\u003eMatrix(a Times c)d b",
          "package": "newsynth",
          "signature": "Vector p a-\u003eMatrix m n a-\u003eMatrix(p Times m)n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:tensor_vertical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the trace of a square matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tr",
          "package": "newsynth",
          "signature": "Matrix n n a -\u003e a",
          "source": "src/Quantum-Synthesis-Matrix.html#tr",
          "type": "function"
        },
        "index": {
          "description": "Return the trace of square matrix",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "tr",
          "normalized": "Matrix a a b-\u003eb",
          "package": "newsynth",
          "signature": "Matrix n n a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:tr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecompose a matrix into a list of columns.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "unMatrix",
          "package": "newsynth",
          "signature": "Matrix m n a -\u003e Vector n (Vector m a)",
          "source": "src/Quantum-Synthesis-Matrix.html#unMatrix",
          "type": "function"
        },
        "index": {
          "description": "Decompose matrix into list of columns",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "unMatrix",
          "normalized": "Matrix a b c-\u003eVector b(Vector a c)",
          "package": "newsynth",
          "partial": "Matrix",
          "signature": "Matrix m n a-\u003eVector n(Vector m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:unMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a vector from a list. Note: since the length of the\n vector is a type-level integer, it cannot be inferred from the\n length of the input list; instead, it must be specified explicitly\n in the type. It is an error to apply this function to a list of\n the wrong length.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector",
          "package": "newsynth",
          "signature": "[a] -\u003e Vector n a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector",
          "type": "function"
        },
        "index": {
          "description": "Construct vector from list Note since the length of the vector is type-level integer it cannot be inferred from the length of the input list instead it must be specified explicitly in the type It is an error to apply this function to list of the wrong length",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector",
          "normalized": "[a]-\u003eVector b a",
          "package": "newsynth",
          "signature": "[a]-\u003eVector n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend two fixed-length lists.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_append",
          "package": "newsynth",
          "signature": "Vector n a -\u003e Vector m a -\u003e Vector (n `Plus` m) a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_append",
          "type": "function"
        },
        "index": {
          "description": "Append two fixed-length lists",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_append",
          "normalized": "Vector a b-\u003eVector c b-\u003eVector(a Plus c)b",
          "package": "newsynth",
          "signature": "Vector n a-\u003eVector m a-\u003eVector(n Plus m)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the vector (0, 1, &#8230;, \u003cem\u003en\u003c/em\u003e-1).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_enum",
          "package": "newsynth",
          "signature": "Vector n a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_enum",
          "type": "function"
        },
        "index": {
          "description": "Create the vector",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_enum",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft strict fold over a fixed-length list.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_foldl",
          "package": "newsynth",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Vector n b -\u003e a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_foldl",
          "type": "function"
        },
        "index": {
          "description": "Left strict fold over fixed-length list",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector c b-\u003ea",
          "package": "newsynth",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eVector n b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight fold over a fixed-length list.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_foldr",
          "package": "newsynth",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector n a -\u003e b",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_foldr",
          "type": "function"
        },
        "index": {
          "description": "Right fold over fixed-length list",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector c a-\u003eb",
          "package": "newsynth",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector n a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the head of a fixed-length list. Note that the type system\n ensures that this never fails.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_head",
          "package": "newsynth",
          "signature": "Vector (Succ n) a -\u003e a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_head",
          "type": "function"
        },
        "index": {
          "description": "Return the head of fixed-length list Note that the type system ensures that this never fails",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_head",
          "normalized": "Vector(Succ a)b-\u003eb",
          "package": "newsynth",
          "signature": "Vector(Succ n)a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the \u003cem\u003ei\u003c/em\u003eth element of the vector. Counting starts from 0.\n Throws an error if the index is out of range.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_index",
          "package": "newsynth",
          "signature": "Vector n a -\u003e i -\u003e a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_index",
          "type": "function"
        },
        "index": {
          "description": "Return the th element of the vector Counting starts from Throws an error if the index is out of range",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_index",
          "normalized": "Vector a b-\u003ec-\u003eb",
          "package": "newsynth",
          "signature": "Vector n a-\u003ei-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the length of a vector. Since this information is\n contained in the type, the vector argument is never evaluated and\n can be a dummy (undefined) argument.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_length",
          "package": "newsynth",
          "signature": "Vector n a -\u003e Integer",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_length",
          "type": "function"
        },
        "index": {
          "description": "Return the length of vector Since this information is contained in the type the vector argument is never evaluated and can be dummy undefined argument",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_length",
          "normalized": "Vector a b-\u003eInteger",
          "package": "newsynth",
          "signature": "Vector n a-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over a fixed-length list.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_map",
          "package": "newsynth",
          "signature": "(a -\u003e b) -\u003e Vector n a -\u003e Vector n b",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_map",
          "type": "function"
        },
        "index": {
          "description": "Map function over fixed-length list",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_map",
          "normalized": "(a-\u003eb)-\u003eVector c a-\u003eVector c b",
          "package": "newsynth",
          "signature": "(a-\u003eb)-\u003eVector n a-\u003eVector n b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the vector (\u003cem\u003ef\u003c/em\u003e(0), \u003cem\u003ef\u003c/em\u003e(1), &#8230;, \u003cem\u003ef\u003c/em\u003e(\u003cem\u003en\u003c/em\u003e-1)).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_of_function",
          "package": "newsynth",
          "signature": "(a -\u003e b) -\u003e Vector n b",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_of_function",
          "type": "function"
        },
        "index": {
          "description": "Create the vector",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_of_function",
          "normalized": "(a-\u003eb)-\u003eVector c b",
          "package": "newsynth",
          "signature": "(a-\u003eb)-\u003eVector n b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_of_function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a fixed-length list consisting of a repetition of the\n given element. Unlike \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e, no count is needed, because this\n information is already contained in the type. However, the type\n must of course be inferable from the context.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_repeat",
          "package": "newsynth",
          "signature": "a -\u003e Vector n a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_repeat",
          "type": "function"
        },
        "index": {
          "description": "Return fixed-length list consisting of repetition of the given element Unlike replicate no count is needed because this information is already contained in the type However the type must of course be inferable from the context",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_repeat",
          "normalized": "a-\u003eVector b a",
          "package": "newsynth",
          "signature": "a-\u003eVector n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVersion of \u003ccode\u003e\u003ca\u003esequence\u003c/a\u003e\u003c/code\u003e for fixed-length lists.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_sequence",
          "package": "newsynth",
          "signature": "Vector n (m a) -\u003e m (Vector n a)",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_sequence",
          "type": "function"
        },
        "index": {
          "description": "Version of sequence for fixed-length lists",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_sequence",
          "normalized": "Vector a(b c)-\u003eb(Vector a c)",
          "package": "newsynth",
          "signature": "Vector n(m a)-\u003em(Vector n a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a vector of length 1.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_singleton",
          "package": "newsynth",
          "signature": "a -\u003e Vector One a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_singleton",
          "type": "function"
        },
        "index": {
          "description": "Construct vector of length",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_singleton",
          "normalized": "a-\u003eVector One a",
          "package": "newsynth",
          "signature": "a-\u003eVector One a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the tail of a fixed-length list. Note that the type system\n ensures that this never fails.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_tail",
          "package": "newsynth",
          "signature": "Vector (Succ n) a -\u003e Vector n a",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_tail",
          "type": "function"
        },
        "index": {
          "description": "Return the tail of fixed-length list Note that the type system ensures that this never fails",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_tail",
          "normalized": "Vector(Succ a)b-\u003eVector a b",
          "package": "newsynth",
          "signature": "Vector(Succ n)a-\u003eVector n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a list of columns into a list of rows.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_transpose",
          "package": "newsynth",
          "signature": "Vector n (Vector m a) -\u003e Vector m (Vector n a)",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_transpose",
          "type": "function"
        },
        "index": {
          "description": "Turn list of columns into list of rows",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_transpose",
          "normalized": "Vector a(Vector b c)-\u003eVector b(Vector a c)",
          "package": "newsynth",
          "signature": "Vector n(Vector m a)-\u003eVector m(Vector n a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip two equal length lists.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_zipwith",
          "package": "newsynth",
          "signature": "(a -\u003e b -\u003e c) -\u003e Vector n a -\u003e Vector n b -\u003e Vector n c",
          "source": "src/Quantum-Synthesis-Matrix.html#vector_zipwith",
          "type": "function"
        },
        "index": {
          "description": "Zip two equal length lists",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "vector_zipwith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eVector d a-\u003eVector d b-\u003eVector d c",
          "package": "newsynth",
          "signature": "(a-\u003eb-\u003ec)-\u003eVector n a-\u003eVector n b-\u003eVector n c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:vector_zipwith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003cem\u003ez\u003c/em\u003e-rotation gate, \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#952;) = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e&#8722;\u003cem\u003ei\u003c/em\u003e&#952;\u003cem\u003eZ\u003c/em\u003e/2\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Matrix",
          "name": "zrot",
          "package": "newsynth",
          "signature": "r -\u003e Matrix Two Two (Cplx r)",
          "source": "src/Quantum-Synthesis-Matrix.html#zrot",
          "type": "function"
        },
        "index": {
          "description": "rotation gate",
          "hierarchy": "Quantum Synthesis Matrix",
          "module": "Quantum.Synthesis.Matrix",
          "name": "zrot",
          "normalized": "a-\u003eMatrix Two Two(Cplx a)",
          "package": "newsynth",
          "signature": "r-\u003eMatrix Two Two(Cplx r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Matrix.html#v:zrot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for the representation and exact\n synthesis of multi-qubit Clifford+\u003cem\u003eT\u003c/em\u003e operators. \n\u003c/p\u003e\u003cp\u003eThe multi-qubit Clifford+\u003cem\u003eT\u003c/em\u003e exact synthesis algorithm is described\n in the paper:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Brett Giles, Peter Selinger. Exact synthesis of multiqubit Clifford+T\n circuits. \u003cem\u003ePhysical Review A\u003c/em\u003e 87, 032332 (7 pages), 2013. Available\n from \u003ca\u003ehttp://arxiv.org/abs/1212.0506\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt generalizes the single-qubit exact synthesis algorithm of\n Kliuchnikov, Maslov, and Mosca.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "MultiQubitSynthesis",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for the representation and exact synthesis of multi-qubit Clifford operators The multi-qubit Clifford exact synthesis algorithm is described in the paper Brett Giles Peter Selinger Exact synthesis of multiqubit Clifford circuits Physical Review pages Available from http arxiv.org abs It generalizes the single-qubit exact synthesis algorithm of Kliuchnikov Maslov and Mosca",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "MultiQubitSynthesis",
          "package": "newsynth",
          "partial": "Multi Qubit Synthesis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn index for a row or column of a matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "Index",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#Index",
          "type": "type"
        },
        "index": {
          "description": "An index for row or column of matrix",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "Index",
          "package": "newsynth",
          "partial": "Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for things that have residues. In a typical\n instance, \u003cem\u003ea\u003c/em\u003e is a ring whose elements are expressed with\n coefficients in &#8484;, and \u003cem\u003eb\u003c/em\u003e is a corresponding ring whose elements\n are expressed with coefficients in &#8484;\u003csub\u003e2\u003c/sub\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "Residue",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#Residue",
          "type": "class"
        },
        "index": {
          "description": "type class for things that have residues In typical instance is ring whose elements are expressed with coefficients in and is corresponding ring whose elements are expressed with coefficients in",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "Residue",
          "package": "newsynth",
          "partial": "Residue",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:Residue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eresidue type\u003c/em\u003e of \u003cem\u003et\u003c/em\u003e &#8712; &#8484;[&#969;] is the residue of \u003cem\u003et\u003c/em\u003e\u003csup\u003e&#8224;\u003c/sup\u003e\u003cem\u003et\u003c/em\u003e.\n It is 0000, 0001, or 1010.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "ResidueType",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#ResidueType",
          "type": "data"
        },
        "index": {
          "description": "The residue type of is the residue of It is or",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "ResidueType",
          "package": "newsynth",
          "partial": "Residue Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:ResidueType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymbolic representation of one- and two-level operators. Note\n that the power \u003cem\u003ek\u003c/em\u003e in the \u003ccode\u003e\u003ca\u003eTL_T\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eTL_omega\u003c/a\u003e\u003c/code\u003e constructors can be\n positive or negative, and should be regarded modulo 8.\n\u003c/p\u003e\u003cp\u003eNote: when we use a list of \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operators to express a\n sequence of operators, the operators are meant to be applied\n right-to-left, i.e., as in the mathematical notation for matrix\n multiplication. This is the opposite of the quantum circuit\n notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TwoLevel",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevel",
          "type": "data"
        },
        "index": {
          "description": "Symbolic representation of one and two-level operators Note that the power in the TL and TL omega constructors can be positive or negative and should be regarded modulo Note when we use list of TwoLevel operators to express sequence of operators the operators are meant to be applied right-to-left i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TwoLevel",
          "package": "newsynth",
          "partial": "Two Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymbolic representation of one- and two-level operators, with an\n alternate set of generators.\n\u003c/p\u003e\u003cp\u003eNote: when we use a list of \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operators to express a\n sequence of operators, the operators are meant to be applied\n right-to-left, i.e., as in the mathematical notation for matrix\n multiplication. This is the opposite of the quantum circuit\n notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TwoLevelAlt",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevelAlt",
          "type": "data"
        },
        "index": {
          "description": "Symbolic representation of one and two-level operators with an alternate set of generators Note when we use list of TwoLevel operators to express sequence of operators the operators are meant to be applied right-to-left i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TwoLevelAlt",
          "package": "newsynth",
          "partial": "Two Level Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevelAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "RT_0000",
          "package": "newsynth",
          "signature": "RT_0000",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#ResidueType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "RT_0000",
          "package": "newsynth",
          "partial": "RT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:RT_0000"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "RT_0001",
          "package": "newsynth",
          "signature": "RT_0001",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#ResidueType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "RT_0001",
          "package": "newsynth",
          "partial": "RT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:RT_0001"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "RT_1010",
          "package": "newsynth",
          "signature": "RT_1010",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#ResidueType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "RT_1010",
          "package": "newsynth",
          "partial": "RT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:RT_1010"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eH\u003c/em\u003e\u003csub\u003e\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e\u003c/sub\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_H",
          "package": "newsynth",
          "signature": "TL_H Index Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_H",
          "package": "newsynth",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_H"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003eT\u003c/em\u003e\u003csub\u003e\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e\u003c/sub\u003e)\u003csup\u003e\u003cem\u003ek\u003c/em\u003e\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_T",
          "package": "newsynth",
          "signature": "TL_T Int Index Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_T",
          "package": "newsynth",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_T"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003cem\u003eT\u003c/em\u003e\u003csup\u003e&#8722;\u003cem\u003em\u003c/em\u003e\u003c/sup\u003e(iH)T\u003csup\u003e\u003cem\u003em\u003c/em\u003e\u003c/sup\u003e)\u003csub\u003e\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e\u003c/sub\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_TiHT",
          "package": "newsynth",
          "signature": "TL_TiHT Int Index Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevelAlt",
          "type": "function"
        },
        "index": {
          "description": "iH",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_TiHT",
          "package": "newsynth",
          "partial": "TL Ti HT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_TiHT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eW\u003c/em\u003e\u003csup\u003e\u003cem\u003em\u003c/em\u003e\u003c/sup\u003e\u003csub\u003e\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e\u003c/sub\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_W",
          "package": "newsynth",
          "signature": "TL_W Int Index Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevelAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_W",
          "package": "newsynth",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_W"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eX\u003c/em\u003e\u003csub\u003e\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e\u003c/sub\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_X",
          "package": "newsynth",
          "signature": "TL_X Index Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_X",
          "package": "newsynth",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eiX\u003c/em\u003e\u003csub\u003e\u003cem\u003ei\u003c/em\u003e,\u003cem\u003ej\u003c/em\u003e\u003c/sub\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_iX",
          "package": "newsynth",
          "signature": "TL_iX Index Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevelAlt",
          "type": "function"
        },
        "index": {
          "description": "iX",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_iX",
          "package": "newsynth",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_iX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(&#969;\u003csub\u003e\u003cem\u003ei\u003c/em\u003e\u003c/sub\u003e)\u003csup\u003e\u003cem\u003ek\u003c/em\u003e\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_omega",
          "package": "newsynth",
          "signature": "TL_omega Int Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_omega",
          "package": "newsynth",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(&#969;\u003csub\u003e\u003cem\u003ei\u003c/em\u003e\u003c/sub\u003e)\u003csup\u003e\u003cem\u003em\u003c/em\u003e\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_omega_alt",
          "package": "newsynth",
          "signature": "TL_omega_alt Int Index",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#TwoLevelAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "TL_omega_alt",
          "package": "newsynth",
          "partial": "TL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:TL_omega_alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operator to a \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e-vector, represented as\n a list. Throws an error if any operation produces a scalar that is\n not in \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "apply_twolevel_zomega",
          "package": "newsynth",
          "signature": "TwoLevel -\u003e [ZOmega] -\u003e [ZOmega]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#apply_twolevel_zomega",
          "type": "function"
        },
        "index": {
          "description": "Apply TwoLevel operator to ZOmega vector represented as list Throws an error if any operation produces scalar that is not in ZOmega",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "apply_twolevel_zomega",
          "normalized": "TwoLevel-\u003e[ZOmega]-\u003e[ZOmega]",
          "package": "newsynth",
          "signature": "TwoLevel-\u003e[ZOmega]-\u003e[ZOmega]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:apply_twolevel_zomega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a list of \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operators to a \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e-vector,\n represented as a list. Throws an error if any operation produces a\n scalar that is not in \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "apply_twolevels_zomega",
          "package": "newsynth",
          "signature": "[TwoLevel] -\u003e [ZOmega] -\u003e [ZOmega]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#apply_twolevels_zomega",
          "type": "function"
        },
        "index": {
          "description": "Apply list of TwoLevel operators to ZOmega vector represented as list Throws an error if any operation produces scalar that is not in ZOmega",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "apply_twolevels_zomega",
          "normalized": "[TwoLevel]-\u003e[ZOmega]-\u003e[ZOmega]",
          "package": "newsynth",
          "signature": "[TwoLevel]-\u003e[ZOmega]-\u003e[ZOmega]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:apply_twolevels_zomega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert a \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operator.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "invert_twolevel",
          "package": "newsynth",
          "signature": "TwoLevel -\u003e TwoLevel",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#invert_twolevel",
          "type": "function"
        },
        "index": {
          "description": "Invert TwoLevel operator",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "invert_twolevel",
          "normalized": "TwoLevel-\u003eTwoLevel",
          "package": "newsynth",
          "signature": "TwoLevel-\u003eTwoLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:invert_twolevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert a list of \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operators.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "invert_twolevels",
          "package": "newsynth",
          "signature": "[TwoLevel] -\u003e [TwoLevel]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#invert_twolevels",
          "type": "function"
        },
        "index": {
          "description": "Invert list of TwoLevel operators",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "invert_twolevels",
          "normalized": "[TwoLevel]-\u003e[TwoLevel]",
          "package": "newsynth",
          "signature": "[TwoLevel]-\u003e[TwoLevel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:invert_twolevels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert a list of \u003ccode\u003e\u003ca\u003eTwoLevelAlt\u003c/a\u003e\u003c/code\u003e operators, and convert the output\n to a list of \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operators.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "invert_twolevels_alt",
          "package": "newsynth",
          "signature": "[TwoLevelAlt] -\u003e [TwoLevel]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#invert_twolevels_alt",
          "type": "function"
        },
        "index": {
          "description": "Invert list of TwoLevelAlt operators and convert the output to list of TwoLevel operators",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "invert_twolevels_alt",
          "normalized": "[TwoLevelAlt]-\u003e[TwoLevel]",
          "package": "newsynth",
          "signature": "[TwoLevelAlt]-\u003e[TwoLevel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:invert_twolevels_alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the \u003cem\u003ei\u003c/em\u003eth element of a list by \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "list_insert",
          "package": "newsynth",
          "signature": "Index -\u003e a -\u003e [a] -\u003e [a]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#list_insert",
          "type": "function"
        },
        "index": {
          "description": "Replace the th element of list by",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "list_insert",
          "normalized": "Index-\u003ea-\u003e[a]-\u003e[a]",
          "package": "newsynth",
          "signature": "Index-\u003ea-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:list_insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a list into pairs. Return a list of pairs, and a final\n element if the length of the list was odd.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "list_pairs",
          "package": "newsynth",
          "signature": "[a] -\u003e ([(a, a)], Maybe a)",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#list_pairs",
          "type": "function"
        },
        "index": {
          "description": "Split list into pairs Return list of pairs and final element if the length of the list was odd",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "list_pairs",
          "normalized": "[a]-\u003e([(a,a)],Maybe a)",
          "package": "newsynth",
          "signature": "[a]-\u003e([(a,a)],Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:list_pairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an element of the form &#969;\u003csup\u003e\u003cem\u003em\u003c/em\u003e\u003c/sup\u003e, return \u003cem\u003em\u003c/em\u003e &#8712; {0,&#8230;,7}, or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if not of that form.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "log_omega",
          "package": "newsynth",
          "signature": "ZOmega -\u003e Maybe Int",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#log_omega",
          "type": "function"
        },
        "index": {
          "description": "Given an element of the form return or Nothing if not of that form",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "log_omega",
          "normalized": "ZOmega-\u003eMaybe Int",
          "package": "newsynth",
          "signature": "ZOmega-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:log_omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a symbolic one- or two-level operator into a matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "matrix_of_twolevel",
          "package": "newsynth",
          "signature": "TwoLevel -\u003e Matrix n n a",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#matrix_of_twolevel",
          "type": "function"
        },
        "index": {
          "description": "Convert symbolic one or two-level operator into matrix",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "matrix_of_twolevel",
          "normalized": "TwoLevel-\u003eMatrix a a b",
          "package": "newsynth",
          "signature": "TwoLevel-\u003eMatrix n n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:matrix_of_twolevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of symbolic one- or two-level operators into a\n matrix. Note that the operators are to be applied right-to-left,\n exactly as in mathematical notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "matrix_of_twolevels",
          "package": "newsynth",
          "signature": "[TwoLevel] -\u003e Matrix n n a",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#matrix_of_twolevels",
          "type": "function"
        },
        "index": {
          "description": "Convert list of symbolic one or two-level operators into matrix Note that the operators are to be applied right-to-left exactly as in mathematical notation",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "matrix_of_twolevels",
          "normalized": "[TwoLevel]-\u003eMatrix a a b",
          "package": "newsynth",
          "signature": "[TwoLevel]-\u003eMatrix n n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:matrix_of_twolevels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply a scalar by &#969;\u003csup\u003e\u003cem\u003en\u003c/em\u003e\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "omega_power",
          "package": "newsynth",
          "signature": "Int -\u003e a -\u003e a",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#omega_power",
          "type": "function"
        },
        "index": {
          "description": "Multiply scalar by",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "omega_power",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "newsynth",
          "signature": "Int-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:omega_power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a one-level matrix with the given entry.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "onelevel_matrix",
          "package": "newsynth",
          "signature": "a -\u003e Index -\u003e Matrix n n a",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#onelevel_matrix",
          "type": "function"
        },
        "index": {
          "description": "Construct one-level matrix with the given entry",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "onelevel_matrix",
          "normalized": "a-\u003eIndex-\u003eMatrix b b a",
          "package": "newsynth",
          "signature": "a-\u003eIndex-\u003eMatrix n n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:onelevel_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the \u003cem\u003eH\u003c/em\u003e operator to a 2-dimensional vector over\n \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e. This throws an error if the result is not well-defined\n over \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "opH_zomega",
          "package": "newsynth",
          "signature": "(ZOmega, ZOmega) -\u003e (ZOmega, ZOmega)",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#opH_zomega",
          "type": "function"
        },
        "index": {
          "description": "Apply the operator to dimensional vector over ZOmega This throws an error if the result is not well-defined over ZOmega",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "opH_zomega",
          "normalized": "(ZOmega,ZOmega)-\u003e(ZOmega,ZOmega)",
          "package": "newsynth",
          "signature": "(ZOmega,ZOmega)-\u003e(ZOmega,ZOmega)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:opH_zomega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the \u003cem\u003eX\u003c/em\u003e operator to a 2-dimensional vector over \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "opX_zomega",
          "package": "newsynth",
          "signature": "(ZOmega, ZOmega) -\u003e (ZOmega, ZOmega)",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#opX_zomega",
          "type": "function"
        },
        "index": {
          "description": "Apply the operator to dimensional vector over ZOmega",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "opX_zomega",
          "normalized": "(ZOmega,ZOmega)-\u003e(ZOmega,ZOmega)",
          "package": "newsynth",
          "signature": "(ZOmega,ZOmega)-\u003e(ZOmega,ZOmega)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:opX_zomega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide an element of \u003ccode\u003e\u003ca\u003eZOmega\u003c/a\u003e\u003c/code\u003e by &#8730;2, or throw an error if it is\n not divisible.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reduce_ZOmega",
          "package": "newsynth",
          "signature": "ZOmega -\u003e ZOmega",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#reduce_ZOmega",
          "type": "function"
        },
        "index": {
          "description": "Divide an element of ZOmega by or throw an error if it is not divisible",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reduce_ZOmega",
          "normalized": "ZOmega-\u003eZOmega",
          "package": "newsynth",
          "partial": "ZOmega",
          "signature": "ZOmega-\u003eZOmega",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:reduce_ZOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRow reduction: Given a unit column vector \u003cem\u003ev\u003c/em\u003e, generate a\n sequence of two-level operators that reduces the \u003cem\u003ei\u003c/em\u003eth standard\n basis vector \u003cem\u003ee\u003c/em\u003e\u003csub\u003e\u003cem\u003ei\u003c/em\u003e\u003c/sub\u003e to \u003cem\u003ev\u003c/em\u003e. Any rows that are already 0 in\n both vectors are guaranteed not to be touched.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reduce_column",
          "package": "newsynth",
          "signature": "Matrix n One DOmega -\u003e Index -\u003e [TwoLevel]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#reduce_column",
          "type": "function"
        },
        "index": {
          "description": "Row reduction Given unit column vector generate sequence of two-level operators that reduces the th standard basis vector to Any rows that are already in both vectors are guaranteed not to be touched",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reduce_column",
          "normalized": "Matrix a One DOmega-\u003eIndex-\u003e[TwoLevel]",
          "package": "newsynth",
          "signature": "Matrix n One DOmega-\u003eIndex-\u003e[TwoLevel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:reduce_column"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRow reduction: Given a unit column vector \u003cem\u003ev\u003c/em\u003e, generate a\n sequence of two-level operators that reduces the \u003cem\u003ei\u003c/em\u003eth standard\n basis vector \u003cem\u003ee\u003c/em\u003e\u003csub\u003e\u003cem\u003ei\u003c/em\u003e\u003c/sub\u003e to \u003cem\u003ev\u003c/em\u003e. Any rows that are already 0 in\n both vectors are guaranteed not to be touched, except possibly row\n \u003cem\u003ei\u003c/em\u003e+1 may be multiplied by a scalar.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reduce_column_alt",
          "package": "newsynth",
          "signature": "Matrix n One DOmega -\u003e Index -\u003e [TwoLevelAlt]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#reduce_column_alt",
          "type": "function"
        },
        "index": {
          "description": "Row reduction Given unit column vector generate sequence of two-level operators that reduces the th standard basis vector to Any rows that are already in both vectors are guaranteed not to be touched except possibly row may be multiplied by scalar",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reduce_column_alt",
          "normalized": "Matrix a One DOmega-\u003eIndex-\u003e[TwoLevelAlt]",
          "package": "newsynth",
          "signature": "Matrix n One DOmega-\u003eIndex-\u003e[TwoLevelAlt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:reduce_column_alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a residue is reducible. A residue \u003cem\u003er\u003c/em\u003e is called \u003cem\u003ereducible\u003c/em\u003e\n if it is of the form \u003cem\u003er\u003c/em\u003e = &#8730;2 &#8901; \u003cem\u003er\u003c/em\u003e', i.e., \u003cem\u003er\u003c/em\u003e &#8712; {0000, 0101, 1010, 1111}.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reducible",
          "package": "newsynth",
          "signature": "Omega Z2 -\u003e Bool",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#reducible",
          "type": "function"
        },
        "index": {
          "description": "Check whether residue is reducible residue is called reducible if it is of the form i.e",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "reducible",
          "normalized": "Omega Z-\u003eBool",
          "package": "newsynth",
          "signature": "Omega Z-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:reducible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the residue of something.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue",
          "package": "newsynth",
          "signature": "a -\u003e b",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#residue",
          "type": "method"
        },
        "index": {
          "description": "Return the residue of something",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue",
          "normalized": "a-\u003eb",
          "package": "newsynth",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:residue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven two irreducible residues \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e of the same type, find\n an index \u003cem\u003em\u003c/em\u003e such that \u003cem\u003ea\u003c/em\u003e + &#969;\u003csup\u003e\u003cem\u003em\u003c/em\u003e\u003c/sup\u003e\u003cem\u003eb\u003c/em\u003e = 0000. If no such index\n exists, find an index \u003cem\u003em\u003c/em\u003e such that \u003cem\u003ea\u003c/em\u003e + &#969;\u003csup\u003e\u003cem\u003em\u003c/em\u003e\u003c/sup\u003e\u003cem\u003eb\u003c/em\u003e = 1111.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_offset",
          "package": "newsynth",
          "signature": "Omega Z2 -\u003e Omega Z2 -\u003e Int",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#residue_offset",
          "type": "function"
        },
        "index": {
          "description": "Given two irreducible residues and of the same type find an index such that If no such index exists find an index such that",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_offset",
          "normalized": "Omega Z-\u003eOmega Z-\u003eInt",
          "package": "newsynth",
          "signature": "Omega Z-\u003eOmega Z-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:residue_offset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the residue's \u003cem\u003eshift\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eThe shift is defined so that: \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 0001, 1110, 0011 have shift 0,\n\u003c/li\u003e\u003cli\u003e 0010, 1101, 0110 have shift 1,\n\u003c/li\u003e\u003cli\u003e 0100, 1011, 1100 have shift 2, and\n\u003c/li\u003e\u003cli\u003e 1000, 0111, 1001 have shift 3.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eResidues of type \u003ccode\u003e\u003ca\u003eRT_0000\u003c/a\u003e\u003c/code\u003e have shift 0.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_shift",
          "package": "newsynth",
          "signature": "Omega Z2 -\u003e Int",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#residue_shift",
          "type": "function"
        },
        "index": {
          "description": "Return the residue shift The shift is defined so that have shift have shift have shift and have shift Residues of type RT have shift",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_shift",
          "normalized": "Omega Z-\u003eInt",
          "package": "newsynth",
          "signature": "Omega Z-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:residue_shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the residue's \u003ccode\u003e\u003ca\u003eResidueType\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_type",
          "package": "newsynth",
          "signature": "Omega Z2 -\u003e ResidueType",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#residue_type",
          "type": "function"
        },
        "index": {
          "description": "Return the residue ResidueType",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_type",
          "normalized": "Omega Z-\u003eResidueType",
          "package": "newsynth",
          "signature": "Omega Z-\u003eResidueType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:residue_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the residue's \u003ccode\u003e\u003ca\u003eResidueType\u003c/a\u003e\u003c/code\u003e and the shift.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_type_shift",
          "package": "newsynth",
          "signature": "Omega Z2 -\u003e (ResidueType, Int)",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#residue_type_shift",
          "type": "function"
        },
        "index": {
          "description": "Return the residue ResidueType and the shift",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "residue_type_shift",
          "normalized": "Omega Z-\u003e(ResidueType,Int)",
          "package": "newsynth",
          "signature": "Omega Z-\u003e(ResidueType,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:residue_type_shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a single row operation as in Lemma 4, applied to rows \u003cem\u003ei\u003c/em\u003e\n and \u003cem\u003ej\u003c/em\u003e.  The entries at rows \u003cem\u003ei\u003c/em\u003e and \u003cem\u003ej\u003c/em\u003e are \u003cem\u003ex\u003c/em\u003e and \u003cem\u003ey\u003c/em\u003e,\n respectively, with respective residues \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e. A precondition\n is that \u003cem\u003ex\u003c/em\u003e and \u003cem\u003ey\u003c/em\u003e are of the same residue type. Returns a list of\n two-level operations that decreases the denominator exponent.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "row_step",
          "package": "newsynth",
          "signature": "((Index, Omega Z2, ZOmega), (Index, Omega Z2, ZOmega)) -\u003e [TwoLevel]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#row_step",
          "type": "function"
        },
        "index": {
          "description": "Perform single row operation as in Lemma applied to rows and The entries at rows and are and respectively with respective residues and precondition is that and are of the same residue type Returns list of two-level operations that decreases the denominator exponent",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "row_step",
          "normalized": "((Index,Omega Z,ZOmega),(Index,Omega Z,ZOmega))-\u003e[TwoLevel]",
          "package": "newsynth",
          "signature": "((Index,Omega Z,ZOmega),(Index,Omega Z,ZOmega))-\u003e[TwoLevel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:row_step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a single row operation as in Lemma 4, applied to rows \u003cem\u003ei\u003c/em\u003e\n and \u003cem\u003ej\u003c/em\u003e, using the generators of Section 6.  The entries at rows\n \u003cem\u003ei\u003c/em\u003e and \u003cem\u003ej\u003c/em\u003e are \u003cem\u003ex\u003c/em\u003e and \u003cem\u003ey\u003c/em\u003e, respectively, with respective residues\n \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e. A precondition is that \u003cem\u003ex\u003c/em\u003e and \u003cem\u003ey\u003c/em\u003e are of the same\n residue type. Returns a list of two-level operations that decreases\n the denominator exponent.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "row_step_alt",
          "package": "newsynth",
          "signature": "((Index, Omega Z2, ZOmega), (Index, Omega Z2, ZOmega)) -\u003e [TwoLevelAlt]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#row_step_alt",
          "type": "function"
        },
        "index": {
          "description": "Perform single row operation as in Lemma applied to rows and using the generators of Section The entries at rows and are and respectively with respective residues and precondition is that and are of the same residue type Returns list of two-level operations that decreases the denominator exponent",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "row_step_alt",
          "normalized": "((Index,Omega Z,ZOmega),(Index,Omega Z,ZOmega))-\u003e[TwoLevelAlt]",
          "package": "newsynth",
          "signature": "((Index,Omega Z,ZOmega),(Index,Omega Z,ZOmega))-\u003e[TwoLevelAlt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:row_step_alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput an exact \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e unitary operator with coefficients in\n \u003cb\u003eD\u003c/b\u003e[&#969;], and output an equivalent sequence of two-level\n operators.  This is the algorithm from the Giles-Selinger paper. It\n has superexponential complexity.\n\u003c/p\u003e\u003cp\u003eNote: the list of \u003ccode\u003e\u003ca\u003eTwoLevel\u003c/a\u003e\u003c/code\u003e operators will be returned in\n right-to-left order, i.e., as in the mathematical notation for\n matrix multiplication. This is the opposite of the quantum circuit\n notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "synthesis_nqubit",
          "package": "newsynth",
          "signature": "Matrix n n DOmega -\u003e [TwoLevel]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#synthesis_nqubit",
          "type": "function"
        },
        "index": {
          "description": "Input an exact unitary operator with coefficients in and output an equivalent sequence of two-level operators This is the algorithm from the Giles-Selinger paper It has superexponential complexity Note the list of TwoLevel operators will be returned in right-to-left order i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "synthesis_nqubit",
          "normalized": "Matrix a a DOmega-\u003e[TwoLevel]",
          "package": "newsynth",
          "signature": "Matrix n n DOmega-\u003e[TwoLevel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:synthesis_nqubit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput an exact \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e unitary operator with coefficients in\n \u003cb\u003eD\u003c/b\u003e[&#969;], and output an equivalent sequence of two-level\n operators (in the alternative generators, where all but at most one\n of the generators has determinant 1).  This is the algorithm from\n the Giles-Selinger paper, Section 6. It has superexponential\n complexity.\n\u003c/p\u003e\u003cp\u003eNote: the list of \u003ccode\u003e\u003ca\u003eTwoLevelAlt\u003c/a\u003e\u003c/code\u003e operators will be returned in\n right-to-left order, i.e., as in the mathematical notation for\n matrix multiplication. This is the opposite of the quantum circuit\n notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "synthesis_nqubit_alt",
          "package": "newsynth",
          "signature": "Matrix n n DOmega -\u003e [TwoLevelAlt]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#synthesis_nqubit_alt",
          "type": "function"
        },
        "index": {
          "description": "Input an exact unitary operator with coefficients in and output an equivalent sequence of two-level operators in the alternative generators where all but at most one of the generators has determinant This is the algorithm from the Giles-Selinger paper Section It has superexponential complexity Note the list of TwoLevelAlt operators will be returned in right-to-left order i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "synthesis_nqubit_alt",
          "normalized": "Matrix a a DOmega-\u003e[TwoLevelAlt]",
          "package": "newsynth",
          "signature": "Matrix n n DOmega-\u003e[TwoLevelAlt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:synthesis_nqubit_alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a unary operator to element \u003cem\u003ei\u003c/em\u003e of a list.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "transform_at",
          "package": "newsynth",
          "signature": "(a -\u003e a) -\u003e Index -\u003e [a] -\u003e [a]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#transform_at",
          "type": "function"
        },
        "index": {
          "description": "Apply unary operator to element of list",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "transform_at",
          "normalized": "(a-\u003ea)-\u003eIndex-\u003e[a]-\u003e[a]",
          "package": "newsynth",
          "signature": "(a-\u003ea)-\u003eIndex-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:transform_at"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a binary operator to elements \u003cem\u003ei\u003c/em\u003e and \u003cem\u003ej\u003c/em\u003e of a list.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "transform_at2",
          "package": "newsynth",
          "signature": "((a, a) -\u003e (a, a)) -\u003e Index -\u003e Index -\u003e [a] -\u003e [a]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#transform_at2",
          "type": "function"
        },
        "index": {
          "description": "Apply binary operator to elements and of list",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "transform_at2",
          "normalized": "((a,a)-\u003e(a,a))-\u003eIndex-\u003eIndex-\u003e[a]-\u003e[a]",
          "package": "newsynth",
          "signature": "((a,a)-\u003e(a,a))-\u003eIndex-\u003eIndex-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:transform_at2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a two-level matrix with the given entries.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "twolevel_matrix",
          "package": "newsynth",
          "signature": "(a, a) -\u003e (a, a) -\u003e Index -\u003e Index -\u003e Matrix n n a",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#twolevel_matrix",
          "type": "function"
        },
        "index": {
          "description": "Construct two-level matrix with the given entries",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "twolevel_matrix",
          "normalized": "(a,a)-\u003e(a,a)-\u003eIndex-\u003eIndex-\u003eMatrix b b a",
          "package": "newsynth",
          "signature": "(a,a)-\u003e(a,a)-\u003eIndex-\u003eIndex-\u003eMatrix n n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:twolevel_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the alternate generators to the original generators.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "twolevels_of_twolevelalts",
          "package": "newsynth",
          "signature": "[TwoLevelAlt] -\u003e [TwoLevel]",
          "source": "src/Quantum-Synthesis-MultiQubitSynthesis.html#twolevels_of_twolevelalts",
          "type": "function"
        },
        "index": {
          "description": "Convert from the alternate generators to the original generators",
          "hierarchy": "Quantum Synthesis MultiQubitSynthesis",
          "module": "Quantum.Synthesis.MultiQubitSynthesis",
          "name": "twolevels_of_twolevelalts",
          "normalized": "[TwoLevelAlt]-\u003e[TwoLevel]",
          "package": "newsynth",
          "signature": "[TwoLevelAlt]-\u003e[TwoLevel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-MultiQubitSynthesis.html#v:twolevels_of_twolevelalts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements an efficient single-qubit Clifford+\u003cem\u003eT\u003c/em\u003e\n approximation algorithm. The algorithm is described here:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Peter Selinger. Efficient Clifford+\u003cem\u003eT\u003c/em\u003e approximation of\n single-qubit operators. \u003ca\u003ehttp://arxiv.org/abs/1212.6253\u003c/a\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "Newsynth",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Newsynth.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements an efficient single-qubit Clifford approximation algorithm The algorithm is described here Peter Selinger Efficient Clifford approximation of single-qubit operators http arxiv.org abs",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "Newsynth",
          "package": "newsynth",
          "partial": "Newsynth",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput &#958; &#8712; &#8484;[&#8730;2] such that &#958; &#8805; 0, &#958;\u003csup\u003e&#8226;\u003c/sup\u003e &#8805; 0, and \u003cem\u003ep\u003c/em\u003e = \n &#958;\u003csup\u003e&#8226;\u003c/sup\u003e&#958; is a prime &#8801; 1 (mod 4) in &#8484;. Output \u003cem\u003et\u003c/em\u003e &#8712; &#8484;[&#969;] such that\n \u003cem\u003et\u003c/em\u003e\u003csup\u003e&#8224;\u003c/sup\u003e\u003cem\u003et\u003c/em\u003e = &#958;. If the hypotheses are not satisfied, this will\n likely loop forever.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "dioph",
          "package": "newsynth",
          "signature": "ZRootTwo -\u003e g -\u003e ZOmega",
          "source": "src/Quantum-Synthesis-Newsynth.html#dioph",
          "type": "function"
        },
        "index": {
          "description": "Input such that and is prime mod in Output such that If the hypotheses are not satisfied this will likely loop forever",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "dioph",
          "normalized": "ZRootTwo-\u003ea-\u003eZOmega",
          "package": "newsynth",
          "signature": "ZRootTwo-\u003eg-\u003eZOmega",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:dioph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput &#958; &#8712; &#8484;[&#8730;2], and maybe output some \u003cem\u003et\u003c/em\u003e &#8712; &#8484;[&#969;] such that \n \u003cem\u003et\u003c/em\u003e\u003csup\u003e&#8224;\u003c/sup\u003e\u003cem\u003et\u003c/em\u003e = &#958;. If &#958; &#8805; 0, &#958;\u003csup\u003e&#8226;\u003c/sup\u003e &#8805; 0 and \u003cem\u003ep\u003c/em\u003e = &#958;\u003csup\u003e&#8226;\u003c/sup\u003e&#958; is a\n prime &#8801; 1 (mod 4) in &#8484;, then this succeeds with probability at least\n 1/2.  Otherwise, the success probability is unspecified and may be\n 0.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "dioph_step",
          "package": "newsynth",
          "signature": "ZRootTwo -\u003e g -\u003e Maybe ZOmega",
          "source": "src/Quantum-Synthesis-Newsynth.html#dioph_step",
          "type": "function"
        },
        "index": {
          "description": "Input and maybe output some such that If and is prime mod in then this succeeds with probability at least Otherwise the success probability is unspecified and may be",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "dioph_step",
          "normalized": "ZRootTwo-\u003ea-\u003eMaybe ZOmega",
          "package": "newsynth",
          "signature": "ZRootTwo-\u003eg-\u003eMaybe ZOmega",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:dioph_step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA useful operation for the \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e monad, used to ensure that\n some condition holds (i.e., return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the condition is\n false). To be used like this:\n\u003c/p\u003e\u003cpre\u003e do\n   x \u003c- something\n   y \u003c- something_else\n   ensure (x \u003e y)\n   ...\n\u003c/pre\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "ensure",
          "package": "newsynth",
          "signature": "Bool -\u003e Maybe ()",
          "source": "src/Quantum-Synthesis-Newsynth.html#ensure",
          "type": "function"
        },
        "index": {
          "description": "useful operation for the Maybe monad used to ensure that some condition holds i.e return Nothing if the condition is false To be used like this do something something else ensure",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "ensure",
          "normalized": "Bool-\u003eMaybe()",
          "package": "newsynth",
          "signature": "Bool-\u003eMaybe()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:ensure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven positive numbers \u003cem\u003eb\u003c/em\u003e and \u003cem\u003ex\u003c/em\u003e, return (\u003cem\u003en\u003c/em\u003e, \u003cem\u003er\u003c/em\u003e) such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003cem\u003ex\u003c/em\u003e = \u003cem\u003er\u003c/em\u003e \u003cem\u003eb\u003c/em\u003e\u003csup\u003e\u003cem\u003en\u003c/em\u003e\u003c/sup\u003e and                           \n\u003c/li\u003e\u003cli\u003e 1 &#8804; \u003cem\u003er\u003c/em\u003e \u003c \u003cem\u003eb\u003c/em\u003e.                                  \n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn other words, let \u003cem\u003en\u003c/em\u003e = &#8970;log\u003csub\u003e\u003cem\u003eb\u003c/em\u003e\u003c/sub\u003e \u003cem\u003ex\u003c/em\u003e&#8971; and \n \u003cem\u003er\u003c/em\u003e = \u003cem\u003ex\u003c/em\u003e \u003cem\u003eb\u003c/em\u003e\u003csup\u003e&#8722;\u003cem\u003en\u003c/em\u003e\u003c/sup\u003e. This can be more efficient than \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e\n (\u003ccode\u003e\u003ca\u003elogBase\u003c/a\u003e\u003c/code\u003e \u003cem\u003eb\u003c/em\u003e \u003cem\u003ex\u003c/em\u003e) depending on the type; moreover, it also works\n for exact types such as \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eQRootTwo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "floorlog",
          "package": "newsynth",
          "signature": "b -\u003e b -\u003e (Integer, b)",
          "source": "src/Quantum-Synthesis-Newsynth.html#floorlog",
          "type": "function"
        },
        "index": {
          "description": "Given positive numbers and return such that and In other words let log and This can be more efficient than floor logBase depending on the type moreover it also works for exact types such as Rational and QRootTwo",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "floorlog",
          "normalized": "a-\u003ea-\u003e(Integer,a)",
          "package": "newsynth",
          "signature": "b-\u003eb-\u003e(Integer,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:floorlog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput two intervals [\u003cem\u003ex\u003c/em\u003e&#8320;, \u003cem\u003ex\u003c/em\u003e&#8321;] &#8838; &#8477; and [\u003cem\u003ey\u003c/em\u003e&#8320;, \u003cem\u003ey\u003c/em\u003e&#8321;] &#8838; &#8477; and a\n source of randomness. Output a random element \u003cem\u003ez\u003c/em\u003e = \u003cem\u003ea\u003c/em\u003e + &#8730;2\u003cem\u003eb\u003c/em\u003e\n &#8712; &#8484;[&#8730;2] such that \u003cem\u003ez\u003c/em\u003e &#8712; [\u003cem\u003ex\u003c/em\u003e&#8320;, \u003cem\u003ex\u003c/em\u003e&#8321;] and \u003cem\u003ez\u003c/em\u003e\u003csup\u003e&#8226;\u003c/sup\u003e &#8712; [\u003cem\u003ey\u003c/em\u003e&#8320;,\n \u003cem\u003ey\u003c/em\u003e&#8321;]. \n\u003c/p\u003e\u003cp\u003eNote: the randomness will not be uniform. To ensure that the set of\n solutions is non-empty, we must have &#916;x&#916;y &#8805; (1 + &#8730;2)&#178;, where &#916;x =\n \u003cem\u003ex\u003c/em\u003e&#8321; &#8722; \u003cem\u003ex\u003c/em\u003e&#8320; &#8805; 0 and &#916;y = \u003cem\u003ey\u003c/em\u003e&#8321; &#8722; \u003cem\u003ey\u003c/em\u003e&#8320; &#8805; 0. If there are no solutions\n at all, the function will return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function is formulated so that the intervals can be specified\n exactly (using a type such as \u003ccode\u003e\u003ca\u003eQRootTwo\u003c/a\u003e\u003c/code\u003e), or approximately (using a\n type such as \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003eFixedPrec\u003c/code\u003e \u003cem\u003ee\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "gridpoint_random",
          "package": "newsynth",
          "signature": "(r, r) -\u003e (r, r) -\u003e g -\u003e Maybe ZRootTwo",
          "source": "src/Quantum-Synthesis-Newsynth.html#gridpoint_random",
          "type": "function"
        },
        "index": {
          "description": "Input two intervals and and source of randomness Output random element such that and Note the randomness will not be uniform To ensure that the set of solutions is non-empty we must have where and If there are no solutions at all the function will return Nothing This function is formulated so that the intervals can be specified exactly using type such as QRootTwo or approximately using type such as Double or FixedPrec",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "gridpoint_random",
          "normalized": "(a,a)-\u003e(a,a)-\u003eb-\u003eMaybe ZRootTwo",
          "package": "newsynth",
          "signature": "(r,r)-\u003e(r,r)-\u003eg-\u003eMaybe ZRootTwo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:gridpoint_random"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput an integer \u003cem\u003ee\u003c/em\u003e, two intervals [\u003cem\u003ex\u003c/em\u003e&#8320;, \u003cem\u003ex\u003c/em\u003e&#8321;] &#8838; &#8477; and [\u003cem\u003ey\u003c/em\u003e&#8320;,\n \u003cem\u003ey\u003c/em\u003e&#8321;] &#8838; &#8477;, and a source of randomness. Output random \u003cem\u003ez\u003c/em\u003e = \u003cem\u003ea\u003c/em\u003e +\n &#8730;2\u003cem\u003eb\u003c/em\u003e &#8712; &#8484;[&#8730;2] such that \u003cem\u003ea\u003c/em\u003e + &#8730;2\u003cem\u003eb\u003c/em\u003e &#8712; [\u003cem\u003ex\u003c/em\u003e&#8320;, \u003cem\u003ex\u003c/em\u003e&#8321;], \u003cem\u003ea\u003c/em\u003e - &#8730;2\u003cem\u003eb\u003c/em\u003e &#8712;\n [\u003cem\u003ey\u003c/em\u003e&#8320;, \u003cem\u003ey\u003c/em\u003e&#8321;], and \u003cem\u003ea\u003c/em\u003e-\u003cem\u003ee\u003c/em\u003e is even.\n\u003c/p\u003e\u003cp\u003eNote: the randomness will not be uniform. To ensure that the set of\n solutions is non-empty, we must have &#916;x&#916;y &#8805; 2(&#8730;2 + 1)&#178;, where &#916;x =\n \u003cem\u003ex\u003c/em\u003e&#8321; &#8722; \u003cem\u003ex\u003c/em\u003e&#8320; &#8805; 0 and &#916;y = \u003cem\u003ey\u003c/em\u003e&#8321; &#8722; \u003cem\u003ey\u003c/em\u003e&#8320; &#8805; 0. If there are no solutions\n at all, the function will return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function is formulated so that the intervals can be specified\n exactly (using a type such as \u003ccode\u003e\u003ca\u003eQRootTwo\u003c/a\u003e\u003c/code\u003e), or approximately (using a\n type such as \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003eFixedPrec\u003c/code\u003e \u003cem\u003ee\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "gridpoint_random_parity",
          "package": "newsynth",
          "signature": "Integer -\u003e (r, r) -\u003e (r, r) -\u003e g -\u003e Maybe ZRootTwo",
          "source": "src/Quantum-Synthesis-Newsynth.html#gridpoint_random_parity",
          "type": "function"
        },
        "index": {
          "description": "Input an integer two intervals and and source of randomness Output random such that and is even Note the randomness will not be uniform To ensure that the set of solutions is non-empty we must have where and If there are no solutions at all the function will return Nothing This function is formulated so that the intervals can be specified exactly using type such as QRootTwo or approximately using type such as Double or FixedPrec",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "gridpoint_random_parity",
          "normalized": "Integer-\u003e(a,a)-\u003e(a,a)-\u003eb-\u003eMaybe ZRootTwo",
          "package": "newsynth",
          "signature": "Integer-\u003e(r,r)-\u003e(r,r)-\u003eg-\u003eMaybe ZRootTwo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:gridpoint_random_parity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput two intervals [\u003cem\u003ex\u003c/em\u003e&#8320;, \u003cem\u003ex\u003c/em\u003e&#8321;] &#8838; &#8477; and [\u003cem\u003ey\u003c/em\u003e&#8320;, \u003cem\u003ey\u003c/em\u003e&#8321;] &#8838; &#8477;. Output\n a list of all points \u003cem\u003ez\u003c/em\u003e = \u003cem\u003ea\u003c/em\u003e + &#8730;2\u003cem\u003eb\u003c/em\u003e &#8712; &#8484;[&#8730;2] such that \u003cem\u003ez\u003c/em\u003e &#8712;\n [\u003cem\u003ex\u003c/em\u003e&#8320;, \u003cem\u003ex\u003c/em\u003e&#8321;] and \u003cem\u003ez\u003c/em\u003e\u003csup\u003e&#8226;\u003c/sup\u003e &#8712; [\u003cem\u003ey\u003c/em\u003e&#8320;, \u003cem\u003ey\u003c/em\u003e&#8321;]. The list will be\n produced lazily, and will be sorted in order of increasing \u003cem\u003ez\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eIt is a theorem that there will be at least one solution if &#916;x&#916;y &#8805; (1\n + &#8730;2)&#178;, and at most one solution if &#916;x&#916;y \u003c 1, where &#916;x = \u003cem\u003ex\u003c/em\u003e&#8321; &#8722; \u003cem\u003ex\u003c/em\u003e&#8320; &#8805; 0\n and &#916;y = \u003cem\u003ey\u003c/em\u003e&#8321; &#8722; \u003cem\u003ey\u003c/em\u003e&#8320; &#8805; 0. Asymptotically, the expected number of\n solutions is &#916;x&#916;y/&#8730;8.\n\u003c/p\u003e\u003cp\u003eThis function is formulated so that the intervals can be specified\n exactly (using a type such as \u003ccode\u003e\u003ca\u003eQRootTwo\u003c/a\u003e\u003c/code\u003e), or approximately (using a\n type such as \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003eFixedPrec\u003c/code\u003e \u003cem\u003ee\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "gridpoints",
          "package": "newsynth",
          "signature": "(r, r) -\u003e (r, r) -\u003e [ZRootTwo]",
          "source": "src/Quantum-Synthesis-Newsynth.html#gridpoints",
          "type": "function"
        },
        "index": {
          "description": "Input two intervals and Output list of all points such that and The list will be produced lazily and will be sorted in order of increasing It is theorem that there will be at least one solution if and at most one solution if where and Asymptotically the expected number of solutions is This function is formulated so that the intervals can be specified exactly using type such as QRootTwo or approximately using type such as Double or FixedPrec",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "gridpoints",
          "normalized": "(a,a)-\u003e(a,a)-\u003e[ZRootTwo]",
          "package": "newsynth",
          "signature": "(r,r)-\u003e(r,r)-\u003e[ZRootTwo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:gridpoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA combinator for turning a probabilistic function that succeeds\n with some small probability into a probabilistic function that\n always succeeds, by trying again and again.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "keeptrying",
          "package": "newsynth",
          "signature": "(g -\u003e Maybe a) -\u003e g -\u003e a",
          "source": "src/Quantum-Synthesis-Newsynth.html#keeptrying",
          "type": "function"
        },
        "index": {
          "description": "combinator for turning probabilistic function that succeeds with some small probability into probabilistic function that always succeeds by trying again and again",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "keeptrying",
          "normalized": "(a-\u003eMaybe b)-\u003ea-\u003eb",
          "package": "newsynth",
          "signature": "(g-\u003eMaybe a)-\u003eg-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:keeptrying"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ekeeptrying\u003c/a\u003e\u003c/code\u003e, but also returns a count of the number of attempts.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "keeptrying_count",
          "package": "newsynth",
          "signature": "(g -\u003e Maybe a) -\u003e g -\u003e (a, Integer)",
          "source": "src/Quantum-Synthesis-Newsynth.html#keeptrying_count",
          "type": "function"
        },
        "index": {
          "description": "Like keeptrying but also returns count of the number of attempts",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "keeptrying_count",
          "normalized": "(a-\u003eMaybe b)-\u003ea-\u003e(b,Integer)",
          "package": "newsynth",
          "signature": "(g-\u003eMaybe a)-\u003eg-\u003e(a,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:keeptrying_count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the head of a list, if non-empty, or else \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "maybe_head",
          "package": "newsynth",
          "signature": "[a] -\u003e Maybe a",
          "source": "src/Quantum-Synthesis-Newsynth.html#maybe_head",
          "type": "function"
        },
        "index": {
          "description": "Return the head of list if non-empty or else Nothing",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "maybe_head",
          "normalized": "[a]-\u003eMaybe a",
          "package": "newsynth",
          "signature": "[a]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:maybe_head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA user-friendly interface to the approximate synthesis\n algorithm. The parameters are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e an angle &#952;, to implement a \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#952;) = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e&#8722;\u003cem\u003ei\u003c/em\u003e&#952;\u003cem\u003eZ\u003c/em\u003e/2\u003c/sup\u003e\n gate;\n\u003c/li\u003e\u003cli\u003e a precision \u003cem\u003eb\u003c/em\u003e &#8805; 0 in bits, such that &#949; = 2\u003csup\u003e-\u003cem\u003eb\u003c/em\u003e\u003c/sup\u003e;\n\u003c/li\u003e\u003cli\u003e a source of randomness \u003cem\u003eg\u003c/em\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOutput a unitary operator in the Clifford+\u003cem\u003eT\u003c/em\u003e group that\n approximates \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#952;) to within &#949; in the operator norm. This\n operator can then be converted to a list of gates with\n \u003ccode\u003e\u003ca\u003eto_gates\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis implementation does not use seeding.\n\u003c/p\u003e\u003cp\u003eNote: the argument \u003cem\u003etheta\u003c/em\u003e is given as a symbolic real number. It\n will automatically be expanded to as many digits as are necessary\n for the internal calculation. In this way, the caller can specify,\n e.g., an angle of \u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e/128 \u003ccode\u003e::\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSymReal\u003c/a\u003e\u003c/code\u003e, without having to worry\n about how many digits of &#960; to specify.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth",
          "package": "newsynth",
          "signature": "Double -\u003e SymReal -\u003e g -\u003e U2 DOmega",
          "source": "src/Quantum-Synthesis-Newsynth.html#newsynth",
          "type": "function"
        },
        "index": {
          "description": "user-friendly interface to the approximate synthesis algorithm The parameters are an angle to implement gate precision in bits such that source of randomness Output unitary operator in the Clifford group that approximates to within in the operator norm This operator can then be converted to list of gates with to gates This implementation does not use seeding Note the argument theta is given as symbolic real number It will automatically be expanded to as many digits as are necessary for the internal calculation In this way the caller can specify e.g an angle of pi SymReal without having to worry about how many digits of to specify",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth",
          "normalized": "Double-\u003eSymReal-\u003ea-\u003eU DOmega",
          "package": "newsynth",
          "signature": "Double-\u003eSymReal-\u003eg-\u003eU DOmega",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:newsynth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003enewsynth\u003c/a\u003e\u003c/code\u003e that returns a list of gates instead of a\n matrix. The inputs are the same as for \u003ccode\u003e\u003ca\u003enewsynth\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: the list of gates will be returned in right-to-left order,\n i.e., as in the mathematical notation for matrix multiplication.\n This is the opposite of the quantum circuit notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth_gates",
          "package": "newsynth",
          "signature": "Double -\u003e SymReal -\u003e g -\u003e [Gate]",
          "source": "src/Quantum-Synthesis-Newsynth.html#newsynth_gates",
          "type": "function"
        },
        "index": {
          "description": "version of newsynth that returns list of gates instead of matrix The inputs are the same as for newsynth Note the list of gates will be returned in right-to-left order i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth_gates",
          "normalized": "Double-\u003eSymReal-\u003ea-\u003e[Gate]",
          "package": "newsynth",
          "signature": "Double-\u003eSymReal-\u003eg-\u003e[Gate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:newsynth_gates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003enewsynth\u003c/a\u003e\u003c/code\u003e that also returns some statistics:\n log\u003csub\u003e0.1\u003c/sub\u003e of the actual approximation error (or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the\n error is 0), and the number of candidates tried.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth_stats",
          "package": "newsynth",
          "signature": "Double -\u003e SymReal -\u003e g -\u003e (U2 DOmega, Maybe Double, Integer)",
          "source": "src/Quantum-Synthesis-Newsynth.html#newsynth_stats",
          "type": "function"
        },
        "index": {
          "description": "version of newsynth that also returns some statistics log of the actual approximation error or Nothing if the error is and the number of candidates tried",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth_stats",
          "normalized": "Double-\u003eSymReal-\u003ea-\u003e(U DOmega,Maybe Double,Integer)",
          "package": "newsynth",
          "signature": "Double-\u003eSymReal-\u003eg-\u003e(U DOmega,Maybe Double,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:newsynth_stats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe internal implementation of the approximate synthesis\n algorithm. The parameters are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e an angle &#952;, to implement a \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#952;) = \u003ci\u003ee\u003c/i\u003e\u003csup\u003e&#8722;\u003cem\u003ei\u003c/em\u003e&#952;\u003cem\u003eZ\u003c/em\u003e/2\u003c/sup\u003e\n gate;\n\u003c/li\u003e\u003cli\u003e a precision \u003cem\u003ep\u003c/em\u003e &#8805; 0 in bits, such that &#949; = 2\u003csup\u003e-\u003cem\u003ep\u003c/em\u003e\u003c/sup\u003e;\n\u003c/li\u003e\u003cli\u003e a source of randomness \u003cem\u003eg\u003c/em\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWith some probability, output a unitary operator in the\n Clifford+\u003cem\u003eT\u003c/em\u003e group that approximates \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#952;) to within &#949; in\n the operator norm. This operator can then be converted to a list of\n gates with \u003ccode\u003e\u003ca\u003eto_gates\u003c/a\u003e\u003c/code\u003e. Also output log\u003csub\u003e0.1\u003c/sub\u003e of the actual\n error, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the error is 0.\n\u003c/p\u003e\u003cp\u003eThis implementation does not use seeding.\n\u003c/p\u003e\u003cp\u003eAs a special case, if the \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#952;) is a Clifford operator\n (to within the given &#949;), always return this operator directly.\n\u003c/p\u003e\u003cp\u003eNote: the parameter &#952; must be of a real number type that has enough\n precision to perform intermediate calculations; this typically\n requires precision O(&#949;\u003csup\u003e2\u003c/sup\u003e).  A more user-friendly function that\n does this automatically is \u003ccode\u003e\u003ca\u003enewsynth\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth_step",
          "package": "newsynth",
          "signature": "r -\u003e r -\u003e g -\u003e Maybe (U2 DOmega, Maybe Double)",
          "source": "src/Quantum-Synthesis-Newsynth.html#newsynth_step",
          "type": "function"
        },
        "index": {
          "description": "The internal implementation of the approximate synthesis algorithm The parameters are an angle to implement gate precision in bits such that source of randomness With some probability output unitary operator in the Clifford group that approximates to within in the operator norm This operator can then be converted to list of gates with to gates Also output log of the actual error or Nothing if the error is This implementation does not use seeding As special case if the is Clifford operator to within the given always return this operator directly Note the parameter must be of real number type that has enough precision to perform intermediate calculations this typically requires precision more user-friendly function that does this automatically is newsynth",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "newsynth_step",
          "normalized": "a-\u003ea-\u003eb-\u003eMaybe(U DOmega,Maybe Double)",
          "package": "newsynth",
          "signature": "r-\u003er-\u003eg-\u003eMaybe(U DOmega,Maybe Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:newsynth_step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponentiation via repeated squaring, parameterized by a\n multiplication function and a unit. Given an associative\n multiplication function \u003ccode\u003e*\u003c/code\u003e with unit \u003ccode\u003ee\u003c/code\u003e, the function \u003ccode\u003e\u003ca\u003epower\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e(*)\u003c/code\u003e \u003cem\u003ee\u003c/em\u003e \u003cem\u003ea\u003c/em\u003e \u003cem\u003en\u003c/em\u003e efficiently computes \u003cem\u003ea\u003c/em\u003e\u003csup\u003e\u003cem\u003en\u003c/em\u003e\u003c/sup\u003e = \u003cem\u003ea\u003c/em\u003e \u003ccode\u003e*\u003c/code\u003e (\u003cem\u003ea\u003c/em\u003e\n \u003ccode\u003e*\u003c/code\u003e (&#8230; \u003ccode\u003e*\u003c/code\u003e (\u003cem\u003ea\u003c/em\u003e \u003ccode\u003e*\u003c/code\u003e \u003cem\u003ee\u003c/em\u003e)&#8230;)).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "power",
          "package": "newsynth",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e Integer -\u003e a",
          "source": "src/Quantum-Synthesis-Newsynth.html#power",
          "type": "function"
        },
        "index": {
          "description": "Exponentiation via repeated squaring parameterized by multiplication function and unit Given an associative multiplication function with unit the function power efficiently computes",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "power",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eInteger-\u003ea",
          "package": "newsynth",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eInteger-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput a positive prime \u003cem\u003ep\u003c/em\u003e &#8801; 1 (mod 4), and output a root of &#8722;1.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "root_minus_one",
          "package": "newsynth",
          "signature": "Integer -\u003e g -\u003e Integer",
          "source": "src/Quantum-Synthesis-Newsynth.html#root_minus_one",
          "type": "function"
        },
        "index": {
          "description": "Input positive prime mod and output root of",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "root_minus_one",
          "normalized": "Integer-\u003ea-\u003eInteger",
          "package": "newsynth",
          "signature": "Integer-\u003eg-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:root_minus_one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInput an integer \u003cem\u003ep\u003c/em\u003e, and maybe output a root of &#8722;1 modulo \u003cem\u003ep\u003c/em\u003e.\n This succeeds with probability at least 1/2 if \u003cem\u003ep\u003c/em\u003e is a positive\n prime &#8801; 1 (mod 4); otherwise, the success probability is\n unspecified (and may be 0).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "root_minus_one_step",
          "package": "newsynth",
          "signature": "Integer -\u003e g -\u003e Maybe Integer",
          "source": "src/Quantum-Synthesis-Newsynth.html#root_minus_one_step",
          "type": "function"
        },
        "index": {
          "description": "Input an integer and maybe output root of modulo This succeeds with probability at least if is positive prime mod otherwise the success probability is unspecified and may be",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "root_minus_one_step",
          "normalized": "Integer-\u003ea-\u003eMaybe Integer",
          "package": "newsynth",
          "signature": "Integer-\u003eg-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:root_minus_one_step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA combinator for turning a probabilistic function that succeeds\n with some small probability into a probabilistic function that\n succeeds with a higher probability, by repeating it \u003cem\u003en\u003c/em\u003e times. \n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "try_for",
          "package": "newsynth",
          "signature": "Integer -\u003e (g -\u003e Maybe a) -\u003e g -\u003e Maybe a",
          "source": "src/Quantum-Synthesis-Newsynth.html#try_for",
          "type": "function"
        },
        "index": {
          "description": "combinator for turning probabilistic function that succeeds with some small probability into probabilistic function that succeeds with higher probability by repeating it times",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "try_for",
          "normalized": "Integer-\u003e(a-\u003eMaybe b)-\u003ea-\u003eMaybe b",
          "package": "newsynth",
          "signature": "Integer-\u003e(g-\u003eMaybe a)-\u003eg-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:try_for"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a square root of an element of &#8484;[&#8730;2], if such a square\n root exists, or else \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "zroottwo_root",
          "package": "newsynth",
          "signature": "ZRootTwo -\u003e Maybe ZRootTwo",
          "source": "src/Quantum-Synthesis-Newsynth.html#zroottwo_root",
          "type": "function"
        },
        "index": {
          "description": "Return square root of an element of if such square root exists or else Nothing",
          "hierarchy": "Quantum Synthesis Newsynth",
          "module": "Quantum.Synthesis.Newsynth",
          "name": "zroottwo_root",
          "normalized": "ZRootTwo-\u003eMaybe ZRootTwo",
          "package": "newsynth",
          "signature": "ZRootTwo-\u003eMaybe ZRootTwo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Newsynth.html#v:zroottwo_root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides ring instances for \u003ca\u003eData.Number.FixedPrec\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.Ring.FixedPrec",
          "name": "FixedPrec",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring-FixedPrec.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides ring instances for Data.Number.FixedPrec",
          "hierarchy": "Quantum Synthesis Ring FixedPrec",
          "module": "Quantum.Synthesis.Ring.FixedPrec",
          "name": "FixedPrec",
          "package": "newsynth",
          "partial": "Fixed Prec",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring-FixedPrec.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides ring instances for \u003ca\u003eQuantum.Synthesis.SymReal\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.Ring.SymReal",
          "name": "SymReal",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring-SymReal.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides ring instances for Quantum.Synthesis.SymReal",
          "hierarchy": "Quantum Synthesis Ring SymReal",
          "module": "Quantum.Synthesis.Ring.SymReal",
          "name": "SymReal",
          "package": "newsynth",
          "partial": "Sym Real",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring-SymReal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides type classes for rings. It also provides\n several specific instances of rings, such as the ring &#8484;&#8322; of\n integers modulo 2, the ring &#8474; of rational numbers, the ring &#8484;[&#189;] of\n dyadic fractions, the ring &#8484;[\u003cem\u003ei\u003c/em\u003e] of Gaussian integers, the ring\n &#8484;[&#8730;2] of quadratic integers with radix 2, and the ring &#8484;[&#969;] of\n cyclotomic integers of degree 8.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Ring",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides type classes for rings It also provides several specific instances of rings such as the ring of integers modulo the ring of rational numbers the ring of dyadic fractions the ring of Gaussian integers the ring of quadratic integers with radix and the ring of cyclotomic integers of degree",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Ring",
          "package": "newsynth",
          "partial": "Ring",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings with complex conjugation, i.e., an\n automorphism mapping \u003cem\u003ei\u003c/em\u003e to &#8722;\u003cem\u003ei\u003c/em\u003e. \n\u003c/p\u003e\u003cp\u003eWhen instances of this type class are vectors or matrices, the\n conjugation also exchanges the roles of rows and columns (in other\n words, it is the adjoint).\n\u003c/p\u003e\u003cp\u003eFor rings that are not complex, the conjugation can be defined to\n be the identity function.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Adjoint",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Adjoint",
          "type": "class"
        },
        "index": {
          "description": "type class for rings with complex conjugation i.e an automorphism mapping to When instances of this type class are vectors or matrices the conjugation also exchanges the roles of rows and columns in other words it is the adjoint For rings that are not complex the conjugation can be defined to be the identity function",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Adjoint",
          "package": "newsynth",
          "partial": "Adjoint",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Adjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings with a &#8730;2-conjugation, i.e., an\n automorphism mapping &#8730;2 to &#8722;&#8730;2. \n\u003c/p\u003e\u003cp\u003eWhen instances of this type class are vectors or matrices, the\n &#8730;2-conjugation does \u003cem\u003enot\u003c/em\u003e exchange the roles of rows and columns.\n\u003c/p\u003e\u003cp\u003eFor rings that have no &#8730;2, the conjugation can be defined to be the\n identity function.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Adjoint2",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Adjoint2",
          "type": "class"
        },
        "index": {
          "description": "type class for rings with conjugation i.e an automorphism mapping to When instances of this type class are vectors or matrices the conjugation does not exchange the roles of rows and columns For rings that have no the conjugation can be defined to be the identity function",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Adjoint2",
          "package": "newsynth",
          "partial": "Adjoint",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Adjoint2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDouble precision complex floating point numbers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "CDouble",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#CDouble",
          "type": "type"
        },
        "index": {
          "description": "Double precision complex floating point numbers",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "CDouble",
          "package": "newsynth",
          "partial": "CDouble",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:CDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingle precision complex floating point numbers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "CFloat",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#CFloat",
          "type": "type"
        },
        "index": {
          "description": "Single precision complex floating point numbers",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "CFloat",
          "package": "newsynth",
          "partial": "CFloat",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:CFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings that contain a square root of -1.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "ComplexRing",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#ComplexRing",
          "type": "class"
        },
        "index": {
          "description": "type class for rings that contain square root of",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ComplexRing",
          "package": "newsynth",
          "partial": "Complex Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:ComplexRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring \u003cem\u003eR\u003c/em\u003e[\u003cem\u003ei\u003c/em\u003e], where \u003cem\u003eR\u003c/em\u003e is any ring. The reason we do not\n use the \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e \u003cem\u003ea\u003c/em\u003e type from the standard Haskell libraries is\n that it assumes too much, for example, it assumes \u003cem\u003ea\u003c/em\u003e is a member\n of the \u003ccode\u003e\u003ca\u003eRealFloat\u003c/a\u003e\u003c/code\u003e class. Also, this allows us to define a more\n sensible \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Cplx",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Cplx",
          "type": "data"
        },
        "index": {
          "description": "The ring where is any ring The reason we do not use the Complex type from the standard Haskell libraries is that it assumes too much for example it assumes is member of the RealFloat class Also this allows us to define more sensible Show instance",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Cplx",
          "package": "newsynth",
          "partial": "Cplx",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Cplx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring \u003cb\u003eD\u003c/b\u003e[\u003cem\u003ei\u003c/em\u003e] = &#8484;[&#189;, \u003cem\u003ei\u003c/em\u003e] of Gaussian dyadic fractions.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "DComplex",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#DComplex",
          "type": "type"
        },
        "index": {
          "description": "The ring of Gaussian dyadic fractions",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "DComplex",
          "package": "newsynth",
          "partial": "DComplex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:DComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring \u003cb\u003eD\u003c/b\u003e[&#969;]. Here \u003cb\u003eD\u003c/b\u003e=&#8484;[&#189;] is the ring of dyadic\n fractions. In fact, \u003cb\u003eD\u003c/b\u003e[&#969;] is isomorphic to the ring \u003cb\u003eD\u003c/b\u003e[&#8730;2,\n i], but they have different \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "DOmega",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#DOmega",
          "type": "type"
        },
        "index": {
          "description": "The ring Here is the ring of dyadic fractions In fact is isomorphic to the ring but they have different Show instances",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "DOmega",
          "package": "newsynth",
          "partial": "DOmega",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:DOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring \u003cb\u003eD\u003c/b\u003e[&#8730;2, \u003cem\u003ei\u003c/em\u003e] = &#8484;[1/&#8730;2, \u003cem\u003ei\u003c/em\u003e].\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "DRComplex",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#DRComplex",
          "type": "type"
        },
        "index": {
          "description": "The ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "DRComplex",
          "package": "newsynth",
          "partial": "DRComplex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:DRComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring \u003cb\u003eD\u003c/b\u003e[&#8730;2] = &#8484;[1/&#8730;2]. \n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "DRootTwo",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#DRootTwo",
          "type": "type"
        },
        "index": {
          "description": "The ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "DRootTwo",
          "package": "newsynth",
          "partial": "DRoot Two",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:DRootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for things from which a common power of 1/&#8730;2 (a\n least denominator exponent) can be factored out. Typical instances\n are \u003ccode\u003e\u003ca\u003eDRootTwo\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eDRComplex\u003c/a\u003e\u003c/code\u003e, as well as tuples, lists, vectors, and\n matrices thereof.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "DenomExp",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#DenomExp",
          "type": "class"
        },
        "index": {
          "description": "type class for things from which common power of least denominator exponent can be factored out Typical instances are DRootTwo DRComplex as well as tuples lists vectors and matrices thereof",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "DenomExp",
          "package": "newsynth",
          "partial": "Denom Exp",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:DenomExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA dyadic fraction is a rational number whose denominator is a\n power of 2. We denote the dyadic fractions by \u003cb\u003eD\u003c/b\u003e = &#8484;[&#189;].\n\u003c/p\u003e\u003cp\u003eWe internally represent a dyadic fraction \u003cem\u003ea\u003c/em\u003e/2\u003csup\u003e\u003cem\u003en\u003c/em\u003e\u003c/sup\u003e as a pair\n (\u003cem\u003ea\u003c/em\u003e,\u003cem\u003en\u003c/em\u003e). Note that this representation is not unique. When it is\n necessary to choose a canonical representative, we choose the least\n possible \u003cem\u003en\u003c/em\u003e&#8805;0.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Dyadic",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Dyadic",
          "type": "data"
        },
        "index": {
          "description": "dyadic fraction is rational number whose denominator is power of We denote the dyadic fractions by We internally represent dyadic fraction as pair Note that this representation is not unique When it is necessary to choose canonical representative we choose the least possible",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Dyadic",
          "package": "newsynth",
          "partial": "Dyadic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Dyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e functions provided by the standard\n Haskell libraries are predicated on many unnecessary assumptions.\n This type class provides an alternative.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003efloor_of\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eceiling_of\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Floor",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Floor",
          "type": "class"
        },
        "index": {
          "description": "The floor and ceiling functions provided by the standard Haskell libraries are predicated on many unnecessary assumptions This type class provides an alternative Minimal complete definition floor of or ceiling of",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Floor",
          "package": "newsynth",
          "partial": "Floor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Floor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings that contain &#189;.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003ehalf\u003c/a\u003e\u003c/code\u003e. The default definition of\n \u003ccode\u003e\u003ca\u003efromDyadic\u003c/a\u003e\u003c/code\u003e uses the expression \u003ccode\u003ea*half^n\u003c/code\u003e. However, this can give\n potentially bad round-off errors for fixed-precision types where\n the expression \u003ccode\u003ehalf^n\u003c/code\u003e can underflow. For such rings, one should\n provide a custom definition, for example by using \u003ccode\u003ea/2^n\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "HalfRing",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#HalfRing",
          "type": "class"
        },
        "index": {
          "description": "type class for rings that contain Minimal complete definition half The default definition of fromDyadic uses the expression half However this can give potentially bad round-off errors for fixed-precision types where the expression half can underflow For such rings one should provide custom definition for example by using instead",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "HalfRing",
          "package": "newsynth",
          "partial": "Half Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:HalfRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA (number-theoretic) \u003cem\u003enorm\u003c/em\u003e on a ring \u003cem\u003eR\u003c/em\u003e is a function \u003cem\u003eN\u003c/em\u003e : \u003cem\u003eR\u003c/em\u003e\n &#8594; &#8484; such that \u003cem\u003eN\u003c/em\u003e(\u003cem\u003ers\u003c/em\u003e) = \u003cem\u003eN\u003c/em\u003e(\u003cem\u003er\u003c/em\u003e)\u003cem\u003eN\u003c/em\u003e(\u003cem\u003es\u003c/em\u003e), for all \u003cem\u003er\u003c/em\u003e, \u003cem\u003es\u003c/em\u003e &#8712; \u003cem\u003eR\u003c/em\u003e.\n The norm also satisfies \u003cem\u003eN\u003c/em\u003e(\u003cem\u003er\u003c/em\u003e) = 0 iff \u003cem\u003er\u003c/em\u003e = 0, and \u003cem\u003eN\u003c/em\u003e(\u003cem\u003er\u003c/em\u003e) = &#177;1\n iff \u003cem\u003er\u003c/em\u003e is a unit of the ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "NormedRing",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#NormedRing",
          "type": "class"
        },
        "index": {
          "description": "number-theoretic norm on ring is function such that rs for all The norm also satisfies iff and iff is unit of the ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "NormedRing",
          "package": "newsynth",
          "partial": "Normed Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:NormedRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring \u003cem\u003eR\u003c/em\u003e[&#969;], where \u003cem\u003eR\u003c/em\u003e is any ring, and &#969; = \u003ci\u003ee\u003c/i\u003e\u003csup\u003ei&#960;/4\u003c/sup\u003e is an\n 8th root of unity. The value \u003ccode\u003e\u003ca\u003eOmega\u003c/a\u003e\u003c/code\u003e \u003cem\u003ea\u003c/em\u003e \u003cem\u003eb\u003c/em\u003e \u003cem\u003ec\u003c/em\u003e \u003cem\u003ed\u003c/em\u003e represents\n \u003cem\u003ea\u003c/em\u003e&#969;\u003csup\u003e3\u003c/sup\u003e+\u003cem\u003eb\u003c/em\u003e&#969;\u003csup\u003e2\u003c/sup\u003e+\u003cem\u003ec\u003c/em\u003e&#969;+\u003cem\u003ed\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Omega",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Omega",
          "type": "data"
        },
        "index": {
          "description": "The ring where is any ring and is an th root of unity The value Omega represents",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Omega",
          "package": "newsynth",
          "partial": "Omega",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings that contain a square root of \u003cem\u003ei\u003c/em\u003e, or\n equivalently, a fourth root of &#8722;1.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "OmegaRing",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#OmegaRing",
          "type": "class"
        },
        "index": {
          "description": "type class for rings that contain square root of or equivalently fourth root of",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "OmegaRing",
          "package": "newsynth",
          "partial": "Omega Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:OmegaRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for things that have parity.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Parity",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Parity",
          "type": "class"
        },
        "index": {
          "description": "type class for things that have parity",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Parity",
          "package": "newsynth",
          "partial": "Parity",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Parity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring &#8474;[\u003cem\u003ei\u003c/em\u003e] of Gaussian rationals.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "QComplex",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#QComplex",
          "type": "type"
        },
        "index": {
          "description": "The ring of Gaussian rationals",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "QComplex",
          "package": "newsynth",
          "partial": "QComplex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:QComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe field &#8474;[&#969;] of \u003cem\u003ecyclotomic rationals\u003c/em\u003e of degree 8.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "QOmega",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#QOmega",
          "type": "type"
        },
        "index": {
          "description": "The field of cyclotomic rationals of degree",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "QOmega",
          "package": "newsynth",
          "partial": "QOmega",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:QOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe field &#8474;[&#8730;2, \u003cem\u003ei\u003c/em\u003e].\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "QRComplex",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#QRComplex",
          "type": "type"
        },
        "index": {
          "description": "The field",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "QRComplex",
          "package": "newsynth",
          "partial": "QRComplex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:QRComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe field &#8474;[&#8730;2].\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "QRootTwo",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#QRootTwo",
          "type": "type"
        },
        "index": {
          "description": "The field",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "QRootTwo",
          "package": "newsynth",
          "partial": "QRoot Two",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:QRootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe define our own variant of the rational numbers, which is an\n identical copy of the type \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e from the standard Haskell\n library, except that it has a more sensible \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Rationals",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Rationals",
          "type": "newtype"
        },
        "index": {
          "description": "We define our own variant of the rational numbers which is an identical copy of the type Rational from the standard Haskell library except that it has more sensible Show instance",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Rationals",
          "package": "newsynth",
          "partial": "Rationals",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Rationals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings that have a \"real\" component. A typical\n instance is \u003cem\u003ea\u003c/em\u003e = \u003ccode\u003e\u003ca\u003eDRComplex\u003c/a\u003e\u003c/code\u003e with \u003cem\u003eb\u003c/em\u003e = \u003ccode\u003e\u003ca\u003eDRootTwo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "RealPart",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#RealPart",
          "type": "class"
        },
        "index": {
          "description": "type class for rings that have real component typical instance is DRComplex with DRootTwo",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "RealPart",
          "package": "newsynth",
          "partial": "Real Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:RealPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class to denote rings. We make \u003ccode\u003e\u003ca\u003eRing\u003c/a\u003e\u003c/code\u003e a synonym of\n Haskell's \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e type class, so that we can use the usual notation\n \u003ccode\u003e\u003ca\u003e+\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e-\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e for the ring operations.  This is not a perfect fit,\n because Haskell's \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e class also contains two non-ring operations\n \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e.  By convention, for rings where these notions\n don't make sense (or are inconvenient to define), we set \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e \u003cem\u003ex\u003c/em\u003e\n = \u003cem\u003ex\u003c/em\u003e and \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e \u003cem\u003ex\u003c/em\u003e = 1.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Ring",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Ring",
          "type": "class"
        },
        "index": {
          "description": "type class to denote rings We make Ring synonym of Haskell Num type class so that we can use the usual notation for the ring operations This is not perfect fit because Haskell Num class also contains two non-ring operations abs and signum By convention for rings where these notions don make sense or are inconvenient to define we set abs and signum",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Ring",
          "package": "newsynth",
          "partial": "Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Ring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings that contain 1/&#8730;2.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "RootHalfRing",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#RootHalfRing",
          "type": "class"
        },
        "index": {
          "description": "type class for rings that contain",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "RootHalfRing",
          "package": "newsynth",
          "partial": "Root Half Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:RootHalfRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring \u003cem\u003eR\u003c/em\u003e[&#8730;2], where \u003cem\u003eR\u003c/em\u003e is any ring. The value \u003ccode\u003e\u003ca\u003eRootTwo\u003c/a\u003e\u003c/code\u003e \u003cem\u003ea\u003c/em\u003e\n \u003cem\u003eb\u003c/em\u003e represents \u003cem\u003ea\u003c/em\u003e + \u003cem\u003eb\u003c/em\u003e &#8730;2.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "RootTwo",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#RootTwo",
          "type": "data"
        },
        "index": {
          "description": "The ring where is any ring The value RootTwo represents",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "RootTwo",
          "package": "newsynth",
          "partial": "Root Two",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:RootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings that contain &#8730;2.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "RootTwoRing",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#RootTwoRing",
          "type": "class"
        },
        "index": {
          "description": "type class for rings that contain",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "RootTwoRing",
          "package": "newsynth",
          "partial": "Root Two Ring",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:RootTwoRing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class relating \"rational\" types to their dyadic\n counterparts.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "ToDyadic",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#ToDyadic",
          "type": "class"
        },
        "index": {
          "description": "type class relating rational types to their dyadic counterparts",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ToDyadic",
          "package": "newsynth",
          "partial": "To Dyadic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:ToDyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for things that can be exactly converted to &#8474;[&#969;].\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "ToQOmega",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#ToQOmega",
          "type": "class"
        },
        "index": {
          "description": "type class for things that can be exactly converted to",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ToQOmega",
          "package": "newsynth",
          "partial": "To QOmega",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:ToQOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for rings that have a distinguished subring \"of\n integers\". A typical instance is \u003cem\u003ea\u003c/em\u003e = \u003ccode\u003e\u003ca\u003eDRootTwo\u003c/a\u003e\u003c/code\u003e, which has \u003cem\u003eb\u003c/em\u003e =\n \u003ccode\u003e\u003ca\u003eZRootTwo\u003c/a\u003e\u003c/code\u003e as its ring of integers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "WholePart",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#WholePart",
          "type": "class"
        },
        "index": {
          "description": "type class for rings that have distinguished subring of integers typical instance is DRootTwo which has ZRootTwo as its ring of integers",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "WholePart",
          "package": "newsynth",
          "partial": "Whole Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:WholePart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring &#8484;&#8322; of integers modulo 2. \n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "Z2",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#Z2",
          "type": "data"
        },
        "index": {
          "description": "The ring of integers modulo",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Z2",
          "package": "newsynth",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:Z2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring &#8484;[\u003cem\u003ei\u003c/em\u003e] of Gaussian integers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "ZComplex",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#ZComplex",
          "type": "type"
        },
        "index": {
          "description": "The ring of Gaussian integers",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ZComplex",
          "package": "newsynth",
          "partial": "ZComplex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:ZComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring &#8484;[&#969;] of \u003cem\u003ecyclotomic integers\u003c/em\u003e of degree 8. Such rings\n were first studied by Kummer around 1840, and used in his proof of\n special cases of Fermat's Last Theorem.  See also:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ca\u003ehttp://fermatslasttheorem.blogspot.com/2006/05/basic-properties-of-cyclotomic.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://fermatslasttheorem.blogspot.com/2006/02/cyclotomic-integers.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Harold M. Edwards, \"Fermat's Last Theorem: A Genetic\n Introduction to Algebraic Number Theory\".\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "ZOmega",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#ZOmega",
          "type": "type"
        },
        "index": {
          "description": "The ring of cyclotomic integers of degree Such rings were first studied by Kummer around and used in his proof of special cases of Fermat Last Theorem See also http fermatslasttheorem.blogspot.com basic-properties-of-cyclotomic.html http fermatslasttheorem.blogspot.com cyclotomic-integers.html Harold Edwards Fermat Last Theorem Genetic Introduction to Algebraic Number Theory",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ZOmega",
          "package": "newsynth",
          "partial": "ZOmega",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:ZOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe ring &#8484;[&#8730;2].\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "ZRootTwo",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-Ring.html#ZRootTwo",
          "type": "type"
        },
        "index": {
          "description": "The ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ZRootTwo",
          "package": "newsynth",
          "partial": "ZRoot Two",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#t:ZRootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "Cplx",
          "package": "newsynth",
          "signature": "Cplx !a !a",
          "source": "src/Quantum-Synthesis-Ring.html#Cplx",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Cplx",
          "package": "newsynth",
          "partial": "Cplx",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:Cplx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "Dyadic",
          "package": "newsynth",
          "signature": "Dyadic !Integer !Integer",
          "source": "src/Quantum-Synthesis-Ring.html#Dyadic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Dyadic",
          "package": "newsynth",
          "partial": "Dyadic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:Dyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "Even",
          "package": "newsynth",
          "signature": "Even",
          "source": "src/Quantum-Synthesis-Ring.html#Z2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Even",
          "package": "newsynth",
          "partial": "Even",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:Even"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "Odd",
          "package": "newsynth",
          "signature": "Odd",
          "source": "src/Quantum-Synthesis-Ring.html#Z2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Odd",
          "package": "newsynth",
          "partial": "Odd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:Odd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "Omega",
          "package": "newsynth",
          "signature": "Omega !a !a !a !a",
          "source": "src/Quantum-Synthesis-Ring.html#Omega",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "Omega",
          "package": "newsynth",
          "partial": "Omega",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:Omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "RootTwo",
          "package": "newsynth",
          "signature": "RootTwo !a !a",
          "source": "src/Quantum-Synthesis-Ring.html#RootTwo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "RootTwo",
          "package": "newsynth",
          "partial": "Root Two",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:RootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "ToRationals",
          "package": "newsynth",
          "signature": "ToRationals",
          "source": "src/Quantum-Synthesis-Ring.html#Rationals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ToRationals",
          "package": "newsynth",
          "partial": "To Rationals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:ToRationals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the adjoint (complex conjugate transpose).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "adj",
          "package": "newsynth",
          "signature": "a -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#adj",
          "type": "method"
        },
        "index": {
          "description": "Compute the adjoint complex conjugate transpose",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "adj",
          "normalized": "a-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:adj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the adjoint, mapping \u003cem\u003ea\u003c/em\u003e + \u003cem\u003eb\u003c/em\u003e&#8730;2 to \u003cem\u003ea\u003c/em\u003e &#8722;\u003cem\u003eb\u003c/em\u003e&#8730;2.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "adj2",
          "package": "newsynth",
          "signature": "a -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#adj2",
          "type": "method"
        },
        "index": {
          "description": "Compute the adjoint mapping to",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "adj2",
          "normalized": "a-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:adj2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the ceiling of \u003cem\u003ex\u003c/em\u003e, i.e., the least integer \u003cem\u003en\u003c/em\u003e such\n that \u003cem\u003ex\u003c/em\u003e &#8804; \u003cem\u003en\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "ceiling_of",
          "package": "newsynth",
          "signature": "r -\u003e Integer",
          "source": "src/Quantum-Synthesis-Ring.html#ceiling_of",
          "type": "method"
        },
        "index": {
          "description": "Compute the ceiling of i.e the least integer such that",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "ceiling_of",
          "normalized": "a-\u003eInteger",
          "package": "newsynth",
          "signature": "r-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:ceiling_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a dyadic fraction \u003cem\u003er\u003c/em\u003e, return (\u003cem\u003ea\u003c/em\u003e,\u003cem\u003en\u003c/em\u003e) such that \u003cem\u003er\u003c/em\u003e =\n \u003cem\u003ea\u003c/em\u003e/2\u003csup\u003e\u003cem\u003en\u003c/em\u003e\u003c/sup\u003e, where \u003cem\u003en\u003c/em\u003e&#8805;0 is chosen as small as possible.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "decompose_dyadic",
          "package": "newsynth",
          "signature": "Dyadic -\u003e (Integer, Integer)",
          "source": "src/Quantum-Synthesis-Ring.html#decompose_dyadic",
          "type": "function"
        },
        "index": {
          "description": "Given dyadic fraction return such that where is chosen as small as possible",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "decompose_dyadic",
          "normalized": "Dyadic-\u003e(Integer,Integer)",
          "package": "newsynth",
          "signature": "Dyadic-\u003e(Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:decompose_dyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the least denominator exponent \u003cem\u003ek\u003c/em\u003e of \u003cem\u003ea\u003c/em\u003e. Returns\n the smallest \u003cem\u003ek\u003c/em\u003e&#8805;0 such that \u003cem\u003ea\u003c/em\u003e = \u003cem\u003eb\u003c/em\u003e/&#8730;2\u003csup\u003e\u003cem\u003ek\u003c/em\u003e\u003c/sup\u003e for some\n integral \u003cem\u003eb\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "denomexp",
          "package": "newsynth",
          "signature": "a -\u003e Integer",
          "source": "src/Quantum-Synthesis-Ring.html#denomexp",
          "type": "method"
        },
        "index": {
          "description": "Calculate the least denominator exponent of Returns the smallest such that for some integral",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "denomexp",
          "normalized": "a-\u003eInteger",
          "package": "newsynth",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:denomexp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate and factor out the least denominator exponent \u003cem\u003ek\u003c/em\u003e of\n \u003cem\u003ea\u003c/em\u003e. Return (\u003cem\u003eb\u003c/em\u003e,\u003cem\u003ek\u003c/em\u003e), where \u003cem\u003ea\u003c/em\u003e = \u003cem\u003eb\u003c/em\u003e/(&#8730;2)\u003csup\u003e\u003cem\u003ek\u003c/em\u003e\u003c/sup\u003e and \u003cem\u003ek\u003c/em\u003e&#8805;0.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "denomexp_decompose",
          "package": "newsynth",
          "signature": "a -\u003e (b, Integer)",
          "source": "src/Quantum-Synthesis-Ring.html#denomexp_decompose",
          "type": "function"
        },
        "index": {
          "description": "Calculate and factor out the least denominator exponent of Return where and",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "denomexp_decompose",
          "normalized": "a-\u003e(b,Integer)",
          "package": "newsynth",
          "signature": "a-\u003e(b,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:denomexp_decompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFactor out a \u003cem\u003ek\u003c/em\u003eth power of 1/&#8730;2 from \u003cem\u003ea\u003c/em\u003e. In other words,\n calculate \u003cem\u003ea\u003c/em\u003e&#8730;2\u003csup\u003e\u003cem\u003ek\u003c/em\u003e\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "denomexp_factor",
          "package": "newsynth",
          "signature": "a -\u003e Integer -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#denomexp_factor",
          "type": "method"
        },
        "index": {
          "description": "Factor out th power of from In other words calculate",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "denomexp_factor",
          "normalized": "a-\u003eInteger-\u003ea",
          "package": "newsynth",
          "signature": "a-\u003eInteger-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:denomexp_factor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the floor of \u003cem\u003ex\u003c/em\u003e, i.e., the greatest integer \u003cem\u003en\u003c/em\u003e such\n that \u003cem\u003en\u003c/em\u003e &#8804; \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "floor_of",
          "package": "newsynth",
          "signature": "r -\u003e Integer",
          "source": "src/Quantum-Synthesis-Ring.html#floor_of",
          "type": "method"
        },
        "index": {
          "description": "Compute the floor of i.e the greatest integer such that",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "floor_of",
          "normalized": "a-\u003eInteger",
          "package": "newsynth",
          "signature": "r-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:floor_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from \u003cb\u003eD\u003c/b\u003e[\u003cem\u003ei\u003c/em\u003e] to any ring containing\n &#189; and \u003cem\u003ei\u003c/em\u003e. This exists because \u003cb\u003eD\u003c/b\u003e[\u003cem\u003ei\u003c/em\u003e] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDComplex",
          "package": "newsynth",
          "signature": "DComplex -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromDComplex",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing and This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDComplex",
          "normalized": "DComplex-\u003ea",
          "package": "newsynth",
          "partial": "DComplex",
          "signature": "DComplex-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromDComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from \u003cb\u003eD\u003c/b\u003e[&#969;] to any ring containing\n 1/&#8730;2 and \u003cem\u003ei\u003c/em\u003e. This exists because \u003cb\u003eD\u003c/b\u003e[&#969;] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDOmega",
          "package": "newsynth",
          "signature": "DOmega -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromDOmega",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing and This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDOmega",
          "normalized": "DOmega-\u003ea",
          "package": "newsynth",
          "partial": "DOmega",
          "signature": "DOmega-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromDOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from \u003cb\u003eD\u003c/b\u003e[&#8730;2, \u003cem\u003ei\u003c/em\u003e] to any ring\n containing 1/&#8730;2 and \u003cem\u003ei\u003c/em\u003e. This exists because \u003cb\u003eD\u003c/b\u003e[&#8730;2, \u003cem\u003ei\u003c/em\u003e] =\n &#8484;[1/&#8730;2, \u003cem\u003ei\u003c/em\u003e] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDRComplex",
          "package": "newsynth",
          "signature": "DRComplex -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromDRComplex",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing and This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDRComplex",
          "normalized": "DRComplex-\u003ea",
          "package": "newsynth",
          "partial": "DRComplex",
          "signature": "DRComplex-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromDRComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from \u003cb\u003eD\u003c/b\u003e[&#8730;2] to any ring containing\n 1/&#8730;2. This exists because \u003cb\u003eD\u003c/b\u003e[&#8730;2] = &#8484;[1/&#8730;2] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDRootTwo",
          "package": "newsynth",
          "signature": "DRootTwo -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromDRootTwo",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDRootTwo",
          "normalized": "DRootTwo-\u003ea",
          "package": "newsynth",
          "partial": "DRoot Two",
          "signature": "DRootTwo-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromDRootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8484;[&#189;] to any \u003ccode\u003e\u003ca\u003eHalfRing\u003c/a\u003e\u003c/code\u003e. This\n exists because &#8484;[&#189;] is the free \u003ccode\u003e\u003ca\u003eHalfRing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDyadic",
          "package": "newsynth",
          "signature": "Dyadic -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromDyadic",
          "type": "method"
        },
        "index": {
          "description": "The unique ring homomorphism from to any HalfRing This exists because is the free HalfRing",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromDyadic",
          "normalized": "Dyadic-\u003ea",
          "package": "newsynth",
          "partial": "Dyadic",
          "signature": "Dyadic-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromDyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8474;[\u003cem\u003ei\u003c/em\u003e] to any ring containing\n the rational numbers and \u003cem\u003ei\u003c/em\u003e. This exists because &#8474;[\u003cem\u003ei\u003c/em\u003e] is the\n free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQComplex",
          "package": "newsynth",
          "signature": "QComplex -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromQComplex",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing the rational numbers and This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQComplex",
          "normalized": "QComplex-\u003ea",
          "package": "newsynth",
          "partial": "QComplex",
          "signature": "QComplex-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromQComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8474;[&#969;] to any ring containing the\n rational numbers, &#8730;2, and \u003cem\u003ei\u003c/em\u003e. This exists because &#8474;[&#969;] is the free\n such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQOmega",
          "package": "newsynth",
          "signature": "QOmega -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromQOmega",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing the rational numbers and This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQOmega",
          "normalized": "QOmega-\u003ea",
          "package": "newsynth",
          "partial": "QOmega",
          "signature": "QOmega-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromQOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8474;[&#8730;2, \u003cem\u003ei\u003c/em\u003e] to any ring\n containing the rational numbers, &#8730;2, and \u003cem\u003ei\u003c/em\u003e. This exists because\n &#8474;[&#8730;2, \u003cem\u003ei\u003c/em\u003e] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQRComplex",
          "package": "newsynth",
          "signature": "QRComplex -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromQRComplex",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing the rational numbers and This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQRComplex",
          "normalized": "QRComplex-\u003ea",
          "package": "newsynth",
          "partial": "QRComplex",
          "signature": "QRComplex-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromQRComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8474;[&#8730;2] to any ring containing\n the rational numbers and &#8730;2. This exists because &#8474;[&#8730;2] is the free\n such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQRootTwo",
          "package": "newsynth",
          "signature": "QRootTwo -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromQRootTwo",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing the rational numbers and This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromQRootTwo",
          "normalized": "QRootTwo-\u003ea",
          "package": "newsynth",
          "partial": "QRoot Two",
          "signature": "QRootTwo-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromQRootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from \u003ccode\u003e\u003ca\u003eRationals\u003c/a\u003e\u003c/code\u003e to any \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromRationals",
          "package": "newsynth",
          "signature": "Rationals -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromRationals",
          "type": "function"
        },
        "index": {
          "description": "Conversion from Rationals to any Fractional type",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromRationals",
          "normalized": "Rationals-\u003ea",
          "package": "newsynth",
          "partial": "Rationals",
          "signature": "Rationals-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromRationals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8484;[\u003cem\u003ei\u003c/em\u003e] to any ring containing\n \u003cem\u003ei\u003c/em\u003e. This exists because &#8484;[\u003cem\u003ei\u003c/em\u003e] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromZComplex",
          "package": "newsynth",
          "signature": "ZComplex -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromZComplex",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromZComplex",
          "normalized": "ZComplex-\u003ea",
          "package": "newsynth",
          "partial": "ZComplex",
          "signature": "ZComplex-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromZComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8484;[&#969;] to any ring containing\n &#969;. This exists because &#8484;[&#969;] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromZOmega",
          "package": "newsynth",
          "signature": "ZOmega -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromZOmega",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromZOmega",
          "normalized": "ZOmega-\u003ea",
          "package": "newsynth",
          "partial": "ZOmega",
          "signature": "ZOmega-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromZOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique ring homomorphism from &#8484;[&#8730;2] to any ring containing\n &#8730;2. This exists because &#8484;[&#8730;2] is the free such ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromZRootTwo",
          "package": "newsynth",
          "signature": "ZRootTwo -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#fromZRootTwo",
          "type": "function"
        },
        "index": {
          "description": "The unique ring homomorphism from to any ring containing This exists because is the free such ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "fromZRootTwo",
          "normalized": "ZRootTwo-\u003ea",
          "package": "newsynth",
          "partial": "ZRoot Two",
          "signature": "ZRootTwo-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:fromZRootTwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe embedding of the ring of integers into the larger ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "from_whole",
          "package": "newsynth",
          "signature": "b -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#from_whole",
          "type": "method"
        },
        "index": {
          "description": "The embedding of the ring of integers into the larger ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "from_whole",
          "normalized": "a-\u003eb",
          "package": "newsynth",
          "signature": "b-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:from_whole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe value &#189;.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "half",
          "package": "newsynth",
          "signature": "a",
          "source": "src/Quantum-Synthesis-Ring.html#half",
          "type": "method"
        },
        "index": {
          "description": "The value",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "half",
          "package": "newsynth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:half"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe complex unit.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "i",
          "package": "newsynth",
          "signature": "a",
          "source": "src/Quantum-Synthesis-Ring.html#i",
          "type": "method"
        },
        "index": {
          "description": "The complex unit",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "i",
          "package": "newsynth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a dyadic fraction \u003cem\u003er\u003c/em\u003e and an integer \u003cem\u003ek\u003c/em\u003e&#8805;0, such that \u003cem\u003ea\u003c/em\u003e =\n \u003cem\u003er\u003c/em\u003e2\u003csup\u003e\u003cem\u003ek\u003c/em\u003e\u003c/sup\u003e is an integer, return \u003cem\u003ea\u003c/em\u003e. If \u003cem\u003ea\u003c/em\u003e is not an integer,\n the behavior is undefined.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "integer_of_dyadic",
          "package": "newsynth",
          "signature": "Dyadic -\u003e Integer -\u003e Integer",
          "source": "src/Quantum-Synthesis-Ring.html#integer_of_dyadic",
          "type": "function"
        },
        "index": {
          "description": "Given dyadic fraction and an integer such that is an integer return If is not an integer the behavior is undefined",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "integer_of_dyadic",
          "normalized": "Dyadic-\u003eInteger-\u003eInteger",
          "package": "newsynth",
          "signature": "Dyadic-\u003eInteger-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:integer_of_dyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor \u003cem\u003en\u003c/em\u003e &#8805; 0, return the floor of the square root of \u003cem\u003en\u003c/em\u003e. This is\n done using integer arithmetic, so there are no rounding errors.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "intsqrt",
          "package": "newsynth",
          "signature": "n -\u003e n",
          "source": "src/Quantum-Synthesis-Ring.html#intsqrt",
          "type": "function"
        },
        "index": {
          "description": "For return the floor of the square root of This is done using integer arithmetic so there are no rounding errors",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "intsqrt",
          "normalized": "a-\u003ea",
          "package": "newsynth",
          "signature": "n-\u003en",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:intsqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the position of the rightmost \"1\" bit of an Integer, or\n -1 if none. Do this in time O(\u003cem\u003en\u003c/em\u003e log \u003cem\u003en\u003c/em\u003e), where \u003cem\u003en\u003c/em\u003e is the size\n of the integer (in digits).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "lobit",
          "package": "newsynth",
          "signature": "Integer -\u003e Integer",
          "source": "src/Quantum-Synthesis-Ring.html#lobit",
          "type": "function"
        },
        "index": {
          "description": "Return the position of the rightmost bit of an Integer or if none Do this in time log where is the size of the integer in digits",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "lobit",
          "normalized": "Integer-\u003eInteger",
          "package": "newsynth",
          "signature": "Integer-\u003eInteger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:lobit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003cem\u003en\u003c/em\u003e is of the form 2\u003csup\u003e\u003cem\u003ek\u003c/em\u003e\u003c/sup\u003e, return \u003cem\u003ek\u003c/em\u003e. Otherwise, return\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "log2",
          "package": "newsynth",
          "signature": "Integer -\u003e Maybe Integer",
          "source": "src/Quantum-Synthesis-Ring.html#log2",
          "type": "function"
        },
        "index": {
          "description": "If is of the form return Otherwise return Nothing",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "log2",
          "normalized": "Integer-\u003eMaybe Integer",
          "package": "newsynth",
          "signature": "Integer-\u003eMaybe Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:log2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \"rational\" value to a \"dyadic\" value, if the\n denominator is a power of 2. Otherwise, return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "maybe_dyadic",
          "package": "newsynth",
          "signature": "a -\u003e Maybe b",
          "source": "src/Quantum-Synthesis-Ring.html#maybe_dyadic",
          "type": "method"
        },
        "index": {
          "description": "Convert rational value to dyadic value if the denominator is power of Otherwise return Nothing",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "maybe_dyadic",
          "normalized": "a-\u003eMaybe b",
          "package": "newsynth",
          "signature": "a-\u003eMaybe b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:maybe_dyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "norm",
          "package": "newsynth",
          "signature": "r -\u003e Integer",
          "source": "src/Quantum-Synthesis-Ring.html#norm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "norm",
          "normalized": "a-\u003eInteger",
          "package": "newsynth",
          "signature": "r-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe square root of \u003cem\u003ei\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "omega",
          "package": "newsynth",
          "signature": "a",
          "source": "src/Quantum-Synthesis-Ring.html#omega",
          "type": "method"
        },
        "index": {
          "description": "The square root of",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "omega",
          "package": "newsynth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:omega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn inverse to the embedding \u003cem\u003eR\u003c/em\u003e &#8614; \u003cem\u003eR\u003c/em\u003e[&#969;]: return the \"real\n rational\" part. \n In other words, map \u003cem\u003ea\u003c/em\u003e&#969;\u003csup\u003e3\u003c/sup\u003e+\u003cem\u003eb\u003c/em\u003e&#969;\u003csup\u003e2\u003c/sup\u003e+\u003cem\u003ec\u003c/em\u003e&#969;+\u003cem\u003ed\u003c/em\u003e to \u003cem\u003ed\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "omega_real",
          "package": "newsynth",
          "signature": "Omega a -\u003e a",
          "source": "src/Quantum-Synthesis-Ring.html#omega_real",
          "type": "function"
        },
        "index": {
          "description": "An inverse to the embedding return the real rational part In other words map to",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "omega_real",
          "normalized": "Omega a-\u003ea",
          "package": "newsynth",
          "signature": "Omega a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:omega_real"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the parity of something.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "parity",
          "package": "newsynth",
          "signature": "a -\u003e Z2",
          "source": "src/Quantum-Synthesis-Ring.html#parity",
          "type": "method"
        },
        "index": {
          "description": "Return the parity of something",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "parity",
          "normalized": "a-\u003eZ",
          "package": "newsynth",
          "signature": "a-\u003eZ",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:parity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the real part.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "real",
          "package": "newsynth",
          "signature": "a -\u003e b",
          "source": "src/Quantum-Synthesis-Ring.html#real",
          "type": "method"
        },
        "index": {
          "description": "Take the real part",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "real",
          "normalized": "a-\u003eb",
          "package": "newsynth",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:real"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe square root of &#189;.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "roothalf",
          "package": "newsynth",
          "signature": "a",
          "source": "src/Quantum-Synthesis-Ring.html#roothalf",
          "type": "method"
        },
        "index": {
          "description": "The square root of",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "roothalf",
          "package": "newsynth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:roothalf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe square root of 2.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "roottwo",
          "package": "newsynth",
          "signature": "a",
          "source": "src/Quantum-Synthesis-Ring.html#roottwo",
          "type": "method"
        },
        "index": {
          "description": "The square root of",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "roottwo",
          "package": "newsynth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:roottwo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e-like method that factors out a common denominator\n exponent.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "showsPrec_DenomExp",
          "package": "newsynth",
          "signature": "Int -\u003e a -\u003e ShowS",
          "source": "src/Quantum-Synthesis-Ring.html#showsPrec_DenomExp",
          "type": "function"
        },
        "index": {
          "description": "Generic show like method that factors out common denominator exponent",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "showsPrec_DenomExp",
          "normalized": "Int-\u003ea-\u003eShowS",
          "package": "newsynth",
          "partial": "Prec Denom Exp",
          "signature": "Int-\u003ea-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:showsPrec_DenomExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn auxiliary function for printing rational numbers, using\n correct precedences, and omitting denominators of 1.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "showsPrec_rational",
          "package": "newsynth",
          "signature": "Int -\u003e Ratio a -\u003e ShowS",
          "source": "src/Quantum-Synthesis-Ring.html#showsPrec_rational",
          "type": "function"
        },
        "index": {
          "description": "An auxiliary function for printing rational numbers using correct precedences and omitting denominators of",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "showsPrec_rational",
          "normalized": "Int-\u003eRatio a-\u003eShowS",
          "package": "newsynth",
          "partial": "Prec",
          "signature": "Int-\u003eRatio a-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:showsPrec_rational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion to \u003ccode\u003e\u003ca\u003eQOmega\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "toQOmega",
          "package": "newsynth",
          "signature": "a -\u003e QOmega",
          "source": "src/Quantum-Synthesis-Ring.html#toQOmega",
          "type": "method"
        },
        "index": {
          "description": "Conversion to QOmega",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "toQOmega",
          "normalized": "a-\u003eQOmega",
          "package": "newsynth",
          "partial": "QOmega",
          "signature": "a-\u003eQOmega",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:toQOmega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \"rational\" value to a \"dyadic\" value, if the\n denominator is a power of 2. Otherwise, throw an error.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "to_dyadic",
          "package": "newsynth",
          "signature": "a -\u003e b",
          "source": "src/Quantum-Synthesis-Ring.html#to_dyadic",
          "type": "function"
        },
        "index": {
          "description": "Convert rational value to dyadic value if the denominator is power of Otherwise throw an error",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "to_dyadic",
          "normalized": "a-\u003eb",
          "package": "newsynth",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:to_dyadic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse of \u003ccode\u003e\u003ca\u003efrom_whole\u003c/a\u003e\u003c/code\u003e. Throws an error if the given\n element is not actually an integer in the ring.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "to_whole",
          "package": "newsynth",
          "signature": "a -\u003e b",
          "source": "src/Quantum-Synthesis-Ring.html#to_whole",
          "type": "method"
        },
        "index": {
          "description": "The inverse of from whole Throws an error if the given element is not actually an integer in the ring",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "to_whole",
          "normalized": "a-\u003eb",
          "package": "newsynth",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:to_whole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.Ring",
          "name": "unRationals",
          "package": "newsynth",
          "signature": "Rational",
          "source": "src/Quantum-Synthesis-Ring.html#Rationals",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "unRationals",
          "package": "newsynth",
          "partial": "Rationals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:unRationals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of the embedding &#8484;[&#8730;2] &#8594; &#8484;[&#969;]. Note that &#8484;[&#8730;2] = &#8484;[&#969;] &#8745;\n &#8477;. This function takes an element of &#8484;[&#969;] that is real, and\n converts it to an element of &#8484;[&#8730;2]. It throws an error if the input\n is not real.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.Ring",
          "name": "zroottwo_of_zomega",
          "package": "newsynth",
          "signature": "ZOmega -\u003e ZRootTwo",
          "source": "src/Quantum-Synthesis-Ring.html#zroottwo_of_zomega",
          "type": "function"
        },
        "index": {
          "description": "Inverse of the embedding Note that This function takes an element of that is real and converts it to an element of It throws an error if the input is not real",
          "hierarchy": "Quantum Synthesis Ring",
          "module": "Quantum.Synthesis.Ring",
          "name": "zroottwo_of_zomega",
          "normalized": "ZOmega-\u003eZRootTwo",
          "package": "newsynth",
          "signature": "ZOmega-\u003eZRootTwo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-Ring.html#v:zroottwo_of_zomega"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for decomposing a unitary \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e\n operator into one- and two-level unitaries. \n\u003c/p\u003e\u003cp\u003eThe algorithm is adapted from Section 4.5.1 of Nielsen and\n Chuang. In addition to what is described in Nielsen and Chuang, our\n algorithm produces two-level operators that can be decomposed using\n only two Euler angles. The algorithm produces at most \u003cem\u003en\u003c/em\u003e(\u003cem\u003en\u003c/em\u003e&#8722;1)/2\n two-level operators of type \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#948;)\u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ex\u003c/em\u003e\u003c/sub\u003e(&#947;), as well\n as \u003cem\u003en\u003c/em\u003e one-level operators of type \u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ei\u003c/em\u003e&#952;\u003c/sup\u003e. Therefore, the\n decomposition of a unitary \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e operator yields \u003cem\u003en\u003c/em\u003e\u003csup\u003e2\u003c/sup\u003e real\n parameters, which is optimal.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "RotationDecomposition",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for decomposing unitary operator into one and two-level unitaries The algorithm is adapted from Section of Nielsen and Chuang In addition to what is described in Nielsen and Chuang our algorithm produces two-level operators that can be decomposed using only two Euler angles The algorithm produces at most two-level operators of type as well as one-level operators of type Therefore the decomposition of unitary operator yields real parameters which is optimal",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "RotationDecomposition",
          "package": "newsynth",
          "partial": "Rotation Decomposition",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn elementary rotation is either a combined \u003cem\u003ex\u003c/em\u003e- and\n \u003cem\u003ez\u003c/em\u003e-rotation, applied at indices \u003cem\u003ej\u003c/em\u003e and \u003cem\u003ek\u003c/em\u003e, or a phase change\n applied at index \u003cem\u003ej\u003c/em\u003e.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eERot_zx\u003c/a\u003e\u003c/code\u003e &#948; &#947; \u003cem\u003ej\u003c/em\u003e \u003cem\u003ek\u003c/em\u003e represents the operator \n \u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ez\u003c/em\u003e\u003c/sub\u003e(&#948;)\u003cem\u003eR\u003c/em\u003e\u003csub\u003e\u003cem\u003ex\u003c/em\u003e\u003c/sub\u003e(&#947;), applied to levels \u003cem\u003ej\u003c/em\u003e and \u003cem\u003ek\u003c/em\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"ERot_zx.png\"/\u003e\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eERot_phase\u003c/a\u003e\u003c/code\u003e &#952; \u003cem\u003ej\u003c/em\u003e represents the operator \u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ei\u003c/em\u003e&#952;\u003c/sup\u003e applied to level\n \u003cem\u003ej\u003c/em\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"ERot_phase.png\"/\u003e\n\u003c/p\u003e\u003cp\u003eNote: when we use a list of \u003ccode\u003e\u003ca\u003eElementaryRot\u003c/a\u003e\u003c/code\u003es to express a sequence of\n operators, the operators are meant to be applied right-to-left,\n i.e., as in the mathematical notation for matrix multiplication.\n This is the opposite of the quantum circuit notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "ElementaryRot",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#ElementaryRot",
          "type": "data"
        },
        "index": {
          "description": "An elementary rotation is either combined and rotation applied at indices and or phase change applied at index ERot zx represents the operator applied to levels and ERot phase represents the operator applied to level Note when we use list of ElementaryRot to express sequence of operators the operators are meant to be applied right-to-left i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "ElementaryRot",
          "package": "newsynth",
          "partial": "Elementary Rot",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#t:ElementaryRot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "ERot_phase",
          "package": "newsynth",
          "signature": "ERot_phase a Index",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#ElementaryRot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "ERot_phase",
          "package": "newsynth",
          "partial": "ERot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:ERot_phase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "ERot_zx",
          "package": "newsynth",
          "signature": "ERot_zx a a Index Index",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#ElementaryRot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "ERot_zx",
          "package": "newsynth",
          "partial": "ERot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:ERot_zx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the phase of the \u003cem\u003ej\u003c/em\u003eth diagonal entry of the given\n matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "get_phase",
          "package": "newsynth",
          "signature": "Matrix n n (Cplx a) -\u003e Index -\u003e ElementaryRot a",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#get_phase",
          "type": "function"
        },
        "index": {
          "description": "Extract the phase of the th diagonal entry of the given matrix",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "get_phase",
          "normalized": "Matrix a a(Cplx b)-\u003eIndex-\u003eElementaryRot b",
          "package": "newsynth",
          "signature": "Matrix n n(Cplx a)-\u003eIndex-\u003eElementaryRot a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:get_phase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a sequence of elementary rotations to an \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "matrix_of_elementaries",
          "package": "newsynth",
          "signature": "[ElementaryRot a] -\u003e Matrix n n (Cplx a)",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#matrix_of_elementaries",
          "type": "function"
        },
        "index": {
          "description": "Convert sequence of elementary rotations to an matrix",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "matrix_of_elementaries",
          "normalized": "[ElementaryRot a]-\u003eMatrix b b(Cplx a)",
          "package": "newsynth",
          "signature": "[ElementaryRot a]-\u003eMatrix n n(Cplx a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:matrix_of_elementaries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a symbolic elementary rotation to a concrete matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "matrix_of_elementary",
          "package": "newsynth",
          "signature": "ElementaryRot a -\u003e Matrix n n (Cplx a)",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#matrix_of_elementary",
          "type": "function"
        },
        "index": {
          "description": "Convert symbolic elementary rotation to concrete matrix",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "matrix_of_elementary",
          "normalized": "ElementaryRot a-\u003eMatrix b b(Cplx a)",
          "package": "newsynth",
          "signature": "ElementaryRot a-\u003eMatrix n n(Cplx a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:matrix_of_elementary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \"random\" unitary \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix. These matrices will\n not quite be uniformly distributed; this function is primarily\n meant to generate test cases. \n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "random_unitary",
          "package": "newsynth",
          "signature": "g -\u003e Matrix n n (Cplx a)",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#random_unitary",
          "type": "function"
        },
        "index": {
          "description": "Return random unitary matrix These matrices will not quite be uniformly distributed this function is primarily meant to generate test cases",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "random_unitary",
          "normalized": "a-\u003eMatrix b b(Cplx c)",
          "package": "newsynth",
          "signature": "g-\u003eMatrix n n(Cplx a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:random_unitary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix to a sequence of elementary rotations.\n\u003c/p\u003e\u003cp\u003eNote: the list of elementary rotations will be returned in\n right-to-left order, i.e., as in the mathematical notation for\n matrix multiplication.  This is the opposite of the quantum circuit\n notation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "rotation_decomposition",
          "package": "newsynth",
          "signature": "Matrix n n (Cplx a) -\u003e [ElementaryRot a]",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#rotation_decomposition",
          "type": "function"
        },
        "index": {
          "description": "Convert an matrix to sequence of elementary rotations Note the list of elementary rotations will be returned in right-to-left order i.e as in the mathematical notation for matrix multiplication This is the opposite of the quantum circuit notation",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "rotation_decomposition",
          "normalized": "Matrix a a(Cplx b)-\u003e[ElementaryRot b]",
          "package": "newsynth",
          "signature": "Matrix n n(Cplx a)-\u003e[ElementaryRot a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:rotation_decomposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a two-level operation on rows \u003cem\u003ej\u003c/em\u003e and \u003cem\u003ek\u003c/em\u003e of a matrix \u003cem\u003eU\u003c/em\u003e,\n such that the resulting matrix has a 0 in the (\u003cem\u003ej\u003c/em\u003e,\u003cem\u003ek\u003c/em\u003e)-position.\n Return the inverse of the two-level operation used, as well as the\n updated matrix.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "rowop",
          "package": "newsynth",
          "signature": "Matrix n n (Cplx a) -\u003e (Index, Index) -\u003e (Matrix n n (Cplx a), [ElementaryRot a])",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#rowop",
          "type": "function"
        },
        "index": {
          "description": "Perform two-level operation on rows and of matrix such that the resulting matrix has in the position Return the inverse of the two-level operation used as well as the updated matrix",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "rowop",
          "normalized": "Matrix a a(Cplx b)-\u003e(Index,Index)-\u003e(Matrix a a(Cplx b),[ElementaryRot b])",
          "package": "newsynth",
          "signature": "Matrix n n(Cplx a)-\u003e(Index,Index)-\u003e(Matrix n n(Cplx a),[ElementaryRot a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:rowop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a random matrix, decompose it, and then re-calculate the\n matrix from the decomposition.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "test",
          "package": "newsynth",
          "signature": "IO ()",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#test",
          "type": "function"
        },
        "index": {
          "description": "Generate random matrix decompose it and then re-calculate the matrix from the decomposition",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "test",
          "normalized": "IO()",
          "package": "newsynth",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:test"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a two-level \u003cem\u003en\u003c/em\u003e&#215;\u003cem\u003en\u003c/em\u003e-matrix from a given 2&#215;2-matrix and\n indices \u003cem\u003ej\u003c/em\u003e and \u003cem\u003ek\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "twolevel_matrix_of_matrix",
          "package": "newsynth",
          "signature": "Matrix Two Two a -\u003e Index -\u003e Index -\u003e Matrix n n a",
          "source": "src/Quantum-Synthesis-RotationDecomposition.html#twolevel_matrix_of_matrix",
          "type": "function"
        },
        "index": {
          "description": "Construct two-level matrix from given matrix and indices and",
          "hierarchy": "Quantum Synthesis RotationDecomposition",
          "module": "Quantum.Synthesis.RotationDecomposition",
          "name": "twolevel_matrix_of_matrix",
          "normalized": "Matrix Two Two a-\u003eIndex-\u003eIndex-\u003eMatrix b b a",
          "package": "newsynth",
          "signature": "Matrix Two Two a-\u003eIndex-\u003eIndex-\u003eMatrix n n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-RotationDecomposition.html#v:twolevel_matrix_of_matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides a symbolic representation of real number\n expressions, as well as a type class of things that can be\n converted to arbitrary precision real numbers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "SymReal",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-SymReal.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides symbolic representation of real number expressions as well as type class of things that can be converted to arbitrary precision real numbers",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "SymReal",
          "package": "newsynth",
          "partial": "Sym Real",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type to represent symbolic expressions for real numbers.\n\u003c/p\u003e\u003cp\u003eCaution: equality \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e at this type denotes symbolic equality of\n expressions, not equality of the defined real numbers.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "SymReal",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "data"
        },
        "index": {
          "description": "type to represent symbolic expressions for real numbers Caution equality at this type denotes symbolic equality of expressions not equality of the defined real numbers",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "SymReal",
          "package": "newsynth",
          "partial": "Sym Real",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#t:SymReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type class for things that can be converted to a real number at\n arbitrary precision.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ToReal",
          "package": "newsynth",
          "source": "src/Quantum-Synthesis-SymReal.html#ToReal",
          "type": "class"
        },
        "index": {
          "description": "type class for things that can be converted to real number at arbitrary precision",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ToReal",
          "package": "newsynth",
          "partial": "To Real",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#t:ToReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eacos \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ACos",
          "package": "newsynth",
          "signature": "ACos SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "acos",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ACos",
          "package": "newsynth",
          "partial": "ACos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:ACos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eacosh \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ACosh",
          "package": "newsynth",
          "signature": "ACosh SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "acosh",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ACosh",
          "package": "newsynth",
          "partial": "ACosh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:ACosh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003easin \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ASin",
          "package": "newsynth",
          "signature": "ASin SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "asin",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ASin",
          "package": "newsynth",
          "partial": "ASin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:ASin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003easinh \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ASinh",
          "package": "newsynth",
          "signature": "ASinh SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "asinh",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ASinh",
          "package": "newsynth",
          "partial": "ASinh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:ASinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eatan \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ATan",
          "package": "newsynth",
          "signature": "ATan SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "atan",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ATan",
          "package": "newsynth",
          "partial": "ATan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:ATan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eatanh \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ATanh",
          "package": "newsynth",
          "signature": "ATanh SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "atanh",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ATanh",
          "package": "newsynth",
          "partial": "ATanh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:ATanh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e|\u003cem\u003ex\u003c/em\u003e|.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Abs",
          "package": "newsynth",
          "signature": "Abs SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Abs",
          "package": "newsynth",
          "partial": "Abs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earctan2 \u003cem\u003ex\u003c/em\u003e \u003cem\u003ey\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ArcTan2",
          "package": "newsynth",
          "signature": "ArcTan2 SymReal SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "arctan2",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "ArcTan2",
          "package": "newsynth",
          "partial": "Arc Tan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:ArcTan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn integer constant.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Const",
          "package": "newsynth",
          "signature": "Const Integer",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "An integer constant",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Const",
          "package": "newsynth",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecos \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Cos",
          "package": "newsynth",
          "signature": "Cos SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "cos",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Cos",
          "package": "newsynth",
          "partial": "Cos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Cos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecosh \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Cosh",
          "package": "newsynth",
          "signature": "Cosh SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "cosh",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Cosh",
          "package": "newsynth",
          "partial": "Cosh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Cosh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA decimal constant. This has a rational value and a string representation.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Decimal",
          "package": "newsynth",
          "signature": "Decimal Rational String",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "decimal constant This has rational value and string representation",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Decimal",
          "package": "newsynth",
          "partial": "Decimal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Decimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ex\u003c/em\u003e \u003ccode\u003e/\u003c/code\u003e \u003cem\u003ey\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Div",
          "package": "newsynth",
          "signature": "Div SymReal SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Div",
          "package": "newsynth",
          "partial": "Div",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ee\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Euler",
          "package": "newsynth",
          "signature": "Euler",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Euler",
          "package": "newsynth",
          "partial": "Euler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Euler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ci\u003ee\u003c/i\u003e\u003csup\u003e\u003cem\u003ex\u003c/em\u003e\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Exp",
          "package": "newsynth",
          "signature": "Exp SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Exp",
          "package": "newsynth",
          "partial": "Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elog \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Log",
          "package": "newsynth",
          "signature": "Log SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "log",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Log",
          "package": "newsynth",
          "partial": "Log",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Log"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ex\u003c/em\u003e \u003ccode\u003e&#8722;\u003c/code\u003e \u003cem\u003ey\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Minus",
          "package": "newsynth",
          "signature": "Minus SymReal SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Minus",
          "package": "newsynth",
          "partial": "Minus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Minus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#8722;\u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Negate",
          "package": "newsynth",
          "signature": "Negate SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Negate",
          "package": "newsynth",
          "partial": "Negate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#960;.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Pi",
          "package": "newsynth",
          "signature": "Pi",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Pi",
          "package": "newsynth",
          "partial": "Pi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ex\u003c/em\u003e \u003ccode\u003e+\u003c/code\u003e \u003cem\u003ey\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Plus",
          "package": "newsynth",
          "signature": "Plus SymReal SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Plus",
          "package": "newsynth",
          "partial": "Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ex\u003c/em\u003e\u003csup\u003e\u003cem\u003ey\u003c/em\u003e\u003c/sup\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Power",
          "package": "newsynth",
          "signature": "Power SymReal SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Power",
          "package": "newsynth",
          "partial": "Power",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e1/\u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Recip",
          "package": "newsynth",
          "signature": "Recip SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Recip",
          "package": "newsynth",
          "partial": "Recip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esignum(\u003cem\u003ex\u003c/em\u003e).\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Signum",
          "package": "newsynth",
          "signature": "Signum SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "signum",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Signum",
          "package": "newsynth",
          "partial": "Signum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Signum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esin \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Sin",
          "package": "newsynth",
          "signature": "Sin SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "sin",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Sin",
          "package": "newsynth",
          "partial": "Sin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Sin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esinh \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Sinh",
          "package": "newsynth",
          "signature": "Sinh SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "sinh",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Sinh",
          "package": "newsynth",
          "partial": "Sinh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Sinh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e&#8730;\u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Sqrt",
          "package": "newsynth",
          "signature": "Sqrt SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Sqrt",
          "package": "newsynth",
          "partial": "Sqrt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Sqrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecos \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Tan",
          "package": "newsynth",
          "signature": "Tan SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "cos",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Tan",
          "package": "newsynth",
          "partial": "Tan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Tan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etanh \u003cem\u003ex\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Tanh",
          "package": "newsynth",
          "signature": "Tanh SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "description": "tanh",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Tanh",
          "package": "newsynth",
          "partial": "Tanh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Tanh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ex\u003c/em\u003e \u003ccode\u003e*\u003c/code\u003e \u003cem\u003ey\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Times",
          "package": "newsynth",
          "signature": "Times SymReal SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#SymReal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "Times",
          "package": "newsynth",
          "partial": "Times",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:Times"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ebinary_fun\u003c/em\u003e ::= \u003cem\u003ebinary_op\u003c/em\u003e \u003cem\u003eexp10\u003c/em\u003e \u003cem\u003eexp10\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "binary_fun",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#binary_fun",
          "type": "function"
        },
        "index": {
          "description": "binary fun binary op exp10 exp10",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "binary_fun",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:binary_fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ebinary_op\u003c/em\u003e ::= \"abs\" | \"signum\" | ...\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "binary_op",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#binary_op",
          "type": "function"
        },
        "index": {
          "description": "binary op abs signum",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "binary_op",
          "normalized": "ReadP(SymReal-\u003eSymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:binary_op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003econst_e\u003c/em\u003e ::= \"e\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "const_e",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#const_e",
          "type": "function"
        },
        "index": {
          "description": "const",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "const_e",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:const_e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003econst_pi\u003c/em\u003e ::= \"pi\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "const_pi",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#const_pi",
          "type": "function"
        },
        "index": {
          "description": "const pi pi",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "const_pi",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:const_pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003ediv_term\u003c/em\u003e ::= \"/\" \u003cem\u003eexp8\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "div_term",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#div_term",
          "type": "function"
        },
        "index": {
          "description": "div term exp8",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "div_term",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:div_term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt would be useful to have a function for converting a symbolic\n real number to a fixed-precision real number with a chosen\n precision, such that the precision \u003cem\u003ee\u003c/em\u003e depends on a parameter \u003cem\u003ed\u003c/em\u003e:\n\u003c/p\u003e\u003cpre\u003e to_fixedprec :: (ToReal r) =\u003e Integer -\u003e r -\u003e FixedPrec e\n to_fixedprec d x = ...\n\u003c/pre\u003e\u003cp\u003eHowever, since \u003cem\u003ee\u003c/em\u003e is a type, \u003cem\u003ed\u003c/em\u003e is a term, and Haskell is not\n dependently typed, this cannot be done directly.\n\u003c/p\u003e\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003edynamic_fixedprec\u003c/a\u003e\u003c/code\u003e is the closest thing we have to a\n workaround. The call \u003ccode\u003edynamic_fixedprec\u003c/code\u003e \u003cem\u003ed\u003c/em\u003e \u003cem\u003ef\u003c/em\u003e \u003cem\u003ex\u003c/em\u003e calls\n \u003cem\u003ef\u003c/em\u003e(\u003cem\u003ex\u003c/em\u003e'), where \u003cem\u003ex\u003c/em\u003e' is the value \u003cem\u003ex\u003c/em\u003e converted to \u003cem\u003ed\u003c/em\u003e digits of\n precision.  In other words, we have\n\u003c/p\u003e\u003cpre\u003e dynamic_fixedprec d f x = f (to_fixedprec d x),\n\u003c/pre\u003e\u003cp\u003ewith the restriction that the precision \u003cem\u003ee\u003c/em\u003e cannot occur freely in\n the result type of \u003cem\u003ef\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "dynamic_fixedprec",
          "package": "newsynth",
          "signature": "FixedPrec e -\u003e a) -\u003e r -\u003e a",
          "source": "src/Quantum-Synthesis-SymReal.html#dynamic_fixedprec",
          "type": "function"
        },
        "index": {
          "description": "It would be useful to have function for converting symbolic real number to fixed-precision real number with chosen precision such that the precision depends on parameter to fixedprec ToReal Integer FixedPrec to fixedprec However since is type is term and Haskell is not dependently typed this cannot be done directly The function dynamic fixedprec is the closest thing we have to workaround The call dynamic fixedprec calls where is the value converted to digits of precision In other words we have dynamic fixedprec to fixedprec with the restriction that the precision cannot occur freely in the result type of",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "dynamic_fixedprec",
          "normalized": "FixedPrec a-\u003eb)-\u003ec-\u003eb",
          "package": "newsynth",
          "signature": "FixedPrec e-\u003ea)-\u003er-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:dynamic_fixedprec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003edynamic_fixedprec\u003c/a\u003e\u003c/code\u003e, but take two real number arguments. In\n terms of the fictitious function \u003ccode\u003eto_fixedprec\u003c/code\u003e, we have:\n\u003c/p\u003e\u003cpre\u003e dynamic_fixedprec2 d f x y = f (to_fixedprec d x) (to_fixedprec d y).\n\u003c/pre\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "dynamic_fixedprec2",
          "package": "newsynth",
          "signature": "FixedPrec e -\u003e FixedPrec e -\u003e a) -\u003e r -\u003e s -\u003e a",
          "source": "src/Quantum-Synthesis-SymReal.html#dynamic_fixedprec2",
          "type": "function"
        },
        "index": {
          "description": "Like dynamic fixedprec but take two real number arguments In terms of the fictitious function to fixedprec we have dynamic fixedprec2 to fixedprec to fixedprec",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "dynamic_fixedprec2",
          "normalized": "FixedPrec a-\u003eFixedPrec a-\u003eb)-\u003ec-\u003ed-\u003eb",
          "package": "newsynth",
          "signature": "FixedPrec e-\u003eFixedPrec e-\u003ea)-\u003er-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:dynamic_fixedprec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eexp10\u003c/em\u003e ::= \u003cem\u003eparenthesized\u003c/em\u003e | \u003cem\u003econst_pi\u003c/em\u003e | \u003cem\u003econst_e\u003c/em\u003e | \u003cem\u003einteger\u003c/em\u003e | \u003cem\u003efloat\u003c/em\u003e | \u003cem\u003eunary_fun\u003c/em\u003e | \u003cem\u003ebinary_fun\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eAn expression whose top-level operator has precedence 10 or\n above. Such expressions are constants, applications of unary\n operators (except unary \"&#8722;\" and \"+\"), and parenthesized\n expressions.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp10",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#exp10",
          "type": "function"
        },
        "index": {
          "description": "exp10 parenthesized const pi const integer float unary fun binary fun An expression whose top-level operator has precedence or above Such expressions are constants applications of unary operators except unary and and parenthesized expressions",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp10",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:exp10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eexp6\u003c/em\u003e ::= (\u003cem\u003enegative\u003c/em\u003e | \u003cem\u003epositive\u003c/em\u003e)? \u003cem\u003eexp7\u003c/em\u003e ( \u003cem\u003eplus_term\u003c/em\u003e | \u003cem\u003eminus_term\u003c/em\u003e )*.\n\u003c/p\u003e\u003cp\u003eAn expression whose top-level operator has precedence 6 or\n above. The operators of precedence 6 are \"+\" and \"&#8722;\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp6",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#exp6",
          "type": "function"
        },
        "index": {
          "description": "exp6 negative positive exp7 plus term minus term An expression whose top-level operator has precedence or above The operators of precedence are and",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp6",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:exp6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eexp7\u003c/em\u003e ::= \u003cem\u003eexp8\u003c/em\u003e ( \u003cem\u003etimes_term\u003c/em\u003e | \u003cem\u003ediv_term\u003c/em\u003e )*.\n\u003c/p\u003e\u003cp\u003eAn expression whose top-level operator has precedence 7 or\n above. The operators of precedence 6 are \"*\" and \"/\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp7",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#exp7",
          "type": "function"
        },
        "index": {
          "description": "exp7 exp8 times term div term An expression whose top-level operator has precedence or above The operators of precedence are and",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp7",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:exp7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eexp8\u003c/em\u003e ::= ( \u003cem\u003epower_term\u003c/em\u003e )* \u003cem\u003eexp10\u003c/em\u003e\n\u003c/p\u003e\u003cp\u003eAn expression whose top-level operator has precedence 8 or\n above. The operators of precedence 6 are \"**\" and \"^\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp8",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#exp8",
          "type": "function"
        },
        "index": {
          "description": "exp8 power term exp10 An expression whose top-level operator has precedence or above The operators of precedence are and",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "exp8",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:exp8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eexpression\u003c/em\u003e ::= \u003cem\u003eexp6\u003c/em\u003e \u003cem\u003eend-of-line\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eThis is a top-level expression.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "expression",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#expression",
          "type": "function"
        },
        "index": {
          "description": "expression exp6 end-of-line This is top-level expression",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "expression",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:expression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003efloat\u003c/em\u003e ::= \u003cem\u003edigit\u003c/em\u003e* \".\" \u003cem\u003edigit\u003c/em\u003e*.\n\u003c/p\u003e\u003cp\u003eThere must be at least one digit, either before or after the decimal point.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "float",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#float",
          "type": "function"
        },
        "index": {
          "description": "float digit digit There must be at least one digit either before or after the decimal point",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "float",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003einteger\u003c/em\u003e ::= \u003cem\u003edigit\u003c/em\u003e \u003cem\u003edigit\u003c/em\u003e*.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "integer",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#integer",
          "type": "function"
        },
        "index": {
          "description": "integer digit digit",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "integer",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eminus_term\u003c/em\u003e ::= \"&#8722;\" \u003cem\u003eexp7\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "minus_term",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#minus_term",
          "type": "function"
        },
        "index": {
          "description": "minus term exp7",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "minus_term",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:minus_term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003enegative\u003c/em\u003e ::= \"&#8722;\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "negative",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#negative",
          "type": "function"
        },
        "index": {
          "description": "negative",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "negative",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:negative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eparenthesized\u003c/em\u003e ::= \"(\" \u003cem\u003eexp6\u003c/em\u003e \")\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "parenthesized",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#parenthesized",
          "type": "function"
        },
        "index": {
          "description": "parenthesized exp6",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "parenthesized",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:parenthesized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a symbolic real number expression. Typical strings that can\n be parsed are \u003ccode\u003e\"1.0\"\u003c/code\u003e, \u003ccode\u003e\"pi/128\"\u003c/code\u003e, \u003ccode\u003e\"(1+sin(pi/3))^2\"\u003c/code\u003e, etc. If\n the expression cannot be parsed, return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "parse_SymReal",
          "package": "newsynth",
          "signature": "String -\u003e Maybe SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#parse_SymReal",
          "type": "function"
        },
        "index": {
          "description": "Parse symbolic real number expression Typical strings that can be parsed are pi sin pi etc If the expression cannot be parsed return Nothing",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "parse_SymReal",
          "normalized": "String-\u003eMaybe SymReal",
          "package": "newsynth",
          "partial": "Sym Real",
          "signature": "String-\u003eMaybe SymReal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:parse_SymReal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eplus_term\u003c/em\u003e ::= \"+\" \u003cem\u003eexp7\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "plus_term",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#plus_term",
          "type": "function"
        },
        "index": {
          "description": "plus term exp7",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "plus_term",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:plus_term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003epositive\u003c/em\u003e ::= \"+\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "positive",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#positive",
          "type": "function"
        },
        "index": {
          "description": "positive",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "positive",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:positive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003epower_term\u003c/em\u003e ::= \u003cem\u003eexp10\u003c/em\u003e \"**\" | \u003cem\u003eexp10\u003c/em\u003e \"^\".\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "power_term",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#power_term",
          "type": "function"
        },
        "index": {
          "description": "power term exp10 exp10",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "power_term",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:power_term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003etimes_term\u003c/em\u003e ::= \"*\" \u003cem\u003eexp8\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "times_term",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#times_term",
          "type": "function"
        },
        "index": {
          "description": "times term exp8",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "times_term",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:times_term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Quantum.Synthesis.SymReal",
          "name": "to_real",
          "package": "newsynth",
          "signature": "a -\u003e r",
          "source": "src/Quantum-Synthesis-SymReal.html#to_real",
          "type": "method"
        },
        "index": {
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "to_real",
          "normalized": "a-\u003eb",
          "package": "newsynth",
          "signature": "a-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:to_real"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eunary_fun\u003c/em\u003e ::= \u003cem\u003eunary_op\u003c/em\u003e \u003cem\u003eexp10\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "unary_fun",
          "package": "newsynth",
          "signature": "ReadP SymReal",
          "source": "src/Quantum-Synthesis-SymReal.html#unary_fun",
          "type": "function"
        },
        "index": {
          "description": "unary fun unary op exp10",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "unary_fun",
          "package": "newsynth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:unary_fun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eunary_op\u003c/em\u003e ::= \"abs\" | \"signum\" | ...\n\u003c/p\u003e",
          "module": "Quantum.Synthesis.SymReal",
          "name": "unary_op",
          "package": "newsynth",
          "signature": "ReadP (SymReal -\u003e SymReal)",
          "source": "src/Quantum-Synthesis-SymReal.html#unary_op",
          "type": "function"
        },
        "index": {
          "description": "unary op abs signum",
          "hierarchy": "Quantum Synthesis SymReal",
          "module": "Quantum.Synthesis.SymReal",
          "name": "unary_op",
          "normalized": "ReadP(SymReal-\u003eSymReal)",
          "package": "newsynth",
          "signature": "ReadP(SymReal-\u003eSymReal)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/newsynth/docs/Quantum-Synthesis-SymReal.html#v:unary_op"
      }
    }
  ]
]