[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "network"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ca\u003eNetwork.BSD\u003c/a\u003e module defines Haskell bindings to network\n programming functionality provided by BSD Unix derivatives.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.BSD",
          "name": "BSD",
          "package": "network",
          "source": "src/Network-BSD.html",
          "type": "module"
        },
        "index": {
          "description": "The Network.BSD module defines Haskell bindings to network programming functionality provided by BSD Unix derivatives",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "BSD",
          "package": "network",
          "partial": "BSD",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "HostEntry",
          "package": "network",
          "source": "src/Network-BSD.html#HostEntry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "HostEntry",
          "package": "network",
          "partial": "Host Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:HostEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEither a host name e.g., \u003ccode\u003e\"haskell.org\"\u003c/code\u003e or a numeric host\n address string consisting of a dotted decimal IPv4 address or an\n IPv6 address e.g., \u003ccode\u003e\"192.168.0.1\"\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "HostName",
          "package": "network",
          "source": "src/Network-Socket.html#HostName",
          "type": "type"
        },
        "index": {
          "description": "Either host name e.g haskell.org or numeric host address string consisting of dotted decimal IPv4 address or an IPv6 address e.g",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "HostName",
          "package": "network",
          "partial": "Host Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:HostName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "NetworkAddr",
          "package": "network",
          "source": "src/Network-BSD.html#NetworkAddr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "NetworkAddr",
          "package": "network",
          "partial": "Network Addr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:NetworkAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "NetworkEntry",
          "package": "network",
          "source": "src/Network-BSD.html#NetworkEntry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "NetworkEntry",
          "package": "network",
          "partial": "Network Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:NetworkEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "NetworkName",
          "package": "network",
          "source": "src/Network-BSD.html#NetworkName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "NetworkName",
          "package": "network",
          "partial": "Network Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:NetworkName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "PortNumber",
          "package": "network",
          "source": "src/Network-Socket-Types.html#PortNumber",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "PortNumber",
          "package": "network",
          "partial": "Port Number",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:PortNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "ProtocolEntry",
          "package": "network",
          "source": "src/Network-BSD.html#ProtocolEntry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "ProtocolEntry",
          "package": "network",
          "partial": "Protocol Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:ProtocolEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "ProtocolName",
          "package": "network",
          "source": "src/Network-BSD.html#ProtocolName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "ProtocolName",
          "package": "network",
          "partial": "Protocol Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:ProtocolName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "ProtocolNumber",
          "package": "network",
          "source": "src/Network-Socket-Types.html#ProtocolNumber",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "ProtocolNumber",
          "package": "network",
          "partial": "Protocol Number",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:ProtocolNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "ServiceEntry",
          "package": "network",
          "source": "src/Network-BSD.html#ServiceEntry",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "ServiceEntry",
          "package": "network",
          "partial": "Service Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:ServiceEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "ServiceName",
          "package": "network",
          "source": "src/Network-Socket.html#ServiceName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "ServiceName",
          "package": "network",
          "partial": "Service Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#t:ServiceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "HostEntry",
          "package": "network",
          "signature": "HostEntry",
          "source": "src/Network-BSD.html#HostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "HostEntry",
          "package": "network",
          "partial": "Host Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:HostEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "NetworkEntry",
          "package": "network",
          "signature": "NetworkEntry",
          "source": "src/Network-BSD.html#NetworkEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "NetworkEntry",
          "package": "network",
          "partial": "Network Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:NetworkEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "ProtocolEntry",
          "package": "network",
          "signature": "ProtocolEntry",
          "source": "src/Network-BSD.html#ProtocolEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "ProtocolEntry",
          "package": "network",
          "partial": "Protocol Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:ProtocolEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "ServiceEntry",
          "package": "network",
          "signature": "ServiceEntry",
          "source": "src/Network-BSD.html#ServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "ServiceEntry",
          "package": "network",
          "partial": "Service Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:ServiceEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the default protocol for a given service.\n\u003c/p\u003e",
          "module": "[\"Network.BSD\",\"Network.Socket\"]",
          "name": "defaultProtocol",
          "package": "network",
          "signature": "ProtocolNumber",
          "source": "src/Network-Socket.html#defaultProtocol",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:defaultProtocol\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:defaultProtocol\"]"
        },
        "index": {
          "description": "This is the default protocol for given service",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "defaultProtocol",
          "package": "network",
          "partial": "Protocol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:defaultProtocol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "endHostEntry",
          "package": "network",
          "signature": "IO ()",
          "source": "src/Network-BSD.html#endHostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "endHostEntry",
          "normalized": "IO()",
          "package": "network",
          "partial": "Host Entry",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:endHostEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose the connection to the network name database.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "endNetworkEntry",
          "package": "network",
          "signature": "IO ()",
          "source": "src/Network-BSD.html#endNetworkEntry",
          "type": "function"
        },
        "index": {
          "description": "Close the connection to the network name database",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "endNetworkEntry",
          "normalized": "IO()",
          "package": "network",
          "partial": "Network Entry",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:endNetworkEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "endProtocolEntry",
          "package": "network",
          "signature": "IO ()",
          "source": "src/Network-BSD.html#endProtocolEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "endProtocolEntry",
          "normalized": "IO()",
          "package": "network",
          "partial": "Protocol Entry",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:endProtocolEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "endServiceEntry",
          "package": "network",
          "signature": "IO ()",
          "source": "src/Network-BSD.html#endServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "endServiceEntry",
          "normalized": "IO()",
          "package": "network",
          "partial": "Service Entry",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:endServiceEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a \u003ccode\u003e\u003ca\u003eHostEntry\u003c/a\u003e\u003c/code\u003e corresponding to the given address and family.\n Note that only IPv4 is currently supported.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "getHostByAddr",
          "package": "network",
          "signature": "Family -\u003e HostAddress -\u003e IO HostEntry",
          "source": "src/Network-BSD.html#getHostByAddr",
          "type": "function"
        },
        "index": {
          "description": "Get HostEntry corresponding to the given address and family Note that only IPv4 is currently supported",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getHostByAddr",
          "normalized": "Family-\u003eHostAddress-\u003eIO HostEntry",
          "package": "network",
          "partial": "Host By Addr",
          "signature": "Family-\u003eHostAddress-\u003eIO HostEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getHostByAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve a \u003ccode\u003e\u003ca\u003eHostName\u003c/a\u003e\u003c/code\u003e to IPv4 address.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "getHostByName",
          "package": "network",
          "signature": "HostName -\u003e IO HostEntry",
          "source": "src/Network-BSD.html#getHostByName",
          "type": "function"
        },
        "index": {
          "description": "Resolve HostName to IPv4 address",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getHostByName",
          "normalized": "HostName-\u003eIO HostEntry",
          "package": "network",
          "partial": "Host By Name",
          "signature": "HostName-\u003eIO HostEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getHostByName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getHostEntries",
          "package": "network",
          "signature": "Bool -\u003e IO [HostEntry]",
          "source": "src/Network-BSD.html#getHostEntries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getHostEntries",
          "normalized": "Bool-\u003eIO[HostEntry]",
          "package": "network",
          "partial": "Host Entries",
          "signature": "Bool-\u003eIO[HostEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getHostEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getHostEntry",
          "package": "network",
          "signature": "IO HostEntry",
          "source": "src/Network-BSD.html#getHostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getHostEntry",
          "package": "network",
          "partial": "Host Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getHostEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalling getHostName returns the standard host name for the current\n processor, as set at boot time.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "getHostName",
          "package": "network",
          "signature": "IO HostName",
          "source": "src/Network-BSD.html#getHostName",
          "type": "function"
        },
        "index": {
          "description": "Calling getHostName returns the standard host name for the current processor as set at boot time",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getHostName",
          "package": "network",
          "partial": "Host Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getHostName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getNetworkByAddr",
          "package": "network",
          "signature": "NetworkAddr -\u003e Family -\u003e IO NetworkEntry",
          "source": "src/Network-BSD.html#getNetworkByAddr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getNetworkByAddr",
          "normalized": "NetworkAddr-\u003eFamily-\u003eIO NetworkEntry",
          "package": "network",
          "partial": "Network By Addr",
          "signature": "NetworkAddr-\u003eFamily-\u003eIO NetworkEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getNetworkByAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getNetworkByName",
          "package": "network",
          "signature": "NetworkName -\u003e IO NetworkEntry",
          "source": "src/Network-BSD.html#getNetworkByName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getNetworkByName",
          "normalized": "NetworkName-\u003eIO NetworkEntry",
          "package": "network",
          "partial": "Network By Name",
          "signature": "NetworkName-\u003eIO NetworkEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getNetworkByName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the list of network entries.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "getNetworkEntries",
          "package": "network",
          "signature": "Bool -\u003e IO [NetworkEntry]",
          "source": "src/Network-BSD.html#getNetworkEntries",
          "type": "function"
        },
        "index": {
          "description": "Get the list of network entries",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getNetworkEntries",
          "normalized": "Bool-\u003eIO[NetworkEntry]",
          "package": "network",
          "partial": "Network Entries",
          "signature": "Bool-\u003eIO[NetworkEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getNetworkEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getNetworkEntry",
          "package": "network",
          "signature": "IO NetworkEntry",
          "source": "src/Network-BSD.html#getNetworkEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getNetworkEntry",
          "package": "network",
          "partial": "Network Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getNetworkEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getProtocolByName",
          "package": "network",
          "signature": "ProtocolName -\u003e IO ProtocolEntry",
          "source": "src/Network-BSD.html#getProtocolByName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getProtocolByName",
          "normalized": "ProtocolName-\u003eIO ProtocolEntry",
          "package": "network",
          "partial": "Protocol By Name",
          "signature": "ProtocolName-\u003eIO ProtocolEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getProtocolByName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getProtocolByNumber",
          "package": "network",
          "signature": "ProtocolNumber -\u003e IO ProtocolEntry",
          "source": "src/Network-BSD.html#getProtocolByNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getProtocolByNumber",
          "normalized": "ProtocolNumber-\u003eIO ProtocolEntry",
          "package": "network",
          "partial": "Protocol By Number",
          "signature": "ProtocolNumber-\u003eIO ProtocolEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getProtocolByNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getProtocolEntries",
          "package": "network",
          "signature": "Bool -\u003e IO [ProtocolEntry]",
          "source": "src/Network-BSD.html#getProtocolEntries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getProtocolEntries",
          "normalized": "Bool-\u003eIO[ProtocolEntry]",
          "package": "network",
          "partial": "Protocol Entries",
          "signature": "Bool-\u003eIO[ProtocolEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getProtocolEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getProtocolEntry",
          "package": "network",
          "signature": "IO ProtocolEntry",
          "source": "src/Network-BSD.html#getProtocolEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getProtocolEntry",
          "package": "network",
          "partial": "Protocol Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getProtocolEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getProtocolNumber",
          "package": "network",
          "signature": "ProtocolName -\u003e IO ProtocolNumber",
          "source": "src/Network-BSD.html#getProtocolNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getProtocolNumber",
          "normalized": "ProtocolName-\u003eIO ProtocolNumber",
          "package": "network",
          "partial": "Protocol Number",
          "signature": "ProtocolName-\u003eIO ProtocolNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getProtocolNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet service by name.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "getServiceByName",
          "package": "network",
          "signature": "ServiceName -\u003e ProtocolName -\u003e IO ServiceEntry",
          "source": "src/Network-BSD.html#getServiceByName",
          "type": "function"
        },
        "index": {
          "description": "Get service by name",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getServiceByName",
          "normalized": "ServiceName-\u003eProtocolName-\u003eIO ServiceEntry",
          "package": "network",
          "partial": "Service By Name",
          "signature": "ServiceName-\u003eProtocolName-\u003eIO ServiceEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getServiceByName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the service given a \u003ccode\u003e\u003ca\u003ePortNumber\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eProtocolName\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "getServiceByPort",
          "package": "network",
          "signature": "PortNumber -\u003e ProtocolName -\u003e IO ServiceEntry",
          "source": "src/Network-BSD.html#getServiceByPort",
          "type": "function"
        },
        "index": {
          "description": "Get the service given PortNumber and ProtocolName",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getServiceByPort",
          "normalized": "PortNumber-\u003eProtocolName-\u003eIO ServiceEntry",
          "package": "network",
          "partial": "Service By Port",
          "signature": "PortNumber-\u003eProtocolName-\u003eIO ServiceEntry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getServiceByPort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getServiceEntries",
          "package": "network",
          "signature": "Bool -\u003e IO [ServiceEntry]",
          "source": "src/Network-BSD.html#getServiceEntries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getServiceEntries",
          "normalized": "Bool-\u003eIO[ServiceEntry]",
          "package": "network",
          "partial": "Service Entries",
          "signature": "Bool-\u003eIO[ServiceEntry]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getServiceEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "getServiceEntry",
          "package": "network",
          "signature": "IO ServiceEntry",
          "source": "src/Network-BSD.html#getServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getServiceEntry",
          "package": "network",
          "partial": "Service Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getServiceEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the \u003ccode\u003e\u003ca\u003ePortNumber\u003c/a\u003e\u003c/code\u003e corresponding to the \u003ccode\u003e\u003ca\u003eServiceName\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "getServicePortNumber",
          "package": "network",
          "signature": "ServiceName -\u003e IO PortNumber",
          "source": "src/Network-BSD.html#getServicePortNumber",
          "type": "function"
        },
        "index": {
          "description": "Get the PortNumber corresponding to the ServiceName",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "getServicePortNumber",
          "normalized": "ServiceName-\u003eIO PortNumber",
          "package": "network",
          "partial": "Service Port Number",
          "signature": "ServiceName-\u003eIO PortNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:getServicePortNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "hostAddress",
          "package": "network",
          "signature": "HostEntry -\u003e HostAddress",
          "source": "src/Network-BSD.html#hostAddress",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "hostAddress",
          "normalized": "HostEntry-\u003eHostAddress",
          "package": "network",
          "partial": "Address",
          "signature": "HostEntry-\u003eHostAddress",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:hostAddress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "hostAddresses",
          "package": "network",
          "signature": "[HostAddress]",
          "source": "src/Network-BSD.html#HostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "hostAddresses",
          "normalized": "[HostAddress]",
          "package": "network",
          "partial": "Addresses",
          "signature": "[HostAddress]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:hostAddresses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "hostAliases",
          "package": "network",
          "signature": "[HostName]",
          "source": "src/Network-BSD.html#HostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "hostAliases",
          "normalized": "[HostName]",
          "package": "network",
          "partial": "Aliases",
          "signature": "[HostName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:hostAliases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "hostFamily",
          "package": "network",
          "signature": "Family",
          "source": "src/Network-BSD.html#HostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "hostFamily",
          "package": "network",
          "partial": "Family",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:hostFamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "hostName",
          "package": "network",
          "signature": "HostName",
          "source": "src/Network-BSD.html#HostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "hostName",
          "package": "network",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:hostName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "networkAddress",
          "package": "network",
          "signature": "NetworkAddr",
          "source": "src/Network-BSD.html#NetworkEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "networkAddress",
          "package": "network",
          "partial": "Address",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:networkAddress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "networkAliases",
          "package": "network",
          "signature": "[NetworkName]",
          "source": "src/Network-BSD.html#NetworkEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "networkAliases",
          "normalized": "[NetworkName]",
          "package": "network",
          "partial": "Aliases",
          "signature": "[NetworkName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:networkAliases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "networkFamily",
          "package": "network",
          "signature": "Family",
          "source": "src/Network-BSD.html#NetworkEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "networkFamily",
          "package": "network",
          "partial": "Family",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:networkFamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "networkName",
          "package": "network",
          "signature": "NetworkName",
          "source": "src/Network-BSD.html#NetworkEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "networkName",
          "package": "network",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:networkName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "protoAliases",
          "package": "network",
          "signature": "[ProtocolName]",
          "source": "src/Network-BSD.html#ProtocolEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "protoAliases",
          "normalized": "[ProtocolName]",
          "package": "network",
          "partial": "Aliases",
          "signature": "[ProtocolName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:protoAliases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "protoName",
          "package": "network",
          "signature": "ProtocolName",
          "source": "src/Network-BSD.html#ProtocolEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "protoName",
          "package": "network",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:protoName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "protoNumber",
          "package": "network",
          "signature": "ProtocolNumber",
          "source": "src/Network-BSD.html#ProtocolEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "protoNumber",
          "package": "network",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:protoNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "serviceAliases",
          "package": "network",
          "signature": "[ServiceName]",
          "source": "src/Network-BSD.html#ServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "serviceAliases",
          "normalized": "[ServiceName]",
          "package": "network",
          "partial": "Aliases",
          "signature": "[ServiceName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:serviceAliases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "serviceName",
          "package": "network",
          "signature": "ServiceName",
          "source": "src/Network-BSD.html#ServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "serviceName",
          "package": "network",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:serviceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "servicePort",
          "package": "network",
          "signature": "PortNumber",
          "source": "src/Network-BSD.html#ServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "servicePort",
          "package": "network",
          "partial": "Port",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:servicePort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "serviceProtocol",
          "package": "network",
          "signature": "ProtocolName",
          "source": "src/Network-BSD.html#ServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "serviceProtocol",
          "package": "network",
          "partial": "Protocol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:serviceProtocol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "setHostEntry",
          "package": "network",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Network-BSD.html#setHostEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "setHostEntry",
          "normalized": "Bool-\u003eIO()",
          "package": "network",
          "partial": "Host Entry",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:setHostEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen the network name database. The parameter specifies\n whether a connection is maintained open between various\n networkEntry calls\n\u003c/p\u003e",
          "module": "Network.BSD",
          "name": "setNetworkEntry",
          "package": "network",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Network-BSD.html#setNetworkEntry",
          "type": "function"
        },
        "index": {
          "description": "Open the network name database The parameter specifies whether connection is maintained open between various networkEntry calls",
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "setNetworkEntry",
          "normalized": "Bool-\u003eIO()",
          "package": "network",
          "partial": "Network Entry",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:setNetworkEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "setProtocolEntry",
          "package": "network",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Network-BSD.html#setProtocolEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "setProtocolEntry",
          "normalized": "Bool-\u003eIO()",
          "package": "network",
          "partial": "Protocol Entry",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:setProtocolEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.BSD",
          "name": "setServiceEntry",
          "package": "network",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Network-BSD.html#setServiceEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network BSD",
          "module": "Network.BSD",
          "name": "setServiceEntry",
          "normalized": "Bool-\u003eIO()",
          "package": "network",
          "partial": "Service Entry",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-BSD.html#v:setServiceEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides access to the BSD \u003cem\u003esocket\u003c/em\u003e interface.  This\n module is generally more efficient than the \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e based network\n functions in \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e.  For detailed documentation, consult\n your favorite POSIX socket reference. All functions communicate\n failures by converting the error number to \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis module is made to be imported with \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e like so:\n\u003c/p\u003e\u003cpre\u003e import Network.Socket hiding (send, sendTo, recv, recvFrom)\n import Network.Socket.ByteString.Lazy\n import Prelude hiding (getContents)\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "Lazy",
          "package": "network",
          "source": "src/Network-Socket-ByteString-Lazy.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides access to the BSD socket interface This module is generally more efficient than the String based network functions in Socket For detailed documentation consult your favorite POSIX socket reference All functions communicate failures by converting the error number to IOError This module is made to be imported with Socket like so import Network.Socket hiding send sendTo recv recvFrom import Network.Socket.ByteString.Lazy import Prelude hiding getContents",
          "hierarchy": "Network Socket ByteString Lazy",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "Lazy",
          "package": "network",
          "partial": "Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString-Lazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket.  The socket must be in a connected\n state.  Data is received on demand, in chunks; each chunk will be\n sized to reflect the amount of data received by individual \u003ccode\u003e\u003ca\u003erecv\u003c/a\u003e\u003c/code\u003e\n calls.\n\u003c/p\u003e\u003cp\u003eAll remaining data from the socket is consumed.  When there is no\n more data to be received, the receiving side of the socket is shut\n down.  If there is an error and an exception is thrown, the socket\n is not shut down.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "getContents",
          "package": "network",
          "signature": "Socket-\u003e IO ByteString",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket The socket must be in connected state Data is received on demand in chunks each chunk will be sized to reflect the amount of data received by individual recv calls All remaining data from the socket is consumed When there is no more data to be received the receiving side of the socket is shut down If there is an error and an exception is thrown the socket is not shut down",
          "hierarchy": "Network Socket ByteString Lazy",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "getContents",
          "normalized": "Socket-\u003eIO ByteString",
          "package": "network",
          "partial": "Contents",
          "signature": "Socket-\u003eIO ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString-Lazy.html#v:getContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket.  The socket must be in a connected\n state.  This function may return fewer bytes than specified.  If\n the received data is longer than the specified length, it may be\n discarded depending on the type of socket.  This function may block\n until a message arrives.\n\u003c/p\u003e\u003cp\u003eIf there is no more data to be received, returns an empty \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "recv",
          "package": "network",
          "signature": "Socket-\u003e Int64-\u003e IO ByteString",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket The socket must be in connected state This function may return fewer bytes than specified If the received data is longer than the specified length it may be discarded depending on the type of socket This function may block until message arrives If there is no more data to be received returns an empty ByteString",
          "hierarchy": "Network Socket ByteString Lazy",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "recv",
          "normalized": "Socket-\u003eInt-\u003eIO ByteString",
          "package": "network",
          "signature": "Socket-\u003eInt-\u003eIO ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString-Lazy.html#v:recv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket. The socket must be in a connected state.\n Returns the number of bytes sent. Applications are responsible for\n ensuring that all data has been sent.\n\u003c/p\u003e\u003cp\u003eBecause a lazily generated \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e may be arbitrarily long,\n this function caps the amount it will attempt to send at 4MB.  This\n number is large (so it should not penalize performance on fast\n networks), but not outrageously so (to avoid demanding lazily\n computed data unnecessarily early).  Before being sent, the lazy\n \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e will be converted to a list of strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003es\n with \u003ccode\u003e\u003ca\u003etoChunks\u003c/a\u003e\u003c/code\u003e; at most 1024 chunks will be sent.  \u003cem\u003eUnix only\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "send",
          "package": "network",
          "signature": "Socket-\u003e ByteString-\u003e IO Int64",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The socket must be in connected state Returns the number of bytes sent Applications are responsible for ensuring that all data has been sent Because lazily generated ByteString may be arbitrarily long this function caps the amount it will attempt to send at MB This number is large so it should not penalize performance on fast networks but not outrageously so to avoid demanding lazily computed data unnecessarily early Before being sent the lazy ByteString will be converted to list of strict ByteString with toChunks at most chunks will be sent Unix only",
          "hierarchy": "Network Socket ByteString Lazy",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "send",
          "normalized": "Socket-\u003eByteString-\u003eIO Int",
          "package": "network",
          "signature": "Socket-\u003eByteString-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString-Lazy.html#v:send"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The socket must be in a connected\n state. This function continues to send data until either all data\n has been sent or an error occurs.  If there is an error, an\n exception is raised, and there is no way to determine how much data\n was sent.  \u003cem\u003eUnix only\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "sendAll",
          "package": "network",
          "signature": "Socket-\u003e ByteString-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The socket must be in connected state This function continues to send data until either all data has been sent or an error occurs If there is an error an exception is raised and there is no way to determine how much data was sent Unix only",
          "hierarchy": "Network Socket ByteString Lazy",
          "module": "Network.Socket.ByteString.Lazy",
          "name": "sendAll",
          "normalized": "Socket-\u003eByteString-\u003eIO()",
          "package": "network",
          "partial": "All",
          "signature": "Socket-\u003eByteString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString-Lazy.html#v:sendAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides access to the BSD \u003cem\u003esocket\u003c/em\u003e interface.  This\n module is generally more efficient than the \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e based network\n functions in \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e.  For detailed documentation, consult\n your favorite POSIX socket reference. All functions communicate\n failures by converting the error number to \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis module is made to be imported with \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e like so:\n\u003c/p\u003e\u003cpre\u003e import Network.Socket hiding (send, sendTo, recv, recvFrom)\n import Network.Socket.ByteString\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Network.Socket.ByteString",
          "name": "ByteString",
          "package": "network",
          "source": "src/Network-Socket-ByteString.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides access to the BSD socket interface This module is generally more efficient than the String based network functions in Socket For detailed documentation consult your favorite POSIX socket reference All functions communicate failures by converting the error number to IOError This module is made to be imported with Socket like so import Network.Socket hiding send sendTo recv recvFrom import Network.Socket.ByteString",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "ByteString",
          "package": "network",
          "partial": "Byte String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket.  The socket must be in a connected\n state.  This function may return fewer bytes than specified.  If\n the message is longer than the specified length, it may be\n discarded depending on the type of socket.  This function may block\n until a message arrives.\n\u003c/p\u003e\u003cp\u003eConsidering hardware and network realities, the maximum number of bytes to\n receive should be a small power of 2, e.g., 4096.\n\u003c/p\u003e\u003cp\u003eFor TCP sockets, a zero length return value means the peer has\n closed its half side of the connection.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "recv",
          "package": "network",
          "signature": "Socket-\u003e Int-\u003e IO ByteString",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket The socket must be in connected state This function may return fewer bytes than specified If the message is longer than the specified length it may be discarded depending on the type of socket This function may block until message arrives Considering hardware and network realities the maximum number of bytes to receive should be small power of e.g For TCP sockets zero length return value means the peer has closed its half side of the connection",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "recv",
          "normalized": "Socket-\u003eInt-\u003eIO ByteString",
          "package": "network",
          "signature": "Socket-\u003eInt-\u003eIO ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:recv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket.  The socket need not be in a\n connected state.  Returns \u003ccode\u003e(bytes, address)\u003c/code\u003e where \u003ccode\u003ebytes\u003c/code\u003e is a\n \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e representing the data received and \u003ccode\u003eaddress\u003c/code\u003e is a\n \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e representing the address of the sending socket.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "recvFrom",
          "package": "network",
          "signature": "Socket-\u003e Int-\u003e IO (ByteString, SockAddr)",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket The socket need not be in connected state Returns bytes address where bytes is ByteString representing the data received and address is SockAddr representing the address of the sending socket",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "recvFrom",
          "normalized": "Socket-\u003eInt-\u003eIO(ByteString,SockAddr)",
          "package": "network",
          "partial": "From",
          "signature": "Socket-\u003eInt-\u003eIO(ByteString,SockAddr)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:recvFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The socket must be connected to a\n remote socket.  Returns the number of bytes sent. Applications are\n responsible for ensuring that all data has been sent.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "send",
          "package": "network",
          "signature": "Socket-\u003e ByteString-\u003e IO Int",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The socket must be connected to remote socket Returns the number of bytes sent Applications are responsible for ensuring that all data has been sent",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "send",
          "normalized": "Socket-\u003eByteString-\u003eIO Int",
          "package": "network",
          "signature": "Socket-\u003eByteString-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:send"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The socket must be connected to a\n remote socket.  Unlike \u003ccode\u003e\u003ca\u003esend\u003c/a\u003e\u003c/code\u003e, this function continues to send data\n until either all data has been sent or an error occurs.  On error,\n an exception is raised, and there is no way to determine how much\n data, if any, was successfully sent.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "sendAll",
          "package": "network",
          "signature": "Socket-\u003e ByteString-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The socket must be connected to remote socket Unlike send this function continues to send data until either all data has been sent or an error occurs On error an exception is raised and there is no way to determine how much data if any was successfully sent",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "sendAll",
          "normalized": "Socket-\u003eByteString-\u003eIO()",
          "package": "network",
          "partial": "All",
          "signature": "Socket-\u003eByteString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:sendAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket. The recipient can be specified\n explicitly, so the socket need not be in a connected state.  Unlike\n \u003ccode\u003e\u003ca\u003esendTo\u003c/a\u003e\u003c/code\u003e, this function continues to send data until either all\n data has been sent or an error occurs.  On error, an exception is\n raised, and there is no way to determine how much data, if any, was\n successfully sent.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "sendAllTo",
          "package": "network",
          "signature": "Socket-\u003e ByteString-\u003e SockAddr-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The recipient can be specified explicitly so the socket need not be in connected state Unlike sendTo this function continues to send data until either all data has been sent or an error occurs On error an exception is raised and there is no way to determine how much data if any was successfully sent",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "sendAllTo",
          "normalized": "Socket-\u003eByteString-\u003eSockAddr-\u003eIO()",
          "package": "network",
          "partial": "All To",
          "signature": "Socket-\u003eByteString-\u003eSockAddr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:sendAllTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The socket must be in a connected\n state.  The data is sent as if the parts have been concatenated.\n This function continues to send data until either all data has been\n sent or an error occurs.  On error, an exception is raised, and\n there is no way to determine how much data, if any, was\n successfully sent.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "sendMany",
          "package": "network",
          "signature": "Socket-\u003e [ByteString]-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The socket must be in connected state The data is sent as if the parts have been concatenated This function continues to send data until either all data has been sent or an error occurs On error an exception is raised and there is no way to determine how much data if any was successfully sent",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "sendMany",
          "normalized": "Socket-\u003e[ByteString]-\u003eIO()",
          "package": "network",
          "partial": "Many",
          "signature": "Socket-\u003e[ByteString]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:sendMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The recipient can be specified\n explicitly, so the socket need not be in a connected state.  The\n data is sent as if the parts have been concatenated.  This function\n continues to send data until either all data has been sent or an\n error occurs.  On error, an exception is raised, and there is no\n way to determine how much data, if any, was successfully sent.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "sendManyTo",
          "package": "network",
          "signature": "Socket-\u003e [ByteString]-\u003e SockAddr-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The recipient can be specified explicitly so the socket need not be in connected state The data is sent as if the parts have been concatenated This function continues to send data until either all data has been sent or an error occurs On error an exception is raised and there is no way to determine how much data if any was successfully sent",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "sendManyTo",
          "normalized": "Socket-\u003e[ByteString]-\u003eSockAddr-\u003eIO()",
          "package": "network",
          "partial": "Many To",
          "signature": "Socket-\u003e[ByteString]-\u003eSockAddr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:sendManyTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The recipient can be specified\n explicitly, so the socket need not be in a connected state.\n Returns the number of bytes sent. Applications are responsible for\n ensuring that all data has been sent.\n\u003c/p\u003e",
          "module": "Network.Socket.ByteString",
          "name": "sendTo",
          "package": "network",
          "signature": "Socket-\u003e ByteString-\u003e SockAddr-\u003e IO Int",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The recipient can be specified explicitly so the socket need not be in connected state Returns the number of bytes sent Applications are responsible for ensuring that all data has been sent",
          "hierarchy": "Network Socket ByteString",
          "module": "Network.Socket.ByteString",
          "name": "sendTo",
          "normalized": "Socket-\u003eByteString-\u003eSockAddr-\u003eIO Int",
          "package": "network",
          "partial": "To",
          "signature": "Socket-\u003eByteString-\u003eSockAddr-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-ByteString.html#v:sendTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module containing semi-public \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e internals.\n Modules which extend the \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e module will need to use\n this module while ideally most users will be able to make do with\n the public interface.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.Socket.Internal",
          "name": "Internal",
          "package": "network",
          "source": "src/Network-Socket-Internal.html",
          "type": "module"
        },
        "index": {
          "description": "module containing semi-public Socket internals Modules which extend the Socket module will need to use this module while ideally most users will be able to make do with the public interface",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "Internal",
          "package": "network",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddress families.\n\u003c/p\u003e\u003cp\u003eA constructor being present here does not mean it is supported by the\n operating system: see \u003ccode\u003e\u003ca\u003eisSupportedFamily\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "Family",
          "package": "network",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "data"
        },
        "index": {
          "description": "Address families constructor being present here does not mean it is supported by the operating system see isSupportedFamily",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "Family",
          "package": "network",
          "partial": "Family",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#t:Family"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket.Internal",
          "name": "FlowInfo",
          "package": "network",
          "source": "src/Network-Socket-Types.html#FlowInfo",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "FlowInfo",
          "package": "network",
          "partial": "Flow Info",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#t:FlowInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNetwork byte order.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "HostAddress",
          "package": "network",
          "source": "src/Network-Socket-Types.html#HostAddress",
          "type": "type"
        },
        "index": {
          "description": "Network byte order",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "HostAddress",
          "package": "network",
          "partial": "Host Address",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#t:HostAddress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHost byte order.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "HostAddress6",
          "package": "network",
          "source": "src/Network-Socket-Types.html#HostAddress6",
          "type": "type"
        },
        "index": {
          "description": "Host byte order",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "HostAddress6",
          "package": "network",
          "partial": "Host Address",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#t:HostAddress6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket.Internal",
          "name": "PortNumber",
          "package": "network",
          "source": "src/Network-Socket-Types.html#PortNumber",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "PortNumber",
          "package": "network",
          "partial": "Port Number",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#t:PortNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket.Internal",
          "name": "ScopeID",
          "package": "network",
          "source": "src/Network-Socket-Types.html#ScopeID",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "ScopeID",
          "package": "network",
          "partial": "Scope ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#t:ScopeID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket.Internal",
          "name": "SockAddr",
          "package": "network",
          "source": "src/Network-Socket-Types.html#SockAddr",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "SockAddr",
          "package": "network",
          "partial": "Sock Addr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#t:SockAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_802",
          "package": "network",
          "signature": "AF_802",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_802\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_802\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_802",
          "package": "network",
          "partial": "AF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_802"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_APPLETALK",
          "package": "network",
          "signature": "AF_APPLETALK",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_APPLETALK\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_APPLETALK\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_APPLETALK",
          "package": "network",
          "partial": "AF APPLETALK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_APPLETALK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ARP",
          "package": "network",
          "signature": "AF_ARP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ARP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ARP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ARP",
          "package": "network",
          "partial": "AF ARP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ARP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ASH",
          "package": "network",
          "signature": "AF_ASH",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ASH\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ASH\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ASH",
          "package": "network",
          "partial": "AF ASH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ASH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ATMPVC",
          "package": "network",
          "signature": "AF_ATMPVC",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ATMPVC\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ATMPVC\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ATMPVC",
          "package": "network",
          "partial": "AF ATMPVC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ATMPVC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ATMSVC",
          "package": "network",
          "signature": "AF_ATMSVC",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ATMSVC\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ATMSVC\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ATMSVC",
          "package": "network",
          "partial": "AF ATMSVC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ATMSVC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_AX25",
          "package": "network",
          "signature": "AF_AX25",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_AX25\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_AX25\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_AX25",
          "package": "network",
          "partial": "AF AX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_AX25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_BLUETOOTH",
          "package": "network",
          "signature": "AF_BLUETOOTH",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_BLUETOOTH\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_BLUETOOTH\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_BLUETOOTH",
          "package": "network",
          "partial": "AF BLUETOOTH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_BLUETOOTH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_BRIDGE",
          "package": "network",
          "signature": "AF_BRIDGE",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_BRIDGE\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_BRIDGE\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_BRIDGE",
          "package": "network",
          "partial": "AF BRIDGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_BRIDGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_CCITT",
          "package": "network",
          "signature": "AF_CCITT",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CCITT\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_CCITT\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_CCITT",
          "package": "network",
          "partial": "AF CCITT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CCITT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_CHAOS",
          "package": "network",
          "signature": "AF_CHAOS",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CHAOS\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_CHAOS\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_CHAOS",
          "package": "network",
          "partial": "AF CHAOS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CHAOS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_CNT",
          "package": "network",
          "signature": "AF_CNT",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CNT\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_CNT\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_CNT",
          "package": "network",
          "partial": "AF CNT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CNT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_COIP",
          "package": "network",
          "signature": "AF_COIP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_COIP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_COIP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_COIP",
          "package": "network",
          "partial": "AF COIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_COIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_CTF",
          "package": "network",
          "signature": "AF_CTF",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CTF\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_CTF\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_CTF",
          "package": "network",
          "partial": "AF CTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_CTF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_DATAKIT",
          "package": "network",
          "signature": "AF_DATAKIT",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_DATAKIT\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_DATAKIT\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_DATAKIT",
          "package": "network",
          "partial": "AF DATAKIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_DATAKIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_DECnet",
          "package": "network",
          "signature": "AF_DECnet",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_DECnet\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_DECnet\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_DECnet",
          "package": "network",
          "partial": "AF DECnet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_DECnet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_DLI",
          "package": "network",
          "signature": "AF_DLI",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_DLI\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_DLI\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_DLI",
          "package": "network",
          "partial": "AF DLI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_DLI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ECMA",
          "package": "network",
          "signature": "AF_ECMA",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ECMA\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ECMA\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ECMA",
          "package": "network",
          "partial": "AF ECMA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ECMA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ECONET",
          "package": "network",
          "signature": "AF_ECONET",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ECONET\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ECONET\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ECONET",
          "package": "network",
          "partial": "AF ECONET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ECONET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ENCAP",
          "package": "network",
          "signature": "AF_ENCAP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ENCAP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ENCAP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ENCAP",
          "package": "network",
          "partial": "AF ENCAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ENCAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_GOSSIP",
          "package": "network",
          "signature": "AF_GOSSIP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_GOSSIP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_GOSSIP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_GOSSIP",
          "package": "network",
          "partial": "AF GOSSIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_GOSSIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_HYLINK",
          "package": "network",
          "signature": "AF_HYLINK",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_HYLINK\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_HYLINK\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_HYLINK",
          "package": "network",
          "partial": "AF HYLINK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_HYLINK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_IMPLINK",
          "package": "network",
          "signature": "AF_IMPLINK",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_IMPLINK\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_IMPLINK\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_IMPLINK",
          "package": "network",
          "partial": "AF IMPLINK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_IMPLINK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_INET",
          "package": "network",
          "signature": "AF_INET",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_INET\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_INET\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_INET",
          "package": "network",
          "partial": "AF INET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_INET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_INET6",
          "package": "network",
          "signature": "AF_INET6",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_INET6\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_INET6\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_INET6",
          "package": "network",
          "partial": "AF INET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_INET6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_INTF",
          "package": "network",
          "signature": "AF_INTF",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_INTF\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_INTF\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_INTF",
          "package": "network",
          "partial": "AF INTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_INTF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_IPX",
          "package": "network",
          "signature": "AF_IPX",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_IPX\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_IPX\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_IPX",
          "package": "network",
          "partial": "AF IPX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_IPX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_IRDA",
          "package": "network",
          "signature": "AF_IRDA",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_IRDA\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_IRDA\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_IRDA",
          "package": "network",
          "partial": "AF IRDA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_IRDA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ISDN",
          "package": "network",
          "signature": "AF_ISDN",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ISDN\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ISDN\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ISDN",
          "package": "network",
          "partial": "AF ISDN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ISDN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ISO",
          "package": "network",
          "signature": "AF_ISO",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ISO\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ISO\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ISO",
          "package": "network",
          "partial": "AF ISO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ISO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_LAT",
          "package": "network",
          "signature": "AF_LAT",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_LAT\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_LAT\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_LAT",
          "package": "network",
          "partial": "AF LAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_LAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_LINK",
          "package": "network",
          "signature": "AF_LINK",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_LINK\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_LINK\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_LINK",
          "package": "network",
          "partial": "AF LINK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_LINK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NATM",
          "package": "network",
          "signature": "AF_NATM",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NATM\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NATM\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NATM",
          "package": "network",
          "partial": "AF NATM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NATM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NBS",
          "package": "network",
          "signature": "AF_NBS",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NBS\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NBS\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NBS",
          "package": "network",
          "partial": "AF NBS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NBS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NDD",
          "package": "network",
          "signature": "AF_NDD",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NDD\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NDD\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NDD",
          "package": "network",
          "partial": "AF NDD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NDD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NETBEUI",
          "package": "network",
          "signature": "AF_NETBEUI",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETBEUI\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NETBEUI\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NETBEUI",
          "package": "network",
          "partial": "AF NETBEUI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETBEUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NETBIOS",
          "package": "network",
          "signature": "AF_NETBIOS",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETBIOS\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NETBIOS\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NETBIOS",
          "package": "network",
          "partial": "AF NETBIOS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETBIOS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NETMAN",
          "package": "network",
          "signature": "AF_NETMAN",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETMAN\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NETMAN\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NETMAN",
          "package": "network",
          "partial": "AF NETMAN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETMAN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NETROM",
          "package": "network",
          "signature": "AF_NETROM",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETROM\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NETROM\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NETROM",
          "package": "network",
          "partial": "AF NETROM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETROM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NETWARE",
          "package": "network",
          "signature": "AF_NETWARE",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETWARE\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NETWARE\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NETWARE",
          "package": "network",
          "partial": "AF NETWARE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NETWARE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NIT",
          "package": "network",
          "signature": "AF_NIT",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NIT\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NIT\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NIT",
          "package": "network",
          "partial": "AF NIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_NS",
          "package": "network",
          "signature": "AF_NS",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NS\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_NS\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_NS",
          "package": "network",
          "partial": "AF NS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_NS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_OSI",
          "package": "network",
          "signature": "AF_OSI",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_OSI\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_OSI\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_OSI",
          "package": "network",
          "partial": "AF OSI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_OSI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_OSINET",
          "package": "network",
          "signature": "AF_OSINET",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_OSINET\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_OSINET\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_OSINET",
          "package": "network",
          "partial": "AF OSINET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_OSINET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_PACKET",
          "package": "network",
          "signature": "AF_PACKET",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_PACKET\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_PACKET\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_PACKET",
          "package": "network",
          "partial": "AF PACKET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_PACKET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_PPPOX",
          "package": "network",
          "signature": "AF_PPPOX",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_PPPOX\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_PPPOX\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_PPPOX",
          "package": "network",
          "partial": "AF PPPOX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_PPPOX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_PUP",
          "package": "network",
          "signature": "AF_PUP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_PUP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_PUP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_PUP",
          "package": "network",
          "partial": "AF PUP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_PUP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_RAW",
          "package": "network",
          "signature": "AF_RAW",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_RAW\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_RAW\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_RAW",
          "package": "network",
          "partial": "AF RAW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_RAW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_RIF",
          "package": "network",
          "signature": "AF_RIF",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_RIF\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_RIF\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_RIF",
          "package": "network",
          "partial": "AF RIF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_RIF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ROSE",
          "package": "network",
          "signature": "AF_ROSE",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ROSE\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ROSE\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ROSE",
          "package": "network",
          "partial": "AF ROSE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ROSE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_ROUTE",
          "package": "network",
          "signature": "AF_ROUTE",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ROUTE\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_ROUTE\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_ROUTE",
          "package": "network",
          "partial": "AF ROUTE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_ROUTE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_SDL",
          "package": "network",
          "signature": "AF_SDL",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SDL\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_SDL\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_SDL",
          "package": "network",
          "partial": "AF SDL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SDL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_SECURITY",
          "package": "network",
          "signature": "AF_SECURITY",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SECURITY\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_SECURITY\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_SECURITY",
          "package": "network",
          "partial": "AF SECURITY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SECURITY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_SIP",
          "package": "network",
          "signature": "AF_SIP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SIP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_SIP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_SIP",
          "package": "network",
          "partial": "AF SIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_SNA",
          "package": "network",
          "signature": "AF_SNA",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SNA\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_SNA\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_SNA",
          "package": "network",
          "partial": "AF SNA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_SNA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_UNIX",
          "package": "network",
          "signature": "AF_UNIX",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_UNIX\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_UNIX\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_UNIX",
          "package": "network",
          "partial": "AF UNIX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_UNIX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_UNSPEC",
          "package": "network",
          "signature": "AF_UNSPEC",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_UNSPEC\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_UNSPEC\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_UNSPEC",
          "package": "network",
          "partial": "AF UNSPEC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_UNSPEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_WAN",
          "package": "network",
          "signature": "AF_WAN",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_WAN\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_WAN\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_WAN",
          "package": "network",
          "partial": "AF WAN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_WAN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_WANPIPE",
          "package": "network",
          "signature": "AF_WANPIPE",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_WANPIPE\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_WANPIPE\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_WANPIPE",
          "package": "network",
          "partial": "AF WANPIPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_WANPIPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "AF_X25",
          "package": "network",
          "signature": "AF_X25",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_X25\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AF_X25\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "AF_X25",
          "package": "network",
          "partial": "AF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:AF_X25"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "PortNum",
          "package": "network",
          "signature": "PortNum Word16",
          "source": "src/Network-Socket-Types.html#PortNumber",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:PortNum\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:PortNum\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "PortNum",
          "package": "network",
          "partial": "Port Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:PortNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "Pseudo_AF_HDRCMPLT",
          "package": "network",
          "signature": "Pseudo_AF_HDRCMPLT",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_HDRCMPLT\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Pseudo_AF_HDRCMPLT\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "Pseudo_AF_HDRCMPLT",
          "package": "network",
          "partial": "Pseudo AF HDRCMPLT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_HDRCMPLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "Pseudo_AF_KEY",
          "package": "network",
          "signature": "Pseudo_AF_KEY",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_KEY\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Pseudo_AF_KEY\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "Pseudo_AF_KEY",
          "package": "network",
          "partial": "Pseudo AF KEY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_KEY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "Pseudo_AF_PIP",
          "package": "network",
          "signature": "Pseudo_AF_PIP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_PIP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Pseudo_AF_PIP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "Pseudo_AF_PIP",
          "package": "network",
          "partial": "Pseudo AF PIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_PIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "Pseudo_AF_RTIP",
          "package": "network",
          "signature": "Pseudo_AF_RTIP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_RTIP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Pseudo_AF_RTIP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "Pseudo_AF_RTIP",
          "package": "network",
          "partial": "Pseudo AF RTIP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_RTIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "Pseudo_AF_XTP",
          "package": "network",
          "signature": "Pseudo_AF_XTP",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_XTP\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Pseudo_AF_XTP\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "Pseudo_AF_XTP",
          "package": "network",
          "partial": "Pseudo AF XTP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:Pseudo_AF_XTP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "SockAddrInet",
          "package": "network",
          "signature": "SockAddrInet PortNumber HostAddress",
          "source": "src/Network-Socket-Types.html#SockAddr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:SockAddrInet\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SockAddrInet\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "SockAddrInet",
          "package": "network",
          "partial": "Sock Addr Inet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:SockAddrInet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "SockAddrInet6",
          "package": "network",
          "signature": "SockAddrInet6 PortNumber FlowInfo HostAddress6 ScopeID",
          "source": "src/Network-Socket-Types.html#SockAddr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:SockAddrInet6\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SockAddrInet6\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "SockAddrInet6",
          "package": "network",
          "partial": "Sock Addr Inet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:SockAddrInet6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\"]",
          "name": "SockAddrUnix",
          "package": "network",
          "signature": "SockAddrUnix String",
          "source": "src/Network-Socket-Types.html#SockAddr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:SockAddrUnix\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SockAddrUnix\"]"
        },
        "index": {
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "SockAddrUnix",
          "package": "network",
          "partial": "Sock Addr Unix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:SockAddrUnix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e from the given memory location.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "peekSockAddr",
          "package": "network",
          "signature": "Ptr SockAddr -\u003e IO SockAddr",
          "source": "src/Network-Socket-Types.html#peekSockAddr",
          "type": "function"
        },
        "index": {
          "description": "Read SockAddr from the given memory location",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "peekSockAddr",
          "normalized": "Ptr SockAddr-\u003eIO SockAddr",
          "package": "network",
          "partial": "Sock Addr",
          "signature": "Ptr SockAddr-\u003eIO SockAddr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:peekSockAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the given \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e to the given memory location.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "pokeSockAddr",
          "package": "network",
          "signature": "Ptr a -\u003e SockAddr -\u003e IO ()",
          "source": "src/Network-Socket-Types.html#pokeSockAddr",
          "type": "function"
        },
        "index": {
          "description": "Write the given SockAddr to the given memory location",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "pokeSockAddr",
          "normalized": "Ptr a-\u003eSockAddr-\u003eIO()",
          "package": "network",
          "partial": "Sock Addr",
          "signature": "Ptr a-\u003eSockAddr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:pokeSockAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the storage requirements (in bytes) of the given\n \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e.  This function differs from \u003ccode\u003e\u003ca\u003esizeOf\u003c/a\u003e\u003c/code\u003e\n in that the value of the argument \u003cem\u003eis\u003c/em\u003e used.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "sizeOfSockAddr",
          "package": "network",
          "signature": "SockAddr -\u003e Int",
          "source": "src/Network-Socket-Types.html#sizeOfSockAddr",
          "type": "function"
        },
        "index": {
          "description": "Computes the storage requirements in bytes of the given SockAddr This function differs from sizeOf in that the value of the argument is used",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "sizeOfSockAddr",
          "normalized": "SockAddr-\u003eInt",
          "package": "network",
          "partial": "Of Sock Addr",
          "signature": "SockAddr-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:sizeOfSockAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComputes the storage requirements (in bytes) required for a\n \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e with the given \u003ccode\u003e\u003ca\u003eFamily\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "sizeOfSockAddrByFamily",
          "package": "network",
          "signature": "Family -\u003e Int",
          "source": "src/Network-Socket-Types.html#sizeOfSockAddrByFamily",
          "type": "function"
        },
        "index": {
          "description": "Computes the storage requirements in bytes required for SockAddr with the given Family",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "sizeOfSockAddrByFamily",
          "normalized": "Family-\u003eInt",
          "package": "network",
          "partial": "Of Sock Addr By Family",
          "signature": "Family-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:sizeOfSockAddrByFamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current socket error.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "throwSocketError",
          "package": "network",
          "signature": "String-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current socket error",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "throwSocketError",
          "normalized": "String-\u003eIO a",
          "package": "network",
          "partial": "Socket Error",
          "signature": "String-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:throwSocketError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ethrowSocketError\u003c/a\u003e\u003c/code\u003e, but the error code is supplied as an argument.\n\u003c/p\u003e\u003cp\u003eOn Windows, do not use errno.  Use a system error code instead.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorCode",
          "package": "network",
          "signature": "String -\u003e CInt -\u003e IO a",
          "source": "src/Network-Socket-Internal.html#throwSocketErrorCode",
          "type": "function"
        },
        "index": {
          "description": "Like throwSocketError but the error code is supplied as an argument On Windows do not use errno Use system error code instead",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorCode",
          "normalized": "String-\u003eCInt-\u003eIO a",
          "package": "network",
          "partial": "Socket Error Code",
          "signature": "String-\u003eCInt-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:throwSocketErrorCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current socket error if\n the IO action returns a result of \u003ccode\u003e-1\u003c/code\u003e, but retries in case of an\n interrupted operation.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorIfMinus1Retry",
          "package": "network",
          "signature": "String-\u003e IO a-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current socket error if the IO action returns result of but retries in case of an interrupted operation",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorIfMinus1Retry",
          "normalized": "String-\u003eIO a-\u003eIO a",
          "package": "network",
          "partial": "Socket Error If Minus Retry",
          "signature": "String-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:throwSocketErrorIfMinus1Retry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current socket error if\n the IO action returns a result of \u003ccode\u003e-1\u003c/code\u003e, but retries in case of an\n interrupted operation.  Checks for operations that would block and\n executes an alternative action before retrying in that case.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorIfMinus1RetryMayBlock",
          "package": "network",
          "signature": "String-\u003e IO b-\u003e IO a-\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current socket error if the IO action returns result of but retries in case of an interrupted operation Checks for operations that would block and executes an alternative action before retrying in that case",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorIfMinus1RetryMayBlock",
          "normalized": "String-\u003eIO a-\u003eIO b-\u003eIO b",
          "package": "network",
          "partial": "Socket Error If Minus Retry May Block",
          "signature": "String-\u003eIO b-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:throwSocketErrorIfMinus1RetryMayBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eIOError\u003c/a\u003e\u003c/code\u003e corresponding to the current socket error if\n the IO action returns a result of \u003ccode\u003e-1\u003c/code\u003e.  Discards the result of the\n IO action after error handling.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorIfMinus1_",
          "package": "network",
          "signature": "String-\u003e IO a-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Throw an IOError corresponding to the current socket error if the IO action returns result of Discards the result of the IO action after error handling",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorIfMinus1_",
          "normalized": "String-\u003eIO a-\u003eIO()",
          "package": "network",
          "partial": "Socket Error If Minus",
          "signature": "String-\u003eIO a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:throwSocketErrorIfMinus1_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ethrowSocketErrorIfMinus1Retry\u003c/a\u003e\u003c/code\u003e, but if the action fails with\n \u003ccode\u003eEWOULDBLOCK\u003c/code\u003e or similar, wait for the socket to be read-ready,\n and try again.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorWaitRead",
          "package": "network",
          "signature": "Socket -\u003e String -\u003e IO a -\u003e IO a",
          "source": "src/Network-Socket-Internal.html#throwSocketErrorWaitRead",
          "type": "function"
        },
        "index": {
          "description": "Like throwSocketErrorIfMinus1Retry but if the action fails with EWOULDBLOCK or similar wait for the socket to be read-ready and try again",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorWaitRead",
          "normalized": "Socket-\u003eString-\u003eIO a-\u003eIO a",
          "package": "network",
          "partial": "Socket Error Wait Read",
          "signature": "Socket-\u003eString-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:throwSocketErrorWaitRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ethrowSocketErrorIfMinus1Retry\u003c/a\u003e\u003c/code\u003e, but if the action fails with\n \u003ccode\u003eEWOULDBLOCK\u003c/code\u003e or similar, wait for the socket to be write-ready,\n and try again.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorWaitWrite",
          "package": "network",
          "signature": "Socket -\u003e String -\u003e IO a -\u003e IO a",
          "source": "src/Network-Socket-Internal.html#throwSocketErrorWaitWrite",
          "type": "function"
        },
        "index": {
          "description": "Like throwSocketErrorIfMinus1Retry but if the action fails with EWOULDBLOCK or similar wait for the socket to be write-ready and try again",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "throwSocketErrorWaitWrite",
          "normalized": "Socket-\u003eString-\u003eIO a-\u003eIO a",
          "package": "network",
          "partial": "Socket Error Wait Write",
          "signature": "Socket-\u003eString-\u003eIO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:throwSocketErrorWaitWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e for use with a function requiring a\n pointer to a \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e and the length of that \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "withNewSockAddr",
          "package": "network",
          "signature": "Family -\u003e (Ptr SockAddr -\u003e Int -\u003e IO a) -\u003e IO a",
          "source": "src/Network-Socket-Types.html#withNewSockAddr",
          "type": "function"
        },
        "index": {
          "description": "Create new SockAddr for use with function requiring pointer to SockAddr and the length of that SockAddr",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "withNewSockAddr",
          "normalized": "Family-\u003e(Ptr SockAddr-\u003eInt-\u003eIO a)-\u003eIO a",
          "package": "network",
          "partial": "New Sock Addr",
          "signature": "Family-\u003e(Ptr SockAddr-\u003eInt-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:withNewSockAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e with a function requiring a pointer to a\n \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e and the length of that \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "withSockAddr",
          "package": "network",
          "signature": "SockAddr -\u003e (Ptr SockAddr -\u003e Int -\u003e IO a) -\u003e IO a",
          "source": "src/Network-Socket-Types.html#withSockAddr",
          "type": "function"
        },
        "index": {
          "description": "Use SockAddr with function requiring pointer to SockAddr and the length of that SockAddr",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "withSockAddr",
          "normalized": "SockAddr-\u003e(Ptr SockAddr-\u003eInt-\u003eIO a)-\u003eIO a",
          "package": "network",
          "partial": "Sock Addr",
          "signature": "SockAddr-\u003e(Ptr SockAddr-\u003eInt-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:withSockAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOn Windows operating systems, the networking subsystem has to be\ninitialised using \u003ccode\u003e\u003ca\u003ewithSocketsDo\u003c/a\u003e\u003c/code\u003e before any networking operations can\nbe used.  eg.\n\u003c/p\u003e\u003cpre\u003e main = withSocketsDo $ do {...}\n\u003c/pre\u003e\u003cp\u003eAlthough this is only strictly necessary on Windows platforms, it is\nharmless on other platforms, so for portability it is good practice to\nuse it all the time.\n\u003c/p\u003e",
          "module": "[\"Network.Socket.Internal\",\"Network.Socket\",\"Network\"]",
          "name": "withSocketsDo",
          "package": "network",
          "signature": "IO a -\u003e IO a",
          "source": "src/Network-Socket-Internal.html#withSocketsDo",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:withSocketsDo\",\"http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:withSocketsDo\",\"http://hackage.haskell.org/package/network/docs/Network.html#v:withSocketsDo\"]"
        },
        "index": {
          "description": "On Windows operating systems the networking subsystem has to be initialised using withSocketsDo before any networking operations can be used eg main withSocketsDo do Although this is only strictly necessary on Windows platforms it is harmless on other platforms so for portability it is good practice to use it all the time",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "withSocketsDo",
          "normalized": "IO a-\u003eIO a",
          "package": "network",
          "partial": "Sockets Do",
          "signature": "IO a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:withSocketsDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZero a structure.\n\u003c/p\u003e",
          "module": "Network.Socket.Internal",
          "name": "zeroMemory",
          "package": "network",
          "signature": "Ptr a -\u003e CSize -\u003e IO ()",
          "source": "src/Network-Socket-Types.html#zeroMemory",
          "type": "function"
        },
        "index": {
          "description": "Zero structure",
          "hierarchy": "Network Socket Internal",
          "module": "Network.Socket.Internal",
          "name": "zeroMemory",
          "normalized": "Ptr a-\u003eCSize-\u003eIO()",
          "package": "network",
          "partial": "Memory",
          "signature": "Ptr a-\u003eCSize-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket-Internal.html#v:zeroMemory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ca\u003eNetwork.Socket\u003c/a\u003e module is for when you want full control over\n sockets.  Essentially the entire C socket API is exposed through\n this module; in general the operations follow the behaviour of the C\n functions of the same name (consult your favourite Unix networking book).\n\u003c/p\u003e\u003cp\u003eA higher level interface to networking operations is provided\n through the module \u003ca\u003eNetwork\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.Socket",
          "name": "Socket",
          "package": "network",
          "source": "src/Network-Socket.html",
          "type": "module"
        },
        "index": {
          "description": "The Network.Socket module is for when you want full control over sockets Essentially the entire socket API is exposed through this module in general the operations follow the behaviour of the functions of the same name consult your favourite Unix networking book higher level interface to networking operations is provided through the module Network",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Socket",
          "package": "network",
          "partial": "Socket",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AddrInfo",
          "package": "network",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AddrInfo",
          "package": "network",
          "partial": "Addr Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:AddrInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlags that control the querying behaviour of \u003ccode\u003e\u003ca\u003egetAddrInfo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "AddrInfoFlag",
          "package": "network",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "data"
        },
        "index": {
          "description": "Flags that control the querying behaviour of getAddrInfo",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AddrInfoFlag",
          "package": "network",
          "partial": "Addr Info Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:AddrInfoFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAddress families.\n\u003c/p\u003e\u003cp\u003eA constructor being present here does not mean it is supported by the\n operating system: see \u003ccode\u003e\u003ca\u003eisSupportedFamily\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Family",
          "package": "network",
          "source": "src/Network-Socket-Types.html#Family",
          "type": "data"
        },
        "index": {
          "description": "Address families constructor being present here does not mean it is supported by the operating system see isSupportedFamily",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Family",
          "package": "network",
          "partial": "Family",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:Family"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "FlowInfo",
          "package": "network",
          "source": "src/Network-Socket-Types.html#FlowInfo",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "FlowInfo",
          "package": "network",
          "partial": "Flow Info",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:FlowInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNetwork byte order.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "HostAddress",
          "package": "network",
          "source": "src/Network-Socket-Types.html#HostAddress",
          "type": "type"
        },
        "index": {
          "description": "Network byte order",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "HostAddress",
          "package": "network",
          "partial": "Host Address",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:HostAddress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHost byte order.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "HostAddress6",
          "package": "network",
          "source": "src/Network-Socket-Types.html#HostAddress6",
          "type": "type"
        },
        "index": {
          "description": "Host byte order",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "HostAddress6",
          "package": "network",
          "partial": "Host Address",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:HostAddress6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEither a host name e.g., \u003ccode\u003e\"haskell.org\"\u003c/code\u003e or a numeric host\n address string consisting of a dotted decimal IPv4 address or an\n IPv6 address e.g., \u003ccode\u003e\"192.168.0.1\"\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "HostName",
          "package": "network",
          "source": "src/Network-Socket.html#HostName",
          "type": "type"
        },
        "index": {
          "description": "Either host name e.g haskell.org or numeric host address string consisting of dotted decimal IPv4 address or an IPv6 address e.g",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "HostName",
          "package": "network",
          "partial": "Host Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:HostName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "NameInfoFlag",
          "package": "network",
          "source": "src/Network-Socket.html#NameInfoFlag",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NameInfoFlag",
          "package": "network",
          "partial": "Name Info Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:NameInfoFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "PortNumber",
          "package": "network",
          "source": "src/Network-Socket-Types.html#PortNumber",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "PortNumber",
          "package": "network",
          "partial": "Port Number",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:PortNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "ProtocolNumber",
          "package": "network",
          "source": "src/Network-Socket-Types.html#ProtocolNumber",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ProtocolNumber",
          "package": "network",
          "partial": "Protocol Number",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:ProtocolNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "ScopeID",
          "package": "network",
          "source": "src/Network-Socket-Types.html#ScopeID",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ScopeID",
          "package": "network",
          "partial": "Scope ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:ScopeID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "ServiceName",
          "package": "network",
          "source": "src/Network-Socket.html#ServiceName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ServiceName",
          "package": "network",
          "partial": "Service Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:ServiceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "ShutdownCmd",
          "package": "network",
          "source": "src/Network-Socket.html#ShutdownCmd",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ShutdownCmd",
          "package": "network",
          "partial": "Shutdown Cmd",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:ShutdownCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "SockAddr",
          "package": "network",
          "source": "src/Network-Socket-Types.html#SockAddr",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SockAddr",
          "package": "network",
          "partial": "Sock Addr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:SockAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "Socket",
          "package": "network",
          "source": "src/Network-Socket-Types.html#Socket",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Socket",
          "package": "network",
          "partial": "Socket",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:Socket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSocket options for use with \u003ccode\u003e\u003ca\u003esetSocketOption\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003egetSocketOption\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe existence of a constructor does not imply that the relevant option\n is supported on your system: see \u003ccode\u003e\u003ca\u003eisSupportedSocketOption\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SocketOption",
          "package": "network",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "data"
        },
        "index": {
          "description": "Socket options for use with setSocketOption and getSocketOption The existence of constructor does not imply that the relevant option is supported on your system see isSupportedSocketOption",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SocketOption",
          "package": "network",
          "partial": "Socket Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:SocketOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe status of the socket as \u003cem\u003edetermined by this library\u003c/em\u003e, not\n necessarily reflecting the state of the connection itself.\n\u003c/p\u003e\u003cp\u003eFor example, the \u003ccode\u003e\u003ca\u003eClosed\u003c/a\u003e\u003c/code\u003e status is applied when the \u003ccode\u003eclose\u003c/code\u003e\n function is called.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SocketStatus",
          "package": "network",
          "source": "src/Network-Socket-Types.html#SocketStatus",
          "type": "data"
        },
        "index": {
          "description": "The status of the socket as determined by this library not necessarily reflecting the state of the connection itself For example the Closed status is applied when the close function is called",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SocketStatus",
          "package": "network",
          "partial": "Socket Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:SocketStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSocket Types.\n\u003c/p\u003e\u003cp\u003eThe existence of a constructor does not necessarily imply that that\n socket type is supported on your system: see \u003ccode\u003e\u003ca\u003eisSupportedSocketType\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SocketType",
          "package": "network",
          "source": "src/Network-Socket-Types.html#SocketType",
          "type": "data"
        },
        "index": {
          "description": "Socket Types The existence of constructor does not necessarily imply that that socket type is supported on your system see isSupportedSocketType",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SocketType",
          "package": "network",
          "partial": "Socket Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#t:SocketType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AI_ADDRCONFIG",
          "package": "network",
          "signature": "AI_ADDRCONFIG",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AI_ADDRCONFIG",
          "package": "network",
          "partial": "AI ADDRCONFIG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AI_ADDRCONFIG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AI_ALL",
          "package": "network",
          "signature": "AI_ALL",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AI_ALL",
          "package": "network",
          "partial": "AI ALL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AI_ALL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AI_CANONNAME",
          "package": "network",
          "signature": "AI_CANONNAME",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AI_CANONNAME",
          "package": "network",
          "partial": "AI CANONNAME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AI_CANONNAME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AI_NUMERICHOST",
          "package": "network",
          "signature": "AI_NUMERICHOST",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AI_NUMERICHOST",
          "package": "network",
          "partial": "AI NUMERICHOST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AI_NUMERICHOST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AI_NUMERICSERV",
          "package": "network",
          "signature": "AI_NUMERICSERV",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AI_NUMERICSERV",
          "package": "network",
          "partial": "AI NUMERICSERV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AI_NUMERICSERV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AI_PASSIVE",
          "package": "network",
          "signature": "AI_PASSIVE",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AI_PASSIVE",
          "package": "network",
          "partial": "AI PASSIVE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AI_PASSIVE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AI_V4MAPPED",
          "package": "network",
          "signature": "AI_V4MAPPED",
          "source": "src/Network-Socket.html#AddrInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AI_V4MAPPED",
          "package": "network",
          "partial": "AI MAPPED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AI_V4MAPPED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "AddrInfo",
          "package": "network",
          "signature": "AddrInfo",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "AddrInfo",
          "package": "network",
          "partial": "Addr Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:AddrInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBound, via \u003ccode\u003ebind\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Bound",
          "package": "network",
          "signature": "Bound",
          "source": "src/Network-Socket-Types.html#SocketStatus",
          "type": "function"
        },
        "index": {
          "description": "Bound via bind",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Bound",
          "package": "network",
          "partial": "Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Bound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_BROADCAST\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Broadcast",
          "package": "network",
          "signature": "Broadcast",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO BROADCAST",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Broadcast",
          "package": "network",
          "partial": "Broadcast",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Broadcast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClosed was closed by \u003ccode\u003eclose\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Closed",
          "package": "network",
          "signature": "Closed",
          "source": "src/Network-Socket-Types.html#SocketStatus",
          "type": "function"
        },
        "index": {
          "description": "Closed was closed by close",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Closed",
          "package": "network",
          "partial": "Closed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Closed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnected or accepted, via \u003ccode\u003econnect\u003c/code\u003e or \u003ccode\u003eaccept\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Connected",
          "package": "network",
          "signature": "Connected",
          "source": "src/Network-Socket-Types.html#SocketStatus",
          "type": "function"
        },
        "index": {
          "description": "Connected or accepted via connect or accept",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Connected",
          "package": "network",
          "partial": "Connected",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Connected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs now a \u003ccode\u003eHandle\u003c/code\u003e (via \u003ccode\u003esocketToHandle\u003c/code\u003e), don't touch\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "ConvertedToHandle",
          "package": "network",
          "signature": "ConvertedToHandle",
          "source": "src/Network-Socket-Types.html#SocketStatus",
          "type": "function"
        },
        "index": {
          "description": "Is now Handle via socketToHandle don touch",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ConvertedToHandle",
          "package": "network",
          "partial": "Converted To Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:ConvertedToHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTCP_CORK\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Cork",
          "package": "network",
          "signature": "Cork",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "TCP CORK",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Cork",
          "package": "network",
          "partial": "Cork",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Cork"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSOCK_DGRAM\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Datagram",
          "package": "network",
          "signature": "Datagram",
          "source": "src/Network-Socket-Types.html#SocketType",
          "type": "function"
        },
        "index": {
          "description": "SOCK DGRAM",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Datagram",
          "package": "network",
          "partial": "Datagram",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Datagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_DEBUG\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Debug",
          "package": "network",
          "signature": "Debug",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO DEBUG",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Debug",
          "package": "network",
          "partial": "Debug",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Debug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_DONTROUTE\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "DontRoute",
          "package": "network",
          "signature": "DontRoute",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO DONTROUTE",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "DontRoute",
          "package": "network",
          "partial": "Dont Route",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:DontRoute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIPV6_V6ONLY\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "IPv6Only",
          "package": "network",
          "signature": "IPv6Only",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "IPV6 V6ONLY",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "IPv6Only",
          "package": "network",
          "partial": "IPv Only",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:IPv6Only"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_KEEPALIVE\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "KeepAlive",
          "package": "network",
          "signature": "KeepAlive",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO KEEPALIVE",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "KeepAlive",
          "package": "network",
          "partial": "Keep Alive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:KeepAlive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_LINGER\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Linger",
          "package": "network",
          "signature": "Linger",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO LINGER",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Linger",
          "package": "network",
          "partial": "Linger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Linger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eListening, via \u003ccode\u003elisten\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Listening",
          "package": "network",
          "signature": "Listening",
          "source": "src/Network-Socket-Types.html#SocketStatus",
          "type": "function"
        },
        "index": {
          "description": "Listening via listen",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Listening",
          "package": "network",
          "partial": "Listening",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Listening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTCP_MAXSEG\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "MaxSegment",
          "package": "network",
          "signature": "MaxSegment",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "TCP MAXSEG",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "MaxSegment",
          "package": "network",
          "partial": "Max Segment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:MaxSegment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "MkSocket",
          "package": "network",
          "signature": "MkSocket CInt Family SocketType ProtocolNumber (MVar SocketStatus)",
          "source": "src/Network-Socket-Types.html#Socket",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "MkSocket",
          "package": "network",
          "partial": "Mk Socket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:MkSocket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "NI_DGRAM",
          "package": "network",
          "signature": "NI_DGRAM",
          "source": "src/Network-Socket.html#NameInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NI_DGRAM",
          "package": "network",
          "partial": "NI DGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NI_DGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "NI_NAMEREQD",
          "package": "network",
          "signature": "NI_NAMEREQD",
          "source": "src/Network-Socket.html#NameInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NI_NAMEREQD",
          "package": "network",
          "partial": "NI NAMEREQD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NI_NAMEREQD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "NI_NOFQDN",
          "package": "network",
          "signature": "NI_NOFQDN",
          "source": "src/Network-Socket.html#NameInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NI_NOFQDN",
          "package": "network",
          "partial": "NI NOFQDN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NI_NOFQDN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "NI_NUMERICHOST",
          "package": "network",
          "signature": "NI_NUMERICHOST",
          "source": "src/Network-Socket.html#NameInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NI_NUMERICHOST",
          "package": "network",
          "partial": "NI NUMERICHOST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NI_NUMERICHOST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "NI_NUMERICSERV",
          "package": "network",
          "signature": "NI_NUMERICSERV",
          "source": "src/Network-Socket.html#NameInfoFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NI_NUMERICSERV",
          "package": "network",
          "partial": "NI NUMERICSERV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NI_NUMERICSERV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTCP_NODELAY\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "NoDelay",
          "package": "network",
          "signature": "NoDelay",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "TCP NODELAY",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NoDelay",
          "package": "network",
          "partial": "No Delay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NoDelay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0, used in getAddrInfo hints, for example\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "NoSocketType",
          "package": "network",
          "signature": "NoSocketType",
          "source": "src/Network-Socket-Types.html#SocketType",
          "type": "function"
        },
        "index": {
          "description": "used in getAddrInfo hints for example",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NoSocketType",
          "package": "network",
          "partial": "No Socket Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NoSocketType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNewly created, unconnected socket\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "NotConnected",
          "package": "network",
          "signature": "NotConnected",
          "source": "src/Network-Socket-Types.html#SocketStatus",
          "type": "function"
        },
        "index": {
          "description": "Newly created unconnected socket",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "NotConnected",
          "package": "network",
          "partial": "Not Connected",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:NotConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_OOBINLINE\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "OOBInline",
          "package": "network",
          "signature": "OOBInline",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO OOBINLINE",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "OOBInline",
          "package": "network",
          "partial": "OOBInline",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:OOBInline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSOCK_RDM\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "RDM",
          "package": "network",
          "signature": "RDM",
          "source": "src/Network-Socket-Types.html#SocketType",
          "type": "function"
        },
        "index": {
          "description": "SOCK RDM",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "RDM",
          "package": "network",
          "partial": "RDM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:RDM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSOCK_RAW\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Raw",
          "package": "network",
          "signature": "Raw",
          "source": "src/Network-Socket-Types.html#SocketType",
          "type": "function"
        },
        "index": {
          "description": "SOCK RAW",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Raw",
          "package": "network",
          "partial": "Raw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Raw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_RCVBUF\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "RecvBuffer",
          "package": "network",
          "signature": "RecvBuffer",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO RCVBUF",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "RecvBuffer",
          "package": "network",
          "partial": "Recv Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:RecvBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_RCVLOWAT\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "RecvLowWater",
          "package": "network",
          "signature": "RecvLowWater",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO RCVLOWAT",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "RecvLowWater",
          "package": "network",
          "partial": "Recv Low Water",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:RecvLowWater"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_RCVTIMEO\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "RecvTimeOut",
          "package": "network",
          "signature": "RecvTimeOut",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO RCVTIMEO",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "RecvTimeOut",
          "package": "network",
          "partial": "Recv Time Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:RecvTimeOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_REUSEADDR\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "ReuseAddr",
          "package": "network",
          "signature": "ReuseAddr",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO REUSEADDR",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ReuseAddr",
          "package": "network",
          "partial": "Reuse Addr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:ReuseAddr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_REUSEPORT\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "ReusePort",
          "package": "network",
          "signature": "ReusePort",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO REUSEPORT",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ReusePort",
          "package": "network",
          "partial": "Reuse Port",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:ReusePort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_SNDBUF\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SendBuffer",
          "package": "network",
          "signature": "SendBuffer",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO SNDBUF",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SendBuffer",
          "package": "network",
          "partial": "Send Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SendBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_SNDLOWAT\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SendLowWater",
          "package": "network",
          "signature": "SendLowWater",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO SNDLOWAT",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SendLowWater",
          "package": "network",
          "partial": "Send Low Water",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SendLowWater"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_SNDTIMEO\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SendTimeOut",
          "package": "network",
          "signature": "SendTimeOut",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO SNDTIMEO",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SendTimeOut",
          "package": "network",
          "partial": "Send Time Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SendTimeOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSOCK_SEQPACKET\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SeqPacket",
          "package": "network",
          "signature": "SeqPacket",
          "source": "src/Network-Socket-Types.html#SocketType",
          "type": "function"
        },
        "index": {
          "description": "SOCK SEQPACKET",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SeqPacket",
          "package": "network",
          "partial": "Seq Packet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SeqPacket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "ShutdownBoth",
          "package": "network",
          "signature": "ShutdownBoth",
          "source": "src/Network-Socket.html#ShutdownCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ShutdownBoth",
          "package": "network",
          "partial": "Shutdown Both",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:ShutdownBoth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "ShutdownReceive",
          "package": "network",
          "signature": "ShutdownReceive",
          "source": "src/Network-Socket.html#ShutdownCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ShutdownReceive",
          "package": "network",
          "partial": "Shutdown Receive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:ShutdownReceive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "ShutdownSend",
          "package": "network",
          "signature": "ShutdownSend",
          "source": "src/Network-Socket.html#ShutdownCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "ShutdownSend",
          "package": "network",
          "partial": "Shutdown Send",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:ShutdownSend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_ERROR\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "SoError",
          "package": "network",
          "signature": "SoError",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO ERROR",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "SoError",
          "package": "network",
          "partial": "So Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:SoError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSOCK_STREAM\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Stream",
          "package": "network",
          "signature": "Stream",
          "source": "src/Network-Socket-Types.html#SocketType",
          "type": "function"
        },
        "index": {
          "description": "SOCK STREAM",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Stream",
          "package": "network",
          "partial": "Stream",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIP_TTL\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "TimeToLive",
          "package": "network",
          "signature": "TimeToLive",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "IP TTL",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "TimeToLive",
          "package": "network",
          "partial": "Time To Live",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:TimeToLive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_TYPE\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "Type",
          "package": "network",
          "signature": "Type",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO TYPE",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "Type",
          "package": "network",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSO_USELOOPBACK\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "UseLoopBack",
          "package": "network",
          "signature": "UseLoopBack",
          "source": "src/Network-Socket.html#SocketOption",
          "type": "function"
        },
        "index": {
          "description": "SO USELOOPBACK",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "UseLoopBack",
          "package": "network",
          "partial": "Use Loop Back",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:UseLoopBack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "aNY_PORT",
          "package": "network",
          "signature": "PortNumber",
          "source": "src/Network-Socket.html#aNY_PORT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "aNY_PORT",
          "package": "network",
          "partial": "NY PORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:aNY_PORT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccept a connection.  The socket must be bound to an address and\n listening for connections.  The return value is a pair \u003ccode\u003e(conn,\n address)\u003c/code\u003e where \u003ccode\u003econn\u003c/code\u003e is a new socket object usable to send and\n receive data on the connection, and \u003ccode\u003eaddress\u003c/code\u003e is the address bound\n to the socket on the other end of the connection.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "accept",
          "package": "network",
          "signature": "Socket -\u003e IO (Socket, SockAddr)",
          "source": "src/Network-Socket.html#accept",
          "type": "function"
        },
        "index": {
          "description": "Accept connection The socket must be bound to an address and listening for connections The return value is pair conn address where conn is new socket object usable to send and receive data on the connection and address is the address bound to the socket on the other end of the connection",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "accept",
          "normalized": "Socket-\u003eIO(Socket,SockAddr)",
          "package": "network",
          "signature": "Socket-\u003eIO(Socket,SockAddr)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:accept"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "addrAddress",
          "package": "network",
          "signature": "SockAddr",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "addrAddress",
          "package": "network",
          "partial": "Address",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:addrAddress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "addrCanonName",
          "package": "network",
          "signature": "Maybe String",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "addrCanonName",
          "package": "network",
          "partial": "Canon Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:addrCanonName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "addrFamily",
          "package": "network",
          "signature": "Family",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "addrFamily",
          "package": "network",
          "partial": "Family",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:addrFamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "addrFlags",
          "package": "network",
          "signature": "[AddrInfoFlag]",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "addrFlags",
          "normalized": "[AddrInfoFlag]",
          "package": "network",
          "partial": "Flags",
          "signature": "[AddrInfoFlag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:addrFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicate whether the given \u003ccode\u003e\u003ca\u003eAddrInfoFlag\u003c/a\u003e\u003c/code\u003e will have any effect on\n this system.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "addrInfoFlagImplemented",
          "package": "network",
          "signature": "AddrInfoFlag -\u003e Bool",
          "source": "src/Network-Socket.html#addrInfoFlagImplemented",
          "type": "function"
        },
        "index": {
          "description": "Indicate whether the given AddrInfoFlag will have any effect on this system",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "addrInfoFlagImplemented",
          "normalized": "AddrInfoFlag-\u003eBool",
          "package": "network",
          "partial": "Info Flag Implemented",
          "signature": "AddrInfoFlag-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:addrInfoFlagImplemented"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "addrProtocol",
          "package": "network",
          "signature": "ProtocolNumber",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "addrProtocol",
          "package": "network",
          "partial": "Protocol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:addrProtocol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "addrSocketType",
          "package": "network",
          "signature": "SocketType",
          "source": "src/Network-Socket.html#AddrInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "addrSocketType",
          "package": "network",
          "partial": "Socket Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:addrSocketType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBind the socket to an address. The socket must not already be\n bound.  The \u003ccode\u003e\u003ca\u003eFamily\u003c/a\u003e\u003c/code\u003e passed to \u003ccode\u003ebind\u003c/code\u003e must be the\n same as that passed to \u003ccode\u003e\u003ca\u003esocket\u003c/a\u003e\u003c/code\u003e.  If the special port number\n \u003ccode\u003e\u003ca\u003eaNY_PORT\u003c/a\u003e\u003c/code\u003e is passed then the system assigns the next available\n use port.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "bind",
          "package": "network",
          "signature": "Socket -\u003e SockAddr -\u003e IO ()",
          "source": "src/Network-Socket.html#bind",
          "type": "function"
        },
        "index": {
          "description": "Bind the socket to an address The socket must not already be bound The Family passed to bind must be the same as that passed to socket If the special port number aNY PORT is passed then the system assigns the next available use port",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "bind",
          "normalized": "Socket-\u003eSockAddr-\u003eIO()",
          "package": "network",
          "signature": "Socket-\u003eSockAddr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated alias for \u003ccode\u003e\u003ca\u003ebind\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "bindSocket",
          "package": "network",
          "signature": "Socket -\u003e SockAddr -\u003e IO ()",
          "source": "src/Network-Socket.html#bindSocket",
          "type": "function"
        },
        "index": {
          "description": "Deprecated alias for bind",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "bindSocket",
          "normalized": "Socket-\u003eSockAddr-\u003eIO()",
          "package": "network",
          "partial": "Socket",
          "signature": "Socket-\u003eSockAddr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:bindSocket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose the socket.  All future operations on the socket object\n will fail.  The remote end will receive no more data (after queued\n data is flushed).\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "close",
          "package": "network",
          "signature": "Socket -\u003e IO ()",
          "source": "src/Network-Socket.html#close",
          "type": "function"
        },
        "index": {
          "description": "Close the socket All future operations on the socket object will fail The remote end will receive no more data after queued data is flushed",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "close",
          "normalized": "Socket-\u003eIO()",
          "package": "network",
          "signature": "Socket-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:close"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnect to a remote socket at address.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "connect",
          "package": "network",
          "signature": "Socket -\u003e SockAddr -\u003e IO ()",
          "source": "src/Network-Socket.html#connect",
          "type": "function"
        },
        "index": {
          "description": "Connect to remote socket at address",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "connect",
          "normalized": "Socket-\u003eSockAddr-\u003eIO()",
          "package": "network",
          "signature": "Socket-\u003eSockAddr-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:connect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault hints for address lookup with \u003ccode\u003e\u003ca\u003egetAddrInfo\u003c/a\u003e\u003c/code\u003e.  The values\n of the \u003ccode\u003e\u003ca\u003eaddrAddress\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eaddrCanonName\u003c/a\u003e\u003c/code\u003e fields are \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e,\n and are never inspected by \u003ccode\u003e\u003ca\u003egetAddrInfo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "defaultHints",
          "package": "network",
          "signature": "AddrInfo",
          "source": "src/Network-Socket.html#defaultHints",
          "type": "function"
        },
        "index": {
          "description": "Default hints for address lookup with getAddrInfo The values of the addrAddress and addrCanonName fields are undefined and are never inspected by getAddrInfo",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "defaultHints",
          "package": "network",
          "partial": "Hints",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:defaultHints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "fdSocket",
          "package": "network",
          "signature": "Socket -\u003e CInt",
          "source": "src/Network-Socket.html#fdSocket",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "fdSocket",
          "normalized": "Socket-\u003eCInt",
          "package": "network",
          "partial": "Socket",
          "signature": "Socket-\u003eCInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:fdSocket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve a host or service name to one or more addresses.\n The \u003ccode\u003e\u003ca\u003eAddrInfo\u003c/a\u003e\u003c/code\u003e values that this function returns contain \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e\n values that you can pass directly to \u003ccode\u003e\u003ca\u003econnect\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003ebind\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function is protocol independent.  It can return both IPv4 and\n IPv6 address information.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eAddrInfo\u003c/a\u003e\u003c/code\u003e argument specifies the preferred query behaviour,\n socket options, or protocol.  You can override these conveniently\n using Haskell's record update syntax on \u003ccode\u003e\u003ca\u003edefaultHints\u003c/a\u003e\u003c/code\u003e, for example\n as follows:\n\u003c/p\u003e\u003cpre\u003e\n   myHints = defaultHints { addrFlags = [AI_ADDRCONFIG, AI_CANONNAME] }\n\u003c/pre\u003e\u003cp\u003eValues for \u003ccode\u003e\u003ca\u003eaddrFlags\u003c/a\u003e\u003c/code\u003e control query behaviour.  The supported\n flags are as follows:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eAI_PASSIVE\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e If no \u003ccode\u003e\u003ca\u003eHostName\u003c/a\u003e\u003c/code\u003e value is provided, the network\n     address in each \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e\n     will be left as a \u003ca\u003ewild card\u003c/a\u003e, i.e. as either \u003ccode\u003e\u003ca\u003eiNADDR_ANY\u003c/a\u003e\u003c/code\u003e\n     or \u003ccode\u003e\u003ca\u003eiN6ADDR_ANY\u003c/a\u003e\u003c/code\u003e.  This is useful for server applications that\n     will accept connections from any client.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eAI_CANONNAME\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The \u003ccode\u003e\u003ca\u003eaddrCanonName\u003c/a\u003e\u003c/code\u003e field of the first returned\n     \u003ccode\u003e\u003ca\u003eAddrInfo\u003c/a\u003e\u003c/code\u003e will contain the \u003ca\u003ecanonical name\u003c/a\u003e of the host.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eAI_NUMERICHOST\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The \u003ccode\u003e\u003ca\u003eHostName\u003c/a\u003e\u003c/code\u003e argument \u003cem\u003emust\u003c/em\u003e be a numeric\n     address in string form, and network name lookups will not be\n     attempted.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: Although the following flags are required by RFC 3493, they\n may not have an effect on all platforms, because the underlying\n network stack may not support them.  To see whether a flag from the\n list below will have any effect, call \u003ccode\u003e\u003ca\u003eaddrInfoFlagImplemented\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eAI_NUMERICSERV\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The \u003ccode\u003e\u003ca\u003eServiceName\u003c/a\u003e\u003c/code\u003e argument \u003cem\u003emust\u003c/em\u003e be a port\n     number in string form, and service name lookups will not be\n     attempted.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eAI_ADDRCONFIG\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The list of returned \u003ccode\u003e\u003ca\u003eAddrInfo\u003c/a\u003e\u003c/code\u003e values will\n     only contain IPv4 addresses if the local system has at least\n     one IPv4 interface configured, and likewise for IPv6.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eAI_V4MAPPED\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e If an IPv6 lookup is performed, and no IPv6\n     addresses are found, IPv6-mapped IPv4 addresses will be\n     returned.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eAI_ALL\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e If \u003ccode\u003e\u003ca\u003eAI_ALL\u003c/a\u003e\u003c/code\u003e is specified, return all matching IPv6 and\n     IPv4 addresses.  Otherwise, this flag has no effect.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eYou must provide a \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e value for at least one of the \u003ccode\u003e\u003ca\u003eHostName\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eServiceName\u003c/a\u003e\u003c/code\u003e arguments.  \u003ccode\u003e\u003ca\u003eHostName\u003c/a\u003e\u003c/code\u003e can be either a numeric\n network address (dotted quad for IPv4, colon-separated hex for\n IPv6) or a hostname.  In the latter case, its addresses will be\n looked up unless \u003ccode\u003e\u003ca\u003eAI_NUMERICHOST\u003c/a\u003e\u003c/code\u003e is specified as a hint.  If you\n do not provide a \u003ccode\u003e\u003ca\u003eHostName\u003c/a\u003e\u003c/code\u003e value \u003cem\u003eand\u003c/em\u003e do not set \u003ccode\u003e\u003ca\u003eAI_PASSIVE\u003c/a\u003e\u003c/code\u003e as\n a hint, network addresses in the result will contain the address of\n the loopback interface.\n\u003c/p\u003e\u003cp\u003eIf the query fails, this function throws an IO exception instead of\n returning an empty list.  Otherwise, it returns a non-empty list\n of \u003ccode\u003e\u003ca\u003eAddrInfo\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e\u003cp\u003eThere are several reasons why a query might result in several\n values.  For example, the queried-for host could be multihomed, or\n the service might be available via several protocols.\n\u003c/p\u003e\u003cp\u003eNote: the order of arguments is slightly different to that defined\n for \u003ccode\u003egetaddrinfo\u003c/code\u003e in RFC 2553.  The \u003ccode\u003e\u003ca\u003eAddrInfo\u003c/a\u003e\u003c/code\u003e parameter comes first\n to make partial application easier.\n\u003c/p\u003e\u003cp\u003eExample:\n \u003ccode\u003e\n   let hints = defaultHints { addrFlags = [AI_ADDRCONFIG, AI_CANONNAME] }\n   addrs \u003c- getAddrInfo (Just hints) (Just \u003ca\u003ewww.haskell.org\u003c/a\u003e) (Just \u003ca\u003ehttp\u003c/a\u003e)\n   let addr = head addrs\n   sock \u003c- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)\n   connect sock (addrAddress addr)\n \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "getAddrInfo",
          "package": "network",
          "signature": "Maybe AddrInfo-\u003e Maybe HostName-\u003e Maybe ServiceName-\u003e IO [AddrInfo]",
          "type": "function"
        },
        "index": {
          "description": "Resolve host or service name to one or more addresses The AddrInfo values that this function returns contain SockAddr values that you can pass directly to connect or bind This function is protocol independent It can return both IPv4 and IPv6 address information The AddrInfo argument specifies the preferred query behaviour socket options or protocol You can override these conveniently using Haskell record update syntax on defaultHints for example as follows myHints defaultHints addrFlags AI ADDRCONFIG AI CANONNAME Values for addrFlags control query behaviour The supported flags are as follows AI PASSIVE If no HostName value is provided the network address in each SockAddr will be left as wild card i.e as either iNADDR ANY or iN6ADDR ANY This is useful for server applications that will accept connections from any client AI CANONNAME The addrCanonName field of the first returned AddrInfo will contain the canonical name of the host AI NUMERICHOST The HostName argument must be numeric address in string form and network name lookups will not be attempted Note Although the following flags are required by RFC they may not have an effect on all platforms because the underlying network stack may not support them To see whether flag from the list below will have any effect call addrInfoFlagImplemented AI NUMERICSERV The ServiceName argument must be port number in string form and service name lookups will not be attempted AI ADDRCONFIG The list of returned AddrInfo values will only contain IPv4 addresses if the local system has at least one IPv4 interface configured and likewise for IPv6 AI V4MAPPED If an IPv6 lookup is performed and no IPv6 addresses are found IPv6-mapped IPv4 addresses will be returned AI ALL If AI ALL is specified return all matching IPv6 and IPv4 addresses Otherwise this flag has no effect You must provide Just value for at least one of the HostName or ServiceName arguments HostName can be either numeric network address dotted quad for IPv4 colon-separated hex for IPv6 or hostname In the latter case its addresses will be looked up unless AI NUMERICHOST is specified as hint If you do not provide HostName value and do not set AI PASSIVE as hint network addresses in the result will contain the address of the loopback interface If the query fails this function throws an IO exception instead of returning an empty list Otherwise it returns non-empty list of AddrInfo values There are several reasons why query might result in several values For example the queried-for host could be multihomed or the service might be available via several protocols Note the order of arguments is slightly different to that defined for getaddrinfo in RFC The AddrInfo parameter comes first to make partial application easier Example let hints defaultHints addrFlags AI ADDRCONFIG AI CANONNAME addrs getAddrInfo Just hints Just www.haskell.org Just http let addr head addrs sock socket addrFamily addr addrSocketType addr addrProtocol addr connect sock addrAddress addr",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "getAddrInfo",
          "normalized": "Maybe AddrInfo-\u003eMaybe HostName-\u003eMaybe ServiceName-\u003eIO[AddrInfo]",
          "package": "network",
          "partial": "Addr Info",
          "signature": "Maybe AddrInfo-\u003eMaybe HostName-\u003eMaybe ServiceName-\u003eIO[AddrInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:getAddrInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolve an address to a host or service name.\n This function is protocol independent.\n\u003c/p\u003e\u003cp\u003eThe list of \u003ccode\u003e\u003ca\u003eNameInfoFlag\u003c/a\u003e\u003c/code\u003e values controls query behaviour.  The\n supported flags are as follows:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eNI_NOFQDN\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e If a host is local, return only the\n     hostname part of the FQDN.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eNI_NUMERICHOST\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The name of the host is not\n     looked up.  Instead, a numeric representation of the host's\n     address is returned.  For an IPv4 address, this will be a\n     dotted-quad string.  For IPv6, it will be colon-separated\n     hexadecimal.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eNI_NUMERICSERV\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e The name of the service is not\n     looked up.  Instead, a numeric representation of the\n     service is returned.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eNI_NAMEREQD\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e If the hostname cannot be looked up, an IO error\n     is thrown.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eNI_DGRAM\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e Resolve a datagram-based service name.  This is\n     required only for the few protocols that have different port\n     numbers for their datagram-based versions than for their\n     stream-based versions.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eHostname and service name lookups can be expensive.  You can\n specify which lookups to perform via the two \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e arguments.  If\n one of these is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, the corresponding value in the returned\n tuple will be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, and no lookup will be performed.\n\u003c/p\u003e\u003cp\u003eIf a host or service's name cannot be looked up, then the numeric\n form of the address or service will be returned.\n\u003c/p\u003e\u003cp\u003eIf the query fails, this function throws an IO exception.\n\u003c/p\u003e\u003cp\u003eExample:\n \u003ccode\u003e\n   (hostName, _) \u003c- getNameInfo [] True False myAddress\n \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "getNameInfo",
          "package": "network",
          "signature": "[NameInfoFlag]-\u003e Bool-\u003e Bool-\u003e SockAddr-\u003e IO (Maybe HostName, Maybe ServiceName)",
          "type": "function"
        },
        "index": {
          "description": "Resolve an address to host or service name This function is protocol independent The list of NameInfoFlag values controls query behaviour The supported flags are as follows NI NOFQDN If host is local return only the hostname part of the FQDN NI NUMERICHOST The name of the host is not looked up Instead numeric representation of the host address is returned For an IPv4 address this will be dotted-quad string For IPv6 it will be colon-separated hexadecimal NI NUMERICSERV The name of the service is not looked up Instead numeric representation of the service is returned NI NAMEREQD If the hostname cannot be looked up an IO error is thrown NI DGRAM Resolve datagram-based service name This is required only for the few protocols that have different port numbers for their datagram-based versions than for their stream-based versions Hostname and service name lookups can be expensive You can specify which lookups to perform via the two Bool arguments If one of these is False the corresponding value in the returned tuple will be Nothing and no lookup will be performed If host or service name cannot be looked up then the numeric form of the address or service will be returned If the query fails this function throws an IO exception Example hostName getNameInfo True False myAddress",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "getNameInfo",
          "normalized": "[NameInfoFlag]-\u003eBool-\u003eBool-\u003eSockAddr-\u003eIO(Maybe HostName,Maybe ServiceName)",
          "package": "network",
          "partial": "Name Info",
          "signature": "[NameInfoFlag]-\u003eBool-\u003eBool-\u003eSockAddr-\u003eIO(Maybe HostName,Maybe ServiceName)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:getNameInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the processID, userID and groupID of the socket's peer.\n\u003c/p\u003e\u003cp\u003eOnly available on platforms that support SO_PEERCRED or GETPEEREID(3)\n on domain sockets.\n GETPEEREID(3) returns userID and groupID. processID is always 0.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "getPeerCred",
          "package": "network",
          "signature": "Socket -\u003e IO (CUInt, CUInt, CUInt)",
          "source": "src/Network-Socket.html#getPeerCred",
          "type": "function"
        },
        "index": {
          "description": "Returns the processID userID and groupID of the socket peer Only available on platforms that support SO PEERCRED or GETPEEREID on domain sockets GETPEEREID returns userID and groupID processID is always",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "getPeerCred",
          "normalized": "Socket-\u003eIO(CUInt,CUInt,CUInt)",
          "package": "network",
          "partial": "Peer Cred",
          "signature": "Socket-\u003eIO(CUInt,CUInt,CUInt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:getPeerCred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "getPeerName",
          "package": "network",
          "signature": "Socket -\u003e IO SockAddr",
          "source": "src/Network-Socket.html#getPeerName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "getPeerName",
          "normalized": "Socket-\u003eIO SockAddr",
          "package": "network",
          "partial": "Peer Name",
          "signature": "Socket-\u003eIO SockAddr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:getPeerName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "getSocketName",
          "package": "network",
          "signature": "Socket -\u003e IO SockAddr",
          "source": "src/Network-Socket.html#getSocketName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "getSocketName",
          "normalized": "Socket-\u003eIO SockAddr",
          "package": "network",
          "partial": "Socket Name",
          "signature": "Socket-\u003eIO SockAddr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:getSocketName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a socket option that gives an Int value.\n There is currently no API to get e.g. the timeval socket options\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "getSocketOption",
          "package": "network",
          "signature": "Socket -\u003e SocketOption -\u003e IO Int",
          "source": "src/Network-Socket.html#getSocketOption",
          "type": "function"
        },
        "index": {
          "description": "Get socket option that gives an Int value There is currently no API to get e.g the timeval socket options",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "getSocketOption",
          "normalized": "Socket-\u003eSocketOption-\u003eIO Int",
          "package": "network",
          "partial": "Socket Option",
          "signature": "Socket-\u003eSocketOption-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:getSocketOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe IPv6 wild card address.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "iN6ADDR_ANY",
          "package": "network",
          "signature": "HostAddress6",
          "source": "src/Network-Socket.html#iN6ADDR_ANY",
          "type": "function"
        },
        "index": {
          "description": "The IPv6 wild card address",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "iN6ADDR_ANY",
          "package": "network",
          "partial": "ADDR ANY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:iN6ADDR_ANY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe IPv4 wild card address.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "iNADDR_ANY",
          "package": "network",
          "signature": "HostAddress",
          "source": "src/Network-Socket.html#iNADDR_ANY",
          "type": "function"
        },
        "index": {
          "description": "The IPv4 wild card address",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "iNADDR_ANY",
          "package": "network",
          "partial": "NADDR ANY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:iNADDR_ANY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "inet_addr",
          "package": "network",
          "signature": "String -\u003e IO HostAddress",
          "source": "src/Network-Socket.html#inet_addr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "inet_addr",
          "normalized": "String-\u003eIO HostAddress",
          "package": "network",
          "signature": "String-\u003eIO HostAddress",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:inet_addr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "inet_ntoa",
          "package": "network",
          "signature": "HostAddress -\u003e IO String",
          "source": "src/Network-Socket.html#inet_ntoa",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "inet_ntoa",
          "normalized": "HostAddress-\u003eIO String",
          "package": "network",
          "signature": "HostAddress-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:inet_ntoa"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "isBound",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#isBound",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isBound",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Bound",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermines whether \u003ccode\u003e\u003ca\u003eclose\u003c/a\u003e\u003c/code\u003e has been used on the \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e. This\n does \u003cem\u003enot\u003c/em\u003e indicate any status about the socket beyond this. If the\n socket has been closed remotely, this function can still return\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "isConnected",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#isConnected",
          "type": "function"
        },
        "index": {
          "description": "Determines whether close has been used on the Socket This does not indicate any status about the socket beyond this If the socket has been closed remotely this function can still return True",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isConnected",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Connected",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "isListening",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#isListening",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isListening",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Listening",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isListening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "isReadable",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#isReadable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isReadable",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Readable",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isReadable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the AF_ constant corresponding to the given family exist on this\n system?\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "isSupportedFamily",
          "package": "network",
          "signature": "Family -\u003e Bool",
          "source": "src/Network-Socket-Types.html#isSupportedFamily",
          "type": "function"
        },
        "index": {
          "description": "Does the AF constant corresponding to the given family exist on this system",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isSupportedFamily",
          "normalized": "Family-\u003eBool",
          "package": "network",
          "partial": "Supported Family",
          "signature": "Family-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isSupportedFamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the \u003ccode\u003e\u003ca\u003eSocketOption\u003c/a\u003e\u003c/code\u003e exist on this system?\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "isSupportedSocketOption",
          "package": "network",
          "signature": "SocketOption -\u003e Bool",
          "source": "src/Network-Socket.html#isSupportedSocketOption",
          "type": "function"
        },
        "index": {
          "description": "Does the SocketOption exist on this system",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isSupportedSocketOption",
          "normalized": "SocketOption-\u003eBool",
          "package": "network",
          "partial": "Supported Socket Option",
          "signature": "SocketOption-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isSupportedSocketOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the SOCK_ constant corresponding to the given SocketType exist on\n this system?\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "isSupportedSocketType",
          "package": "network",
          "signature": "SocketType -\u003e Bool",
          "source": "src/Network-Socket-Types.html#isSupportedSocketType",
          "type": "function"
        },
        "index": {
          "description": "Does the SOCK constant corresponding to the given SocketType exist on this system",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isSupportedSocketType",
          "normalized": "SocketType-\u003eBool",
          "package": "network",
          "partial": "Supported Socket Type",
          "signature": "SocketType-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isSupportedSocketType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "isWritable",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#isWritable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "isWritable",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Writable",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:isWritable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eListen for connections made to the socket.  The second argument\n specifies the maximum number of queued connections and should be at\n least 1; the maximum value is system-dependent (usually 5).\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "listen",
          "package": "network",
          "signature": "Socket -\u003e Int -\u003e IO ()",
          "source": "src/Network-Socket.html#listen",
          "type": "function"
        },
        "index": {
          "description": "Listen for connections made to the socket The second argument specifies the maximum number of queued connections and should be at least the maximum value is system-dependent usually",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "listen",
          "normalized": "Socket-\u003eInt-\u003eIO()",
          "package": "network",
          "signature": "Socket-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:listen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the value of SOMAXCONN, typically 128.\n 128 is good enough for normal network servers but\n is too small for high performance servers.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "maxListenQueue",
          "package": "network",
          "signature": "Int",
          "source": "src/Network-Socket.html#maxListenQueue",
          "type": "function"
        },
        "index": {
          "description": "This is the value of SOMAXCONN typically is good enough for normal network servers but is too small for high performance servers",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "maxListenQueue",
          "package": "network",
          "partial": "Listen Queue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:maxListenQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "mkSocket",
          "package": "network",
          "signature": "CInt -\u003e Family -\u003e SocketType -\u003e ProtocolNumber -\u003e SocketStatus -\u003e IO Socket",
          "source": "src/Network-Socket.html#mkSocket",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "mkSocket",
          "normalized": "CInt-\u003eFamily-\u003eSocketType-\u003eProtocolNumber-\u003eSocketStatus-\u003eIO Socket",
          "package": "network",
          "partial": "Socket",
          "signature": "CInt-\u003eFamily-\u003eSocketType-\u003eProtocolNumber-\u003eSocketStatus-\u003eIO Socket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:mkSocket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "packFamily",
          "package": "network",
          "signature": "Family -\u003e CInt",
          "source": "src/Network-Socket-Types.html#packFamily",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "packFamily",
          "normalized": "Family-\u003eCInt",
          "package": "network",
          "partial": "Family",
          "signature": "Family-\u003eCInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:packFamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "packSocketType",
          "package": "network",
          "signature": "SocketType -\u003e CInt",
          "source": "src/Network-Socket-Types.html#packSocketType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "packSocketType",
          "normalized": "SocketType-\u003eCInt",
          "package": "network",
          "partial": "Socket Type",
          "signature": "SocketType-\u003eCInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:packSocketType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket.  The socket must be in a connected\n state. This function may return fewer bytes than specified.  If the\n message is longer than the specified length, it may be discarded\n depending on the type of socket.  This function may block until a\n message arrives.\n\u003c/p\u003e\u003cp\u003eConsidering hardware and network realities, the maximum number of\n bytes to receive should be a small power of 2, e.g., 4096.\n\u003c/p\u003e\u003cp\u003eFor TCP sockets, a zero length return value means the peer has\n closed its half side of the connection.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "recv",
          "package": "network",
          "signature": "Socket -\u003e Int -\u003e IO String",
          "source": "src/Network-Socket.html#recv",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket The socket must be in connected state This function may return fewer bytes than specified If the message is longer than the specified length it may be discarded depending on the type of socket This function may block until message arrives Considering hardware and network realities the maximum number of bytes to receive should be small power of e.g For TCP sockets zero length return value means the peer has closed its half side of the connection",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "recv",
          "normalized": "Socket-\u003eInt-\u003eIO String",
          "package": "network",
          "signature": "Socket-\u003eInt-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:recv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket.  The socket must be in a connected\n state. This function may return fewer bytes than specified.  If the\n message is longer than the specified length, it may be discarded\n depending on the type of socket.  This function may block until a\n message arrives.\n\u003c/p\u003e\u003cp\u003eConsidering hardware and network realities, the maximum number of\n bytes to receive should be a small power of 2, e.g., 4096.\n\u003c/p\u003e\u003cp\u003eFor TCP sockets, a zero length return value means the peer has\n closed its half side of the connection.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "recvBuf",
          "package": "network",
          "signature": "Socket -\u003e Ptr Word8 -\u003e Int -\u003e IO Int",
          "source": "src/Network-Socket.html#recvBuf",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket The socket must be in connected state This function may return fewer bytes than specified If the message is longer than the specified length it may be discarded depending on the type of socket This function may block until message arrives Considering hardware and network realities the maximum number of bytes to receive should be small power of e.g For TCP sockets zero length return value means the peer has closed its half side of the connection",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "recvBuf",
          "normalized": "Socket-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "package": "network",
          "partial": "Buf",
          "signature": "Socket-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:recvBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket, writing it into buffer instead of\n creating a new string.  The socket need not be in a connected\n state. Returns \u003ccode\u003e(nbytes, address)\u003c/code\u003e where \u003ccode\u003enbytes\u003c/code\u003e is the number of\n bytes received and \u003ccode\u003eaddress\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e representing the\n address of the sending socket.\n\u003c/p\u003e\u003cp\u003eNOTE: blocking on Windows unless you compile with -threaded (see\n GHC ticket #1129)\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "recvBufFrom",
          "package": "network",
          "signature": "Socket -\u003e Ptr a -\u003e Int -\u003e IO (Int, SockAddr)",
          "source": "src/Network-Socket.html#recvBufFrom",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket writing it into buffer instead of creating new string The socket need not be in connected state Returns nbytes address where nbytes is the number of bytes received and address is SockAddr representing the address of the sending socket NOTE blocking on Windows unless you compile with threaded see GHC ticket",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "recvBufFrom",
          "normalized": "Socket-\u003ePtr a-\u003eInt-\u003eIO(Int,SockAddr)",
          "package": "network",
          "partial": "Buf From",
          "signature": "Socket-\u003ePtr a-\u003eInt-\u003eIO(Int,SockAddr)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:recvBufFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "recvFd",
          "package": "network",
          "signature": "Socket -\u003e IO CInt",
          "source": "src/Network-Socket.html#recvFd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "recvFd",
          "normalized": "Socket-\u003eIO CInt",
          "package": "network",
          "partial": "Fd",
          "signature": "Socket-\u003eIO CInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:recvFd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReceive data from the socket. The socket need not be in a\n connected state. Returns \u003ccode\u003e(bytes, nbytes, address)\u003c/code\u003e where \u003ccode\u003ebytes\u003c/code\u003e\n is a \u003ccode\u003eString\u003c/code\u003e of length \u003ccode\u003enbytes\u003c/code\u003e representing the data received and\n \u003ccode\u003eaddress\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eSockAddr\u003c/a\u003e\u003c/code\u003e representing the address of the sending\n socket.\n\u003c/p\u003e\u003cp\u003eNOTE: blocking on Windows unless you compile with -threaded (see\n GHC ticket #1129)\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "recvFrom",
          "package": "network",
          "signature": "Socket -\u003e Int -\u003e IO (String, Int, SockAddr)",
          "source": "src/Network-Socket.html#recvFrom",
          "type": "function"
        },
        "index": {
          "description": "Receive data from the socket The socket need not be in connected state Returns bytes nbytes address where bytes is String of length nbytes representing the data received and address is SockAddr representing the address of the sending socket NOTE blocking on Windows unless you compile with threaded see GHC ticket",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "recvFrom",
          "normalized": "Socket-\u003eInt-\u003eIO(String,Int,SockAddr)",
          "package": "network",
          "partial": "From",
          "signature": "Socket-\u003eInt-\u003eIO(String,Int,SockAddr)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:recvFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "recvLen",
          "package": "network",
          "signature": "Socket -\u003e Int -\u003e IO (String, Int)",
          "source": "src/Network-Socket.html#recvLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "recvLen",
          "normalized": "Socket-\u003eInt-\u003eIO(String,Int)",
          "package": "network",
          "partial": "Len",
          "signature": "Socket-\u003eInt-\u003eIO(String,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:recvLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "sCM_RIGHTS",
          "package": "network",
          "signature": "Int",
          "source": "src/Network-Socket.html#sCM_RIGHTS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sCM_RIGHTS",
          "package": "network",
          "partial": "CM RIGHTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sCM_RIGHTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated alias for \u003ccode\u003e\u003ca\u003eclose\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sClose",
          "package": "network",
          "signature": "Socket -\u003e IO ()",
          "source": "src/Network-Socket.html#sClose",
          "type": "function"
        },
        "index": {
          "description": "Deprecated alias for close",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sClose",
          "normalized": "Socket-\u003eIO()",
          "package": "network",
          "partial": "Close",
          "signature": "Socket-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated alias for \u003ccode\u003e\u003ca\u003eisBound\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sIsBound",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#sIsBound",
          "type": "function"
        },
        "index": {
          "description": "Deprecated alias for isBound",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sIsBound",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Is Bound",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sIsBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated alias for \u003ccode\u003e\u003ca\u003eisConnected\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sIsConnected",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#sIsConnected",
          "type": "function"
        },
        "index": {
          "description": "Deprecated alias for isConnected",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sIsConnected",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Is Connected",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sIsConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated alias for \u003ccode\u003e\u003ca\u003eisListening\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sIsListening",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#sIsListening",
          "type": "function"
        },
        "index": {
          "description": "Deprecated alias for isListening",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sIsListening",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Is Listening",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sIsListening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated alias for \u003ccode\u003e\u003ca\u003eisReadable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sIsReadable",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#sIsReadable",
          "type": "function"
        },
        "index": {
          "description": "Deprecated alias for isReadable",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sIsReadable",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Is Readable",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sIsReadable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated alias for \u003ccode\u003e\u003ca\u003eisWritable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sIsWritable",
          "package": "network",
          "signature": "Socket -\u003e IO Bool",
          "source": "src/Network-Socket.html#sIsWritable",
          "type": "function"
        },
        "index": {
          "description": "Deprecated alias for isWritable",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sIsWritable",
          "normalized": "Socket-\u003eIO Bool",
          "package": "network",
          "partial": "Is Writable",
          "signature": "Socket-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sIsWritable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "sOL_SOCKET",
          "package": "network",
          "signature": "Int",
          "source": "src/Network-Socket.html#sOL_SOCKET",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sOL_SOCKET",
          "package": "network",
          "partial": "OL SOCKET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sOL_SOCKET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "sOMAXCONN",
          "package": "network",
          "signature": "Int",
          "source": "src/Network-Socket.html#sOMAXCONN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sOMAXCONN",
          "package": "network",
          "partial": "OMAXCONN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sOMAXCONN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket. The socket must be connected to a remote\n socket. Returns the number of bytes sent.  Applications are\n responsible for ensuring that all data has been sent.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "send",
          "package": "network",
          "signature": "Socket -\u003e String -\u003e IO Int",
          "source": "src/Network-Socket.html#send",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The socket must be connected to remote socket Returns the number of bytes sent Applications are responsible for ensuring that all data has been sent",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "send",
          "normalized": "Socket-\u003eString-\u003eIO Int",
          "package": "network",
          "signature": "Socket-\u003eString-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:send"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket. The socket must be connected to a remote\n socket. Returns the number of bytes sent.  Applications are\n responsible for ensuring that all data has been sent.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sendBuf",
          "package": "network",
          "signature": "Socket -\u003e Ptr Word8 -\u003e Int -\u003e IO Int",
          "source": "src/Network-Socket.html#sendBuf",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The socket must be connected to remote socket Returns the number of bytes sent Applications are responsible for ensuring that all data has been sent",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sendBuf",
          "normalized": "Socket-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "package": "network",
          "partial": "Buf",
          "signature": "Socket-\u003ePtr Word-\u003eInt-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sendBuf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The recipient can be specified\n explicitly, so the socket need not be in a connected state.\n Returns the number of bytes sent.  Applications are responsible for\n ensuring that all data has been sent.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sendBufTo",
          "package": "network",
          "signature": "Socket -\u003e Ptr a -\u003e Int -\u003e SockAddr -\u003e IO Int",
          "source": "src/Network-Socket.html#sendBufTo",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The recipient can be specified explicitly so the socket need not be in connected state Returns the number of bytes sent Applications are responsible for ensuring that all data has been sent",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sendBufTo",
          "normalized": "Socket-\u003ePtr a-\u003eInt-\u003eSockAddr-\u003eIO Int",
          "package": "network",
          "partial": "Buf To",
          "signature": "Socket-\u003ePtr a-\u003eInt-\u003eSockAddr-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sendBufTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "sendFd",
          "package": "network",
          "signature": "Socket -\u003e CInt -\u003e IO ()",
          "source": "src/Network-Socket.html#sendFd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sendFd",
          "normalized": "Socket-\u003eCInt-\u003eIO()",
          "package": "network",
          "partial": "Fd",
          "signature": "Socket-\u003eCInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sendFd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend data to the socket.  The recipient can be specified\n explicitly, so the socket need not be in a connected state.\n Returns the number of bytes sent.  Applications are responsible for\n ensuring that all data has been sent.\n\u003c/p\u003e\u003cp\u003eNOTE: blocking on Windows unless you compile with -threaded (see\n GHC ticket #1129)\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "sendTo",
          "package": "network",
          "signature": "Socket -\u003e String -\u003e SockAddr -\u003e IO Int",
          "source": "src/Network-Socket.html#sendTo",
          "type": "function"
        },
        "index": {
          "description": "Send data to the socket The recipient can be specified explicitly so the socket need not be in connected state Returns the number of bytes sent Applications are responsible for ensuring that all data has been sent NOTE blocking on Windows unless you compile with threaded see GHC ticket",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "sendTo",
          "normalized": "Socket-\u003eString-\u003eSockAddr-\u003eIO Int",
          "package": "network",
          "partial": "To",
          "signature": "Socket-\u003eString-\u003eSockAddr-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:sendTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet a socket option that expects an Int value.\n There is currently no API to set e.g. the timeval socket options\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "setSocketOption",
          "package": "network",
          "signature": "Socket -\u003e SocketOption -\u003e Int -\u003e IO ()",
          "source": "src/Network-Socket.html#setSocketOption",
          "type": "function"
        },
        "index": {
          "description": "Set socket option that expects an Int value There is currently no API to set e.g the timeval socket options",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "setSocketOption",
          "normalized": "Socket-\u003eSocketOption-\u003eInt-\u003eIO()",
          "package": "network",
          "partial": "Socket Option",
          "signature": "Socket-\u003eSocketOption-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:setSocketOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShut down one or both halves of the connection, depending on the\n second argument to the function.  If the second argument is\n \u003ccode\u003e\u003ca\u003eShutdownReceive\u003c/a\u003e\u003c/code\u003e, further receives are disallowed.  If it is\n \u003ccode\u003e\u003ca\u003eShutdownSend\u003c/a\u003e\u003c/code\u003e, further sends are disallowed.  If it is\n \u003ccode\u003e\u003ca\u003eShutdownBoth\u003c/a\u003e\u003c/code\u003e, further sends and receives are disallowed.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "shutdown",
          "package": "network",
          "signature": "Socket -\u003e ShutdownCmd -\u003e IO ()",
          "source": "src/Network-Socket.html#shutdown",
          "type": "function"
        },
        "index": {
          "description": "Shut down one or both halves of the connection depending on the second argument to the function If the second argument is ShutdownReceive further receives are disallowed If it is ShutdownSend further sends are disallowed If it is ShutdownBoth further sends and receives are disallowed",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "shutdown",
          "normalized": "Socket-\u003eShutdownCmd-\u003eIO()",
          "package": "network",
          "signature": "Socket-\u003eShutdownCmd-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:shutdown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new socket using the given address family, socket type\n and protocol number.  The address family is usually \u003ccode\u003e\u003ca\u003eAF_INET\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eAF_INET6\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eAF_UNIX\u003c/a\u003e\u003c/code\u003e.  The socket type is usually \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eDatagram\u003c/a\u003e\u003c/code\u003e.  The protocol number is usually \u003ccode\u003e\u003ca\u003edefaultProtocol\u003c/a\u003e\u003c/code\u003e.\n If \u003ccode\u003e\u003ca\u003eAF_INET6\u003c/a\u003e\u003c/code\u003e is used, the \u003ccode\u003e\u003ca\u003eIPv6Only\u003c/a\u003e\u003c/code\u003e socket option is set to 0\n so that both IPv4 and IPv6 can be handled with one socket.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "socket",
          "package": "network",
          "signature": "Family -\u003e SocketType -\u003e ProtocolNumber -\u003e IO Socket",
          "source": "src/Network-Socket.html#socket",
          "type": "function"
        },
        "index": {
          "description": "Create new socket using the given address family socket type and protocol number The address family is usually AF INET AF INET6 or AF UNIX The socket type is usually Stream or Datagram The protocol number is usually defaultProtocol If AF INET6 is used the IPv6Only socket option is set to so that both IPv4 and IPv6 can be handled with one socket",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "socket",
          "normalized": "Family-\u003eSocketType-\u003eProtocolNumber-\u003eIO Socket",
          "package": "network",
          "signature": "Family-\u003eSocketType-\u003eProtocolNumber-\u003eIO Socket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:socket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a pair of connected socket objects using the given address\n family, socket type, and protocol number.  Address family, socket\n type, and protocol number are as for the \u003ccode\u003e\u003ca\u003esocket\u003c/a\u003e\u003c/code\u003e function above.\n Availability: Unix.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "socketPair",
          "package": "network",
          "signature": "Family -\u003e SocketType -\u003e ProtocolNumber -\u003e IO (Socket, Socket)",
          "source": "src/Network-Socket.html#socketPair",
          "type": "function"
        },
        "index": {
          "description": "Build pair of connected socket objects using the given address family socket type and protocol number Address family socket type and protocol number are as for the socket function above Availability Unix",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "socketPair",
          "normalized": "Family-\u003eSocketType-\u003eProtocolNumber-\u003eIO(Socket,Socket)",
          "package": "network",
          "partial": "Pair",
          "signature": "Family-\u003eSocketType-\u003eProtocolNumber-\u003eIO(Socket,Socket)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:socketPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "socketPort",
          "package": "network",
          "signature": "Socket -\u003e IO PortNumber",
          "source": "src/Network-Socket.html#socketPort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "socketPort",
          "normalized": "Socket-\u003eIO PortNumber",
          "package": "network",
          "partial": "Port",
          "signature": "Socket-\u003eIO PortNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:socketPort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurns a Socket into an \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e. By default, the new handle is\n unbuffered. Use \u003ccode\u003e\u003ca\u003ehSetBuffering\u003c/a\u003e\u003c/code\u003e to change the buffering.\n\u003c/p\u003e\u003cp\u003eNote that since a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e is automatically closed by a finalizer\n when it is no longer referenced, you should avoid doing any more\n operations on the \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e after calling \u003ccode\u003e\u003ca\u003esocketToHandle\u003c/a\u003e\u003c/code\u003e.  To\n close the \u003ccode\u003e\u003ca\u003eSocket\u003c/a\u003e\u003c/code\u003e after \u003ccode\u003e\u003ca\u003esocketToHandle\u003c/a\u003e\u003c/code\u003e, call \u003ccode\u003e\u003ca\u003ehClose\u003c/a\u003e\u003c/code\u003e\n on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Socket",
          "name": "socketToHandle",
          "package": "network",
          "signature": "Socket -\u003e IOMode -\u003e IO Handle",
          "source": "src/Network-Socket.html#socketToHandle",
          "type": "function"
        },
        "index": {
          "description": "Turns Socket into an Handle By default the new handle is unbuffered Use hSetBuffering to change the buffering Note that since Handle is automatically closed by finalizer when it is no longer referenced you should avoid doing any more operations on the Socket after calling socketToHandle To close the Socket after socketToHandle call hClose on the Handle",
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "socketToHandle",
          "normalized": "Socket-\u003eIOMode-\u003eIO Handle",
          "package": "network",
          "partial": "To Handle",
          "signature": "Socket-\u003eIOMode-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:socketToHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Socket",
          "name": "unpackFamily",
          "package": "network",
          "signature": "CInt -\u003e Family",
          "source": "src/Network-Socket-Types.html#unpackFamily",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Socket",
          "module": "Network.Socket",
          "name": "unpackFamily",
          "normalized": "CInt-\u003eFamily",
          "package": "network",
          "partial": "Family",
          "signature": "CInt-\u003eFamily",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-Socket.html#v:unpackFamily"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines functions for handling URIs.  It presents substantially the\n  same interface as the older GHC Network.URI module, but is implemented using\n  Parsec rather than a Regex library that is not available with Hugs.  The internal\n  representation of URI has been changed so that URI strings are more\n  completely preserved when round-tripping to a URI value and back.\n\u003c/p\u003e\u003cp\u003eIn addition, four methods are provided for parsing different\n  kinds of URI string (as noted in RFC3986):\n      \u003ccode\u003e\u003ca\u003eparseURI\u003c/a\u003e\u003c/code\u003e,\n      \u003ccode\u003e\u003ca\u003eparseURIReference\u003c/a\u003e\u003c/code\u003e,\n      \u003ccode\u003e\u003ca\u003eparseRelativeReference\u003c/a\u003e\u003c/code\u003e and\n      \u003ccode\u003e\u003ca\u003eparseAbsoluteURI\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFurther, four methods are provided for classifying different\n  kinds of URI string (as noted in RFC3986):\n      \u003ccode\u003e\u003ca\u003eisURI\u003c/a\u003e\u003c/code\u003e,\n      \u003ccode\u003e\u003ca\u003eisURIReference\u003c/a\u003e\u003c/code\u003e,\n      \u003ccode\u003e\u003ca\u003eisRelativeReference\u003c/a\u003e\u003c/code\u003e and\n      \u003ccode\u003e\u003ca\u003eisAbsoluteURI\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe long-standing official reference for URI handling was RFC2396 [1],\n  as updated by RFC 2732 [2], but this was replaced by a new specification,\n  RFC3986 [3] in January 2005.  This latter specification has been used\n  as the primary reference for constructing the URI parser implemented\n  here, and it is intended that there is a direct relationship between\n  the syntax definition in that document and this parser implementation.\n\u003c/p\u003e\u003cp\u003eRFC 1808 [4] contains a number of test cases for relative URI handling.\n  Dan Connolly's Python module \u003ccode\u003euripath.py\u003c/code\u003e [5] also contains useful details\n  and test cases.\n\u003c/p\u003e\u003cp\u003eSome of the code has been copied from the previous GHC implementation,\n  but the parser is replaced with one that performs more complete\n  syntax checking of the URI itself, according to RFC3986 [3].\n\u003c/p\u003e\u003cp\u003eReferences\n\u003c/p\u003e\u003col\u003e\u003cli\u003e \u003ca\u003ehttp://www.ietf.org/rfc/rfc2396.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.ietf.org/rfc/rfc2732.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.ietf.org/rfc/rfc3986.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.ietf.org/rfc/rfc1808.txt\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e \u003ca\u003ehttp://www.w3.org/2000/10/swap/uripath.py\u003c/a\u003e\n\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "URI",
          "package": "network",
          "source": "src/Network-URI.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines functions for handling URIs It presents substantially the same interface as the older GHC Network.URI module but is implemented using Parsec rather than Regex library that is not available with Hugs The internal representation of URI has been changed so that URI strings are more completely preserved when round-tripping to URI value and back In addition four methods are provided for parsing different kinds of URI string as noted in RFC3986 parseURI parseURIReference parseRelativeReference and parseAbsoluteURI Further four methods are provided for classifying different kinds of URI string as noted in RFC3986 isURI isURIReference isRelativeReference and isAbsoluteURI The long-standing official reference for URI handling was RFC2396 as updated by RFC but this was replaced by new specification RFC3986 in January This latter specification has been used as the primary reference for constructing the URI parser implemented here and it is intended that there is direct relationship between the syntax definition in that document and this parser implementation RFC contains number of test cases for relative URI handling Dan Connolly Python module uripath.py also contains useful details and test cases Some of the code has been copied from the previous GHC implementation but the parser is replaced with one that performs more complete syntax checking of the URI itself according to RFC3986 References http www.ietf.org rfc rfc2396.txt http www.ietf.org rfc rfc2732.txt http www.ietf.org rfc rfc3986.txt http www.ietf.org rfc rfc1808.txt http www.w3.org swap uripath.py",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "URI",
          "package": "network",
          "partial": "URI",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents a general universal resource identifier using\n  its component parts.\n\u003c/p\u003e\u003cp\u003eFor example, for the URI\n\u003c/p\u003e\u003cpre\u003e   foo://anonymous@www.haskell.org:42/ghc?query#frag\n\u003c/pre\u003e\u003cp\u003ethe components are:\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "URI",
          "package": "network",
          "source": "src/Network-URI.html#URI",
          "type": "data"
        },
        "index": {
          "description": "Represents general universal resource identifier using its component parts For example for the URI foo anonymous@www.haskell.org ghc query frag the components are",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "URI",
          "package": "network",
          "partial": "URI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#t:URI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for authority value within a URI\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "URIAuth",
          "package": "network",
          "source": "src/Network-URI.html#URIAuth",
          "type": "data"
        },
        "index": {
          "description": "Type for authority value within URI",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "URIAuth",
          "package": "network",
          "partial": "URIAuth",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#t:URIAuth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.URI",
          "name": "URI",
          "package": "network",
          "signature": "URI",
          "source": "src/Network-URI.html#URI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "URI",
          "package": "network",
          "partial": "URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:URI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.URI",
          "name": "URIAuth",
          "package": "network",
          "signature": "URIAuth",
          "source": "src/Network-URI.html#URIAuth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "URIAuth",
          "package": "network",
          "partial": "URIAuth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:URIAuth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use uriAuthority, and note changed functionality\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "authority",
          "package": "network",
          "signature": "URI -\u003e String",
          "source": "src/Network-URI.html#authority",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use uriAuthority and note changed functionality",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "authority",
          "normalized": "URI-\u003eString",
          "package": "network",
          "signature": "URI-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:authority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use escapeURIString, and note the flipped arguments\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "escapeString",
          "package": "network",
          "signature": "String -\u003e (Char -\u003e Bool) -\u003e String",
          "source": "src/Network-URI.html#escapeString",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use escapeURIString and note the flipped arguments",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "escapeString",
          "normalized": "String-\u003e(Char-\u003eBool)-\u003eString",
          "package": "network",
          "partial": "String",
          "signature": "String-\u003e(Char-\u003eBool)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:escapeString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEscape character if supplied predicate is not satisfied,\n  otherwise return character as singleton string.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "escapeURIChar",
          "package": "network",
          "signature": "(Char -\u003e Bool) -\u003e Char -\u003e String",
          "source": "src/Network-URI.html#escapeURIChar",
          "type": "function"
        },
        "index": {
          "description": "Escape character if supplied predicate is not satisfied otherwise return character as singleton string",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "escapeURIChar",
          "normalized": "(Char-\u003eBool)-\u003eChar-\u003eString",
          "package": "network",
          "partial": "URIChar",
          "signature": "(Char-\u003eBool)-\u003eChar-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:escapeURIChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCan be used to make a string valid for use in a URI.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "escapeURIString",
          "package": "network",
          "signature": "(Char -\u003e Bool)-\u003e String-\u003e String",
          "type": "function"
        },
        "index": {
          "description": "Can be used to make string valid for use in URI",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "escapeURIString",
          "normalized": "(Char-\u003eBool)-\u003eString-\u003eString",
          "package": "network",
          "partial": "URIString",
          "signature": "(Char-\u003eBool)-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:escapeURIString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use uriFragment, and note changed functionality\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "fragment",
          "package": "network",
          "signature": "URI -\u003e String",
          "source": "src/Network-URI.html#fragment",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use uriFragment and note changed functionality",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "fragment",
          "normalized": "URI-\u003eString",
          "package": "network",
          "signature": "URI-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:fragment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if string contains a valid absolute URI\n  (an absolute URI without a fragment identifier).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isAbsoluteURI",
          "package": "network",
          "signature": "String -\u003e Bool",
          "source": "src/Network-URI.html#isAbsoluteURI",
          "type": "function"
        },
        "index": {
          "description": "Test if string contains valid absolute URI an absolute URI without fragment identifier",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isAbsoluteURI",
          "normalized": "String-\u003eBool",
          "package": "network",
          "partial": "Absolute URI",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isAbsoluteURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the character is allowed in a URI.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isAllowedInURI",
          "package": "network",
          "signature": "Char -\u003e Bool",
          "source": "src/Network-URI.html#isAllowedInURI",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the character is allowed in URI",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isAllowedInURI",
          "normalized": "Char-\u003eBool",
          "package": "network",
          "partial": "Allowed In URI",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isAllowedInURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if string contains a valid IPv4 address\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isIPv4address",
          "package": "network",
          "signature": "String -\u003e Bool",
          "source": "src/Network-URI.html#isIPv4address",
          "type": "function"
        },
        "index": {
          "description": "Test if string contains valid IPv4 address",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isIPv4address",
          "normalized": "String-\u003eBool",
          "package": "network",
          "partial": "IPv",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isIPv4address"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if string contains a valid IPv6 address\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isIPv6address",
          "package": "network",
          "signature": "String -\u003e Bool",
          "source": "src/Network-URI.html#isIPv6address",
          "type": "function"
        },
        "index": {
          "description": "Test if string contains valid IPv6 address",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isIPv6address",
          "normalized": "String-\u003eBool",
          "package": "network",
          "partial": "IPv",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isIPv6address"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if string contains a valid relative URI\n  (a relative URI with optional fragment identifier).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isRelativeReference",
          "package": "network",
          "signature": "String -\u003e Bool",
          "source": "src/Network-URI.html#isRelativeReference",
          "type": "function"
        },
        "index": {
          "description": "Test if string contains valid relative URI relative URI with optional fragment identifier",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isRelativeReference",
          "normalized": "String-\u003eBool",
          "package": "network",
          "partial": "Relative Reference",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isRelativeReference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the character is a \"reserved\" character in a\n  URI.  To include a literal instance of one of these characters in a\n  component of a URI, it must be escaped.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isReserved",
          "package": "network",
          "signature": "Char -\u003e Bool",
          "source": "src/Network-URI.html#isReserved",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the character is reserved character in URI To include literal instance of one of these characters in component of URI it must be escaped",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isReserved",
          "normalized": "Char-\u003eBool",
          "package": "network",
          "partial": "Reserved",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isReserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if string contains a valid URI\n  (an absolute URI with optional fragment identifier).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isURI",
          "package": "network",
          "signature": "String -\u003e Bool",
          "source": "src/Network-URI.html#isURI",
          "type": "function"
        },
        "index": {
          "description": "Test if string contains valid URI an absolute URI with optional fragment identifier",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isURI",
          "normalized": "String-\u003eBool",
          "package": "network",
          "partial": "URI",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if string contains a valid URI reference\n  (an absolute or relative URI with optional fragment identifier).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isURIReference",
          "package": "network",
          "signature": "String -\u003e Bool",
          "source": "src/Network-URI.html#isURIReference",
          "type": "function"
        },
        "index": {
          "description": "Test if string contains valid URI reference an absolute or relative URI with optional fragment identifier",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isURIReference",
          "normalized": "String-\u003eBool",
          "package": "network",
          "partial": "URIReference",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isURIReference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the character is allowed unescaped in a URI.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isUnescapedInURI",
          "package": "network",
          "signature": "Char -\u003e Bool",
          "source": "src/Network-URI.html#isUnescapedInURI",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the character is allowed unescaped in URI",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isUnescapedInURI",
          "normalized": "Char-\u003eBool",
          "package": "network",
          "partial": "Unescaped In URI",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isUnescapedInURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the character is allowed unescaped in a URI component.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isUnescapedInURIComponent",
          "package": "network",
          "signature": "Char -\u003e Bool",
          "source": "src/Network-URI.html#isUnescapedInURIComponent",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the character is allowed unescaped in URI component",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isUnescapedInURIComponent",
          "normalized": "Char-\u003eBool",
          "package": "network",
          "partial": "Unescaped In URIComponent",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isUnescapedInURIComponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the character is an \"unreserved\" character in\n  a URI.  These characters do not need to be escaped in a URI.  The\n  only characters allowed in a URI are either \"reserved\",\n  \"unreserved\", or an escape sequence (\u003ccode\u003e%\u003c/code\u003e followed by two hex digits).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "isUnreserved",
          "package": "network",
          "signature": "Char -\u003e Bool",
          "source": "src/Network-URI.html#isUnreserved",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the character is an unreserved character in URI These characters do not need to be escaped in URI The only characters allowed in URI are either reserved unreserved or an escape sequence followed by two hex digits",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "isUnreserved",
          "normalized": "Char-\u003eBool",
          "package": "network",
          "partial": "Unreserved",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:isUnreserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a new \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e which represents the value of the\n  first \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e interpreted as relative to the second \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e.\n  For example:\n\u003c/p\u003e\u003cpre\u003e \"foo\" `relativeTo` \"http://bar.org/\" = \"http://bar.org/foo\"\n \"http:foo\" `nonStrictRelativeTo` \"http://bar.org/\" = \"http://bar.org/foo\"\n\u003c/pre\u003e\u003cp\u003eAlgorithm from RFC3986 [3], section 5.2.2\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "nonStrictRelativeTo",
          "package": "network",
          "signature": "URI -\u003e URI -\u003e URI",
          "source": "src/Network-URI.html#nonStrictRelativeTo",
          "type": "function"
        },
        "index": {
          "description": "Returns new URI which represents the value of the first URI interpreted as relative to the second URI For example foo relativeTo http bar.org http bar.org foo http foo nonStrictRelativeTo http bar.org http bar.org foo Algorithm from RFC3986 section",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "nonStrictRelativeTo",
          "normalized": "URI-\u003eURI-\u003eURI",
          "package": "network",
          "partial": "Strict Relative To",
          "signature": "URI-\u003eURI-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:nonStrictRelativeTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCase normalization; cf. RFC3986 section 6.2.2.1\n  NOTE:  authority case normalization is not performed\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "normalizeCase",
          "package": "network",
          "signature": "String -\u003e String",
          "source": "src/Network-URI.html#normalizeCase",
          "type": "function"
        },
        "index": {
          "description": "Case normalization cf RFC3986 section NOTE authority case normalization is not performed",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "normalizeCase",
          "normalized": "String-\u003eString",
          "package": "network",
          "partial": "Case",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:normalizeCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoding normalization; cf. RFC3986 section 6.2.2.2\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "normalizeEscape",
          "package": "network",
          "signature": "String -\u003e String",
          "source": "src/Network-URI.html#normalizeEscape",
          "type": "function"
        },
        "index": {
          "description": "Encoding normalization cf RFC3986 section",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "normalizeEscape",
          "normalized": "String-\u003eString",
          "package": "network",
          "partial": "Escape",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:normalizeEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePath segment normalization; cf. RFC3986 section 6.2.2.4\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "normalizePathSegments",
          "package": "network",
          "signature": "String -\u003e String",
          "source": "src/Network-URI.html#normalizePathSegments",
          "type": "function"
        },
        "index": {
          "description": "Path segment normalization cf RFC3986 section",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "normalizePathSegments",
          "normalized": "String-\u003eString",
          "package": "network",
          "partial": "Path Segments",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:normalizePathSegments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlank URI\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "nullURI",
          "package": "network",
          "signature": "URI",
          "source": "src/Network-URI.html#nullURI",
          "type": "function"
        },
        "index": {
          "description": "Blank URI",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "nullURI",
          "package": "network",
          "partial": "URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:nullURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse an absolute URI to a \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e value.\n  Returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not a valid absolute URI.\n  (an absolute URI without a fragment identifier).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "parseAbsoluteURI",
          "package": "network",
          "signature": "String -\u003e Maybe URI",
          "source": "src/Network-URI.html#parseAbsoluteURI",
          "type": "function"
        },
        "index": {
          "description": "Parse an absolute URI to URI value Returns Nothing if the string is not valid absolute URI an absolute URI without fragment identifier",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "parseAbsoluteURI",
          "normalized": "String-\u003eMaybe URI",
          "package": "network",
          "partial": "Absolute URI",
          "signature": "String-\u003eMaybe URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:parseAbsoluteURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a relative URI to a \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e value.\n  Returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not a valid relative URI.\n  (a relative URI with optional fragment identifier).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "parseRelativeReference",
          "package": "network",
          "signature": "String -\u003e Maybe URI",
          "source": "src/Network-URI.html#parseRelativeReference",
          "type": "function"
        },
        "index": {
          "description": "Parse relative URI to URI value Returns Nothing if the string is not valid relative URI relative URI with optional fragment identifier",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "parseRelativeReference",
          "normalized": "String-\u003eMaybe URI",
          "package": "network",
          "partial": "Relative Reference",
          "signature": "String-\u003eMaybe URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:parseRelativeReference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a string containing a URI into a \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e.\n  Returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not a valid URI;\n  (an absolute URI with optional fragment identifier).\n\u003c/p\u003e\u003cp\u003eNOTE: this is different from the previous network.URI,\n  whose \u003ccode\u003eparseURI\u003c/code\u003e function works like \u003ccode\u003e\u003ca\u003eparseURIReference\u003c/a\u003e\u003c/code\u003e\n  in this module.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "parseURI",
          "package": "network",
          "signature": "String -\u003e Maybe URI",
          "source": "src/Network-URI.html#parseURI",
          "type": "function"
        },
        "index": {
          "description": "Turn string containing URI into URI Returns Nothing if the string is not valid URI an absolute URI with optional fragment identifier NOTE this is different from the previous network.URI whose parseURI function works like parseURIReference in this module",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "parseURI",
          "normalized": "String-\u003eMaybe URI",
          "package": "network",
          "partial": "URI",
          "signature": "String-\u003eMaybe URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:parseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a URI reference to a \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e value.\n  Returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the string is not a valid URI reference.\n  (an absolute or relative URI with optional fragment identifier).\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "parseURIReference",
          "package": "network",
          "signature": "String -\u003e Maybe URI",
          "source": "src/Network-URI.html#parseURIReference",
          "type": "function"
        },
        "index": {
          "description": "Parse URI reference to URI value Returns Nothing if the string is not valid URI reference an absolute or relative URI with optional fragment identifier",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "parseURIReference",
          "normalized": "String-\u003eMaybe URI",
          "package": "network",
          "partial": "URIReference",
          "signature": "String-\u003eMaybe URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:parseURIReference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use parseAbsoluteURI\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "parseabsoluteURI",
          "package": "network",
          "signature": "String -\u003e Maybe URI",
          "source": "src/Network-URI.html#parseabsoluteURI",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use parseAbsoluteURI",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "parseabsoluteURI",
          "normalized": "String-\u003eMaybe URI",
          "package": "network",
          "partial": "URI",
          "signature": "String-\u003eMaybe URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:parseabsoluteURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use uriPath\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "path",
          "package": "network",
          "signature": "URI -\u003e String",
          "source": "src/Network-URI.html#path",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use uriPath",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "path",
          "normalized": "URI-\u003eString",
          "package": "network",
          "signature": "URI-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:path"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use uriQuery, and note changed functionality\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "query",
          "package": "network",
          "signature": "URI -\u003e String",
          "source": "src/Network-URI.html#query",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use uriQuery and note changed functionality",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "query",
          "normalized": "URI-\u003eString",
          "package": "network",
          "signature": "URI-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:query"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a new \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e which represents the relative location of\n  the first \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e with respect to the second \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e.  Thus, the\n  values supplied are expected to be absolute URIs, and the result\n  returned may be a relative URI.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e \"http://example.com/Root/sub1/name2#frag\"\n   `relativeFrom` \"http://example.com/Root/sub2/name2#frag\"\n   == \"../sub1/name2#frag\"\n\u003c/pre\u003e\u003cp\u003eThere is no single correct implementation of this function,\n  but any acceptable implementation must satisfy the following:\n\u003c/p\u003e\u003cpre\u003e (uabs `relativeFrom` ubase) `relativeTo` ubase == uabs\n\u003c/pre\u003e\u003cp\u003eFor any valid absolute URI.\n  (cf. \u003ca\u003ehttp://lists.w3.org/Archives/Public/uri/2003Jan/0008.html\u003c/a\u003e\n       \u003ca\u003ehttp://lists.w3.org/Archives/Public/uri/2003Jan/0005.html\u003c/a\u003e)\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "relativeFrom",
          "package": "network",
          "signature": "URI -\u003e URI -\u003e URI",
          "source": "src/Network-URI.html#relativeFrom",
          "type": "function"
        },
        "index": {
          "description": "Returns new URI which represents the relative location of the first URI with respect to the second URI Thus the values supplied are expected to be absolute URIs and the result returned may be relative URI Example http example.com Root sub1 name2 frag relativeFrom http example.com Root sub2 name2 frag sub1 name2 frag There is no single correct implementation of this function but any acceptable implementation must satisfy the following uabs relativeFrom ubase relativeTo ubase uabs For any valid absolute URI cf http lists.w3.org Archives Public uri Jan html http lists.w3.org Archives Public uri Jan html",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "relativeFrom",
          "normalized": "URI-\u003eURI-\u003eURI",
          "package": "network",
          "partial": "From",
          "signature": "URI-\u003eURI-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:relativeFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a new \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e which represents the value of the first \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e\n interpreted as relative to the second \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAlgorithm from RFC3986 [3], section 5.2\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "relativeTo",
          "package": "network",
          "signature": "URI -\u003e URI -\u003e URI",
          "source": "src/Network-URI.html#relativeTo",
          "type": "function"
        },
        "index": {
          "description": "Returns new URI which represents the value of the first URI interpreted as relative to the second URI Algorithm from RFC3986 section",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "relativeTo",
          "normalized": "URI-\u003eURI-\u003eURI",
          "package": "network",
          "partial": "To",
          "signature": "URI-\u003eURI-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:relativeTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use isReserved\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "reserved",
          "package": "network",
          "signature": "Char -\u003e Bool",
          "source": "src/Network-URI.html#reserved",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use isReserved",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "reserved",
          "normalized": "Char-\u003eBool",
          "package": "network",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:reserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use uriScheme\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "scheme",
          "package": "network",
          "signature": "URI -\u003e String",
          "source": "src/Network-URI.html#scheme",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use uriScheme",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "scheme",
          "normalized": "URI-\u003eString",
          "package": "network",
          "signature": "URI-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:scheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurns all instances of escaped characters in the string back\n  into literal characters.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "unEscapeString",
          "package": "network",
          "signature": "String -\u003e String",
          "source": "src/Network-URI.html#unEscapeString",
          "type": "function"
        },
        "index": {
          "description": "Turns all instances of escaped characters in the string back into literal characters",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "unEscapeString",
          "normalized": "String-\u003eString",
          "package": "network",
          "partial": "Escape String",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:unEscapeString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use isUnreserved\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI",
          "name": "unreserved",
          "package": "network",
          "signature": "Char -\u003e Bool",
          "source": "src/Network-URI.html#unreserved",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use isUnreserved",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "unreserved",
          "normalized": "Char-\u003eBool",
          "package": "network",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:unreserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e//anonymous@www.haskell.org:42\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriAuthority",
          "package": "network",
          "signature": "Maybe URIAuth",
          "source": "src/Network-URI.html#URI",
          "type": "function"
        },
        "index": {
          "description": "anonymous@www.haskell.org",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriAuthority",
          "package": "network",
          "partial": "Authority",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriAuthority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e#frag\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriFragment",
          "package": "network",
          "signature": "String",
          "source": "src/Network-URI.html#URI",
          "type": "function"
        },
        "index": {
          "description": "frag",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriFragment",
          "package": "network",
          "partial": "Fragment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriFragment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.URI",
          "name": "uriIsAbsolute",
          "package": "network",
          "signature": "URI -\u003e Bool",
          "source": "src/Network-URI.html#uriIsAbsolute",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriIsAbsolute",
          "normalized": "URI-\u003eBool",
          "package": "network",
          "partial": "Is Absolute",
          "signature": "URI-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriIsAbsolute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.URI",
          "name": "uriIsRelative",
          "package": "network",
          "signature": "URI -\u003e Bool",
          "source": "src/Network-URI.html#uriIsRelative",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriIsRelative",
          "normalized": "URI-\u003eBool",
          "package": "network",
          "partial": "Is Relative",
          "signature": "URI-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriIsRelative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e/ghc\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriPath",
          "package": "network",
          "signature": "String",
          "source": "src/Network-URI.html#URI",
          "type": "function"
        },
        "index": {
          "description": "ghc",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriPath",
          "package": "network",
          "partial": "Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e:42\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriPort",
          "package": "network",
          "signature": "String",
          "source": "src/Network-URI.html#URIAuth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriPort",
          "package": "network",
          "partial": "Port",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriPort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e?query\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriQuery",
          "package": "network",
          "signature": "String",
          "source": "src/Network-URI.html#URI",
          "type": "function"
        },
        "index": {
          "description": "query",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriQuery",
          "package": "network",
          "partial": "Query",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriQuery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003ewww.haskell.org\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriRegName",
          "package": "network",
          "signature": "String",
          "source": "src/Network-URI.html#URIAuth",
          "type": "function"
        },
        "index": {
          "description": "www.haskell.org",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriRegName",
          "package": "network",
          "partial": "Reg Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriRegName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003efoo:\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriScheme",
          "package": "network",
          "signature": "String",
          "source": "src/Network-URI.html#URI",
          "type": "function"
        },
        "index": {
          "description": "foo",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriScheme",
          "package": "network",
          "partial": "Scheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e into a string.\n\u003c/p\u003e\u003cp\u003eUses a supplied function to map the userinfo part of the URI.\n\u003c/p\u003e\u003cp\u003eThe Show instance for URI uses a mapping that hides any password\n  that may be present in the URI.  Use this function with argument \u003ccode\u003eid\u003c/code\u003e\n  to preserve the password in the formatted output.\n\u003c/p\u003e",
          "module": "Network.URI",
          "name": "uriToString",
          "package": "network",
          "signature": "(String -\u003e String) -\u003e URI -\u003e ShowS",
          "source": "src/Network-URI.html#uriToString",
          "type": "function"
        },
        "index": {
          "description": "Turn URI into string Uses supplied function to map the userinfo part of the URI The Show instance for URI uses mapping that hides any password that may be present in the URI Use this function with argument id to preserve the password in the formatted output",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriToString",
          "normalized": "(String-\u003eString)-\u003eURI-\u003eShowS",
          "package": "network",
          "partial": "To String",
          "signature": "(String-\u003eString)-\u003eURI-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003eanonymous@\u003c/pre\u003e",
          "module": "Network.URI",
          "name": "uriUserInfo",
          "package": "network",
          "signature": "String",
          "source": "src/Network-URI.html#URIAuth",
          "type": "function"
        },
        "index": {
          "description": "anonymous",
          "hierarchy": "Network URI",
          "module": "Network.URI",
          "name": "uriUserInfo",
          "package": "network",
          "partial": "User Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network-URI.html#v:uriUserInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ca\u003eNetwork\u003c/a\u003e interface is a \"higher-level\" interface to\n networking facilities, and it is recommended unless you need the\n lower-level interface in \u003ca\u003eNetwork.Socket\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network",
          "name": "Network",
          "package": "network",
          "source": "src/Network.html",
          "type": "module"
        },
        "index": {
          "description": "The Network interface is higher-level interface to networking facilities and it is recommended unless you need the lower-level interface in Network.Socket",
          "hierarchy": "Network",
          "module": "Network",
          "name": "Network",
          "package": "network",
          "partial": "Network",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEither a host name e.g., \u003ccode\u003e\"haskell.org\"\u003c/code\u003e or a numeric host\n address string consisting of a dotted decimal IPv4 address or an\n IPv6 address e.g., \u003ccode\u003e\"192.168.0.1\"\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network",
          "name": "HostName",
          "package": "network",
          "source": "src/Network-Socket.html#HostName",
          "type": "type"
        },
        "index": {
          "description": "Either host name e.g haskell.org or numeric host address string consisting of dotted decimal IPv4 address or an IPv6 address e.g",
          "hierarchy": "Network",
          "module": "Network",
          "name": "HostName",
          "package": "network",
          "partial": "Host Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#t:HostName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "PortID",
          "package": "network",
          "source": "src/Network.html#PortID",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "PortID",
          "package": "network",
          "partial": "Port ID",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#t:PortID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "PortNumber",
          "package": "network",
          "source": "src/Network-Socket-Types.html#PortNumber",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "PortNumber",
          "package": "network",
          "partial": "Port Number",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#t:PortNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "Socket",
          "package": "network",
          "source": "src/Network-Socket-Types.html#Socket",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "Socket",
          "package": "network",
          "partial": "Socket",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#t:Socket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "PortNumber",
          "package": "network",
          "signature": "PortNumber PortNumber",
          "source": "src/Network.html#PortID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "PortNumber",
          "package": "network",
          "partial": "Port Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:PortNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "Service",
          "package": "network",
          "signature": "Service String",
          "source": "src/Network.html#PortID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "Service",
          "package": "network",
          "partial": "Service",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:Service"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "UnixSocket",
          "package": "network",
          "signature": "UnixSocket String",
          "source": "src/Network.html#PortID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "UnixSocket",
          "package": "network",
          "partial": "Unix Socket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:UnixSocket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccept a connection on a socket created by \u003ccode\u003e\u003ca\u003elistenOn\u003c/a\u003e\u003c/code\u003e.  Normal\n I/O operations (see \u003ca\u003eSystem.IO\u003c/a\u003e) can be used on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e\n returned to communicate with the client.\n Notice that although you can pass any Socket to Network.accept,\n only sockets of either AF_UNIX, AF_INET, or AF_INET6 will work\n (this shouldn't be a problem, though). When using AF_UNIX, HostName\n will be set to the path of the socket and PortNumber to -1.\n\u003c/p\u003e",
          "module": "Network",
          "name": "accept",
          "package": "network",
          "signature": "Socket-\u003e IO (Handle, HostName, PortNumber)",
          "type": "function"
        },
        "index": {
          "description": "Accept connection on socket created by listenOn Normal operations see System.IO can be used on the Handle returned to communicate with the client Notice that although you can pass any Socket to Network.accept only sockets of either AF UNIX AF INET or AF INET6 will work this shouldn be problem though When using AF UNIX HostName will be set to the path of the socket and PortNumber to",
          "hierarchy": "Network",
          "module": "Network",
          "name": "accept",
          "normalized": "Socket-\u003eIO(Handle,HostName,PortNumber)",
          "package": "network",
          "signature": "Socket-\u003eIO(Handle,HostName,PortNumber)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:accept"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalling \u003ccode\u003e\u003ca\u003econnectTo\u003c/a\u003e\u003c/code\u003e creates a client side socket which is\n connected to the given host and port.  The Protocol and socket type is\n derived from the given port identifier.  If a port number is given\n then the result is always an internet family \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e socket.\n\u003c/p\u003e",
          "module": "Network",
          "name": "connectTo",
          "package": "network",
          "signature": "HostName -\u003e PortID -\u003e IO Handle",
          "source": "src/Network.html#connectTo",
          "type": "function"
        },
        "index": {
          "description": "Calling connectTo creates client side socket which is connected to the given host and port The Protocol and socket type is derived from the given port identifier If port number is given then the result is always an internet family Stream socket",
          "hierarchy": "Network",
          "module": "Network",
          "name": "connectTo",
          "normalized": "HostName-\u003ePortID-\u003eIO Handle",
          "package": "network",
          "partial": "To",
          "signature": "HostName-\u003ePortID-\u003eIO Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:connectTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates the server side socket which has been bound to the\n specified port.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003emaxListenQueue\u003c/a\u003e\u003c/code\u003e (typically 128) is specified to the listen queue.\n This is good enough for normal network servers but is too small\n for high performance servers.\n\u003c/p\u003e\u003cp\u003eTo avoid the \"Address already in use\" problems,\n the \u003ccode\u003e\u003ca\u003eReuseAddr\u003c/a\u003e\u003c/code\u003e socket option is set on the listening socket.\n\u003c/p\u003e\u003cp\u003eIf available, the \u003ccode\u003e\u003ca\u003eIPv6Only\u003c/a\u003e\u003c/code\u003e socket option is set to 0\n so that both IPv4 and IPv6 can be accepted with this socket.\n\u003c/p\u003e\u003cp\u003eIf you don't like the behavior above, please use the lower level\n \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Network",
          "name": "listenOn",
          "package": "network",
          "signature": "PortID-\u003e IO Socket",
          "type": "function"
        },
        "index": {
          "description": "Creates the server side socket which has been bound to the specified port maxListenQueue typically is specified to the listen queue This is good enough for normal network servers but is too small for high performance servers To avoid the Address already in use problems the ReuseAddr socket option is set on the listening socket If available the IPv6Only socket option is set to so that both IPv4 and IPv6 can be accepted with this socket If you don like the behavior above please use the lower level listen instead",
          "hierarchy": "Network",
          "module": "Network",
          "name": "listenOn",
          "normalized": "PortID-\u003eIO Socket",
          "package": "network",
          "partial": "On",
          "signature": "PortID-\u003eIO Socket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:listenOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "recvFrom",
          "package": "network",
          "signature": "HostName -\u003e PortID -\u003e IO String",
          "source": "src/Network.html#recvFrom",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "recvFrom",
          "normalized": "HostName-\u003ePortID-\u003eIO String",
          "package": "network",
          "partial": "From",
          "signature": "HostName-\u003ePortID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:recvFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose the socket. All future operations on the socket object will fail.\n   The remote end will receive no more data (after queued data is flushed).\n\u003c/p\u003e",
          "module": "Network",
          "name": "sClose",
          "package": "network",
          "signature": "Socket -\u003e IO ()",
          "source": "src/Network.html#sClose",
          "type": "function"
        },
        "index": {
          "description": "Close the socket All future operations on the socket object will fail The remote end will receive no more data after queued data is flushed",
          "hierarchy": "Network",
          "module": "Network",
          "name": "sClose",
          "normalized": "Socket-\u003eIO()",
          "package": "network",
          "partial": "Close",
          "signature": "Socket-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:sClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network",
          "name": "sendTo",
          "package": "network",
          "signature": "HostName -\u003e PortID -\u003e String -\u003e IO ()",
          "source": "src/Network.html#sendTo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network",
          "module": "Network",
          "name": "sendTo",
          "normalized": "HostName-\u003ePortID-\u003eString-\u003eIO()",
          "package": "network",
          "partial": "To",
          "signature": "HostName-\u003ePortID-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:sendTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the \u003ccode\u003e\u003ca\u003ePortID\u003c/a\u003e\u003c/code\u003e associated with a given socket.\n\u003c/p\u003e",
          "module": "Network",
          "name": "socketPort",
          "package": "network",
          "signature": "Socket -\u003e IO PortID",
          "source": "src/Network.html#socketPort",
          "type": "function"
        },
        "index": {
          "description": "Returns the PortID associated with given socket",
          "hierarchy": "Network",
          "module": "Network",
          "name": "socketPort",
          "normalized": "Socket-\u003eIO PortID",
          "package": "network",
          "partial": "Port",
          "signature": "Socket-\u003eIO PortID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/network/docs/Network.html#v:socketPort"
      }
    }
  ]
]