[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "fields"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e class and basic operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Record.Field.Basic",
          "name": "Basic",
          "package": "fields",
          "source": "src/Data-Record-Field-Basic.html",
          "type": "module"
        },
        "index": {
          "description": "The Field class and basic operations",
          "hierarchy": "Data Record Field Basic",
          "module": "Data.Record.Field.Basic",
          "name": "Basic",
          "package": "fields",
          "partial": "Basic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Basic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances of this class can be combined with the functions and\n operators in this package.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Basic",
          "name": "Field",
          "package": "fields",
          "source": "src/Data-Record-Field-Basic.html#Field",
          "type": "class"
        },
        "index": {
          "description": "Instances of this class can be combined with the functions and operators in this package",
          "hierarchy": "Data Record Field Basic",
          "module": "Data.Record.Field.Basic",
          "name": "Field",
          "package": "fields",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Basic.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix modification lookalike.\n\u003c/p\u003e\u003cpre\u003e r.#f =~ g\n\u003c/pre\u003e\u003cp\u003ereturns a modified version of \u003ccode\u003er\u003c/code\u003e so that the fields corresponding to\n \u003ccode\u003ef\u003c/code\u003e are modified with the function \u003ccode\u003eg\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Basic",
          "name": "(=~)",
          "package": "fields",
          "signature": "a -\u003e (Dst a -\u003e Dst a) -\u003e Src a :-\u003e Src a",
          "source": "src/Data-Record-Field-Basic.html#%3D~",
          "type": "function"
        },
        "index": {
          "description": "Infix modification lookalike returns modified version of so that the fields corresponding to are modified with the function",
          "hierarchy": "Data Record Field Basic",
          "module": "Data.Record.Field.Basic",
          "name": "(=~) =~",
          "normalized": "a-\u003e(Dst a-\u003eDst a)-\u003eSrc a-\u003eSrc a",
          "package": "fields",
          "signature": "a-\u003e(Dst a-\u003eDst a)-\u003eSrc a-\u003eSrc a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Basic.html#v:-61--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix assignment lookalike.\n\u003c/p\u003e\u003cpre\u003e r.#f =: v\n\u003c/pre\u003e\u003cp\u003ereturns a modified version of \u003ccode\u003er\u003c/code\u003e so that the field corresponding to\n \u003ccode\u003ef\u003c/code\u003e are set to \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Basic",
          "name": "(=:)",
          "package": "fields",
          "signature": "a -\u003e Dst a -\u003e Src a :-\u003e Src a",
          "source": "src/Data-Record-Field-Basic.html#%3D%3A",
          "type": "function"
        },
        "index": {
          "description": "Infix assignment lookalike returns modified version of so that the field corresponding to are set to",
          "hierarchy": "Data Record Field Basic",
          "module": "Data.Record.Field.Basic",
          "name": "(=:) =:",
          "normalized": "a-\u003eDst a-\u003eSrc a-\u003eSrc a",
          "package": "fields",
          "signature": "a-\u003eDst a-\u003eSrc a-\u003eSrc a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Basic.html#v:-61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value of the field in the given record.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Basic",
          "name": "(.#)",
          "package": "fields",
          "signature": "Src a -\u003e a -\u003e Dst a",
          "source": "src/Data-Record-Field-Basic.html#.%23",
          "type": "function"
        },
        "index": {
          "description": "Return the value of the field in the given record",
          "hierarchy": "Data Record Field Basic",
          "module": "Data.Record.Field.Basic",
          "name": "(.#) .#",
          "normalized": "Src a-\u003ea-\u003eDst a",
          "package": "fields",
          "signature": "Src a-\u003ea-\u003eDst a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Basic.html#v:.-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an \u003ccode\u003e\u003ca\u003efclabels\u003c/a\u003e\u003c/code\u003e lens corresponding to this field.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Basic",
          "name": "field",
          "package": "fields",
          "signature": "a -\u003e Src a :-\u003e Dst a",
          "source": "src/Data-Record-Field-Basic.html#field",
          "type": "method"
        },
        "index": {
          "description": "Return an fclabels lens corresponding to this field",
          "hierarchy": "Data Record Field Basic",
          "module": "Data.Record.Field.Basic",
          "name": "field",
          "normalized": "a-\u003eSrc a-\u003eDst a",
          "package": "fields",
          "signature": "a-\u003eSrc a-\u003eDst a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Basic.html#v:field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenience function for use with the \u003ccode\u003eViewPatterns\u003c/code\u003e extension.\n\u003c/p\u003e\u003cpre\u003e case r of\n      (match int -\u003e 5)                   -\u003e \"It's 5!\"\n      (match (int,str#$length) -\u003e (i,l))\n            | i == l                     -\u003e \"They're equal!\"\n            | otherwise                  -\u003e \"Not equal.\"\n      _                                  -\u003e \"Something else.\"\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Basic",
          "name": "match",
          "package": "fields",
          "signature": "a -\u003e Src a -\u003e Dst a",
          "source": "src/Data-Record-Field-Basic.html#match",
          "type": "function"
        },
        "index": {
          "description": "Convenience function for use with the ViewPatterns extension case of match int It match int str length They re equal otherwise Not equal Something else",
          "hierarchy": "Data Record Field Basic",
          "module": "Data.Record.Field.Basic",
          "name": "match",
          "normalized": "a-\u003eSrc a-\u003eDst a",
          "package": "fields",
          "signature": "a-\u003eSrc a-\u003eDst a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Basic.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eField combinators.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "Combinators",
          "package": "fields",
          "source": "src/Data-Record-Field-Combinators.html",
          "type": "module"
        },
        "index": {
          "description": "Field combinators",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "Combinators",
          "package": "fields",
          "partial": "Combinators",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField composition with arguments in OO-like order.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(#)",
          "package": "fields",
          "signature": "a -\u003e b -\u003e Src a :-\u003e Dst b",
          "source": "src/Data-Record-Field-Combinators.html#%23",
          "type": "function"
        },
        "index": {
          "description": "Field composition with arguments in OO-like order",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(#) #",
          "normalized": "a-\u003eb-\u003eSrc a-\u003eDst b",
          "package": "fields",
          "signature": "a-\u003eb-\u003eSrc a-\u003eDst b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose fields with ordinary functions. As functions are one-way,\n the resulting field cannot be used to set values.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(#$)",
          "package": "fields",
          "signature": "a -\u003e (Dst a -\u003e b) -\u003e Src a :-\u003e b",
          "source": "src/Data-Record-Field-Combinators.html#%23%24",
          "type": "function"
        },
        "index": {
          "description": "Compose fields with ordinary functions As functions are one-way the resulting field cannot be used to set values",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(#$) #$",
          "normalized": "a-\u003e(Dst a-\u003eb)-\u003eSrc a-\u003eb",
          "package": "fields",
          "signature": "a-\u003e(Dst a-\u003eb)-\u003eSrc a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-35--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZippy field reference to be used with \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e=*\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e [ rec1, rec2 ] *# field =* [ value1, value2 ]\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(*#)",
          "package": "fields",
          "signature": "[Src b] -\u003e [b] -\u003e [Dst b]",
          "source": "src/Data-Record-Field-Combinators.html#%2A%23",
          "type": "function"
        },
        "index": {
          "description": "Zippy field reference to be used with rec1 rec2 field value1 value2",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(*#) *#",
          "normalized": "[Src a]-\u003e[a]-\u003e[Dst a]",
          "package": "fields",
          "signature": "[Src b]-\u003e[b]-\u003e[Dst b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-42--35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlattening monadic composition for fields.\n\u003c/p\u003e\u003cpre\u003e person .# superior \u003c##\u003e superior \u003c##\u003e superior \u003c##\u003e superior\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c##\u003e)",
          "package": "fields",
          "signature": "a -\u003e b -\u003e Src a :-\u003e m c",
          "source": "src/Data-Record-Field-Combinators.html#%3C%23%23%3E",
          "type": "function"
        },
        "index": {
          "description": "Flattening monadic composition for fields person superior superior superior superior",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c##\u003e) \u003c##\u003e",
          "normalized": "a-\u003eb-\u003eSrc a-\u003ec d",
          "package": "fields",
          "signature": "a-\u003eb-\u003eSrc a-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-60--35--35--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e functor composition for fields.\n\u003c/p\u003e\u003cpre\u003e book .# characters \u003c#\u003e lastName\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c#\u003e)",
          "package": "fields",
          "signature": "a -\u003e b -\u003e Src a :-\u003e f (Dst b)",
          "source": "src/Data-Record-Field-Combinators.html#%3C%23%3E",
          "type": "function"
        },
        "index": {
          "description": "Applicative functor composition for fields book characters lastName",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c#\u003e) \u003c#\u003e",
          "normalized": "a-\u003eb-\u003eSrc a-\u003ec(Dst b)",
          "package": "fields",
          "signature": "a-\u003eb-\u003eSrc a-\u003ef(Dst b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-60--35--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix modification for the State monad.\n\u003c/p\u003e\u003cpre\u003e (field1, field2) \u003c=~ (f, g)\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c=~)",
          "package": "fields",
          "signature": "a -\u003e (Dst a -\u003e Dst a) -\u003e m ()",
          "source": "src/Data-Record-Field-Combinators.html#%3C%3D~",
          "type": "function"
        },
        "index": {
          "description": "Infix modification for the State monad field1 field2",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c=~) \u003c=~",
          "normalized": "a-\u003e(Dst a-\u003eDst a)-\u003eb()",
          "package": "fields",
          "signature": "a-\u003e(Dst a-\u003eDst a)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-60--61--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix assignment for the State monad.\n\u003c/p\u003e\u003cpre\u003e (field1, field2) \u003c=: (value1, value2)\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c=:)",
          "package": "fields",
          "signature": "a -\u003e Dst a -\u003e m ()",
          "source": "src/Data-Record-Field-Combinators.html#%3C%3D%3A",
          "type": "function"
        },
        "index": {
          "description": "Infix assignment for the State monad field1 field2 value1 value2",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c=:) \u003c=:",
          "normalized": "a-\u003eDst a-\u003eb()",
          "package": "fields",
          "signature": "a-\u003eDst a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-60--61-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix \u003ccode\u003e\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e for fields.\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e persons \u003c.#\u003e firstName\n\u003c/pre\u003e\u003cpre\u003e do (v1, v2) \u003c- takeMVar mv \u003c.#\u003e (field1, field2)\n    putStrLn . unlines $ [ \"v1: \" ++ show v1, \"v2: \" ++ show v2 ]\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c.#\u003e)",
          "package": "fields",
          "signature": "f (Src a) -\u003e a -\u003e f (Dst a)",
          "source": "src/Data-Record-Field-Combinators.html#%3C.%23%3E",
          "type": "function"
        },
        "index": {
          "description": "Infix fmap for fields Examples persons firstName do v1 v2 takeMVar mv field1 field2 putStrLn unlines v1 show v1 v2 show v2",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(\u003c.#\u003e) \u003c.#\u003e",
          "normalized": "a(Src b)-\u003eb-\u003ea(Dst b)",
          "package": "fields",
          "signature": "f(Src a)-\u003ea-\u003ef(Dst a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-60-.-35--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZippy infix assignment to be used with \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e*#\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "(=*)",
          "package": "fields",
          "signature": "a -\u003e [Dst a] -\u003e [Src a :-\u003e Src a]",
          "source": "src/Data-Record-Field-Combinators.html#%3D%2A",
          "type": "function"
        },
        "index": {
          "description": "Zippy infix assignment to be used with",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "(=*) =*",
          "normalized": "a-\u003e[Dst a]-\u003e[Src a-\u003eSrc a]",
          "package": "fields",
          "signature": "a-\u003e[Dst a]-\u003e[Src a-\u003eSrc a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:-61--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity lens.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "idL",
          "package": "fields",
          "signature": "a :-\u003e a",
          "source": "src/Data-Record-Field-Combinators.html#idL",
          "type": "function"
        },
        "index": {
          "description": "Identity lens",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "idL",
          "normalized": "a-\u003ea",
          "package": "fields",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:idL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility combinator in the manner of \u003ccode\u003e\u003ccode\u003eData.Function.on\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e sortBy (compare `onField` (lastName,firstName)) persons\n\u003c/pre\u003e",
          "module": "Data.Record.Field.Combinators",
          "name": "onField",
          "package": "fields",
          "signature": "(Dst a -\u003e Dst a -\u003e t) -\u003e a -\u003e Src a -\u003e Src a -\u003e t",
          "source": "src/Data-Record-Field-Combinators.html#onField",
          "type": "function"
        },
        "index": {
          "description": "Utility combinator in the manner of Data.Function.on sortBy compare onField lastName firstName persons",
          "hierarchy": "Data Record Field Combinators",
          "module": "Data.Record.Field.Combinators",
          "name": "onField",
          "normalized": "(Dst a-\u003eDst a-\u003eb)-\u003ea-\u003eSrc a-\u003eSrc a-\u003eb",
          "package": "fields",
          "partial": "Field",
          "signature": "(Dst a-\u003eDst a-\u003et)-\u003ea-\u003eSrc a-\u003eSrc a-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Combinators.html#v:onField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComposition operators for collection fields.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Record.Field.Indexable",
          "name": "Indexable",
          "package": "fields",
          "source": "src/Data-Record-Field-Indexable.html",
          "type": "module"
        },
        "index": {
          "description": "Composition operators for collection fields",
          "hierarchy": "Data Record Field Indexable",
          "module": "Data.Record.Field.Indexable",
          "name": "Indexable",
          "package": "fields",
          "partial": "Indexable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Indexable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of collection types that can be indexed into.\n\u003c/p\u003e\u003cp\u003eTODO: This should probably be a single-parameter type class with two\n associated types instead.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Indexable",
          "name": "Indexable",
          "package": "fields",
          "source": "src/Data-Record-Field-Indexable.html#Indexable",
          "type": "class"
        },
        "index": {
          "description": "Class of collection types that can be indexed into TODO This should probably be single-parameter type class with two associated types instead",
          "hierarchy": "Data Record Field Indexable",
          "module": "Data.Record.Field.Indexable",
          "name": "Indexable",
          "package": "fields",
          "partial": "Indexable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Indexable.html#t:Indexable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a field with an \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIndexable\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e collection safely. \n\u003c/p\u003e\u003cpre\u003e r .# coll #! idx\n\u003c/pre\u003e\u003cp\u003ereturns \u003ccode\u003eNothing\u003c/code\u003e if \u003ccode\u003eidx\u003c/code\u003e was not found from the collection, and\n \u003ccode\u003eJust v\u003c/code\u003e if \u003ccode\u003ev\u003c/code\u003e was found.\n\u003c/p\u003e\u003cpre\u003e r .# coll #! idx =: Just v\n\u003c/pre\u003e\u003cp\u003esets the value at \u003ccode\u003eidx\u003c/code\u003e in the collection to be \u003ccode\u003ev\u003c/code\u003e. If the value\n wasn't in the collection, it's inserted. The exact semantics of\n insertion depend on the actual collection in question.\n\u003c/p\u003e\u003cpre\u003e r .# coll #! idx =: Nothing\n\u003c/pre\u003e\u003cp\u003eremoves the value at \u003ccode\u003eidx\u003c/code\u003e from the collection, if possible.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Indexable",
          "name": "(#!)",
          "package": "fields",
          "signature": "a -\u003e i -\u003e Src a :-\u003e Maybe (Element (Dst a))",
          "source": "src/Data-Record-Field-Indexable.html#%23%21",
          "type": "function"
        },
        "index": {
          "description": "Compose field with an Indexable collection safely coll idx returns Nothing if idx was not found from the collection and Just if was found coll idx Just sets the value at idx in the collection to be If the value wasn in the collection it inserted The exact semantics of insertion depend on the actual collection in question coll idx Nothing removes the value at idx from the collection if possible",
          "hierarchy": "Data Record Field Indexable",
          "module": "Data.Record.Field.Indexable",
          "name": "(#!) #!",
          "normalized": "a-\u003eb-\u003eSrc a-\u003eMaybe(Element(Dst a))",
          "package": "fields",
          "signature": "a-\u003ei-\u003eSrc a-\u003eMaybe(Element(Dst a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Indexable.html#v:-35--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e(#!)\u003c/code\u003e, but reading a nonexistent value will likely result in a\n bottom value being returned. Also, the resulting field cannot be used\n to remove values.\n\u003c/p\u003e",
          "module": "Data.Record.Field.Indexable",
          "name": "(#!!)",
          "package": "fields",
          "signature": "a -\u003e i -\u003e Src a :-\u003e Element (Dst a)",
          "source": "src/Data-Record-Field-Indexable.html#%23%21%21",
          "type": "function"
        },
        "index": {
          "description": "As but reading nonexistent value will likely result in bottom value being returned Also the resulting field cannot be used to remove values",
          "hierarchy": "Data Record Field Indexable",
          "module": "Data.Record.Field.Indexable",
          "name": "(#!!) #!!",
          "normalized": "a-\u003eb-\u003eSrc a-\u003eElement(Dst a)",
          "package": "fields",
          "signature": "a-\u003ei-\u003eSrc a-\u003eElement(Dst a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Indexable.html#v:-35--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Record.Field.Indexable",
          "name": "indexGet",
          "package": "fields",
          "signature": "i -\u003e a -\u003e Maybe (Element a)",
          "source": "src/Data-Record-Field-Indexable.html#indexGet",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Record Field Indexable",
          "module": "Data.Record.Field.Indexable",
          "name": "indexGet",
          "normalized": "a-\u003eb-\u003eMaybe(Element b)",
          "package": "fields",
          "partial": "Get",
          "signature": "i-\u003ea-\u003eMaybe(Element a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Indexable.html#v:indexGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Record.Field.Indexable",
          "name": "indexSet",
          "package": "fields",
          "signature": "i -\u003e Maybe (Element a) -\u003e a -\u003e a",
          "source": "src/Data-Record-Field-Indexable.html#indexSet",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Record Field Indexable",
          "module": "Data.Record.Field.Indexable",
          "name": "indexSet",
          "normalized": "a-\u003eMaybe(Element b)-\u003eb-\u003eb",
          "package": "fields",
          "partial": "Set",
          "signature": "i-\u003eMaybe(Element a)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Indexable.html#v:indexSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Record.Field.Indexable",
          "name": "unsafeIndexGet",
          "package": "fields",
          "signature": "i -\u003e a -\u003e Element a",
          "source": "src/Data-Record-Field-Indexable.html#unsafeIndexGet",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Record Field Indexable",
          "module": "Data.Record.Field.Indexable",
          "name": "unsafeIndexGet",
          "normalized": "a-\u003eb-\u003eElement b",
          "package": "fields",
          "partial": "Index Get",
          "signature": "i-\u003ea-\u003eElement a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Indexable.html#v:unsafeIndexGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInstances for tuples of fields up to a 10-tuple. This allows\n accessing several fields simultaneously.\n\u003c/p\u003e\u003cpre\u003e r.#(field1, field2, field3#field4) =: (value1, value2, value3)\n\u003c/pre\u003e\u003cp\u003eIn addition, the pair instance is recursively defined, which allows\n stuff like\n\u003c/p\u003e\u003cpre\u003e import Control.Arrow ((***))\n r.#(field1, (field2, field3)) =~ (f *** g *** h)\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.Record.Field.Tuple",
          "name": "Tuple",
          "package": "fields",
          "source": "src/Data-Record-Field-Tuple.html",
          "type": "module"
        },
        "index": {
          "description": "Instances for tuples of fields up to tuple This allows accessing several fields simultaneously field1 field2 field3 field4 value1 value2 value3 In addition the pair instance is recursively defined which allows stuff like import Control.Arrow field1 field2 field3",
          "hierarchy": "Data Record Field Tuple",
          "module": "Data.Record.Field.Tuple",
          "name": "Tuple",
          "package": "fields",
          "partial": "Tuple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field-Tuple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUsing records, especially nested records, in Haskell can sometimes be\n a bit of a chore. Fortunately, there are several libraries in hackage\n to make working with records easier. This library is my attempt to\n build on top of these libraries to make working with records even\n more pleasant!\n\u003c/p\u003e\u003cp\u003eIn most imperative languages, records are accessed using the infix\n dot operator. Record fields can be read simply by suffixing a record\n value with '.field' and they can be modified by simply assigning to\n that location. Although this is not the only way to access records\n (indeed, Haskell does not use it), many people (including myself)\n like it. This library attempts to support this style for Haskell\n records in the following manner:\n\u003c/p\u003e\u003cpre\u003e record.field.subfield      becomes     record .# field # subfield\n record.field = value       becomes     record .# field =: value\n\u003c/pre\u003e\u003cp\u003eOf course, the infix assignment in Haskell is pure and doesn't\n actually mutate anything. Rather, a modified version of the record is\n returned. \n\u003c/p\u003e\u003cp\u003eBelow, a detailed and commented usage example is presented.\n\u003c/p\u003e\u003cpre\u003e import Data.Record.Field\n import Data.Record.Label hiding ((=:))\n\u003c/pre\u003e\u003cp\u003eCurrently, \u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e is built on top of \u003ccode\u003e\u003ca\u003efclabels\u003c/a\u003e\u003c/code\u003e, so we import\n that package as well. We hide the \u003ccode\u003e(=:)\u003c/code\u003e operator because that\n operator is also used by \u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e itself. \n\u003c/p\u003e\u003cp\u003eFirst, let's define some example data types and derive lenses for\n them using \u003ccode\u003e\u003ca\u003efclabels\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e data Person = Person\n      { _firstName :: String\n      , _lastName  :: String\n      , _age       :: Int\n      , _superior  :: Maybe Person\n      } deriving Show\n \n data Book = Book\n      { _title      :: String\n      , _author     :: Person\n      , _characters :: [Person]\n      } deriving Show\n \n $(mkLabels [''Person, ''Book])\n\u003c/pre\u003e\u003cp\u003eNow, let's define some example data.\n\u003c/p\u003e\u003cpre\u003e howard  = Person \"Howard\"  \"Lovecraft\" 46 Nothing\n charles = Person \"Charles\" \"Ward\"      26 Nothing\n marinus = Person \"Marinus\" \"Willett\"   56 Nothing\n william = Person \"William\" \"Dyer\"      53 Nothing\n frank   = Person \"Frank\"   \"Pabodie\"   49 Nothing\n herbert = Person \"Herbert\" \"West\"      32 Nothing\n abdul   = Person \"Abdul\"   \"Alhazred\"  71 Nothing\n\n mountains    = Book \"At the Mountains of Madness\"     undefined []\n caseOfCDW    = Book \"The Case of Charles Dexter Ward\" undefined []\n reanimator   = Book \"Herbert West -- The Re-animator\" undefined []\n necronomicon = Book \"Necronomicon\"                    undefined []\n\n persons = [howard, charles, marinus, herbert, william, frank, abdul]\n books   = [mountains, caseOfCDW, reanimator, necronomicon]\n\u003c/pre\u003e\u003cp\u003eNow, to look up a book's title, we can use the \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e.#\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e operator,\n which is the basis of all \u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e functionality. \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e.#\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e takes a\n value of type \u003ccode\u003ea\u003c/code\u003e and a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e from \u003ccode\u003ea\u003c/code\u003e to some other type (in\n this case, \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e) and returns the value of that field. Since an\n \u003ccode\u003e\u003ca\u003efclabels\u003c/a\u003e\u003c/code\u003e lens is an instance of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, we can just use the\n lens directly.\n\u003c/p\u003e\u003cpre\u003e necronomicon .# title\n -- :: String\n\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eauthor\u003c/code\u003e field, however, was left undefined in the above\n definition. We can set it using the \u003ccode\u003e(=:)\u003c/code\u003e operator\n\u003c/p\u003e\u003cpre\u003e necronomicon .# author =: abdul\n -- :: Book\n\u003c/pre\u003e\u003cp\u003eA notable detail is that the above expression parenthesizes as\n \u003ccode\u003enecronomicon .# (author =: abdul)\u003c/code\u003e. The \u003ccode\u003e(=:)\u003c/code\u003e operator takes a\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and a value for that \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and returns a new \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n that, when read, returns a modified version of the record.\n\u003c/p\u003e\u003cp\u003eFor the sake of the example, I will assume here that the subsequent\n references to \u003ccode\u003enecronomicon\u003c/code\u003e refer to this modified version (and\n similarly for all other assignment examples below), even though\n nothing is mutated in reality.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e=~\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e operator is similar, except that instead of a value, it\n takes a function that modifies the previous value. For example\n\u003c/p\u003e\u003cpre\u003e howard .# age =~ succ\n -- :: Person\n\u003c/pre\u003e\u003cp\u003eTo access fields in nested records, \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003es can be composed using\n the \u003ccode\u003e(#)\u003c/code\u003e combinator.\n\u003c/p\u003e\u003cpre\u003e necronomicon .# author # lastName\n -- :: String\n\u003c/pre\u003e\u003cp\u003eIf we wish to access a field of several records at once, we can use\n the \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c.#\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e operator, which can be used to access fields of\n a record inside a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e. For example\n\u003c/p\u003e\u003cpre\u003e persons \u003c.#\u003e age\n -- :: [Int]\n\u003c/pre\u003e\u003cp\u003eThis also works for assignment. For example, let's fix the \u003ccode\u003eauthor\u003c/code\u003e\n fields of the rest of our books.\n\u003c/p\u003e\u003cpre\u003e [mountains, caseOfCDW, reanimator ] \u003c.#\u003e author =: howard\n -- :: [Book]\n\u003c/pre\u003e\u003cp\u003eBecause \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c.#\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e works for any \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, we could access values\n of type \u003ccode\u003eMaybe Book\u003c/code\u003e, \u003ccode\u003ea -\u003e Book\u003c/code\u003e or \u003ccode\u003eIO Book\u003c/code\u003e similarly.\n\u003c/p\u003e\u003cp\u003eWe frequently wish to access several fields of a record\n simultaneously. \u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e supports this using tuples. A tuple of\n primitive \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003es (currently, \"primitive \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\" means an\n \u003ccode\u003e\u003ca\u003efclabels\u003c/a\u003e\u003c/code\u003e lens) is itself a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, provided that all the\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003es in the tuple have the same source type (ie. you can\n combine \u003ccode\u003eBook :-\u003e String\u003c/code\u003e and \u003ccode\u003eBook :-\u003e Int\u003c/code\u003e but not \u003ccode\u003eBook :-\u003e\n String\u003c/code\u003e and \u003ccode\u003ePerson :-\u003e String\u003c/code\u003e). For example, we could do\n\u003c/p\u003e\u003cpre\u003e howard .# (firstName, lastName, age)\n -- :: (String, String, Int)\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e defines instances for tuples of up to 10 elements. In\n addition, the 2-tuple instance is recursively defined so that a tuple\n \u003ccode\u003e(a, b)\u003c/code\u003e is a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e if \u003ccode\u003ea\u003c/code\u003e is a primitive \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e is\n \u003cem\u003eany\u003c/em\u003e valid field. This makes it possible to do \n\u003c/p\u003e\u003cpre\u003e howard .# (firstName, (lastName, age)) =~ (reverse *** reverse *** negate)\n -- :: Person\n\u003c/pre\u003e\u003cp\u003eWe can also compose a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e with a pure function (for example, a\n regular record field accessor function) using the \u003ccode\u003e('#$')\u003c/code\u003e\n combinator. However, since a function is one-way, the resulting\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e cannot be used to set values, and trying to do so will\n result in an \u003ccode\u003e\u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e howard .# lastName #$ length\n -- :: Int\n\u003c/pre\u003e\u003cp\u003eIf we wish to set fields of several records at once, but so that\n we can also specify the value individually for each record, we can\n use the \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e*#\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e and \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e=*\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e operators, which can be thought of as\n \"zippy\" assignment. They can be used like this\n\u003c/p\u003e\u003cpre\u003e [ mountains, caseOfCDW, reanimator ] *# characters =*\n     [ [ william, frank ]\n     , [ charles, marinus ]\n     , [ herbert ] ]\n -- :: [Book]\n\u003c/pre\u003e\u003cp\u003eFor more complex queries, \u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e also provides the \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c#\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e and\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c##\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e combinators. \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c#\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e combines a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e of type \u003ccode\u003ea :-\u003e\n f b\u003c/code\u003e with a field of type \u003ccode\u003eb :-\u003e c\u003c/code\u003e, producing a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e of type \u003ccode\u003ea\n :-\u003e f c\u003c/code\u003e, where \u003ccode\u003ef\u003c/code\u003e is any \u003ccode\u003e\u003ccode\u003eApplicative\u003c/code\u003e\u003c/code\u003e functor.\n\u003c/p\u003e\u003cpre\u003e mountains .# characters \u003c#\u003e (lastName, age)\n -- :: [(String, Int)]\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c##\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e is similar, except that flattens two monadic \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003es\n together. I.e. the type signature is \u003ccode\u003ea :-\u003e m b -\u003e b :-\u003e m c -\u003e a :-\u003e\n m c\u003c/code\u003e. For example\n\u003c/p\u003e\u003cpre\u003e frank .# superior \u003c##\u003e superior \u003c##\u003e superior\n -- :: Maybe Person\n\u003c/pre\u003e\u003cp\u003eBoth \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c#\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e and \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003c##\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e also support assignment normally,\n although the exact semantics vary depending on the \u003ccode\u003e\u003ccode\u003eApplicative\u003c/code\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e in question.\n\u003c/p\u003e\u003cp\u003eWe might also like to sort or otherwise manipulate collections of\n records easily. For this, \u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e provides the \u003ccode\u003e\u003ccode\u003e\u003ca\u003eonField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n combinator in the manner of \u003ccode\u003e\u003ccode\u003eData.Function.on\u003c/code\u003e\u003c/code\u003e. For example, to sort\n a list of books by their authors' last names, we can use\n\u003c/p\u003e\u003cpre\u003e sortBy (compare `onField` author # lastName) books\n -- :: [Book]\n\u003c/pre\u003e\u003cp\u003eUsing tuples, we can also easily define sub-orderings. For example,\n if we wish to break ties based on the authors' first names and then\n by ages, we can use\n\u003c/p\u003e\u003cpre\u003e sortBy (compare `onField` author # (lastName, firstName, age)) books\n -- :: [Book]\n\u003c/pre\u003e\u003cp\u003eSince \u003ccode\u003e\u003ccode\u003e\u003ca\u003eonField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e accepts any \u003ccode\u003e\u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, we can easily specify more\n complex criteria. To sort a list of books by the sum of their\n characters' ages (which is a bit silly), we could use\n\u003c/p\u003e\u003cpre\u003e sortBy (compare `onField` (characters \u003c#\u003e age) #$ sum) books\n -- :: [Book]\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003efields\u003c/a\u003e\u003c/code\u003e also attempts to support convenient pattern matching by\n means of the \u003ccode\u003e\u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e function and GHC's \u003ccode\u003eViewPatterns\u003c/code\u003e extension.\n To pattern match on records, you could do something like this\n\u003c/p\u003e\u003cpre\u003e case charles of\n      (match lastName        -\u003e \"Dexter\")    -\u003e Left False\n      (match lastName        -\u003e \"Ward\")      -\u003e Left True\n      (match (age, superior) -\u003e (a, Just s))\n         | a \u003e 18                            -\u003e Right a\n         | otherwise                         -\u003e Right (s .# age)\n -- :: Either Bool Int\n\u003c/pre\u003e\u003cp\u003eFinally, a pair of combinators is provided to access record fields of\n collection types. The \u003ccode\u003e(#!)\u003c/code\u003e combinator has the type \u003ccode\u003ea :-\u003e c b -\u003e\n i -\u003e a :-\u003e Maybe b\u003c/code\u003e, where \u003ccode\u003ec\u003c/code\u003e is an instance of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIndexable\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and\n \u003ccode\u003ei\u003c/code\u003e is an index type suitable for \u003ccode\u003ec\u003c/code\u003e. For example, you can use an\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e value to index a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and a value of type \u003ccode\u003ek\u003c/code\u003e to\n index a \u003ccode\u003eMap k v\u003c/code\u003e. The \u003ccode\u003e(#!!)\u003c/code\u003e combinator is also provided. It\n doesn't have \u003ccode\u003eMaybe\u003c/code\u003e in the return type, so using a bad index will\n usually result in an \u003ccode\u003e\u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eCurrently, instances are provided for \u003ccode\u003e[a]\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003eData.Map\u003c/code\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ccode\u003eData.IntMap\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003eData.Array.IArray\u003c/code\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003eData.Set\u003c/code\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ccode\u003eData.IntSet\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Record.Field",
          "name": "Field",
          "package": "fields",
          "source": "src/Data-Record-Field.html",
          "type": "module"
        },
        "index": {
          "description": "Using records especially nested records in Haskell can sometimes be bit of chore Fortunately there are several libraries in hackage to make working with records easier This library is my attempt to build on top of these libraries to make working with records even more pleasant In most imperative languages records are accessed using the infix dot operator Record fields can be read simply by suffixing record value with field and they can be modified by simply assigning to that location Although this is not the only way to access records indeed Haskell does not use it many people including myself like it This library attempts to support this style for Haskell records in the following manner record.field.subfield becomes record field subfield record.field value becomes record field value Of course the infix assignment in Haskell is pure and doesn actually mutate anything Rather modified version of the record is returned Below detailed and commented usage example is presented import Data.Record.Field import Data.Record.Label hiding Currently fields is built on top of fclabels so we import that package as well We hide the operator because that operator is also used by fields itself First let define some example data types and derive lenses for them using fclabels data Person Person firstName String lastName String age Int superior Maybe Person deriving Show data Book Book title String author Person characters Person deriving Show mkLabels Person Book Now let define some example data howard Person Howard Lovecraft Nothing charles Person Charles Ward Nothing marinus Person Marinus Willett Nothing william Person William Dyer Nothing frank Person Frank Pabodie Nothing herbert Person Herbert West Nothing abdul Person Abdul Alhazred Nothing mountains Book At the Mountains of Madness undefined caseOfCDW Book The Case of Charles Dexter Ward undefined reanimator Book Herbert West The Re-animator undefined necronomicon Book Necronomicon undefined persons howard charles marinus herbert william frank abdul books mountains caseOfCDW reanimator necronomicon Now to look up book title we can use the operator which is the basis of all fields functionality takes value of type and Field from to some other type in this case String and returns the value of that field Since an fclabels lens is an instance of Field we can just use the lens directly necronomicon title String The author field however was left undefined in the above definition We can set it using the operator necronomicon author abdul Book notable detail is that the above expression parenthesizes as necronomicon author abdul The operator takes Field and value for that Field and returns new Field that when read returns modified version of the record For the sake of the example will assume here that the subsequent references to necronomicon refer to this modified version and similarly for all other assignment examples below even though nothing is mutated in reality The operator is similar except that instead of value it takes function that modifies the previous value For example howard age succ Person To access fields in nested records Field can be composed using the combinator necronomicon author lastName String If we wish to access field of several records at once we can use the operator which can be used to access fields of record inside Functor For example persons age Int This also works for assignment For example let fix the author fields of the rest of our books mountains caseOfCDW reanimator author howard Book Because works for any Functor we could access values of type Maybe Book Book or IO Book similarly We frequently wish to access several fields of record simultaneously fields supports this using tuples tuple of primitive Field currently primitive Field means an fclabels lens is itself Field provided that all the Field in the tuple have the same source type ie you can combine Book String and Book Int but not Book String and Person String For example we could do howard firstName lastName age String String Int fields defines instances for tuples of up to elements In addition the tuple instance is recursively defined so that tuple is Field if is primitive Field and is any valid field This makes it possible to do howard firstName lastName age reverse reverse negate Person We can also compose Field with pure function for example regular record field accessor function using the combinator However since function is one-way the resulting Field cannot be used to set values and trying to do so will result in an error howard lastName length Int If we wish to set fields of several records at once but so that we can also specify the value individually for each record we can use the and operators which can be thought of as zippy assignment They can be used like this mountains caseOfCDW reanimator characters william frank charles marinus herbert Book For more complex queries fields also provides the and combinators combines Field of type with field of type producing Field of type where is any Applicative functor mountains characters lastName age String Int is similar except that flattens two monadic Field together I.e the type signature is For example frank superior superior superior Maybe Person Both and also support assignment normally although the exact semantics vary depending on the Applicative or Monad in question We might also like to sort or otherwise manipulate collections of records easily For this fields provides the onField combinator in the manner of Data.Function.on For example to sort list of books by their authors last names we can use sortBy compare onField author lastName books Book Using tuples we can also easily define sub-orderings For example if we wish to break ties based on the authors first names and then by ages we can use sortBy compare onField author lastName firstName age books Book Since onField accepts any Field we can easily specify more complex criteria To sort list of books by the sum of their characters ages which is bit silly we could use sortBy compare onField characters age sum books Book fields also attempts to support convenient pattern matching by means of the match function and GHC ViewPatterns extension To pattern match on records you could do something like this case charles of match lastName Dexter Left False match lastName Ward Left True match age superior Just Right otherwise Right age Either Bool Int Finally pair of combinators is provided to access record fields of collection types The combinator has the type Maybe where is an instance of Indexable and is an index type suitable for For example you can use an Integral value to index String and value of type to index Map The combinator is also provided It doesn have Maybe in the return type so using bad index will usually result in an error Currently instances are provided for Data.Map Data.IntMap Data.Array.IArray Data.Set and Data.IntSet",
          "hierarchy": "Data Record Field",
          "module": "Data.Record.Field",
          "name": "Field",
          "package": "fields",
          "partial": "Field",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/fields/docs/Data-Record-Field.html#"
      }
    }
  ]
]