[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "Encode"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003cem\u003eEncode::Arabic::ArabTeX::ZDMG\u003c/em\u003e in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/ArabTeX/ZDMG.pm\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003eEncode.Extend\u003c/a\u003e\n \u003ca\u003eEncode.Mapper\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ZDMG",
          "package": "Encode",
          "source": "src/Encode-Arabic-ArabTeX-ZDMG.html",
          "type": "module"
        },
        "index": {
          "description": "Encode Arabic ArabTeX ZDMG in Perl http search.cpan.org dist Encode-Arabic lib Encode Arabic ArabTeX ZDMG.pm Encode.Extend Encode.Mapper",
          "hierarchy": "Encode Arabic ArabTeX ZDMG",
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ZDMG",
          "package": "Encode",
          "partial": "ZDMG",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX-ZDMG.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ZDMG",
          "package": "Encode",
          "source": "src/Encode-Arabic-ArabTeX-ZDMG.html#ZDMG",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX ZDMG",
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ZDMG",
          "package": "Encode",
          "partial": "ZDMG",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX-ZDMG.html#t:ZDMG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ArabTeX_ZDMG",
          "package": "Encode",
          "signature": "ArabTeX_ZDMG",
          "source": "src/Encode-Arabic-ArabTeX-ZDMG.html#ZDMG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX ZDMG",
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ArabTeX_ZDMG",
          "package": "Encode",
          "partial": "Arab Te ZDMG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX-ZDMG.html#v:ArabTeX_ZDMG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ZDMG",
          "package": "Encode",
          "signature": "ZDMG",
          "source": "src/Encode-Arabic-ArabTeX-ZDMG.html#ZDMG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX ZDMG",
          "module": "Encode.Arabic.ArabTeX.ZDMG",
          "name": "ZDMG",
          "package": "Encode",
          "partial": "ZDMG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX-ZDMG.html#v:ZDMG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003cem\u003eEncode::Arabic::ArabTeX\u003c/em\u003e in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/ArabTeX.pm\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003eEncode.Extend\u003c/a\u003e\n \u003ca\u003eEncode.Mapper\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Arabic.ArabTeX",
          "name": "ArabTeX",
          "package": "Encode",
          "source": "src/Encode-Arabic-ArabTeX.html",
          "type": "module"
        },
        "index": {
          "description": "Encode Arabic ArabTeX in Perl http search.cpan.org dist Encode-Arabic lib Encode Arabic ArabTeX.pm Encode.Extend Encode.Mapper",
          "hierarchy": "Encode Arabic ArabTeX",
          "module": "Encode.Arabic.ArabTeX",
          "name": "ArabTeX",
          "package": "Encode",
          "partial": "Arab Te",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX",
          "name": "ArabTeX",
          "package": "Encode",
          "source": "src/Encode-Arabic-ArabTeX.html#ArabTeX",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX",
          "module": "Encode.Arabic.ArabTeX",
          "name": "ArabTeX",
          "package": "Encode",
          "partial": "Arab Te",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX.html#t:ArabTeX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX",
          "name": "ArabTeX",
          "package": "Encode",
          "signature": "ArabTeX",
          "source": "src/Encode-Arabic-ArabTeX.html#ArabTeX",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX",
          "module": "Encode.Arabic.ArabTeX",
          "name": "ArabTeX",
          "package": "Encode",
          "partial": "Arab Te",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX.html#v:ArabTeX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX",
          "name": "Lagally",
          "package": "Encode",
          "signature": "Lagally",
          "source": "src/Encode-Arabic-ArabTeX.html#ArabTeX",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX",
          "module": "Encode.Arabic.ArabTeX",
          "name": "Lagally",
          "package": "Encode",
          "partial": "Lagally",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX.html#v:Lagally"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX",
          "name": "TeX",
          "package": "Encode",
          "signature": "TeX",
          "source": "src/Encode-Arabic-ArabTeX.html#ArabTeX",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX",
          "module": "Encode.Arabic.ArabTeX",
          "name": "TeX",
          "package": "Encode",
          "partial": "Te",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX.html#v:TeX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX",
          "name": "events",
          "package": "Encode",
          "signature": "String -\u003e [[String]]",
          "source": "src/Encode-Arabic-ArabTeX.html#events",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX",
          "module": "Encode.Arabic.ArabTeX",
          "name": "events",
          "normalized": "String-\u003e[[String]]",
          "package": "Encode",
          "signature": "String-\u003e[[String]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX.html#v:events"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.ArabTeX",
          "name": "tokens",
          "package": "Encode",
          "signature": "String -\u003e [String]",
          "source": "src/Encode-Arabic-ArabTeX.html#tokens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic ArabTeX",
          "module": "Encode.Arabic.ArabTeX",
          "name": "tokens",
          "normalized": "String-\u003e[String]",
          "package": "Encode",
          "signature": "String-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-ArabTeX.html#v:tokens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTim Buckwalter's notation is a one-to-one transliteration of the graphemes\n of the Arabic script using lower ASCII characters only. This system is very\n popular in Natural Language Processing, however, there are limits to its\n applicability due to numerous non-alphabetic characters involved.\n\u003c/p\u003e\u003cp\u003eThe XML-friendly variant of the notation replaces codes \u003ccode\u003e\u003e\u003c/code\u003e, \u003ccode\u003e&\u003c/code\u003e, \u003ccode\u003e\u003c\u003c/code\u003e with\n \u003ccode\u003eO\u003c/code\u003e, \u003ccode\u003eW\u003c/code\u003e, \u003ccode\u003eI\u003c/code\u003e, respectively. In this implementation, the \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003e function\n considers both of these conventions and converts from them, while the\n \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003e function produces the XML-friendly notation only.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eEncode::Arabic::Buckwalter\u003c/em\u003e in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/Buckwalter.pm\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Arabic.Buckwalter",
          "name": "Buckwalter",
          "package": "Encode",
          "source": "src/Encode-Arabic-Buckwalter.html",
          "type": "module"
        },
        "index": {
          "description": "Tim Buckwalter notation is one-to-one transliteration of the graphemes of the Arabic script using lower ASCII characters only This system is very popular in Natural Language Processing however there are limits to its applicability due to numerous non-alphabetic characters involved The XML-friendly variant of the notation replaces codes with respectively In this implementation the decode function considers both of these conventions and converts from them while the encode function produces the XML-friendly notation only Encode Arabic Buckwalter in Perl http search.cpan.org dist Encode-Arabic lib Encode Arabic Buckwalter.pm",
          "hierarchy": "Encode Arabic Buckwalter",
          "module": "Encode.Arabic.Buckwalter",
          "name": "Buckwalter",
          "package": "Encode",
          "partial": "Buckwalter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Buckwalter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Buckwalter",
          "name": "Buckwalter",
          "package": "Encode",
          "source": "src/Encode-Arabic-Buckwalter.html#Buckwalter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Buckwalter",
          "module": "Encode.Arabic.Buckwalter",
          "name": "Buckwalter",
          "package": "Encode",
          "partial": "Buckwalter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Buckwalter.html#t:Buckwalter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Buckwalter",
          "name": "Buckwalter",
          "package": "Encode",
          "signature": "Buckwalter",
          "source": "src/Encode-Arabic-Buckwalter.html#Buckwalter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Buckwalter",
          "module": "Encode.Arabic.Buckwalter",
          "name": "Buckwalter",
          "package": "Encode",
          "partial": "Buckwalter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Buckwalter.html#v:Buckwalter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Buckwalter",
          "name": "Tim",
          "package": "Encode",
          "signature": "Tim",
          "source": "src/Encode-Arabic-Buckwalter.html#Buckwalter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Buckwalter",
          "module": "Encode.Arabic.Buckwalter",
          "name": "Tim",
          "package": "Encode",
          "partial": "Tim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Buckwalter.html#v:Tim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003cem\u003eEncode::Byte\u003c/em\u003e in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode/Byte/Byte.pm\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://search.cpan.org/dist/Encode/lib/Encode/Supported.pod\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://129.69.218.213/arabtex/doc/arabdoc.pdf\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Arabic.Byte",
          "name": "Byte",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html",
          "type": "module"
        },
        "index": {
          "description": "Encode Byte in Perl http search.cpan.org dist Encode Byte Byte.pm http search.cpan.org dist Encode lib Encode Supported.pod http arabtex doc arabdoc.pdf",
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "Byte",
          "package": "Encode",
          "partial": "Byte",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "ASMO449",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#ASMO449",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "ASMO449",
          "package": "Encode",
          "partial": "ASMO",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:ASMO449"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "DOSArabic",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#DOSArabic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "DOSArabic",
          "package": "Encode",
          "partial": "DOSArabic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:DOSArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "DOSFarsi",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#DOSFarsi",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "DOSFarsi",
          "package": "Encode",
          "partial": "DOSFarsi",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:DOSFarsi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "ISIRI3342",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#ISIRI3342",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "ISIRI3342",
          "package": "Encode",
          "partial": "ISIRI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:ISIRI3342"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "ISOArabic",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#ISOArabic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "ISOArabic",
          "package": "Encode",
          "partial": "ISOArabic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:ISOArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "MacArabic",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#MacArabic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "MacArabic",
          "package": "Encode",
          "partial": "Mac Arabic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:MacArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "MacFarsi",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#MacFarsi",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "MacFarsi",
          "package": "Encode",
          "partial": "Mac Farsi",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:MacFarsi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "WinArabic",
          "package": "Encode",
          "source": "src/Encode-Arabic-Byte.html#WinArabic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "WinArabic",
          "package": "Encode",
          "partial": "Win Arabic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#t:WinArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "ASMO449",
          "package": "Encode",
          "signature": "ASMO449",
          "source": "src/Encode-Arabic-Byte.html#ASMO449",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "ASMO449",
          "package": "Encode",
          "partial": "ASMO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:ASMO449"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "CP1006",
          "package": "Encode",
          "signature": "CP1006",
          "source": "src/Encode-Arabic-Byte.html#DOSFarsi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "CP1006",
          "package": "Encode",
          "partial": "CP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:CP1006"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "CP1256",
          "package": "Encode",
          "signature": "CP1256",
          "source": "src/Encode-Arabic-Byte.html#WinArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "CP1256",
          "package": "Encode",
          "partial": "CP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:CP1256"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "CP864",
          "package": "Encode",
          "signature": "CP864",
          "source": "src/Encode-Arabic-Byte.html#DOSArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "CP864",
          "package": "Encode",
          "partial": "CP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:CP864"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "DOSArabic",
          "package": "Encode",
          "signature": "DOSArabic",
          "source": "src/Encode-Arabic-Byte.html#DOSArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "DOSArabic",
          "package": "Encode",
          "partial": "DOSArabic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:DOSArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "DOSFarsi",
          "package": "Encode",
          "signature": "DOSFarsi",
          "source": "src/Encode-Arabic-Byte.html#DOSFarsi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "DOSFarsi",
          "package": "Encode",
          "partial": "DOSFarsi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:DOSFarsi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "ISIRI3342",
          "package": "Encode",
          "signature": "ISIRI3342",
          "source": "src/Encode-Arabic-Byte.html#ISIRI3342",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "ISIRI3342",
          "package": "Encode",
          "partial": "ISIRI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:ISIRI3342"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "ISOArabic",
          "package": "Encode",
          "signature": "ISOArabic",
          "source": "src/Encode-Arabic-Byte.html#ISOArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "ISOArabic",
          "package": "Encode",
          "partial": "ISOArabic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:ISOArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "ISO_8859_6",
          "package": "Encode",
          "signature": "ISO_8859_6",
          "source": "src/Encode-Arabic-Byte.html#ISOArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "ISO_8859_6",
          "package": "Encode",
          "partial": "ISO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:ISO_8859_6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "MacArabic",
          "package": "Encode",
          "signature": "MacArabic",
          "source": "src/Encode-Arabic-Byte.html#MacArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "MacArabic",
          "package": "Encode",
          "partial": "Mac Arabic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:MacArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "MacFarsi",
          "package": "Encode",
          "signature": "MacFarsi",
          "source": "src/Encode-Arabic-Byte.html#MacFarsi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "MacFarsi",
          "package": "Encode",
          "partial": "Mac Farsi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:MacFarsi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "WinArabic",
          "package": "Encode",
          "signature": "WinArabic",
          "source": "src/Encode-Arabic-Byte.html#WinArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "WinArabic",
          "package": "Encode",
          "partial": "Win Arabic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:WinArabic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Byte",
          "name": "Windows_1256",
          "package": "Encode",
          "signature": "Windows_1256",
          "source": "src/Encode-Arabic-Byte.html#WinArabic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Byte",
          "module": "Encode.Arabic.Byte",
          "name": "Windows_1256",
          "package": "Encode",
          "partial": "Windows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Byte.html#v:Windows_1256"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHabash-Soudi-Buckwalter notation is a one-to-one transliteration of the\n graphemes of the Arabic script into various symbols of Unicode defined in\n \u003ca\u003ehttp://scholar.google.com/scholar?q=habash+soudi+buckwalter\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eEncode::Arabic::Habash\u003c/em\u003e in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/Habash.pm\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Arabic.Habash",
          "name": "Habash",
          "package": "Encode",
          "source": "src/Encode-Arabic-Habash.html",
          "type": "module"
        },
        "index": {
          "description": "Habash-Soudi-Buckwalter notation is one-to-one transliteration of the graphemes of the Arabic script into various symbols of Unicode defined in http scholar.google.com scholar habash soudi buckwalter Encode Arabic Habash in Perl http search.cpan.org dist Encode-Arabic lib Encode Arabic Habash.pm",
          "hierarchy": "Encode Arabic Habash",
          "module": "Encode.Arabic.Habash",
          "name": "Habash",
          "package": "Encode",
          "partial": "Habash",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Habash.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Habash",
          "name": "Habash",
          "package": "Encode",
          "source": "src/Encode-Arabic-Habash.html#Habash",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Habash",
          "module": "Encode.Arabic.Habash",
          "name": "Habash",
          "package": "Encode",
          "partial": "Habash",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Habash.html#t:Habash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Habash",
          "name": "HSB",
          "package": "Encode",
          "signature": "HSB",
          "source": "src/Encode-Arabic-Habash.html#Habash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Habash",
          "module": "Encode.Arabic.Habash",
          "name": "HSB",
          "package": "Encode",
          "partial": "HSB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Habash.html#v:HSB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Habash",
          "name": "Habash",
          "package": "Encode",
          "signature": "Habash",
          "source": "src/Encode-Arabic-Habash.html#Habash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Habash",
          "module": "Encode.Arabic.Habash",
          "name": "Habash",
          "package": "Encode",
          "partial": "Habash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Habash.html#v:Habash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Habash",
          "name": "Soudi",
          "package": "Encode",
          "signature": "Soudi",
          "source": "src/Encode-Arabic-Habash.html#Habash",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Habash",
          "module": "Encode.Arabic.Habash",
          "name": "Soudi",
          "package": "Encode",
          "partial": "Soudi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Habash.html#v:Soudi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDil Parkinson's notation is a one-to-one transliteration of the graphemes\n of the Arabic script using lower ASCII characters only.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eEncode::Arabic::Parkinson\u003c/em\u003e in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode-Arabic/lib/Encode/Arabic/Parkinson.pm\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Arabic.Parkinson",
          "name": "Parkinson",
          "package": "Encode",
          "source": "src/Encode-Arabic-Parkinson.html",
          "type": "module"
        },
        "index": {
          "description": "Dil Parkinson notation is one-to-one transliteration of the graphemes of the Arabic script using lower ASCII characters only Encode Arabic Parkinson in Perl http search.cpan.org dist Encode-Arabic lib Encode Arabic Parkinson.pm",
          "hierarchy": "Encode Arabic Parkinson",
          "module": "Encode.Arabic.Parkinson",
          "name": "Parkinson",
          "package": "Encode",
          "partial": "Parkinson",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Parkinson.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Parkinson",
          "name": "Parkinson",
          "package": "Encode",
          "source": "src/Encode-Arabic-Parkinson.html#Parkinson",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Arabic Parkinson",
          "module": "Encode.Arabic.Parkinson",
          "name": "Parkinson",
          "package": "Encode",
          "partial": "Parkinson",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Parkinson.html#t:Parkinson"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Parkinson",
          "name": "Dil",
          "package": "Encode",
          "signature": "Dil",
          "source": "src/Encode-Arabic-Parkinson.html#Parkinson",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Parkinson",
          "module": "Encode.Arabic.Parkinson",
          "name": "Dil",
          "package": "Encode",
          "partial": "Dil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Parkinson.html#v:Dil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Arabic.Parkinson",
          "name": "Parkinson",
          "package": "Encode",
          "signature": "Parkinson",
          "source": "src/Encode-Arabic-Parkinson.html#Parkinson",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Arabic Parkinson",
          "module": "Encode.Arabic.Parkinson",
          "name": "Parkinson",
          "package": "Encode",
          "partial": "Parkinson",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic-Parkinson.html#v:Parkinson"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Haskell version of \u003cem\u003eEncode::Arabic\u003c/em\u003e originally written in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode-Arabic/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003eEncode.Arabic.ArabTeX\u003c/a\u003e\n \u003ca\u003eEncode.Arabic.ArabTeX.ZDMG\u003c/a\u003e\n \u003ca\u003eEncode.Arabic.Buckwalter\u003c/a\u003e\n \u003ca\u003eEncode.Arabic.Parkinson\u003c/a\u003e\n \u003ca\u003eEncode.Arabic.Habash\u003c/a\u003e\n \u003ca\u003eEncode.Arabic.Byte\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Arabic",
          "name": "Arabic",
          "package": "Encode",
          "source": "src/Encode-Arabic.html",
          "type": "module"
        },
        "index": {
          "description": "The Haskell version of Encode Arabic originally written in Perl http search.cpan.org dist Encode-Arabic Encode.Arabic.ArabTeX Encode.Arabic.ArabTeX.ZDMG Encode.Arabic.Buckwalter Encode.Arabic.Parkinson Encode.Arabic.Habash Encode.Arabic.Byte",
          "hierarchy": "Encode Arabic",
          "module": "Encode.Arabic",
          "name": "Arabic",
          "package": "Encode",
          "partial": "Arabic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Arabic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003eEncode.Extend\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.ExPlus",
          "name": "ExPlus",
          "package": "Encode",
          "source": "src/Encode-ExPlus.html",
          "type": "module"
        },
        "index": {
          "description": "Encode.Extend",
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "ExPlus",
          "package": "Encode",
          "partial": "Ex Plus",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "ExtEnv",
          "package": "Encode",
          "source": "src/Encode-ExPlus.html#ExtEnv",
          "type": "class"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "ExtEnv",
          "package": "Encode",
          "partial": "Ext Env",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#t:ExtEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "Extend",
          "package": "Encode",
          "source": "src/Encode-ExPlus.html#Extend",
          "type": "type"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "Extend",
          "package": "Encode",
          "partial": "Extend",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#t:Extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "(\u003c|\u003e)",
          "package": "Encode",
          "signature": "Extend e s a -\u003e Extend e s a -\u003e Extend e s a",
          "source": "src/Encode-ExPlus.html#%3C%7C%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "(\u003c|\u003e) \u003c|\u003e",
          "normalized": "Extend a b c-\u003eExtend a b c-\u003eExtend a b c",
          "package": "Encode",
          "signature": "Extend e s a-\u003eExtend e s a-\u003eExtend e s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:-60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "again",
          "package": "Encode",
          "signature": "Extend e s a -\u003e Extend e s [a]",
          "source": "src/Encode-ExPlus.html#again",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "again",
          "normalized": "Extend a b c-\u003eExtend a b[c]",
          "package": "Encode",
          "signature": "Extend e s a-\u003eExtend e s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:again"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "initEnv",
          "package": "Encode",
          "signature": "e i",
          "source": "src/Encode-ExPlus.html#initEnv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "initEnv",
          "package": "Encode",
          "partial": "Env",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:initEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "inspectEList",
          "package": "Encode",
          "signature": "Extend e s [e s]",
          "source": "src/Encode-ExPlus.html#inspectEList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "inspectEList",
          "normalized": "Extend a b[a b]",
          "package": "Encode",
          "partial": "EList",
          "signature": "Extend e s[e s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:inspectEList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "inspectEnv",
          "package": "Encode",
          "signature": "Extend e s (e s)",
          "source": "src/Encode-ExPlus.html#inspectEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "inspectEnv",
          "package": "Encode",
          "partial": "Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:inspectEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "inspectIList",
          "package": "Encode",
          "signature": "Extend e s [s]",
          "source": "src/Encode-ExPlus.html#inspectIList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "inspectIList",
          "normalized": "Extend a b[b]",
          "package": "Encode",
          "partial": "IList",
          "signature": "Extend e s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:inspectIList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "lookupList",
          "package": "Encode",
          "signature": "s -\u003e [m s a] -\u003e [a]",
          "source": "src/Encode-ExPlus.html#lookupList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "lookupList",
          "normalized": "a-\u003e[b a c]-\u003e[c]",
          "package": "Encode",
          "partial": "List",
          "signature": "s-\u003e[m s a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:lookupList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "lower",
          "package": "Encode",
          "signature": "[s] -\u003e [s] -\u003e Extend e s [s]",
          "source": "src/Encode-ExPlus.html#lower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "lower",
          "normalized": "[a]-\u003e[a]-\u003eExtend b a[a]",
          "package": "Encode",
          "signature": "[s]-\u003e[s]-\u003eExtend e s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "oneof",
          "package": "Encode",
          "signature": "[Map s a] -\u003e m s",
          "source": "src/Encode-ExPlus.html#oneof",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "oneof",
          "normalized": "[Map a b]-\u003ec a",
          "package": "Encode",
          "signature": "[Map s a]-\u003em s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:oneof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "oneof'",
          "package": "Encode",
          "signature": "s -\u003e [Map [s] a] -\u003e m [s]",
          "source": "src/Encode-ExPlus.html#oneof%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "oneof'",
          "normalized": "a-\u003e[Map[a]b]-\u003ec[a]",
          "package": "Encode",
          "signature": "s-\u003e[Map[s]a]-\u003em[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:oneof-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "resetEnv",
          "package": "Encode",
          "signature": "(a -\u003e e s -\u003e e s) -\u003e a -\u003e Extend e s (e s)",
          "source": "src/Encode-ExPlus.html#resetEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "resetEnv",
          "normalized": "(a-\u003eb c-\u003eb c)-\u003ea-\u003eExtend b c(b c)",
          "package": "Encode",
          "partial": "Env",
          "signature": "(a-\u003ee s-\u003ee s)-\u003ea-\u003eExtend e s(e s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:resetEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "returnEList",
          "package": "Encode",
          "signature": "[e s] -\u003e Extend e s [e s]",
          "source": "src/Encode-ExPlus.html#returnEList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "returnEList",
          "normalized": "[a b]-\u003eExtend a b[a b]",
          "package": "Encode",
          "partial": "EList",
          "signature": "[e s]-\u003eExtend e s[e s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:returnEList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "returnIList",
          "package": "Encode",
          "signature": "[s] -\u003e Extend e s [s]",
          "source": "src/Encode-ExPlus.html#returnIList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "returnIList",
          "normalized": "[a]-\u003eExtend b a[a]",
          "package": "Encode",
          "partial": "IList",
          "signature": "[s]-\u003eExtend e s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:returnIList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "upper",
          "package": "Encode",
          "signature": "[s] -\u003e [m s [c]] -\u003e Extend e d ([c] -\u003e [c])",
          "source": "src/Encode-ExPlus.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "upper",
          "normalized": "[a]-\u003e[b a[c]]-\u003eExtend d e([c]-\u003e[c])",
          "package": "Encode",
          "signature": "[s]-\u003e[m s[c]]-\u003eExtend e d([c]-\u003e[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:upper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.ExPlus",
          "name": "upperWith",
          "package": "Encode",
          "signature": "(s -\u003e m -\u003e e d -\u003e [[c]]) -\u003e [s] -\u003e m -\u003e Extend e d ([c] -\u003e [c])",
          "source": "src/Encode-ExPlus.html#upperWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode ExPlus",
          "module": "Encode.ExPlus",
          "name": "upperWith",
          "normalized": "(a-\u003eb-\u003ec d-\u003e[[e]])-\u003e[a]-\u003eb-\u003eExtend c d([e]-\u003e[e])",
          "package": "Encode",
          "partial": "With",
          "signature": "(s-\u003em-\u003ee d-\u003e[[c]])-\u003e[s]-\u003em-\u003eExtend e d([c]-\u003e[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-ExPlus.html#v:upperWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ca\u003eEncode.Arabic.ArabTeX\u003c/a\u003e\n \u003ca\u003eEncode.Arabic.ArabTeX.ZDMG\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Extend",
          "name": "Extend",
          "package": "Encode",
          "source": "src/Encode-Extend.html",
          "type": "module"
        },
        "index": {
          "description": "Encode.Arabic.ArabTeX Encode.Arabic.ArabTeX.ZDMG",
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "Extend",
          "package": "Encode",
          "partial": "Extend",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "ExtEnv",
          "package": "Encode",
          "source": "src/Encode-Extend.html#ExtEnv",
          "type": "class"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "ExtEnv",
          "package": "Encode",
          "partial": "Ext Env",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#t:ExtEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "Extend",
          "package": "Encode",
          "source": "src/Encode-Extend.html#Extend",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "Extend",
          "package": "Encode",
          "partial": "Extend",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#t:Extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "(\u003c|\u003e)",
          "package": "Encode",
          "signature": "Extend e s a -\u003e Extend e s a -\u003e Extend e s a",
          "source": "src/Encode-Extend.html#%3C%7C%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "(\u003c|\u003e) \u003c|\u003e",
          "normalized": "Extend a b c-\u003eExtend a b c-\u003eExtend a b c",
          "package": "Encode",
          "signature": "Extend e s a-\u003eExtend e s a-\u003eExtend e s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:-60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "Ext",
          "package": "Encode",
          "signature": "Ext (InE s e -\u003e [(InE s e, a)])",
          "source": "src/Encode-Extend.html#Extend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "Ext",
          "normalized": "Ext(InE a b-\u003e[(InE a b,c)])",
          "package": "Encode",
          "partial": "Ext",
          "signature": "Ext(InE s e-\u003e[(InE s e,a)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:Ext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "again",
          "package": "Encode",
          "signature": "Extend e s a -\u003e Extend e s [a]",
          "source": "src/Encode-Extend.html#again",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "again",
          "normalized": "Extend a b c-\u003eExtend a b[c]",
          "package": "Encode",
          "signature": "Extend e s a-\u003eExtend e s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:again"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "initEnv",
          "package": "Encode",
          "signature": "e i",
          "source": "src/Encode-Extend.html#initEnv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "initEnv",
          "package": "Encode",
          "partial": "Env",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:initEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "inspectEList",
          "package": "Encode",
          "signature": "Extend e s [e s]",
          "source": "src/Encode-Extend.html#inspectEList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "inspectEList",
          "normalized": "Extend a b[a b]",
          "package": "Encode",
          "partial": "EList",
          "signature": "Extend e s[e s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:inspectEList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "inspectEnv",
          "package": "Encode",
          "signature": "Extend e s (e s)",
          "source": "src/Encode-Extend.html#inspectEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "inspectEnv",
          "package": "Encode",
          "partial": "Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:inspectEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "inspectIList",
          "package": "Encode",
          "signature": "Extend e s [s]",
          "source": "src/Encode-Extend.html#inspectIList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "inspectIList",
          "normalized": "Extend a b[b]",
          "package": "Encode",
          "partial": "IList",
          "signature": "Extend e s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:inspectIList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "lookupList",
          "package": "Encode",
          "signature": "s -\u003e [m s a] -\u003e [a]",
          "source": "src/Encode-Extend.html#lookupList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "lookupList",
          "normalized": "a-\u003e[b a c]-\u003e[c]",
          "package": "Encode",
          "partial": "List",
          "signature": "s-\u003e[m s a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:lookupList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "lower",
          "package": "Encode",
          "signature": "[s] -\u003e [s] -\u003e Extend e s [s]",
          "source": "src/Encode-Extend.html#lower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "lower",
          "normalized": "[a]-\u003e[a]-\u003eExtend b a[a]",
          "package": "Encode",
          "signature": "[s]-\u003e[s]-\u003eExtend e s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "oneof",
          "package": "Encode",
          "signature": "[Map s a] -\u003e m s",
          "source": "src/Encode-Extend.html#oneof",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "oneof",
          "normalized": "[Map a b]-\u003ec a",
          "package": "Encode",
          "signature": "[Map s a]-\u003em s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:oneof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "oneof'",
          "package": "Encode",
          "signature": "s -\u003e [Map [s] a] -\u003e m [s]",
          "source": "src/Encode-Extend.html#oneof%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "oneof'",
          "normalized": "a-\u003e[Map[a]b]-\u003ec[a]",
          "package": "Encode",
          "signature": "s-\u003e[Map[s]a]-\u003em[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:oneof-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "resetEnv",
          "package": "Encode",
          "signature": "(a -\u003e e s -\u003e e s) -\u003e a -\u003e Extend e s (e s)",
          "source": "src/Encode-Extend.html#resetEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "resetEnv",
          "normalized": "(a-\u003eb c-\u003eb c)-\u003ea-\u003eExtend b c(b c)",
          "package": "Encode",
          "partial": "Env",
          "signature": "(a-\u003ee s-\u003ee s)-\u003ea-\u003eExtend e s(e s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:resetEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "returnEList",
          "package": "Encode",
          "signature": "[e s] -\u003e Extend e s [e s]",
          "source": "src/Encode-Extend.html#returnEList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "returnEList",
          "normalized": "[a b]-\u003eExtend a b[a b]",
          "package": "Encode",
          "partial": "EList",
          "signature": "[e s]-\u003eExtend e s[e s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:returnEList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "returnIList",
          "package": "Encode",
          "signature": "[s] -\u003e Extend e s [s]",
          "source": "src/Encode-Extend.html#returnIList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "returnIList",
          "normalized": "[a]-\u003eExtend b a[a]",
          "package": "Encode",
          "partial": "IList",
          "signature": "[s]-\u003eExtend e s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:returnIList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "upper",
          "package": "Encode",
          "signature": "[s] -\u003e [m s [c]] -\u003e Extend e d ([c] -\u003e [c])",
          "source": "src/Encode-Extend.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "upper",
          "normalized": "[a]-\u003e[b a[c]]-\u003eExtend d e([c]-\u003e[c])",
          "package": "Encode",
          "signature": "[s]-\u003e[m s[c]]-\u003eExtend e d([c]-\u003e[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:upper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Extend",
          "name": "upperWith",
          "package": "Encode",
          "signature": "(s -\u003e m -\u003e e d -\u003e [[c]]) -\u003e [s] -\u003e m -\u003e Extend e d ([c] -\u003e [c])",
          "source": "src/Encode-Extend.html#upperWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Extend",
          "module": "Encode.Extend",
          "name": "upperWith",
          "normalized": "(a-\u003eb-\u003ec d-\u003e[[e]])-\u003e[a]-\u003eb-\u003eExtend c d([e]-\u003e[e])",
          "package": "Encode",
          "partial": "With",
          "signature": "(s-\u003em-\u003ee d-\u003e[[c]])-\u003e[s]-\u003em-\u003eExtend e d([c]-\u003e[c])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Extend.html#v:upperWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Haskell version of \u003cem\u003eEncode::Mapper\u003c/em\u003e originally written in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode-Mapper/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003eEncode.Arabic.ArabTeX\u003c/a\u003e\n \u003ca\u003eEncode.Arabic.ArabTeX.ZDMG\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Mapper",
          "name": "Mapper",
          "package": "Encode",
          "source": "src/Encode-Mapper.html",
          "type": "module"
        },
        "index": {
          "description": "The Haskell version of Encode Mapper originally written in Perl http search.cpan.org dist Encode-Mapper Encode.Arabic.ArabTeX Encode.Arabic.ArabTeX.ZDMG",
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "Mapper",
          "package": "Encode",
          "partial": "Mapper",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "Mapper",
          "package": "Encode",
          "source": "src/Encode-Mapper.html#Mapper",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "Mapper",
          "package": "Encode",
          "partial": "Mapper",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#t:Mapper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "Quit",
          "package": "Encode",
          "source": "src/Encode-Mapper.html#Quit",
          "type": "type"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "Quit",
          "package": "Encode",
          "partial": "Quit",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#t:Quit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "(|+|)",
          "package": "Encode",
          "signature": "Mapper s a -\u003e Mapper s a -\u003e Mapper s a",
          "source": "src/Encode-Mapper.html#%7C%2B%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "(|+|) |+|",
          "normalized": "Mapper a b-\u003eMapper a b-\u003eMapper a b",
          "package": "Encode",
          "signature": "Mapper s a-\u003eMapper s a-\u003eMapper s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:-124--43--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "(|-|)",
          "package": "Encode",
          "signature": "[s] -\u003e [s] -\u003e a -\u003e Mapper s (Quit s a)",
          "source": "src/Encode-Mapper.html#%7C-%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "(|-|) |-|",
          "normalized": "[a]-\u003e[a]-\u003eb-\u003eMapper a(Quit a b)",
          "package": "Encode",
          "signature": "[s]-\u003e[s]-\u003ea-\u003eMapper s(Quit s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:-124--45--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "(|.|)",
          "package": "Encode",
          "signature": "[s] -\u003e a -\u003e Mapper s (Quit s a)",
          "source": "src/Encode-Mapper.html#%7C.%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "(|.|) |.|",
          "normalized": "[a]-\u003eb-\u003eMapper a(Quit a b)",
          "package": "Encode",
          "signature": "[s]-\u003ea-\u003eMapper s(Quit s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:-124-.-124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "(|:|)",
          "package": "Encode",
          "signature": "(a -\u003e Mapper s (Quit s a)) -\u003e a -\u003e Mapper s (Quit s a)",
          "source": "src/Encode-Mapper.html#%7C%3A%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "(|:|) |:|",
          "normalized": "(a-\u003eMapper b(Quit b a))-\u003ea-\u003eMapper b(Quit b a)",
          "package": "Encode",
          "signature": "(a-\u003eMapper s(Quit s a))-\u003ea-\u003eMapper s(Quit s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:-124-:-124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "(\u003c-\u003e)",
          "package": "Encode",
          "signature": "m a -\u003e b -\u003e m ([c], b)",
          "source": "src/Encode-Mapper.html#%3C-%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "(\u003c-\u003e) \u003c-\u003e",
          "normalized": "a b-\u003ec-\u003ea([d],c)",
          "package": "Encode",
          "signature": "m a-\u003eb-\u003em([c],b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:-60--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "(\u003c.\u003e)",
          "package": "Encode",
          "signature": "m a -\u003e m b -\u003e m b",
          "source": "src/Encode-Mapper.html#%3C.%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "(\u003c.\u003e) \u003c.\u003e",
          "normalized": "a b-\u003ea c-\u003ea c",
          "package": "Encode",
          "signature": "m a-\u003em b-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:-60-.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "anySymbol",
          "package": "Encode",
          "signature": "[a] -\u003e m a",
          "source": "src/Encode-Mapper.html#anySymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "anySymbol",
          "normalized": "[a]-\u003eb a",
          "package": "Encode",
          "partial": "Symbol",
          "signature": "[a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:anySymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "initPD",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e ([a] -\u003e [a]) -\u003e ParseDeep s a",
          "source": "src/Encode-Mapper.html#initPD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "initPD",
          "normalized": "Mapper a(Quit a b)-\u003e([b]-\u003e[b])-\u003eParseDeep a b",
          "package": "Encode",
          "partial": "PD",
          "signature": "Mapper s(Quit s a)-\u003e([a]-\u003e[a])-\u003eParseDeep s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:initPD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "initPW",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e ([a] -\u003e [a]) -\u003e ParseWide s a",
          "source": "src/Encode-Mapper.html#initPW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "initPW",
          "normalized": "Mapper a(Quit a b)-\u003e([b]-\u003e[b])-\u003eParseWide a b",
          "package": "Encode",
          "partial": "PW",
          "signature": "Mapper s(Quit s a)-\u003e([a]-\u003e[a])-\u003eParseWide s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:initPW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "lastPD",
          "package": "Encode",
          "signature": "[ParseDeep s a] -\u003e ParseDeep s a -\u003e [ParseDeep s a]",
          "source": "src/Encode-Mapper.html#lastPD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "lastPD",
          "normalized": "[ParseDeep a b]-\u003eParseDeep a b-\u003e[ParseDeep a b]",
          "package": "Encode",
          "partial": "PD",
          "signature": "[ParseDeep s a]-\u003eParseDeep s a-\u003e[ParseDeep s a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:lastPD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "lastPW",
          "package": "Encode",
          "signature": "[ParseWide s a] -\u003e ParseWide s a -\u003e [ParseWide s a]",
          "source": "src/Encode-Mapper.html#lastPW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "lastPW",
          "normalized": "[ParseWide a b]-\u003eParseWide a b-\u003e[ParseWide a b]",
          "package": "Encode",
          "partial": "PW",
          "signature": "[ParseWide s a]-\u003eParseWide s a-\u003e[ParseWide s a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:lastPW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "others",
          "package": "Encode",
          "signature": "Mapper s a -\u003e (s -\u003e Maybe (Mapper s a)) -\u003e Mapper s a",
          "source": "src/Encode-Mapper.html#others",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "others",
          "normalized": "Mapper a b-\u003e(a-\u003eMaybe(Mapper a b))-\u003eMapper a b",
          "package": "Encode",
          "signature": "Mapper s a-\u003e(s-\u003eMaybe(Mapper s a))-\u003eMapper s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:others"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseDeep",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [ParseDeep s a] -\u003e [s] -\u003e [ParseDeep s a]",
          "source": "src/Encode-Mapper.html#parseDeep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseDeep",
          "normalized": "Mapper a(Quit a b)-\u003e[ParseDeep a b]-\u003e[a]-\u003e[ParseDeep a b]",
          "package": "Encode",
          "partial": "Deep",
          "signature": "Mapper s(Quit s a)-\u003e[ParseDeep s a]-\u003e[s]-\u003e[ParseDeep s a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongest",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [s] -\u003e [a]",
          "source": "src/Encode-Mapper.html#parseLongest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongest",
          "normalized": "Mapper a(Quit a b)-\u003e[a]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest",
          "signature": "Mapper s(Quit s a)-\u003e[s]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongestCheck",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [s] -\u003e [a]",
          "source": "src/Encode-Mapper.html#parseLongestCheck",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongestCheck",
          "normalized": "Mapper a(Quit a b)-\u003e[a]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest Check",
          "signature": "Mapper s(Quit s a)-\u003e[s]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongestCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongestCheckWith",
          "package": "Encode",
          "signature": "([[[a]]] -\u003e [b]) -\u003e Mapper s (Quit s a) -\u003e [s] -\u003e [b]",
          "source": "src/Encode-Mapper.html#parseLongestCheckWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongestCheckWith",
          "normalized": "([[[a]]]-\u003e[b])-\u003eMapper c(Quit c a)-\u003e[c]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest Check With",
          "signature": "([[[a]]]-\u003e[b])-\u003eMapper s(Quit s a)-\u003e[s]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongestCheckWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongestDeep",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [s] -\u003e [a]",
          "source": "src/Encode-Mapper.html#parseLongestDeep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongestDeep",
          "normalized": "Mapper a(Quit a b)-\u003e[a]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest Deep",
          "signature": "Mapper s(Quit s a)-\u003e[s]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongestDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongestDeepWith",
          "package": "Encode",
          "signature": "([[[a]]] -\u003e [b]) -\u003e Mapper s (Quit s a) -\u003e [s] -\u003e [b]",
          "source": "src/Encode-Mapper.html#parseLongestDeepWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongestDeepWith",
          "normalized": "([[[a]]]-\u003e[b])-\u003eMapper c(Quit c a)-\u003e[c]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest Deep With",
          "signature": "([[[a]]]-\u003e[b])-\u003eMapper s(Quit s a)-\u003e[s]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongestDeepWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongestWide",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [s] -\u003e [a]",
          "source": "src/Encode-Mapper.html#parseLongestWide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongestWide",
          "normalized": "Mapper a(Quit a b)-\u003e[a]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest Wide",
          "signature": "Mapper s(Quit s a)-\u003e[s]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongestWide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongestWideWith",
          "package": "Encode",
          "signature": "([[[a]]] -\u003e [b]) -\u003e Mapper s (Quit s a) -\u003e [s] -\u003e [b]",
          "source": "src/Encode-Mapper.html#parseLongestWideWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongestWideWith",
          "normalized": "([[[a]]]-\u003e[b])-\u003eMapper c(Quit c a)-\u003e[c]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest Wide With",
          "signature": "([[[a]]]-\u003e[b])-\u003eMapper s(Quit s a)-\u003e[s]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongestWideWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseLongestWith",
          "package": "Encode",
          "signature": "([[[a]]] -\u003e [b]) -\u003e Mapper s (Quit s a) -\u003e [s] -\u003e [b]",
          "source": "src/Encode-Mapper.html#parseLongestWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseLongestWith",
          "normalized": "([[[a]]]-\u003e[b])-\u003eMapper c(Quit c a)-\u003e[c]-\u003e[b]",
          "package": "Encode",
          "partial": "Longest With",
          "signature": "([[[a]]]-\u003e[b])-\u003eMapper s(Quit s a)-\u003e[s]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseLongestWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "parseWide",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [ParseWide s a] -\u003e [s] -\u003e [ParseWide s a]",
          "source": "src/Encode-Mapper.html#parseWide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "parseWide",
          "normalized": "Mapper a(Quit a b)-\u003e[ParseWide a b]-\u003e[a]-\u003e[ParseWide a b]",
          "package": "Encode",
          "partial": "Wide",
          "signature": "Mapper s(Quit s a)-\u003e[ParseWide s a]-\u003e[s]-\u003e[ParseWide s a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:parseWide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "some",
          "package": "Encode",
          "signature": "m a -\u003e m [a]",
          "source": "src/Encode-Mapper.html#some",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "some",
          "normalized": "a b-\u003ea[b]",
          "package": "Encode",
          "signature": "m a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:some"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "unParseDeep",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [ParseDeep s a] -\u003e [[[a]]]",
          "source": "src/Encode-Mapper.html#unParseDeep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "unParseDeep",
          "normalized": "Mapper a(Quit a b)-\u003e[ParseDeep a b]-\u003e[[[b]]]",
          "package": "Encode",
          "partial": "Parse Deep",
          "signature": "Mapper s(Quit s a)-\u003e[ParseDeep s a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:unParseDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Mapper",
          "name": "unParseWide",
          "package": "Encode",
          "signature": "Mapper s (Quit s a) -\u003e [ParseWide s a] -\u003e [[[a]]]",
          "source": "src/Encode-Mapper.html#unParseWide",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Mapper",
          "module": "Encode.Mapper",
          "name": "unParseWide",
          "normalized": "Mapper a(Quit a b)-\u003e[ParseWide a b]-\u003e[[[b]]]",
          "package": "Encode",
          "partial": "Parse Wide",
          "signature": "Mapper s(Quit s a)-\u003e[ParseWide s a]-\u003e[[[a]]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Mapper.html#v:unParseWide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModified version of John Meacham's \u003ca\u003ehttp://repetae.net/repos/jhc/UTF8.hs\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Unicode.UTF8",
          "name": "UTF8",
          "package": "Encode",
          "source": "src/Encode-Unicode-UTF8.html",
          "type": "module"
        },
        "index": {
          "description": "Modified version of John Meacham http repetae.net repos jhc UTF8.hs",
          "hierarchy": "Encode Unicode UTF8",
          "module": "Encode.Unicode.UTF8",
          "name": "UTF8",
          "package": "Encode",
          "partial": "UTF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode-UTF8.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Unicode.UTF8",
          "name": "UTF8",
          "package": "Encode",
          "source": "src/Encode-Unicode-UTF8.html#UTF8",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Unicode UTF8",
          "module": "Encode.Unicode.UTF8",
          "name": "UTF8",
          "package": "Encode",
          "partial": "UTF",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode-UTF8.html#t:UTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Unicode.UTF8",
          "name": "UTF",
          "package": "Encode",
          "signature": "UTF",
          "source": "src/Encode-Unicode-UTF8.html#UTF8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Unicode UTF8",
          "module": "Encode.Unicode.UTF8",
          "name": "UTF",
          "package": "Encode",
          "partial": "UTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode-UTF8.html#v:UTF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Unicode.UTF8",
          "name": "UTF8",
          "package": "Encode",
          "signature": "UTF8",
          "source": "src/Encode-Unicode-UTF8.html#UTF8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Unicode UTF8",
          "module": "Encode.Unicode.UTF8",
          "name": "UTF8",
          "package": "Encode",
          "partial": "UTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode-UTF8.html#v:UTF8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Haskell analogy to the \u003cem\u003eEncode::Unicode\u003c/em\u003e module in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003eEncode.Unicode.UTF8\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Unicode",
          "name": "Unicode",
          "package": "Encode",
          "source": "src/Encode-Unicode.html",
          "type": "module"
        },
        "index": {
          "description": "The Haskell analogy to the Encode Unicode module in Perl http search.cpan.org dist Encode Encode.Unicode.UTF8",
          "hierarchy": "Encode Unicode",
          "module": "Encode.Unicode",
          "name": "Unicode",
          "package": "Encode",
          "partial": "Unicode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Unicode",
          "name": "Unicode",
          "package": "Encode",
          "source": "src/Encode-Unicode.html#Unicode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Encode Unicode",
          "module": "Encode.Unicode",
          "name": "Unicode",
          "package": "Encode",
          "partial": "Unicode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode.html#t:Unicode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Unicode",
          "name": "UCS",
          "package": "Encode",
          "signature": "UCS",
          "source": "src/Encode-Unicode.html#Unicode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Unicode",
          "module": "Encode.Unicode",
          "name": "UCS",
          "package": "Encode",
          "partial": "UCS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode.html#v:UCS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Unicode",
          "name": "Unicode",
          "package": "Encode",
          "signature": "Unicode",
          "source": "src/Encode-Unicode.html#Unicode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Unicode",
          "module": "Encode.Unicode",
          "name": "Unicode",
          "package": "Encode",
          "partial": "Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Unicode.html#v:Unicode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExports the \u003ccode\u003e\u003ca\u003eversion\u003c/a\u003e\u003c/code\u003e of the \u003ca\u003eEncode\u003c/a\u003e library and provides support\n for working with the SVN/CVS revision keyword. The \u003ccode\u003e\u003ca\u003erevised\u003c/a\u003e\u003c/code\u003e method\n parses the '$Revision ... $' string supplied to it. Results have the\n type \u003ccode\u003e\u003ca\u003eVersion\u003c/a\u003e\u003c/code\u003e of the \u003ca\u003eData.Version\u003c/a\u003e module, which is exported, too.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode.Version",
          "name": "Version",
          "package": "Encode",
          "source": "src/Encode-Version.html",
          "type": "module"
        },
        "index": {
          "description": "Exports the version of the Encode library and provides support for working with the SVN CVS revision keyword The revised method parses the Revision string supplied to it Results have the type Version of the Data.Version module which is exported too",
          "hierarchy": "Encode Version",
          "module": "Encode.Version",
          "name": "Version",
          "package": "Encode",
          "partial": "Version",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Version.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Version",
          "name": "revised",
          "package": "Encode",
          "signature": "String -\u003e Version",
          "source": "src/Encode-Version.html#revised",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Version",
          "module": "Encode.Version",
          "name": "revised",
          "normalized": "String-\u003eVersion",
          "package": "Encode",
          "signature": "String-\u003eVersion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Version.html#v:revised"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Version",
          "name": "showPretty",
          "package": "Encode",
          "signature": "Version -\u003e String",
          "source": "src/Encode-Version.html#showPretty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Version",
          "module": "Encode.Version",
          "name": "showPretty",
          "normalized": "Version-\u003eString",
          "package": "Encode",
          "partial": "Pretty",
          "signature": "Version-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Version.html#v:showPretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode.Version",
          "name": "version",
          "package": "Encode",
          "signature": "Version",
          "source": "src/Encode-Version.html#version",
          "type": "function"
        },
        "index": {
          "hierarchy": "Encode Version",
          "module": "Encode.Version",
          "name": "version",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode-Version.html#v:version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Haskell analogy to the \u003cem\u003eEncode\u003c/em\u003e module in Perl:\n \u003ca\u003ehttp://search.cpan.org/dist/Encode/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003eEncode.Arabic\u003c/a\u003e \u003ca\u003eEncode.Mapper\u003c/a\u003e \u003ca\u003eEncode.Unicode\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Encode",
          "name": "Encode",
          "package": "Encode",
          "source": "src/Encode.html",
          "type": "module"
        },
        "index": {
          "description": "The Haskell analogy to the Encode module in Perl http search.cpan.org dist Encode Encode.Arabic Encode.Mapper Encode.Unicode",
          "hierarchy": "Encode",
          "module": "Encode",
          "name": "Encode",
          "package": "Encode",
          "partial": "Encode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eCSpace\u003c/a\u003e\u003c/code\u003e type denotes the code space, and it is a synonym to \u003ccode\u003e\u003ca\u003eWord\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Encode",
          "name": "CSpace",
          "package": "Encode",
          "source": "src/Encode.html#CSpace",
          "type": "type"
        },
        "index": {
          "description": "The CSpace type denotes the code space and it is synonym to Word",
          "hierarchy": "Encode",
          "module": "Encode",
          "name": "CSpace",
          "package": "Encode",
          "partial": "CSpace",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode.html#t:CSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncodings are represented as distinct datatypes of the \u003ccode\u003e\u003ca\u003eEncoding\u003c/a\u003e\u003c/code\u003e class,\n   which defines two essential methods:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e turning a list of 'internal code points' into a \u003ccode\u003eString\u003c/code\u003e, and\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e converting the lists in the opposite direction.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eDeveloping a new encoding means to write a new module with a structure\n   similar to this:\n\u003c/p\u003e\u003cpre\u003e\n    module \u003cem\u003eMyEncModule\u003c/em\u003e (\u003cem\u003eMyEncType\u003c/em\u003e (..)) where\n \u003cem\u003e  \u003c/em\u003e\n    import \u003ca\u003eEncode\u003c/a\u003e\n \u003cem\u003e  \u003c/em\u003e\n    data \u003cem\u003eMyEncType\u003c/em\u003e = \u003cem\u003eMyEncName | MyEncAlias deriving (Enum, Show)\u003c/em\u003e\n \u003cem\u003e  \u003c/em\u003e\n    instance \u003ccode\u003e\u003ca\u003eEncoding\u003c/a\u003e\u003c/code\u003e \u003cem\u003eMyEncType\u003c/em\u003e where\n \u003cem\u003e  \u003c/em\u003e\n        \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003e \u003cem\u003eenc data\u003c/em\u003e = \u003cem\u003eshow data\u003c/em\u003e         \u003cem\u003e-- your choices ...\u003c/em\u003e\n \u003cem\u003e  \u003c/em\u003e\n        \u003ccode\u003e\u003ca\u003edecode\u003c/a\u003e\u003c/code\u003e \u003cem\u003eenc data\u003c/em\u003e = \u003cem\u003emap (toEnum . fromEnum) data\u003c/em\u003e\n\u003c/pre\u003e\u003cp\u003e\u003ca\u003eEncode.Unicode.UTF8\u003c/a\u003e is one concrete implementation that realizes\n   and illustrates this template. \u003ca\u003eEncode.Arabic.Buckwalter\u003c/a\u003e implements\n   symmetric recoding using finite maps, and \u003ca\u003eEncode.Arabic.ArabTeX\u003c/a\u003e\n   makes use of monadic parsing and the \u003ca\u003ePureFP\u003c/a\u003e library.\n\u003c/p\u003e",
          "module": "Encode",
          "name": "Encoding",
          "package": "Encode",
          "source": "src/Encode.html#Encoding",
          "type": "class"
        },
        "index": {
          "description": "Encodings are represented as distinct datatypes of the Encoding class which defines two essential methods encode turning list of internal code points into String and decode converting the lists in the opposite direction Developing new encoding means to write new module with structure similar to this module MyEncModule MyEncType where import Encode data MyEncType MyEncName MyEncAlias deriving Enum Show instance Encoding MyEncType where encode enc data show data your choices decode enc data map toEnum fromEnum data Encode.Unicode.UTF8 is one concrete implementation that realizes and illustrates this template Encode.Arabic.Buckwalter implements symmetric recoding using finite maps and Encode.Arabic.ArabTeX makes use of monadic parsing and the PureFP library",
          "hierarchy": "Encode",
          "module": "Encode",
          "name": "Encoding",
          "package": "Encode",
          "partial": "Encoding",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode.html#t:Encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe datatype introduced for the internal representation of Unicode code\n   points is currently defined as \u003ccode\u003enewtype \u003ccode\u003e\u003ca\u003eUPoint\u003c/a\u003e\u003c/code\u003e = UPoint CSpace\u003c/code\u003e. The\n   shift to code points \u003ccode\u003eUPoint\u003c/code\u003e from characters \u003ccode\u003eChar\u003c/code\u003e is intentional, as\n   Unicode support in Haskell is not yet fully implemented, and code points\n   are, anyway, different entities. Since the \u003ccode\u003e\u003ca\u003eUPoint\u003c/a\u003e\u003c/code\u003e type is an instance\n   of the \u003ccode\u003eEnum\u003c/code\u003e class, the type's constructor and destructor functions are\n   available as \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e, respectively.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eUPoint\u003c/a\u003e\u003c/code\u003e datatype should be the transfer point on the way from one\n   encoding into another. It should not be the terminal stop, though. The\n   \u003ccode\u003e\u003ca\u003eencode\u003c/a\u003e\u003c/code\u003e method should be used systematically, and not \u003ccode\u003eshow\u003c/code\u003e, even if\n   it might temporarily produce somehow appealing results.\n\u003c/p\u003e",
          "module": "Encode",
          "name": "UPoint",
          "package": "Encode",
          "source": "src/Encode.html#UPoint",
          "type": "data"
        },
        "index": {
          "description": "The datatype introduced for the internal representation of Unicode code points is currently defined as newtype UPoint UPoint CSpace The shift to code points UPoint from characters Char is intentional as Unicode support in Haskell is not yet fully implemented and code points are anyway different entities Since the UPoint type is an instance of the Enum class the type constructor and destructor functions are available as toEnum and fromEnum respectively The UPoint datatype should be the transfer point on the way from one encoding into another It should not be the terminal stop though The encode method should be used systematically and not show even if it might temporarily produce somehow appealing results",
          "hierarchy": "Encode",
          "module": "Encode",
          "name": "UPoint",
          "package": "Encode",
          "partial": "UPoint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode.html#t:UPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode",
          "name": "decode",
          "package": "Encode",
          "signature": "e -\u003e [Char] -\u003e [UPoint]",
          "source": "src/Encode.html#decode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Encode",
          "module": "Encode",
          "name": "decode",
          "normalized": "a-\u003e[Char]-\u003e[UPoint]",
          "package": "Encode",
          "signature": "e-\u003e[Char]-\u003e[UPoint]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Encode",
          "name": "encode",
          "package": "Encode",
          "signature": "e -\u003e [UPoint] -\u003e [Char]",
          "source": "src/Encode.html#encode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Encode",
          "module": "Encode",
          "name": "encode",
          "normalized": "a-\u003e[UPoint]-\u003e[Char]",
          "package": "Encode",
          "signature": "e-\u003e[UPoint]-\u003e[Char]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Encode.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides the \u003cem\u003eParsek\u003c/em\u003e library developed by Koen Claessen in his\n functional pearl article \u003cem\u003eParallel Parsing Processes\u003c/em\u003e, Journal of Functional\n Programming, 14(6), 741&#150;757, Cambridge University Press, 2004:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.cse.chalmers.se/edu/course/afp/Papers/parser-claessen.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eCopyright (C) 2003  Koen Claessen\n\u003c/p\u003e\u003cp\u003eThis program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\u003c/p\u003e\u003cp\u003eThis program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\u003c/p\u003e\u003cp\u003eYou should have received a copy of the GNU General Public License along\n   with this program; if not, write to the Free Software Foundation, Inc.,\n   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ePureFP.Parsers.Stream\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Parsek",
          "name": "Parsek",
          "package": "Encode",
          "source": "src/Parsek.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides the Parsek library developed by Koen Claessen in his functional pearl article Parallel Parsing Processes Journal of Functional Programming Cambridge University Press http www.cse.chalmers.se edu course afp Papers parser-claessen.pdf Copyright Koen Claessen This program is free software you can redistribute it and or modify it under the terms of the GNU General Public License as published by the Free Software Foundation either version of the License or at your option any later version This program is distributed in the hope that it will be useful but WITHOUT ANY WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS FOR PARTICULAR PURPOSE See the GNU General Public License for more details You should have received copy of the GNU General Public License along with this program if not write to the Free Software Foundation Inc Franklin Street Fifth Floor Boston MA USA PureFP.Parsers.Stream",
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "Parsek",
          "package": "Encode",
          "partial": "Parsek",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "Expect",
          "package": "Encode",
          "source": "src/Parsek.html#Expect",
          "type": "type"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "Expect",
          "package": "Encode",
          "partial": "Expect",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#t:Expect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "ParseMethod",
          "package": "Encode",
          "source": "src/Parsek.html#ParseMethod",
          "type": "type"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "ParseMethod",
          "package": "Encode",
          "partial": "Parse Method",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#t:ParseMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "ParseResult",
          "package": "Encode",
          "source": "src/Parsek.html#ParseResult",
          "type": "type"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "ParseResult",
          "package": "Encode",
          "partial": "Parse Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "Parser",
          "package": "Encode",
          "source": "src/Parsek.html#Parser",
          "type": "data"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "Parser",
          "package": "Encode",
          "partial": "Parser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "Unexpect",
          "package": "Encode",
          "source": "src/Parsek.html#Unexpect",
          "type": "type"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "Unexpect",
          "package": "Encode",
          "partial": "Unexpect",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#t:Unexpect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "(\u003c|\u003e)",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s a -\u003e Parser s a",
          "source": "src/Parsek.html#%3C%7C%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "(\u003c|\u003e) \u003c|\u003e",
          "normalized": "Parser a b-\u003eParser a b-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:-60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "(\u003c\u003c|\u003e)",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s a -\u003e Parser s a",
          "source": "src/Parsek.html#%3C%3C%7C%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "(\u003c\u003c|\u003e) \u003c\u003c|\u003e",
          "normalized": "Parser a b-\u003eParser a b-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:-60--60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "(\u003c?\u003e)",
          "package": "Encode",
          "signature": "Parser s a -\u003e String -\u003e Parser s a",
          "source": "src/Parsek.html#%3C%3F%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "(\u003c?\u003e) \u003c?\u003e",
          "normalized": "Parser a b-\u003eString-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eString-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:-60--63--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "allResults",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) [a]",
          "source": "src/Parsek.html#allResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "allResults",
          "normalized": "ParseMethod a b(Maybe a)[b]",
          "package": "Encode",
          "partial": "Results",
          "signature": "ParseMethod s a(Maybe s)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:allResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "allResultsStaged",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) [[a]]",
          "source": "src/Parsek.html#allResultsStaged",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "allResultsStaged",
          "normalized": "ParseMethod a b(Maybe a)[[b]]",
          "package": "Encode",
          "partial": "Results Staged",
          "signature": "ParseMethod s a(Maybe s)[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:allResultsStaged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "allResultsWithLeftover",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) [(a, [s])]",
          "source": "src/Parsek.html#allResultsWithLeftover",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "allResultsWithLeftover",
          "normalized": "ParseMethod a b(Maybe a)[(b,[a])]",
          "package": "Encode",
          "partial": "Results With Leftover",
          "signature": "ParseMethod s a(Maybe s)[(a,[s])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:allResultsWithLeftover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "alphaNum",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#alphaNum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "alphaNum",
          "package": "Encode",
          "partial": "Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:alphaNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "anyChar",
          "package": "Encode",
          "signature": "Parser s s",
          "source": "src/Parsek.html#anyChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "anyChar",
          "package": "Encode",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:anyChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "anySymbol",
          "package": "Encode",
          "signature": "Parser s s",
          "source": "src/Parsek.html#anySymbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "anySymbol",
          "package": "Encode",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:anySymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "between",
          "package": "Encode",
          "signature": "Parser s open -\u003e Parser s close -\u003e Parser s a -\u003e Parser s a",
          "source": "src/Parsek.html#between",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "between",
          "normalized": "Parser a b-\u003eParser a c-\u003eParser a d-\u003eParser a d",
          "package": "Encode",
          "signature": "Parser s open-\u003eParser s close-\u003eParser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:between"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "chainl",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s (a -\u003e a -\u003e a) -\u003e a -\u003e Parser s a",
          "source": "src/Parsek.html#chainl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "chainl",
          "normalized": "Parser a b-\u003eParser a(b-\u003eb-\u003eb)-\u003eb-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s(a-\u003ea-\u003ea)-\u003ea-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:chainl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "chainl1",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s (a -\u003e a -\u003e a) -\u003e Parser s a",
          "source": "src/Parsek.html#chainl1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "chainl1",
          "normalized": "Parser a b-\u003eParser a(b-\u003eb-\u003eb)-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s(a-\u003ea-\u003ea)-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:chainl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "chainr",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s (a -\u003e a -\u003e a) -\u003e a -\u003e Parser s a",
          "source": "src/Parsek.html#chainr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "chainr",
          "normalized": "Parser a b-\u003eParser a(b-\u003eb-\u003eb)-\u003eb-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s(a-\u003ea-\u003ea)-\u003ea-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:chainr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "chainr1",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s (a -\u003e a -\u003e a) -\u003e Parser s a",
          "source": "src/Parsek.html#chainr1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "chainr1",
          "normalized": "Parser a b-\u003eParser a(b-\u003eb-\u003eb)-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s(a-\u003ea-\u003ea)-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:chainr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "char",
          "package": "Encode",
          "signature": "t -\u003e Parser t t",
          "source": "src/Parsek.html#char",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "char",
          "normalized": "a-\u003eParser a a",
          "package": "Encode",
          "signature": "t-\u003eParser t t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "choice",
          "package": "Encode",
          "signature": "[Parser s a] -\u003e Parser s a",
          "source": "src/Parsek.html#choice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "choice",
          "normalized": "[Parser a b]-\u003eParser a b",
          "package": "Encode",
          "signature": "[Parser s a]-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "completeResults",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) [a]",
          "source": "src/Parsek.html#completeResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "completeResults",
          "normalized": "ParseMethod a b(Maybe a)[b]",
          "package": "Encode",
          "partial": "Results",
          "signature": "ParseMethod s a(Maybe s)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:completeResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "completeResultsWithLine",
          "package": "Encode",
          "signature": "ParseMethod Char a Int [a]",
          "source": "src/Parsek.html#completeResultsWithLine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "completeResultsWithLine",
          "normalized": "ParseMethod Char a Int[a]",
          "package": "Encode",
          "partial": "Results With Line",
          "signature": "ParseMethod Char a Int[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:completeResultsWithLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "count",
          "package": "Encode",
          "signature": "Int -\u003e Parser s a -\u003e Parser s [a]",
          "source": "src/Parsek.html#count",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "count",
          "normalized": "Int-\u003eParser a b-\u003eParser a[b]",
          "package": "Encode",
          "signature": "Int-\u003eParser s a-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "digit",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#digit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "digit",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:digit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "hexDigit",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#hexDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "hexDigit",
          "package": "Encode",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:hexDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "label",
          "package": "Encode",
          "signature": "Parser s a -\u003e String -\u003e Parser s a",
          "source": "src/Parsek.html#label",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "label",
          "normalized": "Parser a b-\u003eString-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eString-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "letter",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#letter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "letter",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:letter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "longestResult",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) a",
          "source": "src/Parsek.html#longestResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "longestResult",
          "package": "Encode",
          "partial": "Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:longestResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "longestResultWithLeftover",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) (a, [s])",
          "source": "src/Parsek.html#longestResultWithLeftover",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "longestResultWithLeftover",
          "normalized": "ParseMethod a b(Maybe a)(b,[a])",
          "package": "Encode",
          "partial": "Result With Leftover",
          "signature": "ParseMethod s a(Maybe s)(a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:longestResultWithLeftover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "longestResults",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) [a]",
          "source": "src/Parsek.html#longestResults",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "longestResults",
          "normalized": "ParseMethod a b(Maybe a)[b]",
          "package": "Encode",
          "partial": "Results",
          "signature": "ParseMethod s a(Maybe s)[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:longestResults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "longestResultsWithLeftover",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) ([a], Maybe [s])",
          "source": "src/Parsek.html#longestResultsWithLeftover",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "longestResultsWithLeftover",
          "normalized": "ParseMethod a b(Maybe a)([b],Maybe[a])",
          "package": "Encode",
          "partial": "Results With Leftover",
          "signature": "ParseMethod s a(Maybe s)([a],Maybe[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:longestResultsWithLeftover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "look",
          "package": "Encode",
          "signature": "Parser s [s]",
          "source": "src/Parsek.html#look",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "look",
          "normalized": "Parser a[a]",
          "package": "Encode",
          "signature": "Parser s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:look"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "lower",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#lower",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "lower",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "many",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s [a]",
          "source": "src/Parsek.html#many",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "many",
          "normalized": "Parser a b-\u003eParser a[b]",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "many1",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s [a]",
          "source": "src/Parsek.html#many1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "many1",
          "normalized": "Parser a b-\u003eParser a[b]",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:many1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "munch",
          "package": "Encode",
          "signature": "(s -\u003e Bool) -\u003e Parser s [s]",
          "source": "src/Parsek.html#munch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "munch",
          "normalized": "(a-\u003eBool)-\u003eParser a[a]",
          "package": "Encode",
          "signature": "(s-\u003eBool)-\u003eParser s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:munch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "munch1",
          "package": "Encode",
          "signature": "(s -\u003e Bool) -\u003e Parser s [s]",
          "source": "src/Parsek.html#munch1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "munch1",
          "normalized": "(a-\u003eBool)-\u003eParser a[a]",
          "package": "Encode",
          "signature": "(s-\u003eBool)-\u003eParser s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:munch1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "newline",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#newline",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "newline",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:newline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "noneOf",
          "package": "Encode",
          "signature": "[a] -\u003e Parser a a",
          "source": "src/Parsek.html#noneOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "noneOf",
          "normalized": "[a]-\u003eParser a a",
          "package": "Encode",
          "partial": "Of",
          "signature": "[a]-\u003eParser a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:noneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "octDigit",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#octDigit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "octDigit",
          "package": "Encode",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:octDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "oneOf",
          "package": "Encode",
          "signature": "[a] -\u003e Parser a a",
          "source": "src/Parsek.html#oneOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "oneOf",
          "normalized": "[a]-\u003eParser a a",
          "package": "Encode",
          "partial": "Of",
          "signature": "[a]-\u003eParser a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:oneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "option",
          "package": "Encode",
          "signature": "a -\u003e Parser s a -\u003e Parser s a",
          "source": "src/Parsek.html#option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "option",
          "normalized": "a-\u003eParser b a-\u003eParser b a",
          "package": "Encode",
          "signature": "a-\u003eParser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "optional",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s ()",
          "source": "src/Parsek.html#optional",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "optional",
          "normalized": "Parser a b-\u003eParser a()",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:optional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "parse",
          "package": "Encode",
          "signature": "Parser s a -\u003e ParseMethod s a e r -\u003e [s] -\u003e ParseResult e r",
          "source": "src/Parsek.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "parse",
          "normalized": "Parser a b-\u003eParseMethod a b c d-\u003e[a]-\u003eParseResult c d",
          "package": "Encode",
          "signature": "Parser s a-\u003eParseMethod s a e r-\u003e[s]-\u003eParseResult e r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "parseFromFile",
          "package": "Encode",
          "signature": "Parser Char a -\u003e ParseMethod Char a e r -\u003e FilePath -\u003e IO (ParseResult e r)",
          "source": "src/Parsek.html#parseFromFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "parseFromFile",
          "normalized": "Parser Char a-\u003eParseMethod Char a b c-\u003eFilePath-\u003eIO(ParseResult b c)",
          "package": "Encode",
          "partial": "From File",
          "signature": "Parser Char a-\u003eParseMethod Char a e r-\u003eFilePath-\u003eIO(ParseResult e r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:parseFromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "pzero",
          "package": "Encode",
          "signature": "Parser s a",
          "source": "src/Parsek.html#pzero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "pzero",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:pzero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "satisfy",
          "package": "Encode",
          "signature": "(s -\u003e Bool) -\u003e Parser s s",
          "source": "src/Parsek.html#satisfy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "satisfy",
          "normalized": "(a-\u003eBool)-\u003eParser a a",
          "package": "Encode",
          "signature": "(s-\u003eBool)-\u003eParser s s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:satisfy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "sepBy",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s sep -\u003e Parser s [a]",
          "source": "src/Parsek.html#sepBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "sepBy",
          "normalized": "Parser a b-\u003eParser a c-\u003eParser a[b]",
          "package": "Encode",
          "partial": "By",
          "signature": "Parser s a-\u003eParser s sep-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:sepBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "sepBy1",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s sep -\u003e Parser s [a]",
          "source": "src/Parsek.html#sepBy1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "sepBy1",
          "normalized": "Parser a b-\u003eParser a c-\u003eParser a[b]",
          "package": "Encode",
          "partial": "By",
          "signature": "Parser s a-\u003eParser s sep-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:sepBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "shortestResult",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) a",
          "source": "src/Parsek.html#shortestResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "shortestResult",
          "package": "Encode",
          "partial": "Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:shortestResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "shortestResultWithLeftover",
          "package": "Encode",
          "signature": "ParseMethod s a (Maybe s) (a, [s])",
          "source": "src/Parsek.html#shortestResultWithLeftover",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "shortestResultWithLeftover",
          "normalized": "ParseMethod a b(Maybe a)(b,[a])",
          "package": "Encode",
          "partial": "Result With Leftover",
          "signature": "ParseMethod s a(Maybe s)(a,[s])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:shortestResultWithLeftover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "skipMany",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s ()",
          "source": "src/Parsek.html#skipMany",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "skipMany",
          "normalized": "Parser a b-\u003eParser a()",
          "package": "Encode",
          "partial": "Many",
          "signature": "Parser s a-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:skipMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "skipMany1",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s ()",
          "source": "src/Parsek.html#skipMany1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "skipMany1",
          "normalized": "Parser a b-\u003eParser a()",
          "package": "Encode",
          "partial": "Many",
          "signature": "Parser s a-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:skipMany1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "space",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#space",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "space",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "spaces",
          "package": "Encode",
          "signature": "Parser Char ()",
          "source": "src/Parsek.html#spaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "spaces",
          "normalized": "Parser Char()",
          "package": "Encode",
          "signature": "Parser Char()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:spaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "string",
          "package": "Encode",
          "signature": "[s] -\u003e Parser s [s]",
          "source": "src/Parsek.html#string",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "string",
          "normalized": "[a]-\u003eParser a[a]",
          "package": "Encode",
          "signature": "[s]-\u003eParser s[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "succeeds",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s (Maybe a)",
          "source": "src/Parsek.html#succeeds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "succeeds",
          "normalized": "Parser a b-\u003eParser a(Maybe b)",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:succeeds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "tab",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#tab",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "tab",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:tab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "try",
          "package": "Encode",
          "signature": "Parser s a -\u003e Parser s a",
          "source": "src/Parsek.html#try",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "try",
          "normalized": "Parser a b-\u003eParser a b",
          "package": "Encode",
          "signature": "Parser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:try"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Parsek",
          "name": "upper",
          "package": "Encode",
          "signature": "Parser Char Char",
          "source": "src/Parsek.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Parsek",
          "module": "Parsek",
          "name": "upper",
          "package": "Encode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/Parsek.html#v:upper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapter 1 and Appendix A of /Pure Functional Parsing &#150; an advanced\n tutorial/ by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.OrdMap",
          "name": "OrdMap",
          "package": "Encode",
          "source": "src/PureFP-OrdMap.html",
          "type": "module"
        },
        "index": {
          "description": "Chapter and Appendix of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf",
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "OrdMap",
          "package": "Encode",
          "partial": "Ord Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "Map",
          "package": "Encode",
          "source": "src/PureFP-OrdMap.html#Map",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "Map",
          "package": "Encode",
          "partial": "Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#t:Map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "OrdMap",
          "package": "Encode",
          "source": "src/PureFP-OrdMap.html#OrdMap",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "OrdMap",
          "package": "Encode",
          "partial": "Ord Map",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#t:OrdMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "(|-\u003e)",
          "package": "Encode",
          "signature": "s -\u003e a -\u003e m s a",
          "source": "src/PureFP-OrdMap.html#%7C-%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "(|-\u003e) |-\u003e",
          "normalized": "a-\u003eb-\u003ec a b",
          "package": "Encode",
          "signature": "s-\u003ea-\u003em s a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:-124--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "(?)",
          "package": "Encode",
          "signature": "m s a -\u003e s -\u003e Maybe a",
          "source": "src/PureFP-OrdMap.html#%3F",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "(?) ?",
          "normalized": "a b c-\u003eb-\u003eMaybe c",
          "package": "Encode",
          "signature": "m s a-\u003es-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:-63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "assocs",
          "package": "Encode",
          "signature": "m s a -\u003e [(s, a)]",
          "source": "src/PureFP-OrdMap.html#assocs",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "assocs",
          "normalized": "a b c-\u003e[(b,c)]",
          "package": "Encode",
          "signature": "m s a-\u003e[(s,a)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:assocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "emptyMap",
          "package": "Encode",
          "signature": "m s a",
          "source": "src/PureFP-OrdMap.html#emptyMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "emptyMap",
          "package": "Encode",
          "partial": "Map",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:emptyMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "isEmptyMap",
          "package": "Encode",
          "signature": "m s a -\u003e Bool",
          "source": "src/PureFP-OrdMap.html#isEmptyMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "isEmptyMap",
          "normalized": "a b c-\u003eBool",
          "package": "Encode",
          "partial": "Empty Map",
          "signature": "m s a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:isEmptyMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "lookupWith",
          "package": "Encode",
          "signature": "a -\u003e m s a -\u003e s -\u003e a",
          "source": "src/PureFP-OrdMap.html#lookupWith",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "lookupWith",
          "normalized": "a-\u003eb c a-\u003ec-\u003ea",
          "package": "Encode",
          "partial": "With",
          "signature": "a-\u003em s a-\u003es-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:lookupWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "makeMapWith",
          "package": "Encode",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(s, a)] -\u003e m s a",
          "source": "src/PureFP-OrdMap.html#makeMapWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "makeMapWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(b,a)]-\u003ec b a",
          "package": "Encode",
          "partial": "Map With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(s,a)]-\u003em s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:makeMapWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "mapMap",
          "package": "Encode",
          "signature": "(a -\u003e b) -\u003e m s a -\u003e m s b",
          "source": "src/PureFP-OrdMap.html#mapMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "mapMap",
          "normalized": "(a-\u003eb)-\u003ec d a-\u003ec d b",
          "package": "Encode",
          "partial": "Map",
          "signature": "(a-\u003eb)-\u003em s a-\u003em s b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:mapMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "mapMapWithKey",
          "package": "Encode",
          "signature": "(s -\u003e t -\u003e a) -\u003e Map s t -\u003e Map s a",
          "source": "src/PureFP-OrdMap.html#mapMapWithKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "mapMapWithKey",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMap a b-\u003eMap a c",
          "package": "Encode",
          "partial": "Map With Key",
          "signature": "(s-\u003et-\u003ea)-\u003eMap s t-\u003eMap s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:mapMapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "mergeWith",
          "package": "Encode",
          "signature": "(a -\u003e a -\u003e a) -\u003e m s a -\u003e m s a -\u003e m s a",
          "source": "src/PureFP-OrdMap.html#mergeWith",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "mergeWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb c a-\u003eb c a-\u003eb c a",
          "package": "Encode",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003em s a-\u003em s a-\u003em s a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:mergeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "ordMap",
          "package": "Encode",
          "signature": "[(s, a)] -\u003e m s a",
          "source": "src/PureFP-OrdMap.html#ordMap",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "ordMap",
          "normalized": "[(a,b)]-\u003ec a b",
          "package": "Encode",
          "partial": "Map",
          "signature": "[(s,a)]-\u003em s a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:ordMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdMap",
          "name": "unionMapWith",
          "package": "Encode",
          "signature": "(a -\u003e a -\u003e a) -\u003e [m s a] -\u003e m s a",
          "source": "src/PureFP-OrdMap.html#unionMapWith",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdMap",
          "module": "PureFP.OrdMap",
          "name": "unionMapWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[b c a]-\u003eb c a",
          "package": "Encode",
          "partial": "Map With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[m s a]-\u003em s a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdMap.html#v:unionMapWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapter 1 and Appendix A of /Pure Functional Parsing &#150; an advanced\n tutorial/ by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.OrdSet",
          "name": "OrdSet",
          "package": "Encode",
          "source": "src/PureFP-OrdSet.html",
          "type": "module"
        },
        "index": {
          "description": "Chapter and Appendix of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf",
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "OrdSet",
          "package": "Encode",
          "partial": "Ord Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "OrdSet",
          "package": "Encode",
          "source": "src/PureFP-OrdSet.html#OrdSet",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "OrdSet",
          "package": "Encode",
          "partial": "Ord Set",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#t:OrdSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "Set",
          "package": "Encode",
          "source": "src/PureFP-OrdSet.html#Set",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "Set",
          "package": "Encode",
          "partial": "Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#t:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "(\u003c++\u003e)",
          "package": "Encode",
          "signature": "m a -\u003e m a -\u003e m a",
          "source": "src/PureFP-OrdSet.html#%3C%2B%2B%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "(\u003c++\u003e) \u003c++\u003e",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "Encode",
          "signature": "m a-\u003em a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:-60--43--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "(\u003c\\\\\u003e)",
          "package": "Encode",
          "signature": "m a -\u003e m a -\u003e m a",
          "source": "src/PureFP-OrdSet.html#%3C%5C%5C%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "(\u003c\\\\\u003e) \u003c\\\\\u003e",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "Encode",
          "signature": "m a-\u003em a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:-60--92--92--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "elemSet",
          "package": "Encode",
          "signature": "a -\u003e m a -\u003e Bool",
          "source": "src/PureFP-OrdSet.html#elemSet",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "elemSet",
          "normalized": "a-\u003eb a-\u003eBool",
          "package": "Encode",
          "partial": "Set",
          "signature": "a-\u003em a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:elemSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "elems",
          "package": "Encode",
          "signature": "m a -\u003e [a]",
          "source": "src/PureFP-OrdSet.html#elems",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "elems",
          "normalized": "a b-\u003e[b]",
          "package": "Encode",
          "signature": "m a-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "emptySet",
          "package": "Encode",
          "signature": "m a",
          "source": "src/PureFP-OrdSet.html#emptySet",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "emptySet",
          "package": "Encode",
          "partial": "Set",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:emptySet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "isEmpty",
          "package": "Encode",
          "signature": "m a -\u003e Bool",
          "source": "src/PureFP-OrdSet.html#isEmpty",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "isEmpty",
          "normalized": "a b-\u003eBool",
          "package": "Encode",
          "partial": "Empty",
          "signature": "m a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:isEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "limit",
          "package": "Encode",
          "signature": "(a -\u003e m a) -\u003e m a -\u003e m a",
          "source": "src/PureFP-OrdSet.html#limit",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "limit",
          "normalized": "(a-\u003eb a)-\u003eb a-\u003eb a",
          "package": "Encode",
          "signature": "(a-\u003em a)-\u003em a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:limit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "makeSet",
          "package": "Encode",
          "signature": "[a] -\u003e m a",
          "source": "src/PureFP-OrdSet.html#makeSet",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "makeSet",
          "normalized": "[a]-\u003eb a",
          "package": "Encode",
          "partial": "Set",
          "signature": "[a]-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:makeSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "ordSet",
          "package": "Encode",
          "signature": "[a] -\u003e m a",
          "source": "src/PureFP-OrdSet.html#ordSet",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "ordSet",
          "normalized": "[a]-\u003eb a",
          "package": "Encode",
          "partial": "Set",
          "signature": "[a]-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:ordSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "plusMinus",
          "package": "Encode",
          "signature": "m a -\u003e m a -\u003e (m a, m a)",
          "source": "src/PureFP-OrdSet.html#plusMinus",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "plusMinus",
          "normalized": "a b-\u003ea b-\u003e(a b,a b)",
          "package": "Encode",
          "partial": "Minus",
          "signature": "m a-\u003em a-\u003e(m a,m a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:plusMinus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "union",
          "package": "Encode",
          "signature": "[m a] -\u003e m a",
          "source": "src/PureFP-OrdSet.html#union",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "union",
          "normalized": "[a b]-\u003ea b",
          "package": "Encode",
          "signature": "[m a]-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.OrdSet",
          "name": "unitSet",
          "package": "Encode",
          "signature": "a -\u003e m a",
          "source": "src/PureFP-OrdSet.html#unitSet",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP OrdSet",
          "module": "PureFP.OrdSet",
          "name": "unitSet",
          "normalized": "a-\u003eb a",
          "package": "Encode",
          "partial": "Set",
          "signature": "a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-OrdSet.html#v:unitSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "AmbExTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-AmbExTrie.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing",
          "hierarchy": "PureFP Parsers AmbExTrie",
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "AmbExTrie",
          "package": "Encode",
          "partial": "Amb Ex Trie",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbExTrie.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "AmbExTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-AmbExTrie.html#AmbExTrie",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP Parsers AmbExTrie",
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "AmbExTrie",
          "package": "Encode",
          "partial": "Amb Ex Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbExTrie.html#t:AmbExTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.AmbExTrie",
          "name": ":&:",
          "package": "Encode",
          "signature": "[a] :&: (Map s (AmbExTrie s a))",
          "source": "src/PureFP-Parsers-AmbExTrie.html#AmbExTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers AmbExTrie",
          "module": "PureFP.Parsers.AmbExTrie",
          "name": ":&:",
          "normalized": "[a](Map b(AmbExTrie b a))",
          "package": "Encode",
          "signature": "[a](Map s(AmbExTrie s a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbExTrie.html#v::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "FMap",
          "package": "Encode",
          "signature": "forall b . FMap (b -\u003e a) (AmbExTrie s b)",
          "source": "src/PureFP-Parsers-AmbExTrie.html#AmbExTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers AmbExTrie",
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "FMap",
          "normalized": "a b FMap(b-\u003ec)(AmbExTrie d b)",
          "package": "Encode",
          "partial": "FMap",
          "signature": "forall b FMap(b-\u003ea)(AmbExTrie s b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbExTrie.html#v:FMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "unfold",
          "package": "Encode",
          "signature": "(a -\u003e b) -\u003e AmbExTrie s a -\u003e AmbExTrie s b",
          "source": "src/PureFP-Parsers-AmbExTrie.html#unfold",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers AmbExTrie",
          "module": "PureFP.Parsers.AmbExTrie",
          "name": "unfold",
          "normalized": "(a-\u003eb)-\u003eAmbExTrie c a-\u003eAmbExTrie c b",
          "package": "Encode",
          "signature": "(a-\u003eb)-\u003eAmbExTrie s a-\u003eAmbExTrie s b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbExTrie.html#v:unfold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.AmbTrie",
          "name": "AmbTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-AmbTrie.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing",
          "hierarchy": "PureFP Parsers AmbTrie",
          "module": "PureFP.Parsers.AmbTrie",
          "name": "AmbTrie",
          "package": "Encode",
          "partial": "Amb Trie",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbTrie.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.AmbTrie",
          "name": "AmbTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-AmbTrie.html#AmbTrie",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP Parsers AmbTrie",
          "module": "PureFP.Parsers.AmbTrie",
          "name": "AmbTrie",
          "package": "Encode",
          "partial": "Amb Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbTrie.html#t:AmbTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.AmbTrie",
          "name": ":&:",
          "package": "Encode",
          "signature": "[a] :&: (Map s (AmbTrie s a))",
          "source": "src/PureFP-Parsers-AmbTrie.html#AmbTrie",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers AmbTrie",
          "module": "PureFP.Parsers.AmbTrie",
          "name": ":&:",
          "normalized": "[a](Map b(AmbTrie b a))",
          "package": "Encode",
          "signature": "[a](Map s(AmbTrie s a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-AmbTrie.html#v::-38-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.ExTrie",
          "name": "ExTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-ExTrie.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing",
          "hierarchy": "PureFP Parsers ExTrie",
          "module": "PureFP.Parsers.ExTrie",
          "name": "ExTrie",
          "package": "Encode",
          "partial": "Ex Trie",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-ExTrie.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.ExTrie",
          "name": "ExTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-ExTrie.html#ExTrie",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP Parsers ExTrie",
          "module": "PureFP.Parsers.ExTrie",
          "name": "ExTrie",
          "package": "Encode",
          "partial": "Ex Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-ExTrie.html#t:ExTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.PairTrie",
          "name": "PairTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-PairTrie.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing",
          "hierarchy": "PureFP Parsers PairTrie",
          "module": "PureFP.Parsers.PairTrie",
          "name": "PairTrie",
          "package": "Encode",
          "partial": "Pair Trie",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-PairTrie.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.PairTrie",
          "name": "PairTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-PairTrie.html#PairTrie",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP Parsers PairTrie",
          "module": "PureFP.Parsers.PairTrie",
          "name": "PairTrie",
          "package": "Encode",
          "partial": "Pair Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-PairTrie.html#t:PairTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.PairTrie",
          "name": "ParserTrie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-PairTrie.html#ParserTrie",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP Parsers PairTrie",
          "module": "PureFP.Parsers.PairTrie",
          "name": "ParserTrie",
          "package": "Encode",
          "partial": "Parser Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-PairTrie.html#t:ParserTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.Parser",
          "name": "Parser",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing",
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "Parser",
          "package": "Encode",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "InputSymbol",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html#InputSymbol",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "InputSymbol",
          "package": "Encode",
          "partial": "Input Symbol",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#t:InputSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "Lookahead",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html#Lookahead",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "Lookahead",
          "package": "Encode",
          "partial": "Lookahead",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#t:Lookahead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "Monoid",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html#Monoid",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "Monoid",
          "package": "Encode",
          "partial": "Monoid",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#t:Monoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "Parser",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html#Parser",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "Parser",
          "package": "Encode",
          "partial": "Parser",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "Sequence",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html#Sequence",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "Sequence",
          "package": "Encode",
          "partial": "Sequence",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#t:Sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "Symbol",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html#Symbol",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "Symbol",
          "package": "Encode",
          "partial": "Symbol",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#t:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "SymbolCont",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Parser.html#SymbolCont",
          "type": "class"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "SymbolCont",
          "package": "Encode",
          "partial": "Symbol Cont",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#t:SymbolCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "(*\u003e)",
          "package": "Encode",
          "signature": "m a -\u003e m b -\u003e m b",
          "source": "src/PureFP-Parsers-Parser.html#%2A%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "(*\u003e) *\u003e",
          "normalized": "a b-\u003ea c-\u003ea c",
          "package": "Encode",
          "signature": "m a-\u003em b-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:-42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "(\u003c*\u003e)",
          "package": "Encode",
          "signature": "m (a -\u003e b) -\u003e m a -\u003e m b",
          "source": "src/PureFP-Parsers-Parser.html#%3C%2A%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "(\u003c*\u003e) \u003c*\u003e",
          "normalized": "a(b-\u003ec)-\u003ea b-\u003ea c",
          "package": "Encode",
          "signature": "m(a-\u003eb)-\u003em a-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:-60--42--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "(\u003c+\u003e)",
          "package": "Encode",
          "signature": "m a -\u003e m a -\u003e m a",
          "source": "src/PureFP-Parsers-Parser.html#%3C%2B%3E",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "Encode",
          "signature": "m a-\u003em a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "(\u003c:\u003e)",
          "package": "Encode",
          "signature": "m a -\u003e m [a] -\u003e m [a]",
          "source": "src/PureFP-Parsers-Parser.html#%3C%3A%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "(\u003c:\u003e) \u003c:\u003e",
          "normalized": "a b-\u003ea[b]-\u003ea[b]",
          "package": "Encode",
          "signature": "m a-\u003em[a]-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:-60-:-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "anyof",
          "package": "Encode",
          "signature": "[m a] -\u003e m a",
          "source": "src/PureFP-Parsers-Parser.html#anyof",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "anyof",
          "normalized": "[a b]-\u003ea b",
          "package": "Encode",
          "signature": "[m a]-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:anyof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "lookahead",
          "package": "Encode",
          "signature": "([s] -\u003e m a) -\u003e m a",
          "source": "src/PureFP-Parsers-Parser.html#lookahead",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "lookahead",
          "normalized": "([a]-\u003eb c)-\u003eb c",
          "package": "Encode",
          "signature": "([s]-\u003em a)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:lookahead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "many",
          "package": "Encode",
          "signature": "m a -\u003e m [a]",
          "source": "src/PureFP-Parsers-Parser.html#many",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "many",
          "normalized": "a b-\u003ea[b]",
          "package": "Encode",
          "signature": "m a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "many0",
          "package": "Encode",
          "signature": "m a -\u003e m ()",
          "source": "src/PureFP-Parsers-Parser.html#many0",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "many0",
          "normalized": "a b-\u003ea()",
          "package": "Encode",
          "signature": "m a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:many0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "minSym",
          "package": "Encode",
          "signature": "s",
          "source": "src/PureFP-Parsers-Parser.html#minSym",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "minSym",
          "package": "Encode",
          "partial": "Sym",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:minSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "parse",
          "package": "Encode",
          "signature": "m a -\u003e [s] -\u003e [([s], a)]",
          "source": "src/PureFP-Parsers-Parser.html#parse",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "parse",
          "normalized": "a b-\u003e[c]-\u003e[([c],b)]",
          "package": "Encode",
          "signature": "m a-\u003e[s]-\u003e[([s],a)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "parseFull",
          "package": "Encode",
          "signature": "m a -\u003e [s] -\u003e [a]",
          "source": "src/PureFP-Parsers-Parser.html#parseFull",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "parseFull",
          "normalized": "a b-\u003e[c]-\u003e[b]",
          "package": "Encode",
          "partial": "Full",
          "signature": "m a-\u003e[s]-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:parseFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "sat",
          "package": "Encode",
          "signature": "(s -\u003e Bool) -\u003e m s",
          "source": "src/PureFP-Parsers-Parser.html#sat",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "sat",
          "normalized": "(a-\u003eBool)-\u003eb a",
          "package": "Encode",
          "signature": "(s-\u003eBool)-\u003em s",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:sat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "satCont",
          "package": "Encode",
          "signature": "(s -\u003e Bool) -\u003e (s -\u003e m a) -\u003e m a",
          "source": "src/PureFP-Parsers-Parser.html#satCont",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "satCont",
          "normalized": "(a-\u003eBool)-\u003e(a-\u003eb c)-\u003eb c",
          "package": "Encode",
          "partial": "Cont",
          "signature": "(s-\u003eBool)-\u003e(s-\u003em a)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:satCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "skip",
          "package": "Encode",
          "signature": "m s",
          "source": "src/PureFP-Parsers-Parser.html#skip",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "skip",
          "package": "Encode",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:skip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "success",
          "package": "Encode",
          "signature": "m ()",
          "source": "src/PureFP-Parsers-Parser.html#success",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "success",
          "normalized": "a()",
          "package": "Encode",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:success"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "sym",
          "package": "Encode",
          "signature": "s -\u003e m s",
          "source": "src/PureFP-Parsers-Parser.html#sym",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "sym",
          "normalized": "a-\u003eb a",
          "package": "Encode",
          "signature": "s-\u003em s",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "symbols",
          "package": "Encode",
          "signature": "[s]",
          "source": "src/PureFP-Parsers-Parser.html#symbols",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "symbols",
          "normalized": "[a]",
          "package": "Encode",
          "signature": "[s]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:symbols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "syms",
          "package": "Encode",
          "signature": "[s] -\u003e m [s]",
          "source": "src/PureFP-Parsers-Parser.html#syms",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "syms",
          "normalized": "[a]-\u003eb[a]",
          "package": "Encode",
          "signature": "[s]-\u003em[s]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:syms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "syms0",
          "package": "Encode",
          "signature": "[s] -\u003e m ()",
          "source": "src/PureFP-Parsers-Parser.html#syms0",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "syms0",
          "normalized": "[a]-\u003eb()",
          "package": "Encode",
          "signature": "[s]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:syms0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Parser",
          "name": "zero",
          "package": "Encode",
          "signature": "m a",
          "source": "src/PureFP-Parsers-Parser.html#zero",
          "type": "method"
        },
        "index": {
          "hierarchy": "PureFP Parsers Parser",
          "module": "PureFP.Parsers.Parser",
          "name": "zero",
          "package": "Encode",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Parser.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.Standard",
          "name": "Standard",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Standard.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing",
          "hierarchy": "PureFP Parsers Standard",
          "module": "PureFP.Parsers.Standard",
          "name": "Standard",
          "package": "Encode",
          "partial": "Standard",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Standard.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Standard",
          "name": "Standard",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Standard.html#Standard",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "PureFP Parsers Standard",
          "module": "PureFP.Parsers.Standard",
          "name": "Standard",
          "package": "Encode",
          "partial": "Standard",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Standard.html#t:Standard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Standard",
          "name": "Std",
          "package": "Encode",
          "signature": "Std ([s] -\u003e [([s], a)])",
          "source": "src/PureFP-Parsers-Standard.html#Standard",
          "type": "function"
        },
        "index": {
          "hierarchy": "PureFP Parsers Standard",
          "module": "PureFP.Parsers.Standard",
          "name": "Std",
          "normalized": "Std([a]-\u003e[([a],b)])",
          "package": "Encode",
          "partial": "Std",
          "signature": "Std([s]-\u003e[([s],a)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Standard.html#v:Std"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003eParsek\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.Stream",
          "name": "Stream",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Stream.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing Parsek",
          "hierarchy": "PureFP Parsers Stream",
          "module": "PureFP.Parsers.Stream",
          "name": "Stream",
          "package": "Encode",
          "partial": "Stream",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Stream.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Stream",
          "name": "Stream",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Stream.html#Stream",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP Parsers Stream",
          "module": "PureFP.Parsers.Stream",
          "name": "Stream",
          "package": "Encode",
          "partial": "Stream",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Stream.html#t:Stream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers.Trie",
          "name": "Trie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Trie.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing",
          "hierarchy": "PureFP Parsers Trie",
          "module": "PureFP.Parsers.Trie",
          "name": "Trie",
          "package": "Encode",
          "partial": "Trie",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Trie.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "PureFP.Parsers.Trie",
          "name": "Trie",
          "package": "Encode",
          "source": "src/PureFP-Parsers-Trie.html#Trie",
          "type": "data"
        },
        "index": {
          "hierarchy": "PureFP Parsers Trie",
          "module": "PureFP.Parsers.Trie",
          "name": "Trie",
          "package": "Encode",
          "partial": "Trie",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers-Trie.html#t:Trie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChapters 3 and 4 of \u003cem\u003ePure Functional Parsing &#150; an advanced tutorial\u003c/em\u003e\n by Peter Ljungl&#246;f\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eWith this limited distribution, you can create only some of the parsers\n described in the thesis. These include in particular:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eStandard\u003c/a\u003e\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ca\u003ePureFP.Parsers.Standard\u003c/a\u003e,\n      the standard parser, sec. 3.2\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ca\u003ePureFP.Parsers.Stream\u003c/a\u003e,\n      the stream processor parser, sec. 3.5.2\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eTrie\u003c/a\u003e\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ca\u003ePureFP.Parsers.Trie\u003c/a\u003e,\n      the trie parser, sec. 4.2.1\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eAmbTrie\u003c/a\u003e\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ca\u003ePureFP.Parsers.AmbTrie\u003c/a\u003e,\n      the ambiguous trie parser, sec. 4.2.2\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eExTrie\u003c/a\u003e\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ca\u003ePureFP.Parsers.ExTrie\u003c/a\u003e,\n      the extended trie parser, sec. 4.3.3\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003eAmbExTrie\u003c/a\u003e\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ca\u003ePureFP.Parsers.AmbExTrie\u003c/a\u003e,\n      the ambiguous extended trie parser, sec. 4.3.4\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003e\u003ca\u003ePairTrie\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eStandard\u003c/a\u003e\u003c/code\u003e \u003ccode\u003es\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e\n      \u003ca\u003ePureFP.Parsers.PairTrie\u003c/a\u003e, together with\n      \u003ca\u003ePureFP.Parsers.Standard\u003c/a\u003e,\n      the paired trie parser, sec. 4.4\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003e\u003ca\u003ePureFP.OrdMap\u003c/a\u003e \u003ca\u003ePureFP.Parsers.Parser\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP.Parsers",
          "name": "Parsers",
          "package": "Encode",
          "source": "src/PureFP-Parsers.html",
          "type": "module"
        },
        "index": {
          "description": "Chapters and of Pure Functional Parsing an advanced tutorial by Peter Ljungl http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software functional-parsing With this limited distribution you can create only some of the parsers described in the thesis These include in particular Standard PureFP.Parsers.Standard the standard parser sec Stream PureFP.Parsers.Stream the stream processor parser sec Trie PureFP.Parsers.Trie the trie parser sec AmbTrie PureFP.Parsers.AmbTrie the ambiguous trie parser sec ExTrie PureFP.Parsers.ExTrie the extended trie parser sec AmbExTrie PureFP.Parsers.AmbExTrie the ambiguous extended trie parser sec PairTrie Standard PureFP.Parsers.PairTrie together with PureFP.Parsers.Standard the paired trie parser sec PureFP.OrdMap PureFP.Parsers.Parser",
          "hierarchy": "PureFP Parsers",
          "module": "PureFP.Parsers",
          "name": "Parsers",
          "package": "Encode",
          "partial": "Parsers",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP-Parsers.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis library is an edited excerpt from the \u003cem\u003eFunctional Parsing\u003c/em\u003e library\n developed by Peter Ljungl&#246;f in his licenciate thesis /Pure Functional\n Parsing &#150; an advanced tutorial/, G&#246;teborg University and\n Chalmers University of Technology, April 2002:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/pubs/p02-lic-thesis.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.ling.gu.se/~peb/software/functional-parsing/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eCopyright (C) 2002  Peter Ljunglof  (C) 2005-2011  Otakar Smrz\n\u003c/p\u003e\u003cp\u003eThis program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\u003c/p\u003e\u003cp\u003eThis program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\u003c/p\u003e\u003cp\u003eYou should have received a copy of the GNU General Public License along\n   with this program; if not, write to the Free Software Foundation, Inc.,\n   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ePureFP.OrdMap\u003c/a\u003e \u003ca\u003ePureFP.OrdSet\u003c/a\u003e \u003ca\u003ePureFP.Parsers\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "PureFP",
          "name": "PureFP",
          "package": "Encode",
          "source": "src/PureFP.html",
          "type": "module"
        },
        "index": {
          "description": "This library is an edited excerpt from the Functional Parsing library developed by Peter Ljungl in his licenciate thesis Pure Functional Parsing an advanced tutorial teborg University and Chalmers University of Technology April http www.ling.gu.se peb pubs p02-lic-thesis.pdf http www.ling.gu.se peb software.html http www.ling.gu.se peb software functional-parsing Copyright Peter Ljunglof Otakar Smrz This program is free software you can redistribute it and or modify it under the terms of the GNU General Public License as published by the Free Software Foundation either version of the License or at your option any later version This program is distributed in the hope that it will be useful but WITHOUT ANY WARRANTY without even the implied warranty of MERCHANTABILITY or FITNESS FOR PARTICULAR PURPOSE See the GNU General Public License for more details You should have received copy of the GNU General Public License along with this program if not write to the Free Software Foundation Inc Franklin Street Fifth Floor Boston MA USA PureFP.OrdMap PureFP.OrdSet PureFP.Parsers",
          "hierarchy": "PureFP",
          "module": "PureFP",
          "name": "PureFP",
          "package": "Encode",
          "partial": "Pure FP",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/Encode/docs/PureFP.html#"
      }
    }
  ]
]