[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "LambdaHack"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic type classes for game actions.\n This module should not be imported anywhere except in \u003ccode\u003eAction\u003c/code\u003e\n and \u003ccode\u003eTypeAction\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "ActionClass",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html",
          "type": "module"
        },
        "index": {
          "description": "Basic type classes for game actions This module should not be imported anywhere except in Action and TypeAction",
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "ActionClass",
          "package": "LambdaHack",
          "partial": "Action Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnection method between a client and a frontend.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "ConnFrontend",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#ConnFrontend",
          "type": "data"
        },
        "index": {
          "description": "Connection method between client and frontend",
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "ConnFrontend",
          "package": "LambdaHack",
          "partial": "Conn Frontend",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#t:ConnFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClient",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClient",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClient",
          "package": "LambdaHack",
          "partial": "Monad Client",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#t:MonadClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClientReadServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientReadServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClientReadServer",
          "package": "LambdaHack",
          "partial": "Monad Client Read Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#t:MonadClientReadServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClientUI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientUI",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClientUI",
          "package": "LambdaHack",
          "partial": "Monad Client UI",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#t:MonadClientUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClientWriteServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientWriteServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "MonadClientWriteServer",
          "package": "LambdaHack",
          "partial": "Monad Client Write Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#t:MonadClientWriteServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe information that is constant across a client playing session,\n including many consecutive games in a single session,\n but is completely disregarded and reset when a new playing session starts.\n Auxiliary AI and computer player clients have no \u003ccode\u003esfs\u003c/code\u003e nor \u003ccode\u003esbinding\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "SessionUI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#SessionUI",
          "type": "data"
        },
        "index": {
          "description": "The information that is constant across client playing session including many consecutive games in single session but is completely disregarded and reset when new playing session starts Auxiliary AI and computer player clients have no sfs nor sbinding",
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "SessionUI",
          "package": "LambdaHack",
          "partial": "Session UI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#t:SessionUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Game.LambdaHack.Client.Action.ActionClass\",\"Game.LambdaHack.Client.Action\"]",
          "name": "ConnFrontend",
          "package": "LambdaHack",
          "signature": "ConnFrontend",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#ConnFrontend",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:ConnFrontend\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:ConnFrontend\"]"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "ConnFrontend",
          "package": "LambdaHack",
          "partial": "Conn Frontend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:ConnFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Game.LambdaHack.Client.Action.ActionClass\",\"Game.LambdaHack.Client.Action\"]",
          "name": "SessionUI",
          "package": "LambdaHack",
          "signature": "SessionUI",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#SessionUI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:SessionUI\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:SessionUI\"]"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "SessionUI",
          "package": "LambdaHack",
          "partial": "Session UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:SessionUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "getClient",
          "package": "LambdaHack",
          "signature": "m StateClient",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#getClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "getClient",
          "package": "LambdaHack",
          "partial": "Client",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:getClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "getsClient",
          "package": "LambdaHack",
          "signature": "(StateClient -\u003e a) -\u003e m a",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#getsClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "getsClient",
          "normalized": "(StateClient-\u003ea)-\u003eb a",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "(StateClient-\u003ea)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:getsClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "getsSession",
          "package": "LambdaHack",
          "signature": "(SessionUI -\u003e a) -\u003e m a",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#getsSession",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "getsSession",
          "normalized": "(SessionUI-\u003ea)-\u003eb a",
          "package": "LambdaHack",
          "partial": "Session",
          "signature": "(SessionUI-\u003ea)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:getsSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "liftIO",
          "package": "LambdaHack",
          "signature": "IO a -\u003e m a",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#liftIO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "liftIO",
          "normalized": "IO a-\u003eb a",
          "package": "LambdaHack",
          "partial": "IO",
          "signature": "IO a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:liftIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "modifyClient",
          "package": "LambdaHack",
          "signature": "(StateClient -\u003e StateClient) -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#modifyClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "modifyClient",
          "normalized": "(StateClient-\u003eStateClient)-\u003ea()",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "(StateClient-\u003eStateClient)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:modifyClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "putClient",
          "package": "LambdaHack",
          "signature": "StateClient -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#putClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "putClient",
          "normalized": "StateClient-\u003ea()",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "StateClient-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:putClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread a keystroke received from the frontend\n\u003c/p\u003e",
          "module": "[\"Game.LambdaHack.Client.Action.ActionClass\",\"Game.LambdaHack.Client.Action\"]",
          "name": "readConnFrontend",
          "package": "LambdaHack",
          "signature": "m KM",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#ConnFrontend",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:readConnFrontend\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:readConnFrontend\"]"
        },
        "index": {
          "description": "read keystroke received from the frontend",
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "readConnFrontend",
          "package": "LambdaHack",
          "partial": "Conn Frontend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:readConnFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "readServer",
          "package": "LambdaHack",
          "signature": "m c",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#readServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "readServer",
          "package": "LambdaHack",
          "partial": "Server",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:readServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "saveClient",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#saveClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "saveClient",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:saveClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "saveName",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e Bool -\u003e String",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#saveName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "saveName",
          "normalized": "FactionId-\u003eBool-\u003eString",
          "package": "LambdaHack",
          "partial": "Name",
          "signature": "FactionId-\u003eBool-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:saveName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebinding of keys to commands\n\u003c/p\u003e",
          "module": "[\"Game.LambdaHack.Client.Action.ActionClass\",\"Game.LambdaHack.Client.Action\"]",
          "name": "sbinding",
          "package": "LambdaHack",
          "signature": "Binding",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#SessionUI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:sbinding\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:sbinding\"]"
        },
        "index": {
          "description": "binding of keys to commands",
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "sbinding",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:sbinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econnection with the frontend\n\u003c/p\u003e",
          "module": "[\"Game.LambdaHack.Client.Action.ActionClass\",\"Game.LambdaHack.Client.Action\"]",
          "name": "sfconn",
          "package": "LambdaHack",
          "signature": "ConnFrontend",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#SessionUI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:sfconn\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:sfconn\"]"
        },
        "index": {
          "description": "connection with the frontend",
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "sfconn",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:sfconn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrite a UI request to the frontend\n\u003c/p\u003e",
          "module": "[\"Game.LambdaHack.Client.Action.ActionClass\",\"Game.LambdaHack.Client.Action\"]",
          "name": "writeConnFrontend",
          "package": "LambdaHack",
          "signature": "FrontReq -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#ConnFrontend",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:writeConnFrontend\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:writeConnFrontend\"]"
        },
        "index": {
          "description": "write UI request to the frontend",
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "writeConnFrontend",
          "normalized": "FrontReq-\u003ea()",
          "package": "LambdaHack",
          "partial": "Conn Frontend",
          "signature": "FrontReq-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:writeConnFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "writeServer",
          "package": "LambdaHack",
          "signature": "d -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#writeServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action ActionClass",
          "module": "Game.LambdaHack.Client.Action.ActionClass",
          "name": "writeServer",
          "normalized": "a-\u003eb()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "d-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionClass.html#v:writeServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe main game action monad type implementation. Just as any other\n component of the library, this implementation can be substituted.\n This module should not be imported anywhere except in \u003ccode\u003eAction\u003c/code\u003e\n to expose the executor to any code using the library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.Action.ActionType",
          "name": "ActionType",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionType.html",
          "type": "module"
        },
        "index": {
          "description": "The main game action monad type implementation Just as any other component of the library this implementation can be substituted This module should not be imported anywhere except in Action to expose the executor to any code using the library",
          "hierarchy": "Game LambdaHack Client Action ActionType",
          "module": "Game.LambdaHack.Client.Action.ActionType",
          "name": "ActionType",
          "package": "LambdaHack",
          "partial": "Action Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionType.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eServer state transformation monad.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action.ActionType",
          "name": "ActionCli",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionType.html#ActionCli",
          "type": "data"
        },
        "index": {
          "description": "Server state transformation monad",
          "hierarchy": "Game LambdaHack Client Action ActionType",
          "module": "Game.LambdaHack.Client.Action.ActionType",
          "name": "ActionCli",
          "package": "LambdaHack",
          "partial": "Action Cli",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionType.html#t:ActionCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInit the client, then run an action, with a given session,\n state and history, in the \u003ccode\u003eIO\u003c/code\u003e monad.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action.ActionType",
          "name": "executorCli",
          "package": "LambdaHack",
          "signature": "ActionCli c d () -\u003e SessionUI -\u003e State -\u003e StateClient -\u003e ChanServer c d -\u003e IO ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionType.html#executorCli",
          "type": "function"
        },
        "index": {
          "description": "Init the client then run an action with given session state and history in the IO monad",
          "hierarchy": "Game LambdaHack Client Action ActionType",
          "module": "Game.LambdaHack.Client.Action.ActionType",
          "name": "executorCli",
          "normalized": "ActionCli a b()-\u003eSessionUI-\u003eState-\u003eStateClient-\u003eChanServer a b-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Cli",
          "signature": "ActionCli c d()-\u003eSessionUI-\u003eState-\u003eStateClient-\u003eChanServer c d-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action-ActionType.html#v:executorCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGame action monads and basic building blocks for human and computer\n player actions. Has no access to the the main action type.\n Does not export the \u003ccode\u003eliftIO\u003c/code\u003e operation nor a few other implementation\n details.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "Action",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action.html",
          "type": "module"
        },
        "index": {
          "description": "Game action monads and basic building blocks for human and computer player actions Has no access to the the main action type Does not export the liftIO operation nor few other implementation details",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "Action",
          "package": "LambdaHack",
          "partial": "Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnection method between a client and a frontend.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "ConnFrontend",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#ConnFrontend",
          "type": "data"
        },
        "index": {
          "description": "Connection method between client and frontend",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "ConnFrontend",
          "package": "LambdaHack",
          "partial": "Conn Frontend",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#t:ConnFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClient",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClient",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClient",
          "package": "LambdaHack",
          "partial": "Monad Client",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#t:MonadClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClientReadServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientReadServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClientReadServer",
          "package": "LambdaHack",
          "partial": "Monad Client Read Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#t:MonadClientReadServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClientUI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientUI",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClientUI",
          "package": "LambdaHack",
          "partial": "Monad Client UI",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#t:MonadClientUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClientWriteServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientWriteServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "MonadClientWriteServer",
          "package": "LambdaHack",
          "partial": "Monad Client Write Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#t:MonadClientWriteServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe information that is constant across a client playing session,\n including many consecutive games in a single session,\n but is completely disregarded and reset when a new playing session starts.\n Auxiliary AI and computer player clients have no \u003ccode\u003esfs\u003c/code\u003e nor \u003ccode\u003esbinding\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "SessionUI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#SessionUI",
          "type": "data"
        },
        "index": {
          "description": "The information that is constant across client playing session including many consecutive games in single session but is completely disregarded and reset when new playing session starts Auxiliary AI and computer player clients have no sfs nor sbinding",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "SessionUI",
          "package": "LambdaHack",
          "partial": "Session UI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#t:SessionUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "accessCacheBfs",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Point -\u003e m (Maybe Int)",
          "source": "src/Game-LambdaHack-Client-Action.html#accessCacheBfs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "accessCacheBfs",
          "normalized": "ActorId-\u003ePoint-\u003ea(Maybe Int)",
          "package": "LambdaHack",
          "partial": "Cache Bfs",
          "signature": "ActorId-\u003ePoint-\u003em(Maybe Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:accessCacheBfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "actorAbilities",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Maybe ActorId -\u003e m [Ability]",
          "source": "src/Game-LambdaHack-Client-Action.html#actorAbilities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "actorAbilities",
          "normalized": "ActorId-\u003eMaybe ActorId-\u003ea[Ability]",
          "package": "LambdaHack",
          "partial": "Abilities",
          "signature": "ActorId-\u003eMaybe ActorId-\u003em[Ability]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:actorAbilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "actorAimsPos",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Point -\u003e m Bool",
          "source": "src/Game-LambdaHack-Client-Action.html#actorAimsPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "actorAimsPos",
          "normalized": "ActorId-\u003ePoint-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "Aims Pos",
          "signature": "ActorId-\u003ePoint-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:actorAimsPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether one is permitted to aim at a target\n (this is only checked for actors; positions let player\n shoot at obstacles, e.g., to destroy them).\n This assumes \u003ccode\u003eaidTgtToPos\u003c/code\u003e does not return \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: Perception is not enough for the check,\n because the target actor can be obscured by a glass wall\n or be out of sight range, but in weapon range.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "aidTgtAims",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e LevelId -\u003e Maybe Target -\u003e m (Maybe Text)",
          "source": "src/Game-LambdaHack-Client-Action.html#aidTgtAims",
          "type": "function"
        },
        "index": {
          "description": "Check whether one is permitted to aim at target this is only checked for actors positions let player shoot at obstacles e.g to destroy them This assumes aidTgtToPos does not return Nothing Note Perception is not enough for the check because the target actor can be obscured by glass wall or be out of sight range but in weapon range",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "aidTgtAims",
          "normalized": "ActorId-\u003eLevelId-\u003eMaybe Target-\u003ea(Maybe Text)",
          "package": "LambdaHack",
          "partial": "Tgt Aims",
          "signature": "ActorId-\u003eLevelId-\u003eMaybe Target-\u003em(Maybe Text)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:aidTgtAims"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the position of an actor's target.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "aidTgtToPos",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e LevelId -\u003e Maybe Target -\u003e m (Maybe Point)",
          "source": "src/Game-LambdaHack-Client-Action.html#aidTgtToPos",
          "type": "function"
        },
        "index": {
          "description": "Calculate the position of an actor target",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "aidTgtToPos",
          "normalized": "ActorId-\u003eLevelId-\u003eMaybe Target-\u003ea(Maybe Point)",
          "package": "LambdaHack",
          "partial": "Tgt To Pos",
          "signature": "ActorId-\u003eLevelId-\u003eMaybe Target-\u003em(Maybe Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:aidTgtToPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender animations on top of the current screen frame.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "animate",
          "package": "LambdaHack",
          "signature": "LevelId -\u003e Animation -\u003e m Frames",
          "source": "src/Game-LambdaHack-Client-Action.html#animate",
          "type": "function"
        },
        "index": {
          "description": "Render animations on top of the current screen frame",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "animate",
          "normalized": "LevelId-\u003eAnimation-\u003ea Frames",
          "package": "LambdaHack",
          "signature": "LevelId-\u003eAnimation-\u003em Frames",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:animate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the key binding.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "askBinding",
          "package": "LambdaHack",
          "signature": "m Binding",
          "source": "src/Game-LambdaHack-Client-Action.html#askBinding",
          "type": "function"
        },
        "index": {
          "description": "Get the key binding",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "askBinding",
          "package": "LambdaHack",
          "partial": "Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:askBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClosest (wrt paths) enemy actors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestFoes",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m [(Int, (ActorId, Actor))]",
          "source": "src/Game-LambdaHack-Client-Action.html#closestFoes",
          "type": "function"
        },
        "index": {
          "description": "Closest wrt paths enemy actors",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestFoes",
          "normalized": "ActorId-\u003ea[(Int,(ActorId,Actor))]",
          "package": "LambdaHack",
          "partial": "Foes",
          "signature": "ActorId-\u003em[(Int,(ActorId,Actor))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:closestFoes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClosest (wrt paths) items.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestItems",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m [(Int, (Point, ItemBag))]",
          "source": "src/Game-LambdaHack-Client-Action.html#closestItems",
          "type": "function"
        },
        "index": {
          "description": "Closest wrt paths items",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestItems",
          "normalized": "ActorId-\u003ea[(Int,(Point,ItemBag))]",
          "package": "LambdaHack",
          "partial": "Items",
          "signature": "ActorId-\u003em[(Int,(Point,ItemBag))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:closestItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinds smells closest to the actor, except under the actor.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestSmell",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m [(Int, (Point, SmellTime))]",
          "source": "src/Game-LambdaHack-Client-Action.html#closestSmell",
          "type": "function"
        },
        "index": {
          "description": "Finds smells closest to the actor except under the actor",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestSmell",
          "normalized": "ActorId-\u003ea[(Int,(Point,SmellTime))]",
          "package": "LambdaHack",
          "partial": "Smell",
          "signature": "ActorId-\u003em[(Int,(Point,SmellTime))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:closestSmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClosest (wrt paths) triggerable open tiles.\n The second argument can ever be true only if there's\n no escape from the dungeon.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestTriggers",
          "package": "LambdaHack",
          "signature": "Maybe Bool -\u003e Bool -\u003e ActorId -\u003e m [Point]",
          "source": "src/Game-LambdaHack-Client-Action.html#closestTriggers",
          "type": "function"
        },
        "index": {
          "description": "Closest wrt paths triggerable open tiles The second argument can ever be true only if there no escape from the dungeon",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestTriggers",
          "normalized": "Maybe Bool-\u003eBool-\u003eActorId-\u003ea[Point]",
          "package": "LambdaHack",
          "partial": "Triggers",
          "signature": "Maybe Bool-\u003eBool-\u003eActorId-\u003em[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:closestTriggers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClosest reachable unknown tile position, if any.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestUnknown",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m (Maybe Point)",
          "source": "src/Game-LambdaHack-Client-Action.html#closestUnknown",
          "type": "function"
        },
        "index": {
          "description": "Closest reachable unknown tile position if any",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "closestUnknown",
          "normalized": "ActorId-\u003ea(Maybe Point)",
          "package": "LambdaHack",
          "partial": "Unknown",
          "signature": "ActorId-\u003em(Maybe Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:closestUnknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "connFrontend",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e ChanFrontend -\u003e ConnFrontend",
          "source": "src/Game-LambdaHack-Client-Action.html#connFrontend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "connFrontend",
          "normalized": "FactionId-\u003eChanFrontend-\u003eConnFrontend",
          "package": "LambdaHack",
          "partial": "Frontend",
          "signature": "FactionId-\u003eChanFrontend-\u003eConnFrontend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:connFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "cursorToPos",
          "package": "LambdaHack",
          "signature": "m (Maybe Point)",
          "source": "src/Game-LambdaHack-Client-Action.html#cursorToPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "cursorToPos",
          "package": "LambdaHack",
          "partial": "To Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:cursorToPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "debugPrint",
          "package": "LambdaHack",
          "signature": "Text -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#debugPrint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "debugPrint",
          "normalized": "Text-\u003ea()",
          "package": "LambdaHack",
          "partial": "Print",
          "signature": "Text-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:debugPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint a prompt and an overlay and wait for a player keypress.\n If many overlays, scroll screenfuls with SPACE. Do not wrap screenfuls\n (in some menus \u003ccode\u003e?\u003c/code\u003e cycles views, so the user can restart from the top).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayChoiceUI",
          "package": "LambdaHack",
          "signature": "Msg -\u003e Overlay -\u003e [KM] -\u003e m (Either Slideshow KM)",
          "source": "src/Game-LambdaHack-Client-Action.html#displayChoiceUI",
          "type": "function"
        },
        "index": {
          "description": "Print prompt and an overlay and wait for player keypress If many overlays scroll screenfuls with SPACE Do not wrap screenfuls in some menus cycles views so the user can restart from the top",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayChoiceUI",
          "normalized": "Msg-\u003eOverlay-\u003e[KM]-\u003ea(Either Slideshow KM)",
          "package": "LambdaHack",
          "partial": "Choice UI",
          "signature": "Msg-\u003eOverlay-\u003e[KM]-\u003em(Either Slideshow KM)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:displayChoiceUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush frames or delays to the frame queue.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayFrames",
          "package": "LambdaHack",
          "signature": "Frames -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#displayFrames",
          "type": "function"
        },
        "index": {
          "description": "Push frames or delays to the frame queue",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayFrames",
          "normalized": "Frames-\u003ea()",
          "package": "LambdaHack",
          "partial": "Frames",
          "signature": "Frames-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:displayFrames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay a msg with a \u003ccode\u003emore\u003c/code\u003e prompt. Return value indicates if the player\n tried to cancel/escape.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayMore",
          "package": "LambdaHack",
          "signature": "ColorMode -\u003e Msg -\u003e m Bool",
          "source": "src/Game-LambdaHack-Client-Action.html#displayMore",
          "type": "function"
        },
        "index": {
          "description": "Display msg with more prompt Return value indicates if the player tried to cancel escape",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayMore",
          "normalized": "ColorMode-\u003eMsg-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "More",
          "signature": "ColorMode-\u003eMsg-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:displayMore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush the frame depicting the current level to the frame queue.\n Only one screenful of the report is shown, the rest is ignored.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayPush",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#displayPush",
          "type": "function"
        },
        "index": {
          "description": "Push the frame depicting the current level to the frame queue Only one screenful of the report is shown the rest is ignored",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayPush",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Push",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:displayPush"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint a yes/no question and return the player's answer. Use black\n and white colours to turn player's attention to the choice.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayYesNo",
          "package": "LambdaHack",
          "signature": "ColorMode -\u003e Msg -\u003e m Bool",
          "source": "src/Game-LambdaHack-Client-Action.html#displayYesNo",
          "type": "function"
        },
        "index": {
          "description": "Print yes no question and return the player answer Use black and white colours to turn player attention to the choice",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "displayYesNo",
          "normalized": "ColorMode-\u003eMsg-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "Yes No",
          "signature": "ColorMode-\u003eMsg-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:displayYesNo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw the current level with the overlay on top.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "drawOverlay",
          "package": "LambdaHack",
          "signature": "Bool -\u003e ColorMode -\u003e Overlay -\u003e m SingleFrame",
          "source": "src/Game-LambdaHack-Client-Action.html#drawOverlay",
          "type": "function"
        },
        "index": {
          "description": "Draw the current level with the overlay on top",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "drawOverlay",
          "normalized": "Bool-\u003eColorMode-\u003eOverlay-\u003ea SingleFrame",
          "package": "LambdaHack",
          "partial": "Overlay",
          "signature": "Bool-\u003eColorMode-\u003eOverlay-\u003em SingleFrame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:drawOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFurthest (wrt paths) known position, except under the actor.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "furthestKnown",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m (Maybe Point)",
          "source": "src/Game-LambdaHack-Client-Action.html#furthestKnown",
          "type": "function"
        },
        "index": {
          "description": "Furthest wrt paths known position except under the actor",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "furthestKnown",
          "normalized": "ActorId-\u003ea(Maybe Point)",
          "package": "LambdaHack",
          "partial": "Known",
          "signature": "ActorId-\u003em(Maybe Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:furthestKnown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "getArenaUI",
          "package": "LambdaHack",
          "signature": "m LevelId",
          "source": "src/Game-LambdaHack-Client-Action.html#getArenaUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getArenaUI",
          "package": "LambdaHack",
          "partial": "Arena UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getArenaUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "getCacheBfs",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m (Array BfsDistance)",
          "source": "src/Game-LambdaHack-Client-Action.html#getCacheBfs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getCacheBfs",
          "normalized": "ActorId-\u003ea(Array BfsDistance)",
          "package": "LambdaHack",
          "partial": "Cache Bfs",
          "signature": "ActorId-\u003em(Array BfsDistance)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getCacheBfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet cached BFS data and path or, if not stored, generate,\n store and return. Due to laziness, they are not calculated until needed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getCacheBfsAndPath",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Point -\u003e m (Array BfsDistance, Maybe [Point])",
          "source": "src/Game-LambdaHack-Client-Action.html#getCacheBfsAndPath",
          "type": "function"
        },
        "index": {
          "description": "Get cached BFS data and path or if not stored generate store and return Due to laziness they are not calculated until needed",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getCacheBfsAndPath",
          "normalized": "ActorId-\u003ePoint-\u003ea(Array BfsDistance,Maybe[Point])",
          "package": "LambdaHack",
          "partial": "Cache Bfs And Path",
          "signature": "ActorId-\u003ePoint-\u003em(Array BfsDistance,Maybe[Point])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getCacheBfsAndPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "getClient",
          "package": "LambdaHack",
          "signature": "m StateClient",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#getClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getClient",
          "package": "LambdaHack",
          "partial": "Client",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay a slideshow, awaiting confirmation for each slide except the last.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getInitConfirms",
          "package": "LambdaHack",
          "signature": "ColorMode -\u003e [KM] -\u003e Slideshow -\u003e m Bool",
          "source": "src/Game-LambdaHack-Client-Action.html#getInitConfirms",
          "type": "function"
        },
        "index": {
          "description": "Display slideshow awaiting confirmation for each slide except the last",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getInitConfirms",
          "normalized": "ColorMode-\u003e[KM]-\u003eSlideshow-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "Init Confirms",
          "signature": "ColorMode-\u003e[KM]-\u003eSlideshow-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getInitConfirms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay an overlay and wait for a human player command.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getKeyOverlayCommand",
          "package": "LambdaHack",
          "signature": "Bool -\u003e Overlay -\u003e m KM",
          "source": "src/Game-LambdaHack-Client-Action.html#getKeyOverlayCommand",
          "type": "function"
        },
        "index": {
          "description": "Display an overlay and wait for human player command",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getKeyOverlayCommand",
          "normalized": "Bool-\u003eOverlay-\u003ea KM",
          "package": "LambdaHack",
          "partial": "Key Overlay Command",
          "signature": "Bool-\u003eOverlay-\u003em KM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getKeyOverlayCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "getLeaderUI",
          "package": "LambdaHack",
          "signature": "m ActorId",
          "source": "src/Game-LambdaHack-Client-Action.html#getLeaderUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getLeaderUI",
          "package": "LambdaHack",
          "partial": "Leader UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getLeaderUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current perception of a client.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getPerFid",
          "package": "LambdaHack",
          "signature": "LevelId -\u003e m Perception",
          "source": "src/Game-LambdaHack-Client-Action.html#getPerFid",
          "type": "function"
        },
        "index": {
          "description": "Get the current perception of client",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getPerFid",
          "normalized": "LevelId-\u003ea Perception",
          "package": "LambdaHack",
          "partial": "Per Fid",
          "signature": "LevelId-\u003em Perception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getPerFid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "getsClient",
          "package": "LambdaHack",
          "signature": "(StateClient -\u003e a) -\u003e m a",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#getsClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "getsClient",
          "normalized": "(StateClient-\u003ea)-\u003eb a",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "(StateClient-\u003ea)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:getsClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "leaderTgtAims",
          "package": "LambdaHack",
          "signature": "m (Maybe Text)",
          "source": "src/Game-LambdaHack-Client-Action.html#leaderTgtAims",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "leaderTgtAims",
          "package": "LambdaHack",
          "partial": "Tgt Aims",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:leaderTgtAims"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "leaderTgtToPos",
          "package": "LambdaHack",
          "signature": "m (Maybe Point)",
          "source": "src/Game-LambdaHack-Client-Action.html#leaderTgtToPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "leaderTgtToPos",
          "package": "LambdaHack",
          "partial": "Tgt To Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:leaderTgtToPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead and parse UI config file.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "mkConfigUI",
          "package": "LambdaHack",
          "signature": "Ops RuleKind -\u003e IO ConfigUI",
          "source": "src/Game-LambdaHack-Client-Action.html#mkConfigUI",
          "type": "function"
        },
        "index": {
          "description": "Read and parse UI config file",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "mkConfigUI",
          "normalized": "Ops RuleKind-\u003eIO ConfigUI",
          "package": "LambdaHack",
          "partial": "Config UI",
          "signature": "Ops RuleKind-\u003eIO ConfigUI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:mkConfigUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "modifyClient",
          "package": "LambdaHack",
          "signature": "(StateClient -\u003e StateClient) -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#modifyClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "modifyClient",
          "normalized": "(StateClient-\u003eStateClient)-\u003ea()",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "(StateClient-\u003eStateClient)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:modifyClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a message to the current report.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "msgAdd",
          "package": "LambdaHack",
          "signature": "Msg -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#msgAdd",
          "type": "function"
        },
        "index": {
          "description": "Add message to the current report",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "msgAdd",
          "normalized": "Msg-\u003ea()",
          "package": "LambdaHack",
          "partial": "Add",
          "signature": "Msg-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:msgAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWipe out and set a new value for the current report.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "msgReset",
          "package": "LambdaHack",
          "signature": "Msg -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#msgReset",
          "type": "function"
        },
        "index": {
          "description": "Wipe out and set new value for the current report",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "msgReset",
          "normalized": "Msg-\u003ea()",
          "package": "LambdaHack",
          "partial": "Reset",
          "signature": "Msg-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:msgReset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "overlayToBlankSlideshow",
          "package": "LambdaHack",
          "signature": "Msg -\u003e Overlay -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-Action.html#overlayToBlankSlideshow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "overlayToBlankSlideshow",
          "normalized": "Msg-\u003eOverlay-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "To Blank Slideshow",
          "signature": "Msg-\u003eOverlay-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:overlayToBlankSlideshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe prompt is shown after the current message at the top of each slide.\n Together they may take more than one line. The prompt is not added\n to history. The portions of overlay that fit on the the rest\n of the screen are displayed below. As many slides as needed are shown.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "overlayToSlideshow",
          "package": "LambdaHack",
          "signature": "Msg -\u003e Overlay -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-Action.html#overlayToSlideshow",
          "type": "function"
        },
        "index": {
          "description": "The prompt is shown after the current message at the top of each slide Together they may take more than one line The prompt is not added to history The portions of overlay that fit on the the rest of the screen are displayed below As many slides as needed are shown",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "overlayToSlideshow",
          "normalized": "Msg-\u003eOverlay-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "To Slideshow",
          "signature": "Msg-\u003eOverlay-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:overlayToSlideshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe part of speech describing the actor or a special name if a leader\n of the observer's faction. The actor may not be present in the dungeon.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "partActorLeader",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Actor -\u003e m Part",
          "source": "src/Game-LambdaHack-Client-Action.html#partActorLeader",
          "type": "function"
        },
        "index": {
          "description": "The part of speech describing the actor or special name if leader of the observer faction The actor may not be present in the dungeon",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "partActorLeader",
          "normalized": "ActorId-\u003eActor-\u003ea Part",
          "package": "LambdaHack",
          "partial": "Actor Leader",
          "signature": "ActorId-\u003eActor-\u003em Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:partActorLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe part of speech describing the actor (designated by actor id\n and present in the dungeon) or a special name if a leader\n of the observer's faction.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "partAidLeader",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m Part",
          "source": "src/Game-LambdaHack-Client-Action.html#partAidLeader",
          "type": "function"
        },
        "index": {
          "description": "The part of speech describing the actor designated by actor id and present in the dungeon or special name if leader of the observer faction",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "partAidLeader",
          "normalized": "ActorId-\u003ea Part",
          "package": "LambdaHack",
          "partial": "Aid Leader",
          "signature": "ActorId-\u003em Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:partAidLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe prompt is shown after the current message, but not added to history.\n This is useful, e.g., in targeting mode, not to spam history.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "promptToSlideshow",
          "package": "LambdaHack",
          "signature": "Msg -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-Action.html#promptToSlideshow",
          "type": "function"
        },
        "index": {
          "description": "The prompt is shown after the current message but not added to history This is useful e.g in targeting mode not to spam history",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "promptToSlideshow",
          "normalized": "Msg-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "To Slideshow",
          "signature": "Msg-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:promptToSlideshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "putClient",
          "package": "LambdaHack",
          "signature": "StateClient -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#putClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "putClient",
          "normalized": "StateClient-\u003ea()",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "StateClient-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:putClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "readServer",
          "package": "LambdaHack",
          "signature": "m c",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#readServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "readServer",
          "package": "LambdaHack",
          "partial": "Server",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:readServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStore current report in the history and reset report.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "recordHistory",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#recordHistory",
          "type": "function"
        },
        "index": {
          "description": "Store current report in the history and reset report",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "recordHistory",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "History",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:recordHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssuming the client runs on the same machine and for the same\n user as the server, move the server savegame out of the way.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "removeServerSave",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#removeServerSave",
          "type": "function"
        },
        "index": {
          "description": "Assuming the client runs on the same machine and for the same user as the server move the server savegame out of the way",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "removeServerSave",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Server Save",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:removeServerSave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "restoreGame",
          "package": "LambdaHack",
          "signature": "m (Maybe (State, StateClient))",
          "source": "src/Game-LambdaHack-Client-Action.html#restoreGame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "restoreGame",
          "normalized": "a(Maybe(State,StateClient))",
          "package": "LambdaHack",
          "partial": "Game",
          "signature": "m(Maybe(State,StateClient))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:restoreGame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvoke pseudo-random computation with the generator kept in the state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Action",
          "name": "rndToAction",
          "package": "LambdaHack",
          "signature": "Rnd a -\u003e m a",
          "source": "src/Game-LambdaHack-Client-Action.html#rndToAction",
          "type": "function"
        },
        "index": {
          "description": "Invoke pseudo-random computation with the generator kept in the state",
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "rndToAction",
          "normalized": "Rnd a-\u003eb a",
          "package": "LambdaHack",
          "partial": "To Action",
          "signature": "Rnd a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:rndToAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "saveClient",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#saveClient",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "saveClient",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Client",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:saveClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "scoreToSlideshow",
          "package": "LambdaHack",
          "signature": "Int -\u003e Status -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-Action.html#scoreToSlideshow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "scoreToSlideshow",
          "normalized": "Int-\u003eStatus-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "To Slideshow",
          "signature": "Int-\u003eStatus-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:scoreToSlideshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "stopPlayBack",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#stopPlayBack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "stopPlayBack",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Play Back",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:stopPlayBack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "stopRunning",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-Action.html#stopRunning",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "stopRunning",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Running",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:stopRunning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "targetDescLeader",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m Text",
          "source": "src/Game-LambdaHack-Client-Action.html#targetDescLeader",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "targetDescLeader",
          "normalized": "ActorId-\u003ea Text",
          "package": "LambdaHack",
          "partial": "Desc Leader",
          "signature": "ActorId-\u003em Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:targetDescLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "unexploredDepth",
          "package": "LambdaHack",
          "signature": "m (Int -\u003e LevelId -\u003e Bool)",
          "source": "src/Game-LambdaHack-Client-Action.html#unexploredDepth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "unexploredDepth",
          "normalized": "a(Int-\u003eLevelId-\u003eBool)",
          "package": "LambdaHack",
          "partial": "Depth",
          "signature": "m(Int-\u003eLevelId-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:unexploredDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "viewedLevel",
          "package": "LambdaHack",
          "signature": "m LevelId",
          "source": "src/Game-LambdaHack-Client-Action.html#viewedLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "viewedLevel",
          "package": "LambdaHack",
          "partial": "Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:viewedLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Action",
          "name": "writeServer",
          "package": "LambdaHack",
          "signature": "d -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#writeServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Action",
          "module": "Game.LambdaHack.Client.Action",
          "name": "writeServer",
          "normalized": "a-\u003eb()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "d-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Action.html#v:writeServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of client UI response to atomic commands.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "AtomicSemCli",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-AtomicSemCli.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of client UI response to atomic commands See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Client AtomicSemCli",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "AtomicSemCli",
          "package": "LambdaHack",
          "partial": "Atomic Sem Cli",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-AtomicSemCli.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClients keep a subset of atomic commands sent by the server\n and add some of their own. The result of this function is the list\n of commands kept for each command received.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "cmdAtomicFilterCli",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e m [CmdAtomic]",
          "source": "src/Game-LambdaHack-Client-AtomicSemCli.html#cmdAtomicFilterCli",
          "type": "function"
        },
        "index": {
          "description": "Clients keep subset of atomic commands sent by the server and add some of their own The result of this function is the list of commands kept for each command received",
          "hierarchy": "Game LambdaHack Client AtomicSemCli",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "cmdAtomicFilterCli",
          "normalized": "CmdAtomic-\u003ea[CmdAtomic]",
          "package": "LambdaHack",
          "partial": "Atomic Filter Cli",
          "signature": "CmdAtomic-\u003em[CmdAtomic]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-AtomicSemCli.html#v:cmdAtomicFilterCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Game.LambdaHack.Client.AtomicSemCli\",\"Game.LambdaHack.Common.AtomicSem\"]",
          "name": "cmdAtomicSem",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-AtomicSem.html#cmdAtomicSem",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-AtomicSemCli.html#v:cmdAtomicSem\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicSem.html#v:cmdAtomicSem\"]"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client AtomicSemCli",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "cmdAtomicSem",
          "normalized": "CmdAtomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Atomic Sem",
          "signature": "CmdAtomic-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-AtomicSemCli.html#v:cmdAtomicSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEffect of atomic actions on client state is calculated\n in the global state before the command is executed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "cmdAtomicSemCli",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-AtomicSemCli.html#cmdAtomicSemCli",
          "type": "function"
        },
        "index": {
          "description": "Effect of atomic actions on client state is calculated in the global state before the command is executed",
          "hierarchy": "Game LambdaHack Client AtomicSemCli",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "cmdAtomicSemCli",
          "normalized": "CmdAtomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Atomic Sem Cli",
          "signature": "CmdAtomic-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-AtomicSemCli.html#v:cmdAtomicSemCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVisualization of atomic actions for the client is perfomed\n in the global state after the command is executed and after\n the client state is modified by the command.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "drawCmdAtomicUI",
          "package": "LambdaHack",
          "signature": "Bool -\u003e CmdAtomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-AtomicSemCli.html#drawCmdAtomicUI",
          "type": "function"
        },
        "index": {
          "description": "Visualization of atomic actions for the client is perfomed in the global state after the command is executed and after the client state is modified by the command",
          "hierarchy": "Game LambdaHack Client AtomicSemCli",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "drawCmdAtomicUI",
          "normalized": "Bool-\u003eCmdAtomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Cmd Atomic UI",
          "signature": "Bool-\u003eCmdAtomic-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-AtomicSemCli.html#v:drawCmdAtomicUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "drawSfxAtomicUI",
          "package": "LambdaHack",
          "signature": "Bool -\u003e SfxAtomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-AtomicSemCli.html#drawSfxAtomicUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client AtomicSemCli",
          "module": "Game.LambdaHack.Client.AtomicSemCli",
          "name": "drawSfxAtomicUI",
          "normalized": "Bool-\u003eSfxAtomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Sfx Atomic UI",
          "signature": "Bool-\u003eSfxAtomic-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-AtomicSemCli.html#v:drawSfxAtomicUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBinding of keys to commands.\n No operation in this module involves the \u003ccode\u003eState\u003c/code\u003e or \u003ccode\u003eAction\u003c/code\u003e type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "Binding",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Binding.html",
          "type": "module"
        },
        "index": {
          "description": "Binding of keys to commands No operation in this module involves the State or Action type",
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "Binding",
          "package": "LambdaHack",
          "partial": "Binding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBindings and other information about human player commands.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "Binding",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Binding.html#Binding",
          "type": "data"
        },
        "index": {
          "description": "Bindings and other information about human player commands",
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "Binding",
          "package": "LambdaHack",
          "partial": "Binding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#t:Binding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Binding",
          "name": "Binding",
          "package": "LambdaHack",
          "signature": "Binding",
          "source": "src/Game-LambdaHack-Client-Binding.html#Binding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "Binding",
          "package": "LambdaHack",
          "partial": "Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#v:Binding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe properly ordered list\n   of commands for the help menu\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "bcmdList",
          "package": "LambdaHack",
          "signature": "[(KM, (Text, CmdCategory, HumanCmd))]",
          "source": "src/Game-LambdaHack-Client-Binding.html#Binding",
          "type": "function"
        },
        "index": {
          "description": "the properly ordered list of commands for the help menu",
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "bcmdList",
          "normalized": "[(KM,(Text,CmdCategory,HumanCmd))]",
          "package": "LambdaHack",
          "partial": "List",
          "signature": "[(KM,(Text,CmdCategory,HumanCmd))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#v:bcmdList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebinding of keys to commands\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "bcmdMap",
          "package": "LambdaHack",
          "signature": "(Map KM (Text, CmdCategory, HumanCmd))",
          "source": "src/Game-LambdaHack-Client-Binding.html#Binding",
          "type": "function"
        },
        "index": {
          "description": "binding of keys to commands",
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "bcmdMap",
          "normalized": "(Map KM(Text,CmdCategory,HumanCmd))",
          "package": "LambdaHack",
          "partial": "Map",
          "signature": "(Map KM(Text,CmdCategory,HumanCmd))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#v:bcmdMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eand from commands to their keys\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "brevMap",
          "package": "LambdaHack",
          "signature": "(Map HumanCmd KM)",
          "source": "src/Game-LambdaHack-Client-Binding.html#Binding",
          "type": "function"
        },
        "index": {
          "description": "and from commands to their keys",
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "brevMap",
          "package": "LambdaHack",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#v:brevMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduce a set of help screens from the key bindings.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "keyHelp",
          "package": "LambdaHack",
          "signature": "Binding -\u003e Slideshow",
          "source": "src/Game-LambdaHack-Client-Binding.html#keyHelp",
          "type": "function"
        },
        "index": {
          "description": "Produce set of help screens from the key bindings",
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "keyHelp",
          "normalized": "Binding-\u003eSlideshow",
          "package": "LambdaHack",
          "partial": "Help",
          "signature": "Binding-\u003eSlideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#v:keyHelp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinding of keys to movement and other standard commands,\n as well as commands defined in the config file.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "stdBinding",
          "package": "LambdaHack",
          "signature": "Ops RuleKind-\u003e ConfigUI-\u003e Binding",
          "type": "function"
        },
        "index": {
          "description": "Binding of keys to movement and other standard commands as well as commands defined in the config file",
          "hierarchy": "Game LambdaHack Client Binding",
          "module": "Game.LambdaHack.Client.Binding",
          "name": "stdBinding",
          "normalized": "Ops RuleKind-\u003eConfigUI-\u003eBinding",
          "package": "LambdaHack",
          "partial": "Binding",
          "signature": "Ops RuleKind-\u003eConfigUI-\u003eBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Binding.html#v:stdBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of most \u003ccode\u003eCmdClientAI\u003c/code\u003e client commands.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "ClientSem",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-ClientSem.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of most CmdClientAI client commands",
          "hierarchy": "Game LambdaHack Client ClientSem",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "ClientSem",
          "package": "LambdaHack",
          "partial": "Client Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-ClientSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine and process the next human player command. The argument is\n the last stop message due to running, if any.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "humanCommand",
          "package": "LambdaHack",
          "signature": "Maybe Msg -\u003e m CmdSer",
          "source": "src/Game-LambdaHack-Client-ClientSem.html#humanCommand",
          "type": "function"
        },
        "index": {
          "description": "Determine and process the next human player command The argument is the last stop message due to running if any",
          "hierarchy": "Game LambdaHack Client ClientSem",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "humanCommand",
          "normalized": "Maybe Msg-\u003ea CmdSer",
          "package": "LambdaHack",
          "partial": "Command",
          "signature": "Maybe Msg-\u003em CmdSer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-ClientSem.html#v:humanCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "queryAI",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m CmdTakeTimeSer",
          "source": "src/Game-LambdaHack-Client-ClientSem.html#queryAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client ClientSem",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "queryAI",
          "normalized": "ActorId-\u003ea CmdTakeTimeSer",
          "package": "LambdaHack",
          "partial": "AI",
          "signature": "ActorId-\u003em CmdTakeTimeSer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-ClientSem.html#v:queryAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "queryAIPick",
          "package": "LambdaHack",
          "signature": "(ActorId, Actor) -\u003e m CmdTakeTimeSer",
          "source": "src/Game-LambdaHack-Client-ClientSem.html#queryAIPick",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client ClientSem",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "queryAIPick",
          "normalized": "(ActorId,Actor)-\u003ea CmdTakeTimeSer",
          "package": "LambdaHack",
          "partial": "AIPick",
          "signature": "(ActorId,Actor)-\u003em CmdTakeTimeSer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-ClientSem.html#v:queryAIPick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandle the move of a UI player.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "queryUI",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m CmdSer",
          "source": "src/Game-LambdaHack-Client-ClientSem.html#queryUI",
          "type": "function"
        },
        "index": {
          "description": "Handle the move of UI player",
          "hierarchy": "Game LambdaHack Client ClientSem",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "queryUI",
          "normalized": "ActorId-\u003ea CmdSer",
          "package": "LambdaHack",
          "partial": "UI",
          "signature": "ActorId-\u003em CmdSer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-ClientSem.html#v:queryUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "refreshTarget",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e (ActorId, Actor) -\u003e m (Maybe ((ActorId, Actor), (Target, PathEtc)))",
          "source": "src/Game-LambdaHack-Client-ClientSem.html#refreshTarget",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client ClientSem",
          "module": "Game.LambdaHack.Client.ClientSem",
          "name": "refreshTarget",
          "normalized": "ActorId-\u003e(ActorId,Actor)-\u003ea(Maybe((ActorId,Actor),(Target,PathEtc)))",
          "package": "LambdaHack",
          "partial": "Target",
          "signature": "ActorId-\u003e(ActorId,Actor)-\u003em(Maybe((ActorId,Actor),(Target,PathEtc)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-ClientSem.html#v:refreshTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePersonal game configuration file type definitions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.Config",
          "name": "Config",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Config.html",
          "type": "module"
        },
        "index": {
          "description": "Personal game configuration file type definitions",
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "Config",
          "package": "LambdaHack",
          "partial": "Config",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFully typed contents of the UI config file. This config\n is a part of a game client.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Config",
          "name": "ConfigUI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "data"
        },
        "index": {
          "description": "Fully typed contents of the UI config file This config is part of game client",
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "ConfigUI",
          "package": "LambdaHack",
          "partial": "Config UI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#t:ConfigUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "ConfigUI",
          "package": "LambdaHack",
          "signature": "ConfigUI",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "ConfigUI",
          "package": "LambdaHack",
          "partial": "Config UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:ConfigUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "configCommands",
          "package": "LambdaHack",
          "signature": "[(KM, (CmdCategory, HumanCmd))]",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "configCommands",
          "normalized": "[(KM,(CmdCategory,HumanCmd))]",
          "package": "LambdaHack",
          "partial": "Commands",
          "signature": "[(KM,(CmdCategory,HumanCmd))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:configCommands"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "configFont",
          "package": "LambdaHack",
          "signature": "String",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "configFont",
          "package": "LambdaHack",
          "partial": "Font",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:configFont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "configHeroNames",
          "package": "LambdaHack",
          "signature": "[(Int, Text)]",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "configHeroNames",
          "normalized": "[(Int,Text)]",
          "package": "LambdaHack",
          "partial": "Hero Names",
          "signature": "[(Int,Text)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:configHeroNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "configHistoryMax",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "configHistoryMax",
          "package": "LambdaHack",
          "partial": "History Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:configHistoryMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "configMaxFps",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "configMaxFps",
          "package": "LambdaHack",
          "partial": "Max Fps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:configMaxFps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "configNoAnim",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "configNoAnim",
          "package": "LambdaHack",
          "partial": "No Anim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:configNoAnim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Config",
          "name": "configRunStopMsgs",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Client-Config.html#ConfigUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Config",
          "module": "Game.LambdaHack.Client.Config",
          "name": "configRunStopMsgs",
          "package": "LambdaHack",
          "partial": "Run Stop Msgs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Config.html#v:configRunStopMsgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDisplay game data on the screen using one of the available frontends\n (determined at compile time with cabal flags).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "Draw",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Draw.html",
          "type": "module"
        },
        "index": {
          "description": "Display game data on the screen using one of the available frontends determined at compile time with cabal flags",
          "hierarchy": "Game LambdaHack Client Draw",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "Draw",
          "package": "LambdaHack",
          "partial": "Draw",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Draw.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eColor mode for the display.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "ColorMode",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Draw.html#ColorMode",
          "type": "data"
        },
        "index": {
          "description": "Color mode for the display",
          "hierarchy": "Game LambdaHack Client Draw",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "ColorMode",
          "package": "LambdaHack",
          "partial": "Color Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Draw.html#t:ColorMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblack+white only\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "ColorBW",
          "package": "LambdaHack",
          "signature": "ColorBW",
          "source": "src/Game-LambdaHack-Client-Draw.html#ColorMode",
          "type": "function"
        },
        "index": {
          "description": "black white only",
          "hierarchy": "Game LambdaHack Client Draw",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "ColorBW",
          "package": "LambdaHack",
          "partial": "Color BW",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Draw.html#v:ColorBW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormal, with full colours\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "ColorFull",
          "package": "LambdaHack",
          "signature": "ColorFull",
          "source": "src/Game-LambdaHack-Client-Draw.html#ColorMode",
          "type": "function"
        },
        "index": {
          "description": "normal with full colours",
          "hierarchy": "Game LambdaHack Client Draw",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "ColorFull",
          "package": "LambdaHack",
          "partial": "Color Full",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Draw.html#v:ColorFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraw the whole screen: level map and status area.\n Pass at most a single page if overlay of text unchanged\n to the frontends to display separately or overlay over map,\n depending on the frontend.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "draw",
          "package": "LambdaHack",
          "signature": "Bool -\u003e ColorMode -\u003e COps -\u003e Perception -\u003e LevelId -\u003e Maybe ActorId -\u003e Maybe Point -\u003e Maybe Point -\u003e Maybe (Array BfsDistance, Maybe [Point]) -\u003e StateClient -\u003e State -\u003e Text -\u003e Text -\u003e Overlay -\u003e SingleFrame",
          "source": "src/Game-LambdaHack-Client-Draw.html#draw",
          "type": "function"
        },
        "index": {
          "description": "Draw the whole screen level map and status area Pass at most single page if overlay of text unchanged to the frontends to display separately or overlay over map depending on the frontend",
          "hierarchy": "Game LambdaHack Client Draw",
          "module": "Game.LambdaHack.Client.Draw",
          "name": "draw",
          "normalized": "Bool-\u003eColorMode-\u003eCOps-\u003ePerception-\u003eLevelId-\u003eMaybe ActorId-\u003eMaybe Point-\u003eMaybe Point-\u003eMaybe(Array BfsDistance,Maybe[Point])-\u003eStateClient-\u003eState-\u003eText-\u003eText-\u003eOverlay-\u003eSingleFrame",
          "package": "LambdaHack",
          "signature": "Bool-\u003eColorMode-\u003eCOps-\u003ePerception-\u003eLevelId-\u003eMaybe ActorId-\u003eMaybe Point-\u003eMaybe Point-\u003eMaybe(Array BfsDistance,Maybe[Point])-\u003eStateClient-\u003eState-\u003eText-\u003eText-\u003eOverlay-\u003eSingleFrame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Draw.html#v:draw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of \u003ccode\u003e\u003ca\u003eCmd\u003c/a\u003e\u003c/code\u003e client commands that return server commands.\n A couple of them do not take time, the rest does.\n TODO: document\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "HumanGlobal",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of Cmd client commands that return server commands couple of them do not take time the rest does TODO document",
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "HumanGlobal",
          "package": "LambdaHack",
          "partial": "Human Global",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "SlideOrCmd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#SlideOrCmd",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "SlideOrCmd",
          "package": "LambdaHack",
          "partial": "Slide Or Cmd",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#t:SlideOrCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAsk for a direction and alter a tile, if possible.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "alterDirHuman",
          "package": "LambdaHack",
          "signature": "[Trigger] -\u003e m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#alterDirHuman",
          "type": "function"
        },
        "index": {
          "description": "Ask for direction and alter tile if possible",
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "alterDirHuman",
          "normalized": "[Trigger]-\u003ea(SlideOrCmd CmdTakeTimeSer)",
          "package": "LambdaHack",
          "partial": "Dir Human",
          "signature": "[Trigger]-\u003em(SlideOrCmd CmdTakeTimeSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:alterDirHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "applyHuman",
          "package": "LambdaHack",
          "signature": "[Trigger] -\u003e m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#applyHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "applyHuman",
          "normalized": "[Trigger]-\u003ea(SlideOrCmd CmdTakeTimeSer)",
          "package": "LambdaHack",
          "partial": "Human",
          "signature": "[Trigger]-\u003em(SlideOrCmd CmdTakeTimeSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:applyHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDrop a single item.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "dropHuman",
          "package": "LambdaHack",
          "signature": "m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#dropHuman",
          "type": "function"
        },
        "index": {
          "description": "Drop single item",
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "dropHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:dropHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "failWith",
          "package": "LambdaHack",
          "signature": "Msg -\u003e m (SlideOrCmd a)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#failWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "failWith",
          "normalized": "Msg-\u003ea(SlideOrCmd b)",
          "package": "LambdaHack",
          "partial": "With",
          "signature": "Msg-\u003em(SlideOrCmd a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:failWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "gameExitHuman",
          "package": "LambdaHack",
          "signature": "m (SlideOrCmd CmdSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#gameExitHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "gameExitHuman",
          "package": "LambdaHack",
          "partial": "Exit Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:gameExitHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "gameRestartHuman",
          "package": "LambdaHack",
          "signature": "Text -\u003e m (SlideOrCmd CmdSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#gameRestartHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "gameRestartHuman",
          "normalized": "Text-\u003ea(SlideOrCmd CmdSer)",
          "package": "LambdaHack",
          "partial": "Restart Human",
          "signature": "Text-\u003em(SlideOrCmd CmdSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:gameRestartHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "gameSaveHuman",
          "package": "LambdaHack",
          "signature": "m CmdSer",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#gameSaveHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "gameSaveHuman",
          "package": "LambdaHack",
          "partial": "Save Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:gameSaveHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "moveRunHuman",
          "package": "LambdaHack",
          "signature": "Bool -\u003e Vector -\u003e m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#moveRunHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "moveRunHuman",
          "normalized": "Bool-\u003eVector-\u003ea(SlideOrCmd CmdTakeTimeSer)",
          "package": "LambdaHack",
          "partial": "Run Human",
          "signature": "Bool-\u003eVector-\u003em(SlideOrCmd CmdTakeTimeSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:moveRunHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "pickupHuman",
          "package": "LambdaHack",
          "signature": "m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#pickupHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "pickupHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:pickupHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "projectHuman",
          "package": "LambdaHack",
          "signature": "[Trigger] -\u003e m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#projectHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "projectHuman",
          "normalized": "[Trigger]-\u003ea(SlideOrCmd CmdTakeTimeSer)",
          "package": "LambdaHack",
          "partial": "Human",
          "signature": "[Trigger]-\u003em(SlideOrCmd CmdTakeTimeSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:projectHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "resendHuman",
          "package": "LambdaHack",
          "signature": "m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#resendHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "resendHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:resendHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "stepToTargetHuman",
          "package": "LambdaHack",
          "signature": "m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#stepToTargetHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "stepToTargetHuman",
          "package": "LambdaHack",
          "partial": "To Target Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:stepToTargetHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeader tries to trigger the tile he's standing on.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "triggerTileHuman",
          "package": "LambdaHack",
          "signature": "[Trigger] -\u003e m (SlideOrCmd CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#triggerTileHuman",
          "type": "function"
        },
        "index": {
          "description": "Leader tries to trigger the tile he standing on",
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "triggerTileHuman",
          "normalized": "[Trigger]-\u003ea(SlideOrCmd CmdTakeTimeSer)",
          "package": "LambdaHack",
          "partial": "Tile Human",
          "signature": "[Trigger]-\u003em(SlideOrCmd CmdTakeTimeSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:triggerTileHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeader waits a turn (and blocks, etc.).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "waitHuman",
          "package": "LambdaHack",
          "signature": "m CmdTakeTimeSer",
          "source": "src/Game-LambdaHack-Client-HumanGlobal.html#waitHuman",
          "type": "function"
        },
        "index": {
          "description": "Leader waits turn and blocks etc",
          "hierarchy": "Game LambdaHack Client HumanGlobal",
          "module": "Game.LambdaHack.Client.HumanGlobal",
          "name": "waitHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanGlobal.html#v:waitHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of \u003ccode\u003eHumanCmd\u003c/code\u003e client commands that do not return\n server commands. None of such commands takes game time.\n TODO: document\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "HumanLocal",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of HumanCmd client commands that do not return server commands None of such commands takes game time TODO document",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "HumanLocal",
          "package": "LambdaHack",
          "partial": "Human Local",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccept something, e.g., targeting mode, keeping cursor where it was.\n Or perform the default action, if nothing needs accepting.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "acceptHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#acceptHuman",
          "type": "function"
        },
        "index": {
          "description": "Accept something e.g targeting mode keeping cursor where it was Or perform the default action if nothing needs accepting",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "acceptHuman",
          "normalized": "a Slideshow-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "Human",
          "signature": "m Slideshow-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:acceptHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCancel something, e.g., targeting mode, resetting the cursor\n to the position of the leader. Chosen target is not invalidated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "cancelHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#cancelHuman",
          "type": "function"
        },
        "index": {
          "description": "Cancel something e.g targeting mode resetting the cursor to the position of the leader Chosen target is not invalidated",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "cancelHuman",
          "normalized": "a Slideshow-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "Human",
          "signature": "m Slideshow-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:cancelHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear current messages, show the next screen if any.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "clearHuman",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#clearHuman",
          "type": "function"
        },
        "index": {
          "description": "Clear current messages show the next screen if any",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "clearHuman",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Human",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:clearHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTweak the \u003ccode\u003eeps\u003c/code\u003e parameter of the targeting digital line.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "epsIncrHuman",
          "package": "LambdaHack",
          "signature": "Bool -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#epsIncrHuman",
          "type": "function"
        },
        "index": {
          "description": "Tweak the eps parameter of the targeting digital line",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "epsIncrHuman",
          "normalized": "Bool-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "Incr Human",
          "signature": "Bool-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:epsIncrHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a list of item names.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "floorItemOverlay",
          "package": "LambdaHack",
          "signature": "ItemBag -\u003e m Overlay",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#floorItemOverlay",
          "type": "function"
        },
        "index": {
          "description": "Create list of item names",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "floorItemOverlay",
          "normalized": "ItemBag-\u003ea Overlay",
          "package": "LambdaHack",
          "partial": "Item Overlay",
          "signature": "ItemBag-\u003em Overlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:floorItemOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "gameDifficultyCycle",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#gameDifficultyCycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "gameDifficultyCycle",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Difficulty Cycle",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:gameDifficultyCycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay command help.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "helpHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#helpHuman",
          "type": "function"
        },
        "index": {
          "description": "Display command help",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "helpHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:helpHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "historyHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#historyHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "historyHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:historyHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay inventory\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "inventoryHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#inventoryHuman",
          "type": "function"
        },
        "index": {
          "description": "Display inventory",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "inventoryHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:inventoryHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a list of item names.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "itemOverlay",
          "package": "LambdaHack",
          "signature": "ItemBag -\u003e ItemInv -\u003e m Overlay",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#itemOverlay",
          "type": "function"
        },
        "index": {
          "description": "Create list of item names",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "itemOverlay",
          "normalized": "ItemBag-\u003eItemInv-\u003ea Overlay",
          "package": "LambdaHack",
          "partial": "Overlay",
          "signature": "ItemBag-\u003eItemInv-\u003em Overlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:itemOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduces a textual description of the terrain and items at an already\n explored position. Mute for unknown positions.\n The detailed variant is for use in the targeting mode.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "lookAt",
          "package": "LambdaHack",
          "signature": "Bool-\u003e Text-\u003e Bool-\u003e Point-\u003e ActorId-\u003e Text-\u003e m Text",
          "type": "function"
        },
        "index": {
          "description": "Produces textual description of the terrain and items at an already explored position Mute for unknown positions The detailed variant is for use in the targeting mode",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "lookAt",
          "normalized": "Bool-\u003eText-\u003eBool-\u003ePoint-\u003eActorId-\u003eText-\u003ea Text",
          "package": "LambdaHack",
          "partial": "At",
          "signature": "Bool-\u003eText-\u003eBool-\u003ePoint-\u003eActorId-\u003eText-\u003em Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:lookAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "macroHuman",
          "package": "LambdaHack",
          "signature": "[String] -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#macroHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "macroHuman",
          "normalized": "[String]-\u003ea()",
          "package": "LambdaHack",
          "partial": "Human",
          "signature": "[String]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:macroHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay the main menu.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "mainMenuHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#mainMenuHuman",
          "type": "function"
        },
        "index": {
          "description": "Display the main menu",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "mainMenuHuman",
          "package": "LambdaHack",
          "partial": "Menu Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:mainMenuHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "markSmellHuman",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#markSmellHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "markSmellHuman",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Smell Human",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:markSmellHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "markSuspectHuman",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#markSuspectHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "markSuspectHuman",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Suspect Human",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:markSuspectHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "markVisionHuman",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#markVisionHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "markVisionHuman",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Vision Human",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:markVisionHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitches current member to the previous in the whole dungeon, wrapping.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "memberBackHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#memberBackHuman",
          "type": "function"
        },
        "index": {
          "description": "Switches current member to the previous in the whole dungeon wrapping",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "memberBackHuman",
          "package": "LambdaHack",
          "partial": "Back Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:memberBackHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitches current member to the next on the level, if any, wrapping.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "memberCycleHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#memberCycleHuman",
          "type": "function"
        },
        "index": {
          "description": "Switches current member to the next on the level if any wrapping",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "memberCycleHuman",
          "package": "LambdaHack",
          "partial": "Cycle Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:memberCycleHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "moveCursorHuman",
          "package": "LambdaHack",
          "signature": "Vector -\u003e Int -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#moveCursorHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "moveCursorHuman",
          "normalized": "Vector-\u003eInt-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "Cursor Human",
          "signature": "Vector-\u003eInt-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:moveCursorHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect a faction leader. False, if nothing to do.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "pickLeader",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m Bool",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#pickLeader",
          "type": "function"
        },
        "index": {
          "description": "Select faction leader False if nothing to do",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "pickLeader",
          "normalized": "ActorId-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "Leader",
          "signature": "ActorId-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:pickLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "pickLeaderHuman",
          "package": "LambdaHack",
          "signature": "Int -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#pickLeaderHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "pickLeaderHuman",
          "normalized": "Int-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "Leader Human",
          "signature": "Int-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:pickLeaderHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "recordHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#recordHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "recordHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:recordHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "repeatHuman",
          "package": "LambdaHack",
          "signature": "Int -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#repeatHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "repeatHuman",
          "normalized": "Int-\u003ea()",
          "package": "LambdaHack",
          "partial": "Human",
          "signature": "Int-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:repeatHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "selectActorHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#selectActorHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "selectActorHuman",
          "package": "LambdaHack",
          "partial": "Actor Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:selectActorHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "selectNoneHuman",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#selectNoneHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "selectNoneHuman",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "None Human",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:selectNoneHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the displayed level in targeting mode to (at most)\n k levels shallower. Enters targeting mode, if not already in one.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtAscendHuman",
          "package": "LambdaHack",
          "signature": "Int -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#tgtAscendHuman",
          "type": "function"
        },
        "index": {
          "description": "Change the displayed level in targeting mode to at most levels shallower Enters targeting mode if not already in one",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtAscendHuman",
          "normalized": "Int-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "Ascend Human",
          "signature": "Int-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:tgtAscendHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtClearHuman",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#tgtClearHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtClearHuman",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Clear Human",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:tgtClearHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtEnemyHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#tgtEnemyHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtEnemyHuman",
          "package": "LambdaHack",
          "partial": "Enemy Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:tgtEnemyHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCycle targeting mode. Do not change position of the cursor,\n switch among things at that position.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtFloorHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#tgtFloorHuman",
          "type": "function"
        },
        "index": {
          "description": "Cycle targeting mode Do not change position of the cursor switch among things at that position",
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtFloorHuman",
          "package": "LambdaHack",
          "partial": "Floor Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:tgtFloorHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtItemHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#tgtItemHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtItemHuman",
          "package": "LambdaHack",
          "partial": "Item Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:tgtItemHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtStairHuman",
          "package": "LambdaHack",
          "signature": "Bool -\u003e m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#tgtStairHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtStairHuman",
          "normalized": "Bool-\u003ea Slideshow",
          "package": "LambdaHack",
          "partial": "Stair Human",
          "signature": "Bool-\u003em Slideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:tgtStairHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtUnknownHuman",
          "package": "LambdaHack",
          "signature": "m Slideshow",
          "source": "src/Game-LambdaHack-Client-HumanLocal.html#tgtUnknownHuman",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client HumanLocal",
          "module": "Game.LambdaHack.Client.HumanLocal",
          "name": "tgtUnknownHuman",
          "package": "LambdaHack",
          "partial": "Unknown Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanLocal.html#v:tgtUnknownHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of human player commands.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.HumanSem",
          "name": "HumanSem",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-HumanSem.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of human player commands",
          "hierarchy": "Game LambdaHack Client HumanSem",
          "module": "Game.LambdaHack.Client.HumanSem",
          "name": "HumanSem",
          "package": "LambdaHack",
          "partial": "Human Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe semantics of human player commands in terms of the \u003ccode\u003eAction\u003c/code\u003e monad.\n Decides if the action takes time and what action to perform.\n Some time cosuming commands are enabled in targeting mode, but cannot be\n invoked in targeting mode on a remote level (level different than\n the level of the leader).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.HumanSem",
          "name": "cmdHumanSem",
          "package": "LambdaHack",
          "signature": "HumanCmd -\u003e m (SlideOrCmd CmdSer)",
          "source": "src/Game-LambdaHack-Client-HumanSem.html#cmdHumanSem",
          "type": "function"
        },
        "index": {
          "description": "The semantics of human player commands in terms of the Action monad Decides if the action takes time and what action to perform Some time cosuming commands are enabled in targeting mode but cannot be invoked in targeting mode on remote level level different than the level of the leader",
          "hierarchy": "Game LambdaHack Client HumanSem",
          "module": "Game.LambdaHack.Client.HumanSem",
          "name": "cmdHumanSem",
          "normalized": "HumanCmd-\u003ea(SlideOrCmd CmdSer)",
          "package": "LambdaHack",
          "partial": "Human Sem",
          "signature": "HumanCmd-\u003em(SlideOrCmd CmdSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-HumanSem.html#v:cmdHumanSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe main loop of the client, processing human and computer player\n moves turn by turn.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.LoopAction",
          "name": "LoopAction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-LoopAction.html",
          "type": "module"
        },
        "index": {
          "description": "The main loop of the client processing human and computer player moves turn by turn",
          "hierarchy": "Game LambdaHack Client LoopAction",
          "module": "Game.LambdaHack.Client.LoopAction",
          "name": "LoopAction",
          "package": "LambdaHack",
          "partial": "Loop Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-LoopAction.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.LoopAction",
          "name": "loopAI",
          "package": "LambdaHack",
          "signature": "DebugModeCli -\u003e (CmdClientAI -\u003e m ()) -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-LoopAction.html#loopAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client LoopAction",
          "module": "Game.LambdaHack.Client.LoopAction",
          "name": "loopAI",
          "normalized": "DebugModeCli-\u003e(CmdClientAI-\u003ea())-\u003ea()",
          "package": "LambdaHack",
          "partial": "AI",
          "signature": "DebugModeCli-\u003e(CmdClientAI-\u003em())-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-LoopAction.html#v:loopAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.LoopAction",
          "name": "loopUI",
          "package": "LambdaHack",
          "signature": "DebugModeCli -\u003e (CmdClientUI -\u003e m ()) -\u003e m ()",
          "source": "src/Game-LambdaHack-Client-LoopAction.html#loopUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client LoopAction",
          "module": "Game.LambdaHack.Client.LoopAction",
          "name": "loopUI",
          "normalized": "DebugModeCli-\u003e(CmdClientUI-\u003ea())-\u003ea()",
          "package": "LambdaHack",
          "partial": "UI",
          "signature": "DebugModeCli-\u003e(CmdClientUI-\u003em())-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-LoopAction.html#v:loopUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRunning and disturbance.\n\u003c/p\u003e\u003cp\u003eThe general rule is: whatever is behind you (and so ignored previously),\n determines what you ignore moving forward. This is calcaulated\n separately for the tiles to the left, to the right and in the middle\n along the running direction. So, if you want to ignore something\n start running when you stand on it (or to the right or left, respectively)\n or by entering it (or passing to the right or left, respectively).\n\u003c/p\u003e\u003cp\u003eSome things are never ignored, such as: enemies seen, imporant messages\n heard, solid tiles and actors in the way.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.RunAction",
          "name": "RunAction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-RunAction.html",
          "type": "module"
        },
        "index": {
          "description": "Running and disturbance The general rule is whatever is behind you and so ignored previously determines what you ignore moving forward This is calcaulated separately for the tiles to the left to the right and in the middle along the running direction So if you want to ignore something start running when you stand on it or to the right or left respectively or by entering it or passing to the right or left respectively Some things are never ignored such as enemies seen imporant messages heard solid tiles and actors in the way",
          "hierarchy": "Game LambdaHack Client RunAction",
          "module": "Game.LambdaHack.Client.RunAction",
          "name": "RunAction",
          "package": "LambdaHack",
          "partial": "Run Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-RunAction.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContinue running in the given direction.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.RunAction",
          "name": "continueRun",
          "package": "LambdaHack",
          "signature": "RunParams -\u003e m (Either Msg (RunParams, CmdTakeTimeSer))",
          "source": "src/Game-LambdaHack-Client-RunAction.html#continueRun",
          "type": "function"
        },
        "index": {
          "description": "Continue running in the given direction",
          "hierarchy": "Game LambdaHack Client RunAction",
          "module": "Game.LambdaHack.Client.RunAction",
          "name": "continueRun",
          "normalized": "RunParams-\u003ea(Either Msg(RunParams,CmdTakeTimeSer))",
          "package": "LambdaHack",
          "partial": "Run",
          "signature": "RunParams-\u003em(Either Msg(RunParams,CmdTakeTimeSer))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-RunAction.html#v:continueRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActor moves or searches or alters. No visible actor at the position.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.RunAction",
          "name": "moveRunAid",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Vector -\u003e m (Either Msg CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-RunAction.html#moveRunAid",
          "type": "function"
        },
        "index": {
          "description": "Actor moves or searches or alters No visible actor at the position",
          "hierarchy": "Game LambdaHack Client RunAction",
          "module": "Game.LambdaHack.Client.RunAction",
          "name": "moveRunAid",
          "normalized": "ActorId-\u003eVector-\u003ea(Either Msg CmdTakeTimeSer)",
          "package": "LambdaHack",
          "partial": "Run Aid",
          "signature": "ActorId-\u003eVector-\u003em(Either Msg CmdTakeTimeSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-RunAction.html#v:moveRunAid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServer and client game state types and operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "State",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-State.html",
          "type": "module"
        },
        "index": {
          "description": "Server and client game state types and operations",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "State",
          "package": "LambdaHack",
          "partial": "State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "LastRecord",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-State.html#LastRecord",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "LastRecord",
          "package": "LambdaHack",
          "partial": "Last Record",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#t:LastRecord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "PathEtc",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-State.html#PathEtc",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "PathEtc",
          "package": "LambdaHack",
          "partial": "Path Etc",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#t:PathEtc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParameters of the current run.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "RunParams",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-State.html#RunParams",
          "type": "data"
        },
        "index": {
          "description": "Parameters of the current run",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "RunParams",
          "package": "LambdaHack",
          "partial": "Run Params",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#t:RunParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClient state, belonging to a single faction.\n Some of the data, e.g, the history, carries over\n from game to game, even across playing sessions.\n Data invariant: if \u003ccode\u003e_sleader\u003c/code\u003e is \u003ccode\u003eNothing\u003c/code\u003e then so is \u003ccode\u003esrunning\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "StateClient",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "data"
        },
        "index": {
          "description": "Client state belonging to single faction Some of the data e.g the history carries over from game to game even across playing sessions Data invariant if sleader is Nothing then so is srunning",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "StateClient",
          "package": "LambdaHack",
          "partial": "State Client",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#t:StateClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of na actor target.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "Target",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-State.html#Target",
          "type": "data"
        },
        "index": {
          "description": "The type of na actor target",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "Target",
          "package": "LambdaHack",
          "partial": "Target",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#t:Target"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent targeting mode of a client.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "TgtMode",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-State.html#TgtMode",
          "type": "newtype"
        },
        "index": {
          "description": "Current targeting mode of client",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "TgtMode",
          "package": "LambdaHack",
          "partial": "Tgt Mode",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#t:TgtMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "RunParams",
          "package": "LambdaHack",
          "signature": "RunParams",
          "source": "src/Game-LambdaHack-Client-State.html#RunParams",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "RunParams",
          "package": "LambdaHack",
          "partial": "Run Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:RunParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "StateClient",
          "package": "LambdaHack",
          "signature": "StateClient",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "StateClient",
          "package": "LambdaHack",
          "partial": "State Client",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:StateClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etarget an actor; cycle only trough seen foes, unless the flag is set\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "TEnemy",
          "package": "LambdaHack",
          "signature": "TEnemy !ActorId !Bool",
          "source": "src/Game-LambdaHack-Client-State.html#Target",
          "type": "function"
        },
        "index": {
          "description": "target an actor cycle only trough seen foes unless the flag is set",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "TEnemy",
          "package": "LambdaHack",
          "partial": "TEnemy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:TEnemy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elast seen position of the targeted actor\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "TEnemyPos",
          "package": "LambdaHack",
          "signature": "TEnemyPos !ActorId !LevelId !Point !Bool",
          "source": "src/Game-LambdaHack-Client-State.html#Target",
          "type": "function"
        },
        "index": {
          "description": "last seen position of the targeted actor",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "TEnemyPos",
          "package": "LambdaHack",
          "partial": "TEnemy Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:TEnemyPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etarget a concrete spot\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "TPoint",
          "package": "LambdaHack",
          "signature": "TPoint !LevelId !Point",
          "source": "src/Game-LambdaHack-Client-State.html#Target",
          "type": "function"
        },
        "index": {
          "description": "target concrete spot",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "TPoint",
          "package": "LambdaHack",
          "partial": "TPoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:TPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etarget position relative to actor\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "TVector",
          "package": "LambdaHack",
          "signature": "TVector !Vector",
          "source": "src/Game-LambdaHack-Client-State.html#Target",
          "type": "function"
        },
        "index": {
          "description": "target position relative to actor",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "TVector",
          "package": "LambdaHack",
          "partial": "TVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:TVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "TgtMode",
          "package": "LambdaHack",
          "signature": "TgtMode",
          "source": "src/Game-LambdaHack-Client-State.html#TgtMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "TgtMode",
          "package": "LambdaHack",
          "partial": "Tgt Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:TgtMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent picked party leader\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "_sleader",
          "package": "LambdaHack",
          "signature": "(Maybe ActorId)",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "current picked party leader",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "_sleader",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:_sleader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efaction controlled by the client\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "_sside",
          "package": "LambdaHack",
          "signature": "FactionId",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "faction controlled by the client",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "_sside",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:_sside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "defHistory",
          "package": "LambdaHack",
          "signature": "IO History",
          "source": "src/Game-LambdaHack-Client-State.html#defHistory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "defHistory",
          "package": "LambdaHack",
          "partial": "History",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:defHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitial game client state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "defStateClient",
          "package": "LambdaHack",
          "signature": "History -\u003e ConfigUI -\u003e FactionId -\u003e Bool -\u003e StateClient",
          "source": "src/Game-LambdaHack-Client-State.html#defStateClient",
          "type": "function"
        },
        "index": {
          "description": "Initial game client state",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "defStateClient",
          "normalized": "History-\u003eConfigUI-\u003eFactionId-\u003eBool-\u003eStateClient",
          "package": "LambdaHack",
          "partial": "State Client",
          "signature": "History-\u003eConfigUI-\u003eFactionId-\u003eBool-\u003eStateClient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:defStateClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet target parameters from client state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "getTarget",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e StateClient -\u003e Maybe Target",
          "source": "src/Game-LambdaHack-Client-State.html#getTarget",
          "type": "function"
        },
        "index": {
          "description": "Get target parameters from client state",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "getTarget",
          "normalized": "ActorId-\u003eStateClient-\u003eMaybe Target",
          "package": "LambdaHack",
          "partial": "Target",
          "signature": "ActorId-\u003eStateClient-\u003eMaybe Target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:getTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edistance of the run so far\n   (plus one, if multiple runners)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "runDist",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Client-State.html#RunParams",
          "type": "function"
        },
        "index": {
          "description": "distance of the run so far plus one if multiple runners",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "runDist",
          "package": "LambdaHack",
          "partial": "Dist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:runDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe direction of the initial step\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "runInitDir",
          "package": "LambdaHack",
          "signature": "(Maybe Vector)",
          "source": "src/Game-LambdaHack-Client-State.html#RunParams",
          "type": "function"
        },
        "index": {
          "description": "the direction of the initial step",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "runInitDir",
          "package": "LambdaHack",
          "partial": "Init Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:runInitDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe original leader from run start\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "runLeader",
          "package": "LambdaHack",
          "signature": "ActorId",
          "source": "src/Game-LambdaHack-Client-State.html#RunParams",
          "type": "function"
        },
        "index": {
          "description": "the original leader from run start",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "runLeader",
          "package": "LambdaHack",
          "partial": "Leader",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:runLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe list of actors that take part\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "runMembers",
          "package": "LambdaHack",
          "signature": "[ActorId]",
          "source": "src/Game-LambdaHack-Client-State.html#RunParams",
          "type": "function"
        },
        "index": {
          "description": "the list of actors that take part",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "runMembers",
          "normalized": "[ActorId]",
          "package": "LambdaHack",
          "partial": "Members",
          "signature": "[ActorId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:runMembers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emessage with the next stop reason\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "runStopMsg",
          "package": "LambdaHack",
          "signature": "(Maybe Text)",
          "source": "src/Game-LambdaHack-Client-State.html#RunParams",
          "type": "function"
        },
        "index": {
          "description": "message with the next stop reason",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "runStopMsg",
          "package": "LambdaHack",
          "partial": "Stop Msg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:runStopMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epathfinding distances for our actors\n   and paths to their targets, if any\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sbfsD",
          "package": "LambdaHack",
          "signature": "(EnumMap ActorId (Array BfsDistance, Point, Int, Maybe [Point]))",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "pathfinding distances for our actors and paths to their targets if any",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sbfsD",
          "normalized": "(EnumMap ActorId(Array BfsDistance,Point,Int,Maybe[Point]))",
          "package": "LambdaHack",
          "signature": "(EnumMap ActorId(Array BfsDistance,Point,Int,Maybe[Point]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sbfsD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclient config (including initial RNG)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sconfigUI",
          "package": "LambdaHack",
          "signature": "ConfigUI",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "client config including initial RNG",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sconfigUI",
          "package": "LambdaHack",
          "partial": "UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sconfigUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent game difficulty level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "scurDifficulty",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "current game difficulty level",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "scurDifficulty",
          "package": "LambdaHack",
          "partial": "Difficulty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:scurDifficulty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe common, cursor target\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "scursor",
          "package": "LambdaHack",
          "signature": "Target",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "the common cursor target",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "scursor",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:scursor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclient debugging mode\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sdebugCli",
          "package": "LambdaHack",
          "signature": "DebugModeCli",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "client debugging mode",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sdebugCli",
          "package": "LambdaHack",
          "partial": "Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sdebugCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremembered item discoveries\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sdisco",
          "package": "LambdaHack",
          "signature": "Discovery",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "remembered item discoveries",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sdisco",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sdisco"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea parameter of the tgt digital line\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "seps",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "parameter of the tgt digital line",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "seps",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:seps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe set of fully explored levels\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sexplored",
          "package": "LambdaHack",
          "signature": "(EnumSet LevelId)",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "the set of fully explored levels",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sexplored",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sexplored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efaction perception indexed by levels\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sfper",
          "package": "LambdaHack",
          "signature": "FactionPers",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "faction perception indexed by levels",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sfper",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sfper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehistory of messages\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "shistory",
          "package": "LambdaHack",
          "signature": "History",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "history of messages",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "shistory",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:shistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhether it's an AI client\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sisAI",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "whether it an AI client",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sisAI",
          "package": "LambdaHack",
          "partial": "AI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sisAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elast command sent to the server\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastCmd",
          "package": "LambdaHack",
          "signature": "(Maybe CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "last command sent to the server",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastCmd",
          "package": "LambdaHack",
          "partial": "Cmd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:slastCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elast command key pressed\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastKey",
          "package": "LambdaHack",
          "signature": "(Maybe KM)",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "last command key pressed",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastKey",
          "package": "LambdaHack",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:slastKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estate of key sequence playback\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastPlay",
          "package": "LambdaHack",
          "signature": "[KM]",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "state of key sequence playback",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastPlay",
          "normalized": "[KM]",
          "package": "LambdaHack",
          "partial": "Play",
          "signature": "[KM]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:slastPlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estate of key sequence recording\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastRecord",
          "package": "LambdaHack",
          "signature": "LastRecord",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "state of key sequence recording",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "slastRecord",
          "package": "LambdaHack",
          "partial": "Record",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:slastRecord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emark smell, if the leader can smell\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "smarkSmell",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "mark smell if the leader can smell",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "smarkSmell",
          "package": "LambdaHack",
          "partial": "Smell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:smarkSmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emark suspect features\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "smarkSuspect",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "mark suspect features",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "smarkSuspect",
          "package": "LambdaHack",
          "partial": "Suspect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:smarkSuspect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emark leader and party FOV\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "smarkVision",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "mark leader and party FOV",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "smarkVision",
          "package": "LambdaHack",
          "partial": "Vision",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:smarkVision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexit the game loop\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "squit",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "exit the game loop",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "squit",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:squit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent random generator\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "srandom",
          "package": "LambdaHack",
          "signature": "StdGen",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "current random generator",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "srandom",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:srandom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent messages\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sreport",
          "package": "LambdaHack",
          "signature": "Report",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "current messages",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sreport",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sreport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparameters of the current run, if any\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "srunning",
          "package": "LambdaHack",
          "signature": "(Maybe RunParams)",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "parameters of the current run if any",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "srunning",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:srunning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe set of currently selected actors\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sselected",
          "package": "LambdaHack",
          "signature": "(EnumSet ActorId)",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "the set of currently selected actors",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sselected",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sselected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "sside",
          "package": "LambdaHack",
          "signature": "StateClient -\u003e FactionId",
          "source": "src/Game-LambdaHack-Client-State.html#sside",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sside",
          "normalized": "StateClient-\u003eFactionId",
          "package": "LambdaHack",
          "signature": "StateClient-\u003eFactionId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etargets of our actors in the dungeon\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "stargetD",
          "package": "LambdaHack",
          "signature": "(EnumMap ActorId (Target, Maybe PathEtc))",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "targets of our actors in the dungeon",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "stargetD",
          "normalized": "(EnumMap ActorId(Target,Maybe PathEtc))",
          "package": "LambdaHack",
          "signature": "(EnumMap ActorId(Target,Maybe PathEtc))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:stargetD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etargeting mode\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "stgtMode",
          "package": "LambdaHack",
          "signature": "(Maybe TgtMode)",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "targeting mode",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "stgtMode",
          "package": "LambdaHack",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:stgtMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eatomic commands performed to date\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "sundo",
          "package": "LambdaHack",
          "signature": "[Atomic]",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "atomic commands performed to date",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "sundo",
          "normalized": "[Atomic]",
          "package": "LambdaHack",
          "signature": "[Atomic]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:sundo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplayer just waited this many times\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "swaitTimes",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Client-State.html#StateClient",
          "type": "function"
        },
        "index": {
          "description": "player just waited this many times",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "swaitTimes",
          "package": "LambdaHack",
          "partial": "Times",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:swaitTimes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "tgtLevelId",
          "package": "LambdaHack",
          "signature": "LevelId",
          "source": "src/Game-LambdaHack-Client-State.html#TgtMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "tgtLevelId",
          "package": "LambdaHack",
          "partial": "Level Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:tgtLevelId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "toggleMarkSmell",
          "package": "LambdaHack",
          "signature": "StateClient -\u003e StateClient",
          "source": "src/Game-LambdaHack-Client-State.html#toggleMarkSmell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "toggleMarkSmell",
          "normalized": "StateClient-\u003eStateClient",
          "package": "LambdaHack",
          "partial": "Mark Smell",
          "signature": "StateClient-\u003eStateClient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:toggleMarkSmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "toggleMarkSuspect",
          "package": "LambdaHack",
          "signature": "StateClient -\u003e StateClient",
          "source": "src/Game-LambdaHack-Client-State.html#toggleMarkSuspect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "toggleMarkSuspect",
          "normalized": "StateClient-\u003eStateClient",
          "package": "LambdaHack",
          "partial": "Mark Suspect",
          "signature": "StateClient-\u003eStateClient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:toggleMarkSuspect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.State",
          "name": "toggleMarkVision",
          "package": "LambdaHack",
          "signature": "StateClient -\u003e StateClient",
          "source": "src/Game-LambdaHack-Client-State.html#toggleMarkVision",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "toggleMarkVision",
          "normalized": "StateClient-\u003eStateClient",
          "package": "LambdaHack",
          "partial": "Mark Vision",
          "signature": "StateClient-\u003eStateClient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:toggleMarkVision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate picked leader within state. Verify actor's faction.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "updateLeader",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e State -\u003e StateClient -\u003e StateClient",
          "source": "src/Game-LambdaHack-Client-State.html#updateLeader",
          "type": "function"
        },
        "index": {
          "description": "Update picked leader within state Verify actor faction",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "updateLeader",
          "normalized": "ActorId-\u003eState-\u003eStateClient-\u003eStateClient",
          "package": "LambdaHack",
          "partial": "Leader",
          "signature": "ActorId-\u003eState-\u003eStateClient-\u003eStateClient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:updateLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate target parameters within client state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.State",
          "name": "updateTarget",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e (Maybe Target -\u003e Maybe Target) -\u003e StateClient -\u003e StateClient",
          "source": "src/Game-LambdaHack-Client-State.html#updateTarget",
          "type": "function"
        },
        "index": {
          "description": "Update target parameters within client state",
          "hierarchy": "Game LambdaHack Client State",
          "module": "Game.LambdaHack.Client.State",
          "name": "updateTarget",
          "normalized": "ActorId-\u003e(Maybe Target-\u003eMaybe Target)-\u003eStateClient-\u003eStateClient",
          "package": "LambdaHack",
          "partial": "Target",
          "signature": "ActorId-\u003e(Maybe Target-\u003eMaybe Target)-\u003eStateClient-\u003eStateClient",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-State.html#v:updateTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAI strategies to direct actors not controlled directly by human players.\n No operation in this module involves the \u003ccode\u003eState\u003c/code\u003e or \u003ccode\u003eAction\u003c/code\u003e type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "Strategy",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Strategy.html",
          "type": "module"
        },
        "index": {
          "description": "AI strategies to direct actors not controlled directly by human players No operation in this module involves the State or Action type",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "Strategy",
          "package": "LambdaHack",
          "partial": "Strategy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA strategy is a choice of (non-empty) frequency tables\n of possible actions.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "Strategy",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Strategy.html#Strategy",
          "type": "data"
        },
        "index": {
          "description": "strategy is choice of non-empty frequency tables of possible actions",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "Strategy",
          "package": "LambdaHack",
          "partial": "Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#t:Strategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrategy with the actions from both argument strategies,\n with original frequencies.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "(.|)",
          "package": "LambdaHack",
          "signature": "Strategy a -\u003e Strategy a -\u003e Strategy a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#.%7C",
          "type": "function"
        },
        "index": {
          "description": "Strategy with the actions from both argument strategies with original frequencies",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "(.|) .|",
          "normalized": "Strategy a-\u003eStrategy a-\u003eStrategy a",
          "package": "LambdaHack",
          "signature": "Strategy a-\u003eStrategy a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:.-124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConditionally accepted strategy.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "(.=\u003e)",
          "package": "LambdaHack",
          "signature": "Bool -\u003e Strategy a -\u003e Strategy a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#.%3D%3E",
          "type": "function"
        },
        "index": {
          "description": "Conditionally accepted strategy",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "(.=\u003e) .=\u003e",
          "normalized": "Bool-\u003eStrategy a-\u003eStrategy a",
          "package": "LambdaHack",
          "signature": "Bool-\u003eStrategy a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:.-61--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen better choices are towards the start of the list,\n this is the best frequency of the strategy.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "bestVariant",
          "package": "LambdaHack",
          "signature": "Strategy a -\u003e Frequency a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#bestVariant",
          "type": "function"
        },
        "index": {
          "description": "When better choices are towards the start of the list this is the best frequency of the strategy",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "bestVariant",
          "normalized": "Strategy a-\u003eFrequency a",
          "package": "LambdaHack",
          "partial": "Variant",
          "signature": "Strategy a-\u003eFrequency a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:bestVariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrategy where only the actions from the given single frequency table\n can be picked.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "liftFrequency",
          "package": "LambdaHack",
          "signature": "Frequency a -\u003e Strategy a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#liftFrequency",
          "type": "function"
        },
        "index": {
          "description": "Strategy where only the actions from the given single frequency table can be picked",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "liftFrequency",
          "normalized": "Frequency a-\u003eStrategy a",
          "package": "LambdaHack",
          "partial": "Frequency",
          "signature": "Frequency a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:liftFrequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "nullStrategy",
          "package": "LambdaHack",
          "signature": "Strategy a -\u003e Bool",
          "source": "src/Game-LambdaHack-Client-Strategy.html#nullStrategy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "nullStrategy",
          "normalized": "Strategy a-\u003eBool",
          "package": "LambdaHack",
          "partial": "Strategy",
          "signature": "Strategy a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:nullStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrategy with all actions not satisfying the predicate removed.\n The remaining actions keep their original relative frequency values.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "only",
          "package": "LambdaHack",
          "signature": "(a -\u003e Bool) -\u003e Strategy a -\u003e Strategy a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#only",
          "type": "function"
        },
        "index": {
          "description": "Strategy with all actions not satisfying the predicate removed The remaining actions keep their original relative frequency values",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "only",
          "normalized": "(a-\u003eBool)-\u003eStrategy a-\u003eStrategy a",
          "package": "LambdaHack",
          "signature": "(a-\u003eBool)-\u003eStrategy a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:only"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrategy with no actions at all.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "reject",
          "package": "LambdaHack",
          "signature": "Strategy a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#reject",
          "type": "function"
        },
        "index": {
          "description": "Strategy with no actions at all",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "reject",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:reject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOverwrite the description of all frequencies within the strategy.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "renameStrategy",
          "package": "LambdaHack",
          "signature": "Text -\u003e Strategy a -\u003e Strategy a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#renameStrategy",
          "type": "function"
        },
        "index": {
          "description": "Overwrite the description of all frequencies within the strategy",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "renameStrategy",
          "normalized": "Text-\u003eStrategy a-\u003eStrategy a",
          "package": "LambdaHack",
          "partial": "Strategy",
          "signature": "Text-\u003eStrategy a-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:renameStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e, but pick a name of the single frequency.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "returN",
          "package": "LambdaHack",
          "signature": "Text -\u003e a -\u003e Strategy a",
          "source": "src/Game-LambdaHack-Client-Strategy.html#returN",
          "type": "function"
        },
        "index": {
          "description": "Like return but pick name of the single frequency",
          "hierarchy": "Game LambdaHack Client Strategy",
          "module": "Game.LambdaHack.Client.Strategy",
          "name": "returN",
          "normalized": "Text-\u003ea-\u003eStrategy a",
          "package": "LambdaHack",
          "signature": "Text-\u003ea-\u003eStrategy a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-Strategy.html#v:returN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAI strategy operations implemented with the \u003ccode\u003eAction\u003c/code\u003e monad.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client.StrategyAction",
          "name": "StrategyAction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-StrategyAction.html",
          "type": "module"
        },
        "index": {
          "description": "AI strategy operations implemented with the Action monad",
          "hierarchy": "Game LambdaHack Client StrategyAction",
          "module": "Game.LambdaHack.Client.StrategyAction",
          "name": "StrategyAction",
          "package": "LambdaHack",
          "partial": "Strategy Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-StrategyAction.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAI strategy based on actor's sight, smell, intelligence, etc.\n Never empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.StrategyAction",
          "name": "actionStrategy",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m (Strategy CmdTakeTimeSer)",
          "source": "src/Game-LambdaHack-Client-StrategyAction.html#actionStrategy",
          "type": "function"
        },
        "index": {
          "description": "AI strategy based on actor sight smell intelligence etc Never empty",
          "hierarchy": "Game LambdaHack Client StrategyAction",
          "module": "Game.LambdaHack.Client.StrategyAction",
          "name": "actionStrategy",
          "normalized": "ActorId-\u003ea(Strategy CmdTakeTimeSer)",
          "package": "LambdaHack",
          "partial": "Strategy",
          "signature": "ActorId-\u003em(Strategy CmdTakeTimeSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-StrategyAction.html#v:actionStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAI proposes possible targets for the actor. Never empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client.StrategyAction",
          "name": "targetStrategy",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e ActorId -\u003e m (Strategy (Target, PathEtc))",
          "source": "src/Game-LambdaHack-Client-StrategyAction.html#targetStrategy",
          "type": "function"
        },
        "index": {
          "description": "AI proposes possible targets for the actor Never empty",
          "hierarchy": "Game LambdaHack Client StrategyAction",
          "module": "Game.LambdaHack.Client.StrategyAction",
          "name": "targetStrategy",
          "normalized": "ActorId-\u003eActorId-\u003ea(Strategy(Target,PathEtc))",
          "package": "LambdaHack",
          "partial": "Strategy",
          "signature": "ActorId-\u003eActorId-\u003em(Strategy(Target,PathEtc))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client-StrategyAction.html#v:targetStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of client commands.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Client",
          "name": "Client",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of client commands See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "Client",
          "package": "LambdaHack",
          "partial": "Client",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client",
          "name": "MonadClient",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClient",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "MonadClient",
          "package": "LambdaHack",
          "partial": "Monad Client",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#t:MonadClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client",
          "name": "MonadClientReadServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientReadServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "MonadClientReadServer",
          "package": "LambdaHack",
          "partial": "Monad Client Read Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#t:MonadClientReadServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client",
          "name": "MonadClientUI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientUI",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "MonadClientUI",
          "package": "LambdaHack",
          "partial": "Monad Client UI",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#t:MonadClientUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client",
          "name": "MonadClientWriteServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Client-Action-ActionClass.html#MonadClientWriteServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "MonadClientWriteServer",
          "package": "LambdaHack",
          "partial": "Monad Client Write Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#t:MonadClientWriteServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client",
          "name": "cmdClientAISem",
          "package": "LambdaHack",
          "signature": "CmdClientAI -\u003e m ()",
          "source": "src/Game-LambdaHack-Client.html#cmdClientAISem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "cmdClientAISem",
          "normalized": "CmdClientAI-\u003ea()",
          "package": "LambdaHack",
          "partial": "Client AISem",
          "signature": "CmdClientAI-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#v:cmdClientAISem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Client",
          "name": "cmdClientUISem",
          "package": "LambdaHack",
          "signature": "CmdClientUI -\u003e m ()",
          "source": "src/Game-LambdaHack-Client.html#cmdClientUISem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "cmdClientUISem",
          "normalized": "CmdClientUI-\u003ea()",
          "package": "LambdaHack",
          "partial": "Client UISem",
          "signature": "CmdClientUI-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#v:cmdClientUISem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWire together game content, the main loop of game clients,\n the main game loop assigned to this frontend (possibly containing\n the server loop, if the whole game runs in one process),\n UI config and the definitions of game commands.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Client",
          "name": "exeFrontend",
          "package": "LambdaHack",
          "signature": "(m () -\u003e SessionUI -\u003e State -\u003e StateClient -\u003e ChanServer CmdClientUI CmdSer -\u003e IO ()) -\u003e (n () -\u003e SessionUI -\u003e State -\u003e StateClient -\u003e ChanServer CmdClientAI CmdTakeTimeSer -\u003e IO ()) -\u003e COps -\u003e DebugModeCli -\u003e ((FactionId -\u003e ChanFrontend -\u003e ChanServer CmdClientUI CmdSer -\u003e IO ()) -\u003e (FactionId -\u003e ChanServer CmdClientAI CmdTakeTimeSer -\u003e IO ()) -\u003e IO ()) -\u003e IO ()",
          "source": "src/Game-LambdaHack-Client.html#exeFrontend",
          "type": "function"
        },
        "index": {
          "description": "Wire together game content the main loop of game clients the main game loop assigned to this frontend possibly containing the server loop if the whole game runs in one process UI config and the definitions of game commands",
          "hierarchy": "Game LambdaHack Client",
          "module": "Game.LambdaHack.Client",
          "name": "exeFrontend",
          "normalized": "(a()-\u003eSessionUI-\u003eState-\u003eStateClient-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(b()-\u003eSessionUI-\u003eState-\u003eStateClient-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eCOps-\u003eDebugModeCli-\u003e((FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eIO())-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Frontend",
          "signature": "(m()-\u003eSessionUI-\u003eState-\u003eStateClient-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(n()-\u003eSessionUI-\u003eState-\u003eStateClient-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eCOps-\u003eDebugModeCli-\u003e((FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Client.html#v:exeFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAI strategy abilities.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Ability",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Ability.html",
          "type": "module"
        },
        "index": {
          "description": "AI strategy abilities",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Ability",
          "package": "LambdaHack",
          "partial": "Ability",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll possible AI actor abilities. AI chooses among these when considering\n the next action to perform. The ability descriptions refer to the target\n that any actor picks each turn, depending on the actor's characteristics\n and his environment.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Ability",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "data"
        },
        "index": {
          "description": "All possible AI actor abilities AI chooses among these when considering the next action to perform The ability descriptions refer to the target that any actor picks each turn depending on the actor characteristics and his environment",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Ability",
          "package": "LambdaHack",
          "partial": "Ability",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#t:Ability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echase the target, ignoring any actors on the way\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Chase",
          "package": "LambdaHack",
          "signature": "Chase",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "chase the target ignoring any actors on the way",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Chase",
          "package": "LambdaHack",
          "partial": "Chase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Chase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eswitch places with a friend\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Displace",
          "package": "LambdaHack",
          "signature": "Displace",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "switch places with friend",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Displace",
          "package": "LambdaHack",
          "partial": "Displace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Displace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eflee if almost dead\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Flee",
          "package": "LambdaHack",
          "signature": "Flee",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "flee if almost dead",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Flee",
          "package": "LambdaHack",
          "partial": "Flee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Flee"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eheal if almost dead\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Heal",
          "package": "LambdaHack",
          "signature": "Heal",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "heal if almost dead",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Heal",
          "package": "LambdaHack",
          "partial": "Heal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Heal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emelee target\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Melee",
          "package": "LambdaHack",
          "signature": "Melee",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "melee target",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Melee",
          "package": "LambdaHack",
          "partial": "Melee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Melee"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egather items, if no foes visible\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Pickup",
          "package": "LambdaHack",
          "signature": "Pickup",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "gather items if no foes visible",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Pickup",
          "package": "LambdaHack",
          "partial": "Pickup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Pickup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattack the visible target opponent at range, some of the time\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Ranged",
          "package": "LambdaHack",
          "signature": "Ranged",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "attack the visible target opponent at range some of the time",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Ranged",
          "package": "LambdaHack",
          "partial": "Ranged",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Ranged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euse items, if target opponent visible, some of the time\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Tools",
          "package": "LambdaHack",
          "signature": "Tools",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "use items if target opponent visible some of the time",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Tools",
          "package": "LambdaHack",
          "partial": "Tools",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Tools"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emove along a set trajectory, if any, meleeing any opponents\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Track",
          "package": "LambdaHack",
          "signature": "Track",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "move along set trajectory if any meleeing any opponents",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Track",
          "package": "LambdaHack",
          "partial": "Track",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Track"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etrigger a feature\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Trigger",
          "package": "LambdaHack",
          "signature": "Trigger",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "trigger feature",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Trigger",
          "package": "LambdaHack",
          "partial": "Trigger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Trigger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewander around, meleeing any opponents on the way\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Wander",
          "package": "LambdaHack",
          "signature": "Wander",
          "source": "src/Game-LambdaHack-Common-Ability.html#Ability",
          "type": "function"
        },
        "index": {
          "description": "wander around meleeing any opponents on the way",
          "hierarchy": "Game LambdaHack Common Ability",
          "module": "Game.LambdaHack.Common.Ability",
          "name": "Wander",
          "package": "LambdaHack",
          "partial": "Wander",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Ability.html#v:Wander"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGame action monads and basic building blocks for human and computer\n player actions. Has no access to the the main action type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Action",
          "name": "Action",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Action.html",
          "type": "module"
        },
        "index": {
          "description": "Game action monads and basic building blocks for human and computer player actions Has no access to the the main action type",
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "Action",
          "package": "LambdaHack",
          "partial": "Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "MonadAction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Action.html#MonadAction",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "MonadAction",
          "package": "LambdaHack",
          "partial": "Monad Action",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#t:MonadAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "MonadActionRO",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Action.html#MonadActionRO",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "MonadActionRO",
          "package": "LambdaHack",
          "partial": "Monad Action RO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#t:MonadActionRO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "MonadAtomic",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Action.html#MonadAtomic",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "MonadAtomic",
          "package": "LambdaHack",
          "partial": "Monad Atomic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#t:MonadAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "execAtomic",
          "package": "LambdaHack",
          "signature": "Atomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Action.html#execAtomic",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "execAtomic",
          "normalized": "Atomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Atomic",
          "signature": "Atomic-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:execAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "execCmdAtomic",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Action.html#execCmdAtomic",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "execCmdAtomic",
          "normalized": "CmdAtomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "signature": "CmdAtomic-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:execCmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "execSfxAtomic",
          "package": "LambdaHack",
          "signature": "SfxAtomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Action.html#execSfxAtomic",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "execSfxAtomic",
          "normalized": "SfxAtomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Sfx Atomic",
          "signature": "SfxAtomic-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:execSfxAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "getLevel",
          "package": "LambdaHack",
          "signature": "LevelId -\u003e m Level",
          "source": "src/Game-LambdaHack-Common-Action.html#getLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "getLevel",
          "normalized": "LevelId-\u003ea Level",
          "package": "LambdaHack",
          "partial": "Level",
          "signature": "LevelId-\u003em Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:getLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "getState",
          "package": "LambdaHack",
          "signature": "m State",
          "source": "src/Game-LambdaHack-Common-Action.html#getState",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "getState",
          "package": "LambdaHack",
          "partial": "State",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:getState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "getsState",
          "package": "LambdaHack",
          "signature": "(State -\u003e a) -\u003e m a",
          "source": "src/Game-LambdaHack-Common-Action.html#getsState",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "getsState",
          "normalized": "(State-\u003ea)-\u003eb a",
          "package": "LambdaHack",
          "partial": "State",
          "signature": "(State-\u003ea)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:getsState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "modifyState",
          "package": "LambdaHack",
          "signature": "(State -\u003e State) -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Action.html#modifyState",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "modifyState",
          "normalized": "(State-\u003eState)-\u003ea()",
          "package": "LambdaHack",
          "partial": "State",
          "signature": "(State-\u003eState)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:modifyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "nUI",
          "package": "LambdaHack",
          "signature": "m Int",
          "source": "src/Game-LambdaHack-Common-Action.html#nUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "nUI",
          "package": "LambdaHack",
          "partial": "UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:nUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "putState",
          "package": "LambdaHack",
          "signature": "State -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Action.html#putState",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "putState",
          "normalized": "State-\u003ea()",
          "package": "LambdaHack",
          "partial": "State",
          "signature": "State-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:putState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Action",
          "name": "serverSaveName",
          "package": "LambdaHack",
          "signature": "String",
          "source": "src/Game-LambdaHack-Common-Action.html#serverSaveName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Action",
          "module": "Game.LambdaHack.Common.Action",
          "name": "serverSaveName",
          "package": "LambdaHack",
          "partial": "Save Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Action.html#v:serverSaveName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eActors in the game: heroes, monsters, etc. No operation in this module\n involves the \u003ccode\u003eState\u003c/code\u003e or \u003ccode\u003eAction\u003c/code\u003e type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "Actor",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html",
          "type": "module"
        },
        "index": {
          "description": "Actors in the game heroes monsters etc No operation in this module involves the State or Action type",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "Actor",
          "package": "LambdaHack",
          "partial": "Actor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActor properties that are changing throughout the game.\n If they are dublets of properties from \u003ccode\u003eActorKind\u003c/code\u003e,\n they are usually modified temporarily, but tend to return\n to the original value from \u003ccode\u003eActorKind\u003c/code\u003e over time. E.g., HP.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "Actor",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "data"
        },
        "index": {
          "description": "Actor properties that are changing throughout the game If they are dublets of properties from ActorKind they are usually modified temporarily but tend to return to the original value from ActorKind over time E.g HP",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "Actor",
          "package": "LambdaHack",
          "partial": "Actor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:Actor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll actors on the level, indexed by actor identifier.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ActorDict",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#ActorDict",
          "type": "type"
        },
        "index": {
          "description": "All actors on the level indexed by actor identifier",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ActorDict",
          "package": "LambdaHack",
          "partial": "Actor Dict",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:ActorDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA unique identifier of an actor in the dungeon.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ActorId",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#ActorId",
          "type": "data"
        },
        "index": {
          "description": "unique identifier of an actor in the dungeon",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ActorId",
          "package": "LambdaHack",
          "partial": "Actor Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:ActorId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "InvChar",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#InvChar",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "InvChar",
          "package": "LambdaHack",
          "partial": "Inv Char",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:InvChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemBag",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#ItemBag",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemBag",
          "package": "LambdaHack",
          "partial": "Item Bag",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:ItemBag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll items in the dungeon (including in actor inventories),\n indexed by item identifier.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemDict",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#ItemDict",
          "type": "type"
        },
        "index": {
          "description": "All items in the dungeon including in actor inventories indexed by item identifier",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemDict",
          "package": "LambdaHack",
          "partial": "Item Dict",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:ItemDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemInv",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#ItemInv",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemInv",
          "package": "LambdaHack",
          "partial": "Item Inv",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:ItemInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse item map, for item creation, to keep items and item identifiers\n in bijection.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemRev",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Actor.html#ItemRev",
          "type": "type"
        },
        "index": {
          "description": "Reverse item map for item creation to keep items and item identifiers in bijection",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "ItemRev",
          "package": "LambdaHack",
          "partial": "Item Rev",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#t:ItemRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "Actor",
          "package": "LambdaHack",
          "signature": "Actor",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "Actor",
          "package": "LambdaHack",
          "partial": "Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:Actor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "InvChar",
          "package": "LambdaHack",
          "signature": "InvChar",
          "source": "src/Game-LambdaHack-Common-Actor.html#InvChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "InvChar",
          "package": "LambdaHack",
          "partial": "Inv Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:InvChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA template for a new actor.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "actorTemplate",
          "package": "LambdaHack",
          "signature": "Id ActorKind -\u003e Char -\u003e Text -\u003e Color -\u003e Speed -\u003e Int -\u003e Maybe [Vector] -\u003e Point -\u003e LevelId -\u003e Time -\u003e FactionId -\u003e Bool -\u003e Actor",
          "source": "src/Game-LambdaHack-Common-Actor.html#actorTemplate",
          "type": "function"
        },
        "index": {
          "description": "template for new actor",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "actorTemplate",
          "normalized": "Id ActorKind-\u003eChar-\u003eText-\u003eColor-\u003eSpeed-\u003eInt-\u003eMaybe[Vector]-\u003ePoint-\u003eLevelId-\u003eTime-\u003eFactionId-\u003eBool-\u003eActor",
          "package": "LambdaHack",
          "partial": "Template",
          "signature": "Id ActorKind-\u003eChar-\u003eText-\u003eColor-\u003eSpeed-\u003eInt-\u003eMaybe[Vector]-\u003ePoint-\u003eLevelId-\u003eTime-\u003eFactionId-\u003eBool-\u003eActor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:actorTemplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "allLetters",
          "package": "LambdaHack",
          "signature": "[InvChar]",
          "source": "src/Game-LambdaHack-Common-Actor.html#allLetters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "allLetters",
          "normalized": "[InvChar]",
          "package": "LambdaHack",
          "partial": "Letters",
          "signature": "[InvChar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:allLetters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssigns a letter to an item, for inclusion in the inventory\n of a hero. Tries to to use the requested letter, if any.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "assignLetter",
          "package": "LambdaHack",
          "signature": "ItemId -\u003e Maybe InvChar -\u003e Actor -\u003e Maybe InvChar",
          "source": "src/Game-LambdaHack-Common-Actor.html#assignLetter",
          "type": "function"
        },
        "index": {
          "description": "Assigns letter to an item for inclusion in the inventory of hero Tries to to use the requested letter if any",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "assignLetter",
          "normalized": "ItemId-\u003eMaybe InvChar-\u003eActor-\u003eMaybe InvChar",
          "package": "LambdaHack",
          "partial": "Letter",
          "signature": "ItemId-\u003eMaybe InvChar-\u003eActor-\u003eMaybe InvChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:assignLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eitems carried\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bbag",
          "package": "LambdaHack",
          "signature": "ItemBag",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "items carried",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bbag",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bbag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual map color\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bcolor",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "individual map color",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bcolor",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bcolor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efaction the actor belongs to\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bfid",
          "package": "LambdaHack",
          "signature": "FactionId",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "faction the actor belongs to",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bfid",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bfid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent hit points\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bhp",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "current hit points",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bhp",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bhp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap from letters to items\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "binv",
          "package": "LambdaHack",
          "signature": "ItemInv",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "map from letters to items",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "binv",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:binv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe kind of the actor\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bkind",
          "package": "LambdaHack",
          "signature": "(Id ActorKind)",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "the kind of the actor",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bkind",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bkind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enext inventory letter\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bletter",
          "package": "LambdaHack",
          "signature": "InvChar",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "next inventory letter",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bletter",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bletter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "blid",
          "package": "LambdaHack",
          "signature": "LevelId",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "current level",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "blid",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:blid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "individual name",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprevious level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "boldlid",
          "package": "LambdaHack",
          "signature": "LevelId",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "previous level",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "boldlid",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:boldlid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprevious position\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "boldpos",
          "package": "LambdaHack",
          "signature": "Point",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "previous position",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "boldpos",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:boldpos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent position\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bpos",
          "package": "LambdaHack",
          "signature": "Point",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "current position",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bpos",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bpos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis a projectile? (shorthand only,\n   this can be deduced from bkind)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bproj",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "is projectile shorthand only this can be deduced from bkind",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bproj",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bproj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether an actor is braced for combat this clip.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "braced",
          "package": "LambdaHack",
          "signature": "Actor -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Actor.html#braced",
          "type": "function"
        },
        "index": {
          "description": "Whether an actor is braced for combat this clip",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "braced",
          "normalized": "Actor-\u003eBool",
          "package": "LambdaHack",
          "signature": "Actor-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:braced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual speed\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bspeed",
          "package": "LambdaHack",
          "signature": "Speed",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "individual speed",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bspeed",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bspeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual map symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bsymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "individual map symbol",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bsymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bsymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eabsolute time of next action\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "btime",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "absolute time of next action",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "btime",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:btime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etrajectory the actor must travel\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "btrajectory",
          "package": "LambdaHack",
          "signature": "(Maybe [Vector])",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "trajectory the actor must travel",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "btrajectory",
          "normalized": "(Maybe[Vector])",
          "package": "LambdaHack",
          "signature": "(Maybe[Vector])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:btrajectory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis the actor waiting right now?\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bwait",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Actor.html#Actor",
          "type": "function"
        },
        "index": {
          "description": "is the actor waiting right now",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "bwait",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:bwait"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "checkAdjacent",
          "package": "LambdaHack",
          "signature": "Actor -\u003e Actor -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Actor.html#checkAdjacent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "checkAdjacent",
          "normalized": "Actor-\u003eActor-\u003eBool",
          "package": "LambdaHack",
          "partial": "Adjacent",
          "signature": "Actor-\u003eActor-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:checkAdjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique kind of heroes.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "heroKindId",
          "package": "LambdaHack",
          "signature": "Ops ActorKind -\u003e Id ActorKind",
          "source": "src/Game-LambdaHack-Common-Actor.html#heroKindId",
          "type": "function"
        },
        "index": {
          "description": "The unique kind of heroes",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "heroKindId",
          "normalized": "Ops ActorKind-\u003eId ActorKind",
          "package": "LambdaHack",
          "partial": "Kind Id",
          "signature": "Ops ActorKind-\u003eId ActorKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:heroKindId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "invChar",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Common-Actor.html#InvChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "invChar",
          "package": "LambdaHack",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:invChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "letterLabel",
          "package": "LambdaHack",
          "signature": "InvChar -\u003e Part",
          "source": "src/Game-LambdaHack-Common-Actor.html#letterLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "letterLabel",
          "normalized": "InvChar-\u003ePart",
          "package": "LambdaHack",
          "partial": "Label",
          "signature": "InvChar-\u003ePart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:letterLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "letterRange",
          "package": "LambdaHack",
          "signature": "[InvChar] -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Actor.html#letterRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "letterRange",
          "normalized": "[InvChar]-\u003eText",
          "package": "LambdaHack",
          "partial": "Range",
          "signature": "[InvChar]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:letterRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "mapActorItems_",
          "package": "LambdaHack",
          "signature": "(ItemId -\u003e Int -\u003e m a) -\u003e Actor -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Actor.html#mapActorItems_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "mapActorItems_",
          "normalized": "(ItemId-\u003eInt-\u003ea b)-\u003eActor-\u003ea()",
          "package": "LambdaHack",
          "partial": "Actor Items",
          "signature": "(ItemId-\u003eInt-\u003em a)-\u003eActor-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:mapActorItems_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChance that a new monster is generated. Currently depends on the\n number of monsters already present, and on the level. In the future,\n the strength of the character and the strength of the monsters present\n could further influence the chance, and the chance could also affect\n which monster is generated. How many and which monsters are generated\n will also depend on the cave kind used to build the level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "monsterGenChance",
          "package": "LambdaHack",
          "signature": "Int -\u003e Int -\u003e Int -\u003e Rnd Bool",
          "source": "src/Game-LambdaHack-Common-Actor.html#monsterGenChance",
          "type": "function"
        },
        "index": {
          "description": "Chance that new monster is generated Currently depends on the number of monsters already present and on the level In the future the strength of the character and the strength of the monsters present could further influence the chance and the chance could also affect which monster is generated How many and which monsters are generated will also depend on the cave kind used to build the level",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "monsterGenChance",
          "normalized": "Int-\u003eInt-\u003eInt-\u003eRnd Bool",
          "package": "LambdaHack",
          "partial": "Gen Chance",
          "signature": "Int-\u003eInt-\u003eInt-\u003eRnd Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:monsterGenChance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe part of speech describing the actor.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "partActor",
          "package": "LambdaHack",
          "signature": "Actor -\u003e Part",
          "source": "src/Game-LambdaHack-Common-Actor.html#partActor",
          "type": "function"
        },
        "index": {
          "description": "The part of speech describing the actor",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "partActor",
          "normalized": "Actor-\u003ePart",
          "package": "LambdaHack",
          "partial": "Actor",
          "signature": "Actor-\u003ePart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:partActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unique kind of projectiles.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "projectileKindId",
          "package": "LambdaHack",
          "signature": "Ops ActorKind -\u003e Id ActorKind",
          "source": "src/Game-LambdaHack-Common-Actor.html#projectileKindId",
          "type": "function"
        },
        "index": {
          "description": "The unique kind of projectiles",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "projectileKindId",
          "normalized": "Ops ActorKind-\u003eId ActorKind",
          "package": "LambdaHack",
          "partial": "Kind Id",
          "signature": "Ops ActorKind-\u003eId ActorKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:projectileKindId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Actor",
          "name": "rmFromBag",
          "package": "LambdaHack",
          "signature": "Int -\u003e ItemId -\u003e ItemBag -\u003e ItemBag",
          "source": "src/Game-LambdaHack-Common-Actor.html#rmFromBag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "rmFromBag",
          "normalized": "Int-\u003eItemId-\u003eItemBag-\u003eItemBag",
          "package": "LambdaHack",
          "partial": "From Bag",
          "signature": "Int-\u003eItemId-\u003eItemBag-\u003eItemBag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:rmFromBag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow long until an actor's smell vanishes from a tile.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "smellTimeout",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Common-Actor.html#smellTimeout",
          "type": "function"
        },
        "index": {
          "description": "How long until an actor smell vanishes from tile",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "smellTimeout",
          "package": "LambdaHack",
          "partial": "Timeout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:smellTimeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd time taken by a single step at the actor's current speed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "timeAddFromSpeed",
          "package": "LambdaHack",
          "signature": "Actor -\u003e Time -\u003e Time",
          "source": "src/Game-LambdaHack-Common-Actor.html#timeAddFromSpeed",
          "type": "function"
        },
        "index": {
          "description": "Add time taken by single step at the actor current speed",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "timeAddFromSpeed",
          "normalized": "Actor-\u003eTime-\u003eTime",
          "package": "LambdaHack",
          "partial": "Add From Speed",
          "signature": "Actor-\u003eTime-\u003eTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:timeAddFromSpeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks for the presence of actors in a position.\n Does not check if the tile is walkable.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "unoccupied",
          "package": "LambdaHack",
          "signature": "[Actor] -\u003e Point -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Actor.html#unoccupied",
          "type": "function"
        },
        "index": {
          "description": "Checks for the presence of actors in position Does not check if the tile is walkable",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "unoccupied",
          "normalized": "[Actor]-\u003ePoint-\u003eBool",
          "package": "LambdaHack",
          "signature": "[Actor]-\u003ePoint-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:unoccupied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe actor waited last turn.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "waitedLastTurn",
          "package": "LambdaHack",
          "signature": "Actor -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Actor.html#waitedLastTurn",
          "type": "function"
        },
        "index": {
          "description": "The actor waited last turn",
          "hierarchy": "Game LambdaHack Common Actor",
          "module": "Game.LambdaHack.Common.Actor",
          "name": "waitedLastTurn",
          "normalized": "Actor-\u003eBool",
          "package": "LambdaHack",
          "partial": "Last Turn",
          "signature": "Actor-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Actor.html#v:waitedLastTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOperations on the \u003ccode\u003e\u003ca\u003eActor\u003c/a\u003e\u003c/code\u003e type that need the \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e type,\n but not the \u003ccode\u003eAction\u003c/code\u003e type.\n TODO: Document an export list after it's rewritten according to #17.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "ActorState",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ActorState.html",
          "type": "module"
        },
        "index": {
          "description": "Operations on the Actor type that need the State type but not the Action type TODO Document an export list after it rewritten according to",
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "ActorState",
          "package": "LambdaHack",
          "partial": "Actor State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorAssocs",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e Bool) -\u003e LevelId -\u003e State -\u003e [(ActorId, Actor)]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorAssocs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorAssocs",
          "normalized": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[(ActorId,Actor)]",
          "package": "LambdaHack",
          "partial": "Assocs",
          "signature": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[(ActorId,Actor)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorAssocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorAssocsLvl",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e Bool) -\u003e Level -\u003e ActorDict -\u003e [(ActorId, Actor)]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorAssocsLvl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorAssocsLvl",
          "normalized": "(FactionId-\u003eBool)-\u003eLevel-\u003eActorDict-\u003e[(ActorId,Actor)]",
          "package": "LambdaHack",
          "partial": "Assocs Lvl",
          "signature": "(FactionId-\u003eBool)-\u003eLevel-\u003eActorDict-\u003e[(ActorId,Actor)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorAssocsLvl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorContainer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e ItemInv -\u003e ItemId -\u003e Container",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorContainer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorContainer",
          "normalized": "ActorId-\u003eItemInv-\u003eItemId-\u003eContainer",
          "package": "LambdaHack",
          "partial": "Container",
          "signature": "ActorId-\u003eItemInv-\u003eItemId-\u003eContainer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorContainer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorContainerB",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Actor -\u003e ItemId -\u003e Item -\u003e Maybe Container",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorContainerB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorContainerB",
          "normalized": "ActorId-\u003eActor-\u003eItemId-\u003eItem-\u003eMaybe Container",
          "package": "LambdaHack",
          "partial": "Container",
          "signature": "ActorId-\u003eActor-\u003eItemId-\u003eItem-\u003eMaybe Container",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorContainerB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorList",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e Bool) -\u003e LevelId -\u003e State -\u003e [Actor]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorList",
          "normalized": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[Actor]",
          "package": "LambdaHack",
          "partial": "List",
          "signature": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[Actor]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorNotProjAssocs",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e Bool) -\u003e LevelId -\u003e State -\u003e [(ActorId, Actor)]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorNotProjAssocs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorNotProjAssocs",
          "normalized": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[(ActorId,Actor)]",
          "package": "LambdaHack",
          "partial": "Not Proj Assocs",
          "signature": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[(ActorId,Actor)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorNotProjAssocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorNotProjAssocsLvl",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e Bool) -\u003e Level -\u003e ActorDict -\u003e [(ActorId, Actor)]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorNotProjAssocsLvl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorNotProjAssocsLvl",
          "normalized": "(FactionId-\u003eBool)-\u003eLevel-\u003eActorDict-\u003e[(ActorId,Actor)]",
          "package": "LambdaHack",
          "partial": "Not Proj Assocs Lvl",
          "signature": "(FactionId-\u003eBool)-\u003eLevel-\u003eActorDict-\u003e[(ActorId,Actor)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorNotProjAssocsLvl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorNotProjList",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e Bool) -\u003e LevelId -\u003e State -\u003e [Actor]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#actorNotProjList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "actorNotProjList",
          "normalized": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[Actor]",
          "package": "LambdaHack",
          "partial": "Not Proj List",
          "signature": "(FactionId-\u003eBool)-\u003eLevelId-\u003eState-\u003e[Actor]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:actorNotProjList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate loot's worth for heroes on the current level.\n\u003c/p\u003e\u003cp\u003eWarning: scores are shown during the game, so when the server calculates\n then, we should be careful not to leak secret information\n (e.g., the nature of the items through the total worth of inventory).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "calculateTotal",
          "package": "LambdaHack",
          "signature": "Actor -\u003e State -\u003e (ItemBag, Int)",
          "source": "src/Game-LambdaHack-Common-ActorState.html#calculateTotal",
          "type": "function"
        },
        "index": {
          "description": "Calculate loot worth for heroes on the current level Warning scores are shown during the game so when the server calculates then we should be careful not to leak secret information e.g the nature of the items through the total worth of inventory",
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "calculateTotal",
          "normalized": "Actor-\u003eState-\u003e(ItemBag,Int)",
          "package": "LambdaHack",
          "partial": "Total",
          "signature": "Actor-\u003eState-\u003e(ItemBag,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:calculateTotal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "foesAdjacent",
          "package": "LambdaHack",
          "signature": "X -\u003e Y -\u003e Point -\u003e [Actor] -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-ActorState.html#foesAdjacent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "foesAdjacent",
          "normalized": "X-\u003eY-\u003ePoint-\u003e[Actor]-\u003eBool",
          "package": "LambdaHack",
          "partial": "Adjacent",
          "signature": "X-\u003eY-\u003ePoint-\u003e[Actor]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:foesAdjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorBag",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e State -\u003e ItemBag",
          "source": "src/Game-LambdaHack-Common-ActorState.html#getActorBag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorBag",
          "normalized": "ActorId-\u003eState-\u003eItemBag",
          "package": "LambdaHack",
          "partial": "Actor Bag",
          "signature": "ActorId-\u003eState-\u003eItemBag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:getActorBag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets actor body from the current level. Error if not found.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorBody",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e State -\u003e Actor",
          "source": "src/Game-LambdaHack-Common-ActorState.html#getActorBody",
          "type": "function"
        },
        "index": {
          "description": "Gets actor body from the current level Error if not found",
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorBody",
          "normalized": "ActorId-\u003eState-\u003eActor",
          "package": "LambdaHack",
          "partial": "Actor Body",
          "signature": "ActorId-\u003eState-\u003eActor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:getActorBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorInv",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e State -\u003e ItemInv",
          "source": "src/Game-LambdaHack-Common-ActorState.html#getActorInv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorInv",
          "normalized": "ActorId-\u003eState-\u003eItemInv",
          "package": "LambdaHack",
          "partial": "Actor Inv",
          "signature": "ActorId-\u003eState-\u003eItemInv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:getActorInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets actor's items from the current level. Warning: this does not work\n for viewing items of actors from remote level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorItem",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e State -\u003e [(ItemId, Item)]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#getActorItem",
          "type": "function"
        },
        "index": {
          "description": "Gets actor items from the current level Warning this does not work for viewing items of actors from remote level",
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getActorItem",
          "normalized": "ActorId-\u003eState-\u003e[(ItemId,Item)]",
          "package": "LambdaHack",
          "partial": "Actor Item",
          "signature": "ActorId-\u003eState-\u003e[(ItemId,Item)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:getActorItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getFloorItem",
          "package": "LambdaHack",
          "signature": "LevelId -\u003e Point -\u003e State -\u003e [(ItemId, Item)]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#getFloorItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getFloorItem",
          "normalized": "LevelId-\u003ePoint-\u003eState-\u003e[(ItemId,Item)]",
          "package": "LambdaHack",
          "partial": "Floor Item",
          "signature": "LevelId-\u003ePoint-\u003eState-\u003e[(ItemId,Item)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:getFloorItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getItemBody",
          "package": "LambdaHack",
          "signature": "ItemId -\u003e State -\u003e Item",
          "source": "src/Game-LambdaHack-Common-ActorState.html#getItemBody",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "getItemBody",
          "normalized": "ItemId-\u003eState-\u003eItem",
          "package": "LambdaHack",
          "partial": "Item Body",
          "signature": "ItemId-\u003eState-\u003eItem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:getItemBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if the actor is present on the current level.\n The order of argument here and in other functions is set to allow\n\u003c/p\u003e\u003cpre\u003e b \u003c- getsState (memActor a)\n\u003c/pre\u003e",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "memActor",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e LevelId -\u003e State -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-ActorState.html#memActor",
          "type": "function"
        },
        "index": {
          "description": "Checks if the actor is present on the current level The order of argument here and in other functions is set to allow getsState memActor",
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "memActor",
          "normalized": "ActorId-\u003eLevelId-\u003eState-\u003eBool",
          "package": "LambdaHack",
          "partial": "Actor",
          "signature": "ActorId-\u003eLevelId-\u003eState-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:memActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "nearbyFreePoints",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e (Id TileKind -\u003e Bool) -\u003e Point -\u003e LevelId -\u003e State -\u003e [Point]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#nearbyFreePoints",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "nearbyFreePoints",
          "normalized": "Ops TileKind-\u003e(Id TileKind-\u003eBool)-\u003ePoint-\u003eLevelId-\u003eState-\u003e[Point]",
          "package": "LambdaHack",
          "partial": "Free Points",
          "signature": "Ops TileKind-\u003e(Id TileKind-\u003eBool)-\u003ePoint-\u003eLevelId-\u003eState-\u003e[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:nearbyFreePoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinds an actor at a position on the current level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "posToActor",
          "package": "LambdaHack",
          "signature": "Point -\u003e LevelId -\u003e State -\u003e Maybe ((ActorId, Actor), [(ItemId, Item)])",
          "source": "src/Game-LambdaHack-Common-ActorState.html#posToActor",
          "type": "function"
        },
        "index": {
          "description": "Finds an actor at position on the current level",
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "posToActor",
          "normalized": "Point-\u003eLevelId-\u003eState-\u003eMaybe((ActorId,Actor),[(ItemId,Item)])",
          "package": "LambdaHack",
          "partial": "To Actor",
          "signature": "Point-\u003eLevelId-\u003eState-\u003eMaybe((ActorId,Actor),[(ItemId,Item)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:posToActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "posToActors",
          "package": "LambdaHack",
          "signature": "Point -\u003e LevelId -\u003e State -\u003e [((ActorId, Actor), [(ItemId, Item)])]",
          "source": "src/Game-LambdaHack-Common-ActorState.html#posToActors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "posToActors",
          "normalized": "Point-\u003eLevelId-\u003eState-\u003e[((ActorId,Actor),[(ItemId,Item)])]",
          "package": "LambdaHack",
          "partial": "To Actors",
          "signature": "Point-\u003eLevelId-\u003eState-\u003e[((ActorId,Actor),[(ItemId,Item)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:posToActors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "tryFindHeroK",
          "package": "LambdaHack",
          "signature": "State -\u003e FactionId -\u003e Int -\u003e Maybe (ActorId, Actor)",
          "source": "src/Game-LambdaHack-Common-ActorState.html#tryFindHeroK",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "tryFindHeroK",
          "normalized": "State-\u003eFactionId-\u003eInt-\u003eMaybe(ActorId,Actor)",
          "package": "LambdaHack",
          "partial": "Find Hero",
          "signature": "State-\u003eFactionId-\u003eInt-\u003eMaybe(ActorId,Actor)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:tryFindHeroK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "updateActorBody",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e (Actor -\u003e Actor) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-ActorState.html#updateActorBody",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "updateActorBody",
          "normalized": "ActorId-\u003e(Actor-\u003eActor)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "Actor Body",
          "signature": "ActorId-\u003e(Actor-\u003eActor)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:updateActorBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the level identifier and starting position on the level,\n after a level change.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "whereTo",
          "package": "LambdaHack",
          "signature": "LevelId-\u003e Point-\u003e Int-\u003e Dungeon-\u003e (LevelId, Point)",
          "type": "function"
        },
        "index": {
          "description": "Compute the level identifier and starting position on the level after level change",
          "hierarchy": "Game LambdaHack Common ActorState",
          "module": "Game.LambdaHack.Common.ActorState",
          "name": "whereTo",
          "normalized": "LevelId-\u003ePoint-\u003eInt-\u003eDungeon-\u003e(LevelId,Point)",
          "package": "LambdaHack",
          "partial": "To",
          "signature": "LevelId-\u003ePoint-\u003eInt-\u003eDungeon-\u003e(LevelId,Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ActorState.html#v:whereTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eScreen frames and animations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "Animation",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Animation.html",
          "type": "module"
        },
        "index": {
          "description": "Screen frames and animations",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "Animation",
          "package": "LambdaHack",
          "partial": "Animation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcFrame",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Animation.html#AcFrame",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcFrame",
          "package": "LambdaHack",
          "partial": "Ac Frame",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#t:AcFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnimation is a list of frame modifications to play one by one,\n where each modification if a map from positions to level map symbols.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "Animation",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Animation.html#Animation",
          "type": "data"
        },
        "index": {
          "description": "Animation is list of frame modifications to play one by one where each modification if map from positions to level map symbols",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "Animation",
          "package": "LambdaHack",
          "partial": "Animation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#t:Animation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "DebugModeCli",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "DebugModeCli",
          "package": "LambdaHack",
          "partial": "Debug Mode Cli",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#t:DebugModeCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequences of screen frames, including delays.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "Frames",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Animation.html#Frames",
          "type": "type"
        },
        "index": {
          "description": "Sequences of screen frames including delays",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "Frames",
          "package": "LambdaHack",
          "partial": "Frames",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#t:Frames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data sufficent to draw a single game screen frame.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "SingleFrame",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Animation.html#SingleFrame",
          "type": "data"
        },
        "index": {
          "description": "The data sufficent to draw single game screen frame",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "SingleFrame",
          "package": "LambdaHack",
          "partial": "Single Frame",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#t:SingleFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcConfirm",
          "package": "LambdaHack",
          "signature": "AcConfirm !SingleFrame",
          "source": "src/Game-LambdaHack-Common-Animation.html#AcFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcConfirm",
          "package": "LambdaHack",
          "partial": "Ac Confirm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:AcConfirm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcDelay",
          "package": "LambdaHack",
          "signature": "AcDelay",
          "source": "src/Game-LambdaHack-Common-Animation.html#AcFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcDelay",
          "package": "LambdaHack",
          "partial": "Ac Delay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:AcDelay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcNormal",
          "package": "LambdaHack",
          "signature": "AcNormal !SingleFrame",
          "source": "src/Game-LambdaHack-Common-Animation.html#AcFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcNormal",
          "package": "LambdaHack",
          "partial": "Ac Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:AcNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcRunning",
          "package": "LambdaHack",
          "signature": "AcRunning !SingleFrame",
          "source": "src/Game-LambdaHack-Common-Animation.html#AcFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "AcRunning",
          "package": "LambdaHack",
          "partial": "Ac Running",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:AcRunning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "DebugModeCli",
          "package": "LambdaHack",
          "signature": "DebugModeCli",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "DebugModeCli",
          "package": "LambdaHack",
          "partial": "Debug Mode Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:DebugModeCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "SingleFrame",
          "package": "LambdaHack",
          "signature": "SingleFrame",
          "source": "src/Game-LambdaHack-Common-Animation.html#SingleFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "SingleFrame",
          "package": "LambdaHack",
          "partial": "Single Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:SingleFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttack that hits through a block.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "blockHit",
          "package": "LambdaHack",
          "signature": "(Point, Point) -\u003e Color -\u003e Color -\u003e Animation",
          "source": "src/Game-LambdaHack-Common-Animation.html#blockHit",
          "type": "function"
        },
        "index": {
          "description": "Attack that hits through block",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "blockHit",
          "normalized": "(Point,Point)-\u003eColor-\u003eColor-\u003eAnimation",
          "package": "LambdaHack",
          "partial": "Hit",
          "signature": "(Point,Point)-\u003eColor-\u003eColor-\u003eAnimation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:blockHit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttack that is blocked.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "blockMiss",
          "package": "LambdaHack",
          "signature": "(Point, Point) -\u003e Animation",
          "source": "src/Game-LambdaHack-Common-Animation.html#blockMiss",
          "type": "function"
        },
        "index": {
          "description": "Attack that is blocked",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "blockMiss",
          "normalized": "(Point,Point)-\u003eAnimation",
          "package": "LambdaHack",
          "partial": "Miss",
          "signature": "(Point,Point)-\u003eAnimation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:blockMiss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeath animation for an organic body.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "deathBody",
          "package": "LambdaHack",
          "signature": "Point -\u003e Animation",
          "source": "src/Game-LambdaHack-Common-Animation.html#deathBody",
          "type": "function"
        },
        "index": {
          "description": "Death animation for an organic body",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "deathBody",
          "normalized": "Point-\u003eAnimation",
          "package": "LambdaHack",
          "partial": "Body",
          "signature": "Point-\u003eAnimation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:deathBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "decodeLine",
          "package": "LambdaHack",
          "signature": "ScreenLine -\u003e [AttrChar]",
          "source": "src/Game-LambdaHack-Common-Animation.html#decodeLine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "decodeLine",
          "normalized": "ScreenLine-\u003e[AttrChar]",
          "package": "LambdaHack",
          "partial": "Line",
          "signature": "ScreenLine-\u003e[AttrChar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:decodeLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "defDebugModeCli",
          "package": "LambdaHack",
          "signature": "DebugModeCli",
          "source": "src/Game-LambdaHack-Common-Animation.html#defDebugModeCli",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "defDebugModeCli",
          "package": "LambdaHack",
          "partial": "Debug Mode Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:defDebugModeCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "encodeLine",
          "package": "LambdaHack",
          "signature": "[AttrChar] -\u003e ScreenLine",
          "source": "src/Game-LambdaHack-Common-Animation.html#encodeLine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "encodeLine",
          "normalized": "[AttrChar]-\u003eScreenLine",
          "package": "LambdaHack",
          "partial": "Line",
          "signature": "[AttrChar]-\u003eScreenLine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:encodeLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "fadeout",
          "package": "LambdaHack",
          "signature": "Bool -\u003e Bool -\u003e X -\u003e Y -\u003e Rnd Animation",
          "source": "src/Game-LambdaHack-Common-Animation.html#fadeout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "fadeout",
          "normalized": "Bool-\u003eBool-\u003eX-\u003eY-\u003eRnd Animation",
          "package": "LambdaHack",
          "signature": "Bool-\u003eBool-\u003eX-\u003eY-\u003eRnd Animation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:fadeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOverlays the \u003ccode\u003esfTop\u003c/code\u003e and \u003ccode\u003esfBottom\u003c/code\u003e fields onto the \u003ccode\u003esfLevel\u003c/code\u003e field.\n The resulting frame has empty \u003ccode\u003esfTop\u003c/code\u003e and \u003ccode\u003esfBottom\u003c/code\u003e.\n To be used by simple frontends that don't display overlays\n in separate windows\u003cem\u003epanes\u003c/em\u003escrolled views.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "overlayOverlay",
          "package": "LambdaHack",
          "signature": "SingleFrame -\u003e SingleFrame",
          "source": "src/Game-LambdaHack-Common-Animation.html#overlayOverlay",
          "type": "function"
        },
        "index": {
          "description": "Overlays the sfTop and sfBottom fields onto the sfLevel field The resulting frame has empty sfTop and sfBottom To be used by simple frontends that don display overlays in separate windows panes scrolled views",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "overlayOverlay",
          "normalized": "SingleFrame-\u003eSingleFrame",
          "package": "LambdaHack",
          "partial": "Overlay",
          "signature": "SingleFrame-\u003eSingleFrame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:overlayOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender animations on top of a screen frame.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "renderAnim",
          "package": "LambdaHack",
          "signature": "X -\u003e Y -\u003e SingleFrame -\u003e Animation -\u003e Frames",
          "source": "src/Game-LambdaHack-Common-Animation.html#renderAnim",
          "type": "function"
        },
        "index": {
          "description": "Render animations on top of screen frame",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "renderAnim",
          "normalized": "X-\u003eY-\u003eSingleFrame-\u003eAnimation-\u003eFrames",
          "package": "LambdaHack",
          "partial": "Anim",
          "signature": "X-\u003eY-\u003eSingleFrame-\u003eAnimation-\u003eFrames",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:renderAnim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "restrictAnim",
          "package": "LambdaHack",
          "signature": "EnumSet Point -\u003e Animation -\u003e Animation",
          "source": "src/Game-LambdaHack-Common-Animation.html#restrictAnim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "restrictAnim",
          "normalized": "EnumSet Point-\u003eAnimation-\u003eAnimation",
          "package": "LambdaHack",
          "partial": "Anim",
          "signature": "EnumSet Point-\u003eAnimation-\u003eAnimation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:restrictAnim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow clients' internal debug messages.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sdbgMsgCli",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Show clients internal debug messages",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sdbgMsgCli",
          "package": "LambdaHack",
          "partial": "Msg Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sdbgMsgCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe difficulty level for all UI clients.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sdifficultyCli",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "The difficulty level for all UI clients",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sdifficultyCli",
          "package": "LambdaHack",
          "partial": "Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sdifficultyCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edisplay only \u003ccode\u003esfTop\u003c/code\u003e, on blank screen\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfBlank",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Animation.html#SingleFrame",
          "type": "function"
        },
        "index": {
          "description": "display only sfTop on blank screen",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfBlank",
          "package": "LambdaHack",
          "partial": "Blank",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sfBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esome extra lines to show at the bottom\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfBottom",
          "package": "LambdaHack",
          "signature": "[ScreenLine]",
          "source": "src/Game-LambdaHack-Common-Animation.html#SingleFrame",
          "type": "function"
        },
        "index": {
          "description": "some extra lines to show at the bottom",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfBottom",
          "normalized": "[ScreenLine]",
          "package": "LambdaHack",
          "partial": "Bottom",
          "signature": "[ScreenLine]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sfBottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escreen, from top to bottom, line by line\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfLevel",
          "package": "LambdaHack",
          "signature": "[ScreenLine]",
          "source": "src/Game-LambdaHack-Common-Animation.html#SingleFrame",
          "type": "function"
        },
        "index": {
          "description": "screen from top to bottom line by line",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfLevel",
          "normalized": "[ScreenLine]",
          "package": "LambdaHack",
          "partial": "Level",
          "signature": "[ScreenLine]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sfLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esome extra lines to show over the top\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfTop",
          "package": "LambdaHack",
          "signature": "Overlay",
          "source": "src/Game-LambdaHack-Common-Animation.html#SingleFrame",
          "type": "function"
        },
        "index": {
          "description": "some extra lines to show over the top",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfTop",
          "package": "LambdaHack",
          "partial": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sfTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFont to use for the main game window.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfont",
          "package": "LambdaHack",
          "signature": "(Maybe String)",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Font to use for the main game window",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfont",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sfont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether to use no frontend at all (for benchmarking, etc.).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfrontendNo",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Whether to use no frontend at all for benchmarking etc",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfrontendNo",
          "package": "LambdaHack",
          "partial": "No",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sfrontendNo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether to use the stdout/stdin frontend.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfrontendStd",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Whether to use the stdout stdin frontend",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "sfrontendStd",
          "package": "LambdaHack",
          "partial": "Std",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:sfrontendStd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximal frames per second.\n This is better low and fixed, to avoid jerkiness and delays\n that tell the player there are many intelligent enemies on the level.\n That's better than scaling AI sofistication down based\n on the FPS setting and machine speed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "smaxFps",
          "package": "LambdaHack",
          "signature": "(Maybe Int)",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Maximal frames per second This is better low and fixed to avoid jerkiness and delays that tell the player there are many intelligent enemies on the level That better than scaling AI sofistication down based on the FPS setting and machine speed",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "smaxFps",
          "package": "LambdaHack",
          "partial": "Fps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:smaxFps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart a new game, overwriting the save file.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snewGameCli",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Start new game overwriting the save file",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snewGameCli",
          "package": "LambdaHack",
          "partial": "Game Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:snewGameCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDon't show any animations.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snoAnim",
          "package": "LambdaHack",
          "signature": "(Maybe Bool)",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Don show any animations",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snoAnim",
          "package": "LambdaHack",
          "partial": "Anim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:snoAnim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDon't maintain any requested delays between frames,\n e.g., for screensaver.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snoDelay",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Don maintain any requested delays between frames e.g for screensaver",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snoDelay",
          "package": "LambdaHack",
          "partial": "Delay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:snoDelay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAuto-answer all prompts, e.g., for screensaver.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snoMore",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Auto-answer all prompts e.g for screensaver",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "snoMore",
          "package": "LambdaHack",
          "partial": "More",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:snoMore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrefix of the save game file.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "ssavePrefixCli",
          "package": "LambdaHack",
          "signature": "(Maybe String)",
          "source": "src/Game-LambdaHack-Common-Animation.html#DebugModeCli",
          "type": "function"
        },
        "index": {
          "description": "Prefix of the save game file",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "ssavePrefixCli",
          "package": "LambdaHack",
          "partial": "Prefix Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:ssavePrefixCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap-places animation, both hostile and friendly.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "swapPlaces",
          "package": "LambdaHack",
          "signature": "(Point, Point) -\u003e Animation",
          "source": "src/Game-LambdaHack-Common-Animation.html#swapPlaces",
          "type": "function"
        },
        "index": {
          "description": "Swap-places animation both hostile and friendly",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "swapPlaces",
          "normalized": "(Point,Point)-\u003eAnimation",
          "package": "LambdaHack",
          "partial": "Places",
          "signature": "(Point,Point)-\u003eAnimation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:swapPlaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttack animation. A part of it also reused for self-damage and healing.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "twirlSplash",
          "package": "LambdaHack",
          "signature": "(Point, Point) -\u003e Color -\u003e Color -\u003e Animation",
          "source": "src/Game-LambdaHack-Common-Animation.html#twirlSplash",
          "type": "function"
        },
        "index": {
          "description": "Attack animation part of it also reused for self-damage and healing",
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "twirlSplash",
          "normalized": "(Point,Point)-\u003eColor-\u003eColor-\u003eAnimation",
          "package": "LambdaHack",
          "partial": "Splash",
          "signature": "(Point,Point)-\u003eColor-\u003eColor-\u003eAnimation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:twirlSplash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "xsizeSingleFrame",
          "package": "LambdaHack",
          "signature": "SingleFrame -\u003e X",
          "source": "src/Game-LambdaHack-Common-Animation.html#xsizeSingleFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "xsizeSingleFrame",
          "normalized": "SingleFrame-\u003eX",
          "package": "LambdaHack",
          "partial": "Single Frame",
          "signature": "SingleFrame-\u003eX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:xsizeSingleFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Animation",
          "name": "ysizeSingleFrame",
          "package": "LambdaHack",
          "signature": "SingleFrame -\u003e X",
          "source": "src/Game-LambdaHack-Common-Animation.html#ysizeSingleFrame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Animation",
          "module": "Game.LambdaHack.Common.Animation",
          "name": "ysizeSingleFrame",
          "normalized": "SingleFrame-\u003eX",
          "package": "LambdaHack",
          "partial": "Single Frame",
          "signature": "SingleFrame-\u003eX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Animation.html#v:ysizeSingleFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA set of atomic commands shared by client and server.\n These are the largest building blocks that have no components\n that can be observed in isolation.\n\u003c/p\u003e\u003cp\u003eWe try to make atomic commands respect the laws of energy and mass\n conservation, unless they really can't, e.g., monster spawning.\n For example item removal from inventory is not an atomic command,\n but item dropped from the inventory to the ground is. This makes\n it easier to undo the commands. In principle, the commands are the only\n way to affect the basic game state (\u003ccode\u003eState\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eSee\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AtomicCmd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html",
          "type": "module"
        },
        "index": {
          "description": "set of atomic commands shared by client and server These are the largest building blocks that have no components that can be observed in isolation We try to make atomic commands respect the laws of energy and mass conservation unless they really can e.g monster spawning For example item removal from inventory is not an atomic command but item dropped from the inventory to the ground is This makes it easier to undo the commands In principle the commands are the only way to affect the basic game state State See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AtomicCmd",
          "package": "LambdaHack",
          "partial": "Atomic Cmd",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "Atomic",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#Atomic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "Atomic",
          "package": "LambdaHack",
          "partial": "Atomic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#t:Atomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract syntax of atomic commands.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CmdAtomic",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "data"
        },
        "index": {
          "description": "Abstract syntax of atomic commands",
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CmdAtomic",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#t:CmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HitAtomic",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#HitAtomic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HitAtomic",
          "package": "LambdaHack",
          "partial": "Hit Atomic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#t:HitAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SfxAtomic",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SfxAtomic",
          "package": "LambdaHack",
          "partial": "Sfx Atomic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#t:SfxAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ActivateD",
          "package": "LambdaHack",
          "signature": "ActivateD !ActorId !ItemId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ActivateD",
          "package": "LambdaHack",
          "partial": "Activate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:ActivateD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AgeActorA",
          "package": "LambdaHack",
          "signature": "AgeActorA !ActorId !Time",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AgeActorA",
          "package": "LambdaHack",
          "partial": "Age Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:AgeActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AgeGameA",
          "package": "LambdaHack",
          "signature": "AgeGameA !Time",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AgeGameA",
          "package": "LambdaHack",
          "partial": "Age Game",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:AgeGameA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AgeLevelA",
          "package": "LambdaHack",
          "signature": "AgeLevelA !LevelId !Time",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AgeLevelA",
          "package": "LambdaHack",
          "partial": "Age Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:AgeLevelA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AlterSmellA",
          "package": "LambdaHack",
          "signature": "AlterSmellA !LevelId !Point !(Maybe Time) !(Maybe Time)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AlterSmellA",
          "package": "LambdaHack",
          "partial": "Alter Smell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:AlterSmellA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AlterTileA",
          "package": "LambdaHack",
          "signature": "AlterTileA !LevelId !Point !(Id TileKind) !(Id TileKind)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "AlterTileA",
          "package": "LambdaHack",
          "partial": "Alter Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:AlterTileA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CatchD",
          "package": "LambdaHack",
          "signature": "CatchD !ActorId !ItemId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CatchD",
          "package": "LambdaHack",
          "partial": "Catch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:CatchD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CheckD",
          "package": "LambdaHack",
          "signature": "CheckD !ActorId !ItemId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CheckD",
          "package": "LambdaHack",
          "partial": "Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:CheckD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CmdAtomic",
          "package": "LambdaHack",
          "signature": "CmdAtomic !CmdAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#Atomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CmdAtomic",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:CmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ColorActorA",
          "package": "LambdaHack",
          "signature": "ColorActorA !ActorId !Color !Color",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ColorActorA",
          "package": "LambdaHack",
          "partial": "Color Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:ColorActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CoverA",
          "package": "LambdaHack",
          "signature": "CoverA !LevelId !Point !ItemId !(Id ItemKind)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CoverA",
          "package": "LambdaHack",
          "partial": "Cover",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:CoverA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CreateActorA",
          "package": "LambdaHack",
          "signature": "CreateActorA !ActorId !Actor ![(ItemId, Item)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CreateActorA",
          "normalized": "CreateActorA ActorId Actor[(ItemId,Item)]",
          "package": "LambdaHack",
          "partial": "Create Actor",
          "signature": "CreateActorA ActorId Actor[(ItemId,Item)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:CreateActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CreateItemA",
          "package": "LambdaHack",
          "signature": "CreateItemA !ItemId !Item !Int !Container",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "CreateItemA",
          "package": "LambdaHack",
          "partial": "Create Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:CreateItemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DestroyActorA",
          "package": "LambdaHack",
          "signature": "DestroyActorA !ActorId !Actor ![(ItemId, Item)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DestroyActorA",
          "normalized": "DestroyActorA ActorId Actor[(ItemId,Item)]",
          "package": "LambdaHack",
          "partial": "Destroy Actor",
          "signature": "DestroyActorA ActorId Actor[(ItemId,Item)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:DestroyActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DestroyItemA",
          "package": "LambdaHack",
          "signature": "DestroyItemA !ItemId !Item !Int !Container",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DestroyItemA",
          "package": "LambdaHack",
          "partial": "Destroy Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:DestroyItemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DiplFactionA",
          "package": "LambdaHack",
          "signature": "DiplFactionA !FactionId !FactionId !Diplomacy !Diplomacy",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DiplFactionA",
          "package": "LambdaHack",
          "partial": "Dipl Faction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:DiplFactionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DiscoverA",
          "package": "LambdaHack",
          "signature": "DiscoverA !LevelId !Point !ItemId !(Id ItemKind)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DiscoverA",
          "package": "LambdaHack",
          "partial": "Discover",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:DiscoverA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DisplaceActorA",
          "package": "LambdaHack",
          "signature": "DisplaceActorA !ActorId !ActorId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DisplaceActorA",
          "package": "LambdaHack",
          "partial": "Displace Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:DisplaceActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DisplayDelayD",
          "package": "LambdaHack",
          "signature": "DisplayDelayD !FactionId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DisplayDelayD",
          "package": "LambdaHack",
          "partial": "Display Delay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:DisplayDelayD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DisplayPushD",
          "package": "LambdaHack",
          "signature": "DisplayPushD !FactionId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "DisplayPushD",
          "package": "LambdaHack",
          "partial": "Display Push",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:DisplayPushD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "EffectD",
          "package": "LambdaHack",
          "signature": "EffectD !ActorId !(Effect Int)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "EffectD",
          "package": "LambdaHack",
          "partial": "Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:EffectD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HasteActorA",
          "package": "LambdaHack",
          "signature": "HasteActorA !ActorId !Speed",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HasteActorA",
          "package": "LambdaHack",
          "partial": "Haste Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:HasteActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HealActorA",
          "package": "LambdaHack",
          "signature": "HealActorA !ActorId !Int",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HealActorA",
          "package": "LambdaHack",
          "partial": "Heal Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:HealActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HitBlockD",
          "package": "LambdaHack",
          "signature": "HitBlockD",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#HitAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HitBlockD",
          "package": "LambdaHack",
          "partial": "Hit Block",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:HitBlockD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HitD",
          "package": "LambdaHack",
          "signature": "HitD",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#HitAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "HitD",
          "package": "LambdaHack",
          "partial": "Hit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:HitD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "KillExitA",
          "package": "LambdaHack",
          "signature": "KillExitA !FactionId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "KillExitA",
          "package": "LambdaHack",
          "partial": "Kill Exit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:KillExitA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LeadFactionA",
          "package": "LambdaHack",
          "signature": "LeadFactionA !FactionId !(Maybe ActorId) !(Maybe ActorId)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LeadFactionA",
          "package": "LambdaHack",
          "partial": "Lead Faction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:LeadFactionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseActorA",
          "package": "LambdaHack",
          "signature": "LoseActorA !ActorId !Actor ![(ItemId, Item)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseActorA",
          "normalized": "LoseActorA ActorId Actor[(ItemId,Item)]",
          "package": "LambdaHack",
          "partial": "Lose Actor",
          "signature": "LoseActorA ActorId Actor[(ItemId,Item)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:LoseActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseItemA",
          "package": "LambdaHack",
          "signature": "LoseItemA !ItemId !Item !Int !Container",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseItemA",
          "package": "LambdaHack",
          "partial": "Lose Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:LoseItemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseSmellA",
          "package": "LambdaHack",
          "signature": "LoseSmellA !LevelId ![(Point, Time)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseSmellA",
          "normalized": "LoseSmellA LevelId[(Point,Time)]",
          "package": "LambdaHack",
          "partial": "Lose Smell",
          "signature": "LoseSmellA LevelId[(Point,Time)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:LoseSmellA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseTileA",
          "package": "LambdaHack",
          "signature": "LoseTileA !LevelId ![(Point, Id TileKind)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "LoseTileA",
          "normalized": "LoseTileA LevelId[(Point,Id TileKind)]",
          "package": "LambdaHack",
          "partial": "Lose Tile",
          "signature": "LoseTileA LevelId[(Point,Id TileKind)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:LoseTileA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MissBlockD",
          "package": "LambdaHack",
          "signature": "MissBlockD",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#HitAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MissBlockD",
          "package": "LambdaHack",
          "partial": "Miss Block",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:MissBlockD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MoveActorA",
          "package": "LambdaHack",
          "signature": "MoveActorA !ActorId !Point !Point",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MoveActorA",
          "package": "LambdaHack",
          "partial": "Move Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:MoveActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MoveItemA",
          "package": "LambdaHack",
          "signature": "MoveItemA !ItemId !Int !Container !Container",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MoveItemA",
          "package": "LambdaHack",
          "partial": "Move Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:MoveItemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MsgAllA",
          "package": "LambdaHack",
          "signature": "MsgAllA !Msg",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MsgAllA",
          "package": "LambdaHack",
          "partial": "Msg All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:MsgAllA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MsgAllD",
          "package": "LambdaHack",
          "signature": "MsgAllD !Msg",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MsgAllD",
          "package": "LambdaHack",
          "partial": "Msg All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:MsgAllD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MsgFidD",
          "package": "LambdaHack",
          "signature": "MsgFidD !FactionId !Msg",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "MsgFidD",
          "package": "LambdaHack",
          "partial": "Msg Fid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:MsgFidD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "PerceptionA",
          "package": "LambdaHack",
          "signature": "PerceptionA !LevelId !Perception !Perception",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "PerceptionA",
          "package": "LambdaHack",
          "partial": "Perception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:PerceptionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ProjectD",
          "package": "LambdaHack",
          "signature": "ProjectD !ActorId !ItemId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ProjectD",
          "package": "LambdaHack",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:ProjectD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "QuitFactionA",
          "package": "LambdaHack",
          "signature": "QuitFactionA !FactionId !(Maybe Actor) !(Maybe Status) !(Maybe Status)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "QuitFactionA",
          "package": "LambdaHack",
          "partial": "Quit Faction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:QuitFactionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RecoilD",
          "package": "LambdaHack",
          "signature": "RecoilD !ActorId !ActorId !Item !HitAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RecoilD",
          "package": "LambdaHack",
          "partial": "Recoil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:RecoilD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RecordHistoryD",
          "package": "LambdaHack",
          "signature": "RecordHistoryD !FactionId",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RecordHistoryD",
          "package": "LambdaHack",
          "partial": "Record History",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:RecordHistoryD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RestartA",
          "package": "LambdaHack",
          "signature": "RestartA !FactionId !Discovery !FactionPers !State !DebugModeCli !Text",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RestartA",
          "package": "LambdaHack",
          "partial": "Restart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:RestartA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RestartServerA",
          "package": "LambdaHack",
          "signature": "RestartServerA !State",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "RestartServerA",
          "package": "LambdaHack",
          "partial": "Restart Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:RestartServerA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ResumeA",
          "package": "LambdaHack",
          "signature": "ResumeA !FactionId !FactionPers",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ResumeA",
          "package": "LambdaHack",
          "partial": "Resume",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:ResumeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ResumeServerA",
          "package": "LambdaHack",
          "signature": "ResumeServerA !State",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ResumeServerA",
          "package": "LambdaHack",
          "partial": "Resume Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:ResumeServerA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SaveBkpA",
          "package": "LambdaHack",
          "signature": "SaveBkpA",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SaveBkpA",
          "package": "LambdaHack",
          "partial": "Save Bkp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:SaveBkpA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SearchTileA",
          "package": "LambdaHack",
          "signature": "SearchTileA !ActorId !Point !(Id TileKind) !(Id TileKind)",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SearchTileA",
          "package": "LambdaHack",
          "partial": "Search Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:SearchTileA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SfxAtomic",
          "package": "LambdaHack",
          "signature": "SfxAtomic !SfxAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#Atomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SfxAtomic",
          "package": "LambdaHack",
          "partial": "Sfx Atomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:SfxAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ShunD",
          "package": "LambdaHack",
          "signature": "ShunD !ActorId !Point !Feature",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "ShunD",
          "package": "LambdaHack",
          "partial": "Shun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:ShunD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotActorA",
          "package": "LambdaHack",
          "signature": "SpotActorA !ActorId !Actor ![(ItemId, Item)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotActorA",
          "normalized": "SpotActorA ActorId Actor[(ItemId,Item)]",
          "package": "LambdaHack",
          "partial": "Spot Actor",
          "signature": "SpotActorA ActorId Actor[(ItemId,Item)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:SpotActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotItemA",
          "package": "LambdaHack",
          "signature": "SpotItemA !ItemId !Item !Int !Container",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotItemA",
          "package": "LambdaHack",
          "partial": "Spot Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:SpotItemA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotSmellA",
          "package": "LambdaHack",
          "signature": "SpotSmellA !LevelId ![(Point, Time)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotSmellA",
          "normalized": "SpotSmellA LevelId[(Point,Time)]",
          "package": "LambdaHack",
          "partial": "Spot Smell",
          "signature": "SpotSmellA LevelId[(Point,Time)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:SpotSmellA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotTileA",
          "package": "LambdaHack",
          "signature": "SpotTileA !LevelId ![(Point, Id TileKind)]",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "SpotTileA",
          "normalized": "SpotTileA LevelId[(Point,Id TileKind)]",
          "package": "LambdaHack",
          "partial": "Spot Tile",
          "signature": "SpotTileA LevelId[(Point,Id TileKind)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:SpotTileA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "StrikeD",
          "package": "LambdaHack",
          "signature": "StrikeD !ActorId !ActorId !Item !HitAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "StrikeD",
          "package": "LambdaHack",
          "partial": "Strike",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:StrikeD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "TrajectoryActorA",
          "package": "LambdaHack",
          "signature": "TrajectoryActorA !ActorId !(Maybe [Vector]) !(Maybe [Vector])",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "TrajectoryActorA",
          "normalized": "TrajectoryActorA ActorId(Maybe[Vector])(Maybe[Vector])",
          "package": "LambdaHack",
          "partial": "Trajectory Actor",
          "signature": "TrajectoryActorA ActorId(Maybe[Vector])(Maybe[Vector])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:TrajectoryActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "TriggerD",
          "package": "LambdaHack",
          "signature": "TriggerD !ActorId !Point !Feature",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#SfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "TriggerD",
          "package": "LambdaHack",
          "partial": "Trigger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:TriggerD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "WaitActorA",
          "package": "LambdaHack",
          "signature": "WaitActorA !ActorId !Bool !Bool",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#CmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "WaitActorA",
          "package": "LambdaHack",
          "partial": "Wait Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:WaitActorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "undoAtomic",
          "package": "LambdaHack",
          "signature": "Atomic -\u003e Maybe Atomic",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#undoAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "undoAtomic",
          "normalized": "Atomic-\u003eMaybe Atomic",
          "package": "LambdaHack",
          "partial": "Atomic",
          "signature": "Atomic-\u003eMaybe Atomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:undoAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "undoCmdAtomic",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e Maybe CmdAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#undoCmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "undoCmdAtomic",
          "normalized": "CmdAtomic-\u003eMaybe CmdAtomic",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "signature": "CmdAtomic-\u003eMaybe CmdAtomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:undoCmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "undoSfxAtomic",
          "package": "LambdaHack",
          "signature": "SfxAtomic -\u003e SfxAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicCmd.html#undoSfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicCmd",
          "module": "Game.LambdaHack.Common.AtomicCmd",
          "name": "undoSfxAtomic",
          "normalized": "SfxAtomic-\u003eSfxAtomic",
          "package": "LambdaHack",
          "partial": "Sfx Atomic",
          "signature": "SfxAtomic-\u003eSfxAtomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicCmd.html#v:undoSfxAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of atomic commands shared by client and server.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "AtomicPos",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of atomic commands shared by client and server See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "AtomicPos",
          "package": "LambdaHack",
          "partial": "Atomic Pos",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type representing visibility of actions to factions,\n based on the position of the action, etc.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosAtomic",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "data"
        },
        "index": {
          "description": "The type representing visibility of actions to factions based on the position of the action etc",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosAtomic",
          "package": "LambdaHack",
          "partial": "Pos Atomic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#t:PosAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeverybody notices\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosAll",
          "package": "LambdaHack",
          "signature": "PosAll",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "everybody notices",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosAll",
          "package": "LambdaHack",
          "partial": "Pos All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eonly the faction notices\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosFid",
          "package": "LambdaHack",
          "signature": "PosFid !FactionId",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "only the faction notices",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosFid",
          "package": "LambdaHack",
          "partial": "Pos Fid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosFid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efaction and server notices\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosFidAndSer",
          "package": "LambdaHack",
          "signature": "PosFidAndSer !FactionId",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "faction and server notices",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosFidAndSer",
          "package": "LambdaHack",
          "partial": "Pos Fid And Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosFidAndSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eobservers and the faction notice\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosFidAndSight",
          "package": "LambdaHack",
          "signature": "PosFidAndSight !FactionId !LevelId ![Point]",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "observers and the faction notice",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosFidAndSight",
          "normalized": "PosFidAndSight FactionId LevelId[Point]",
          "package": "LambdaHack",
          "partial": "Pos Fid And Sight",
          "signature": "PosFidAndSight FactionId LevelId[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosFidAndSight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enever broadcasted, but sent manually\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosNone",
          "package": "LambdaHack",
          "signature": "PosNone",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "never broadcasted but sent manually",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosNone",
          "package": "LambdaHack",
          "partial": "Pos None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eonly the server notices\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosSer",
          "package": "LambdaHack",
          "signature": "PosSer",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "only the server notices",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosSer",
          "package": "LambdaHack",
          "partial": "Pos Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhomever sees all the positions, notices\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosSight",
          "package": "LambdaHack",
          "signature": "PosSight !LevelId ![Point]",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "whomever sees all the positions notices",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosSight",
          "normalized": "PosSight LevelId[Point]",
          "package": "LambdaHack",
          "partial": "Pos Sight",
          "signature": "PosSight LevelId[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosSight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhomever smells all the positions, notices\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosSmell",
          "package": "LambdaHack",
          "signature": "PosSmell !LevelId ![Point]",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#PosAtomic",
          "type": "function"
        },
        "index": {
          "description": "whomever smells all the positions notices",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "PosSmell",
          "normalized": "PosSmell LevelId[Point]",
          "package": "LambdaHack",
          "partial": "Pos Smell",
          "signature": "PosSmell LevelId[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:PosSmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecompose an atomic action. The original action is visible\n if it's positions are visible both before and after the action\n (in between the FOV might have changed). The decomposed actions\n are only tested vs the FOV after the action and they give reduced\n information that still modifies client's state to match the server state\n wrt the current FOV and the subset of \u003ccode\u003eposCmdAtomic\u003c/code\u003e that is visible.\n The original actions give more information not only due to spanning\n potentially more positions than those visible. E.g., \u003ccode\u003eMoveActorA\u003c/code\u003e\n informs about the continued existence of the actor between\n moves, v.s., popping out of existence and then back in.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "breakCmdAtomic",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e m [CmdAtomic]",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#breakCmdAtomic",
          "type": "function"
        },
        "index": {
          "description": "Decompose an atomic action The original action is visible if it positions are visible both before and after the action in between the FOV might have changed The decomposed actions are only tested vs the FOV after the action and they give reduced information that still modifies client state to match the server state wrt the current FOV and the subset of posCmdAtomic that is visible The original actions give more information not only due to spanning potentially more positions than those visible E.g MoveActorA informs about the continued existence of the actor between moves v.s popping out of existence and then back in",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "breakCmdAtomic",
          "normalized": "CmdAtomic-\u003ea[CmdAtomic]",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "signature": "CmdAtomic-\u003em[CmdAtomic]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:breakCmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "loudCmdAtomic",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e CmdAtomic -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#loudCmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "loudCmdAtomic",
          "normalized": "FactionId-\u003eCmdAtomic-\u003eBool",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "signature": "FactionId-\u003eCmdAtomic-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:loudCmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduces the positions where the action takes place. If a faction\n is returned, the action is visible only for that faction, if Nothing\n is returned, it's never visible. Empty list of positions implies\n the action is visible always.\n\u003c/p\u003e\u003cp\u003eThe goal of the mechanics: client should not get significantly\n more information by looking at the atomic commands he is able to see\n than by looking at the state changes they enact. E.g., \u003ccode\u003eDisplaceActorA\u003c/code\u003e\n in a black room, with one actor carrying a 0-radius light would not be\n distinguishable by looking at the state (or the screen) from \u003ccode\u003eMoveActorA\u003c/code\u003e\n of the illuminated actor, hence such \u003ccode\u003eDisplaceActorA\u003c/code\u003e should not be\n observable, but \u003ccode\u003eMoveActorA\u003c/code\u003e should be (or the former should be perceived\n as the latter). However, to simplify, we assing as strict visibility\n requirements to \u003ccode\u003eMoveActorA\u003c/code\u003e as to \u003ccode\u003eDisplaceActorA\u003c/code\u003e and fall back\n to \u003ccode\u003eSpotActorA\u003c/code\u003e (which provides minimal information that does not\n contradict state) if the visibility is lower.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "posCmdAtomic",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e m PosAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#posCmdAtomic",
          "type": "function"
        },
        "index": {
          "description": "Produces the positions where the action takes place If faction is returned the action is visible only for that faction if Nothing is returned it never visible Empty list of positions implies the action is visible always The goal of the mechanics client should not get significantly more information by looking at the atomic commands he is able to see than by looking at the state changes they enact E.g DisplaceActorA in black room with one actor carrying radius light would not be distinguishable by looking at the state or the screen from MoveActorA of the illuminated actor hence such DisplaceActorA should not be observable but MoveActorA should be or the former should be perceived as the latter However to simplify we assing as strict visibility requirements to MoveActorA as to DisplaceActorA and fall back to SpotActorA which provides minimal information that does not contradict state if the visibility is lower",
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "posCmdAtomic",
          "normalized": "CmdAtomic-\u003ea PosAtomic",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "signature": "CmdAtomic-\u003em PosAtomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:posCmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "posSfxAtomic",
          "package": "LambdaHack",
          "signature": "SfxAtomic -\u003e m PosAtomic",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#posSfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "posSfxAtomic",
          "normalized": "SfxAtomic-\u003ea PosAtomic",
          "package": "LambdaHack",
          "partial": "Sfx Atomic",
          "signature": "SfxAtomic-\u003em PosAtomic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:posSfxAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "resetsFovAtomic",
          "package": "LambdaHack",
          "signature": "CmdAtomic -\u003e m (Maybe [FactionId])",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#resetsFovAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "resetsFovAtomic",
          "normalized": "CmdAtomic-\u003ea(Maybe[FactionId])",
          "package": "LambdaHack",
          "partial": "Fov Atomic",
          "signature": "CmdAtomic-\u003em(Maybe[FactionId])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:resetsFovAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "seenAtomicCli",
          "package": "LambdaHack",
          "signature": "Bool -\u003e FactionId -\u003e Perception -\u003e PosAtomic -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#seenAtomicCli",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "seenAtomicCli",
          "normalized": "Bool-\u003eFactionId-\u003ePerception-\u003ePosAtomic-\u003eBool",
          "package": "LambdaHack",
          "partial": "Atomic Cli",
          "signature": "Bool-\u003eFactionId-\u003ePerception-\u003ePosAtomic-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:seenAtomicCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "seenAtomicSer",
          "package": "LambdaHack",
          "signature": "PosAtomic -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-AtomicPos.html#seenAtomicSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicPos",
          "module": "Game.LambdaHack.Common.AtomicPos",
          "name": "seenAtomicSer",
          "normalized": "PosAtomic-\u003eBool",
          "package": "LambdaHack",
          "partial": "Atomic Ser",
          "signature": "PosAtomic-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicPos.html#v:seenAtomicSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of atomic commands shared by client and server.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.AtomicSem",
          "name": "AtomicSem",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-AtomicSem.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of atomic commands shared by client and server See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Common AtomicSem",
          "module": "Game.LambdaHack.Common.AtomicSem",
          "name": "AtomicSem",
          "package": "LambdaHack",
          "partial": "Atomic Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicSem",
          "name": "posOfAid",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m (LevelId, Point)",
          "source": "src/Game-LambdaHack-Common-AtomicSem.html#posOfAid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicSem",
          "module": "Game.LambdaHack.Common.AtomicSem",
          "name": "posOfAid",
          "normalized": "ActorId-\u003ea(LevelId,Point)",
          "package": "LambdaHack",
          "partial": "Of Aid",
          "signature": "ActorId-\u003em(LevelId,Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicSem.html#v:posOfAid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.AtomicSem",
          "name": "posOfContainer",
          "package": "LambdaHack",
          "signature": "Container -\u003e m (LevelId, Point)",
          "source": "src/Game-LambdaHack-Common-AtomicSem.html#posOfContainer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common AtomicSem",
          "module": "Game.LambdaHack.Common.AtomicSem",
          "name": "posOfContainer",
          "normalized": "Container-\u003ea(LevelId,Point)",
          "package": "LambdaHack",
          "partial": "Of Container",
          "signature": "Container-\u003em(LevelId,Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-AtomicSem.html#v:posOfContainer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstract syntax of client commands.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ClientCmd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html",
          "type": "module"
        },
        "index": {
          "description": "Abstract syntax of client commands See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ClientCmd",
          "package": "LambdaHack",
          "partial": "Client Cmd",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnection channels between the server and a single client.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ChanServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#ChanServer",
          "type": "data"
        },
        "index": {
          "description": "Connection channels between the server and single client",
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ChanServer",
          "package": "LambdaHack",
          "partial": "Chan Server",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#t:ChanServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract syntax of client commands that don't use the UI.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdClientAI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientAI",
          "type": "data"
        },
        "index": {
          "description": "Abstract syntax of client commands that don use the UI",
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdClientAI",
          "package": "LambdaHack",
          "partial": "Cmd Client AI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#t:CmdClientAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract syntax of client commands that use the UI.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdClientUI",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientUI",
          "type": "data"
        },
        "index": {
          "description": "Abstract syntax of client commands that use the UI",
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdClientUI",
          "package": "LambdaHack",
          "partial": "Cmd Client UI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#t:CmdClientUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnection information for all factions, indexed by faction identifier.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ConnServerDict",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#ConnServerDict",
          "type": "type"
        },
        "index": {
          "description": "Connection information for all factions indexed by faction identifier",
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ConnServerDict",
          "package": "LambdaHack",
          "partial": "Conn Server Dict",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#t:ConnServerDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConnections to the human-controlled client of a faction and\n to the AI client for the same faction.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ConnServerFaction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#ConnServerFaction",
          "type": "type"
        },
        "index": {
          "description": "Connections to the human-controlled client of faction and to the AI client for the same faction",
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ConnServerFaction",
          "package": "LambdaHack",
          "partial": "Conn Server Faction",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#t:ConnServerFaction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ChanServer",
          "package": "LambdaHack",
          "signature": "ChanServer",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#ChanServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "ChanServer",
          "package": "LambdaHack",
          "partial": "Chan Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:ChanServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdAtomicAI",
          "package": "LambdaHack",
          "signature": "CmdAtomicAI !CmdAtomic",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdAtomicAI",
          "package": "LambdaHack",
          "partial": "Cmd Atomic AI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:CmdAtomicAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdAtomicUI",
          "package": "LambdaHack",
          "signature": "CmdAtomicUI !CmdAtomic",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdAtomicUI",
          "package": "LambdaHack",
          "partial": "Cmd Atomic UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:CmdAtomicUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdPingAI",
          "package": "LambdaHack",
          "signature": "CmdPingAI",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdPingAI",
          "package": "LambdaHack",
          "partial": "Cmd Ping AI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:CmdPingAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdPingUI",
          "package": "LambdaHack",
          "signature": "CmdPingUI",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdPingUI",
          "package": "LambdaHack",
          "partial": "Cmd Ping UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:CmdPingUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdQueryAI",
          "package": "LambdaHack",
          "signature": "CmdQueryAI !ActorId",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdQueryAI",
          "package": "LambdaHack",
          "partial": "Cmd Query AI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:CmdQueryAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdQueryUI",
          "package": "LambdaHack",
          "signature": "CmdQueryUI !ActorId",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "CmdQueryUI",
          "package": "LambdaHack",
          "partial": "Cmd Query UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:CmdQueryUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "SfxAtomicUI",
          "package": "LambdaHack",
          "signature": "SfxAtomicUI !SfxAtomic",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#CmdClientUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "SfxAtomicUI",
          "package": "LambdaHack",
          "partial": "Sfx Atomic UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:SfxAtomicUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "debugAid",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Text -\u003e a -\u003e m Text",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#debugAid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "debugAid",
          "normalized": "ActorId-\u003eText-\u003ea-\u003eb Text",
          "package": "LambdaHack",
          "partial": "Aid",
          "signature": "ActorId-\u003eText-\u003ea-\u003em Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:debugAid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "debugCmdClientAI",
          "package": "LambdaHack",
          "signature": "CmdClientAI -\u003e m Text",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#debugCmdClientAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "debugCmdClientAI",
          "normalized": "CmdClientAI-\u003ea Text",
          "package": "LambdaHack",
          "partial": "Cmd Client AI",
          "signature": "CmdClientAI-\u003em Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:debugCmdClientAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "debugCmdClientUI",
          "package": "LambdaHack",
          "signature": "CmdClientUI -\u003e m Text",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#debugCmdClientUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "debugCmdClientUI",
          "normalized": "CmdClientUI-\u003ea Text",
          "package": "LambdaHack",
          "partial": "Cmd Client UI",
          "signature": "CmdClientUI-\u003em Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:debugCmdClientUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "fromServer",
          "package": "LambdaHack",
          "signature": "(TQueue c)",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#ChanServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "fromServer",
          "package": "LambdaHack",
          "partial": "Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:fromServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "toServer",
          "package": "LambdaHack",
          "signature": "(TQueue d)",
          "source": "src/Game-LambdaHack-Common-ClientCmd.html#ChanServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ClientCmd",
          "module": "Game.LambdaHack.Common.ClientCmd",
          "name": "toServer",
          "package": "LambdaHack",
          "partial": "Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ClientCmd.html#v:toServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eColours and text attributes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Color",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Color.html",
          "type": "module"
        },
        "index": {
          "description": "Colours and text attributes",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Color",
          "package": "LambdaHack",
          "partial": "Color",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eText attributes: foreground and backgroud colors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Attr",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Color.html#Attr",
          "type": "data"
        },
        "index": {
          "description": "Text attributes foreground and backgroud colors",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Attr",
          "package": "LambdaHack",
          "partial": "Attr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#t:Attr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "AttrChar",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Color.html#AttrChar",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "AttrChar",
          "package": "LambdaHack",
          "partial": "Attr Char",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#t:AttrChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eColours supported by the major frontends.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Color",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "data"
        },
        "index": {
          "description": "Colours supported by the major frontends",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Color",
          "package": "LambdaHack",
          "partial": "Color",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#t:Color"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Attr",
          "package": "LambdaHack",
          "signature": "Attr",
          "source": "src/Game-LambdaHack-Common-Color.html#Attr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Attr",
          "package": "LambdaHack",
          "partial": "Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Attr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "AttrChar",
          "package": "LambdaHack",
          "signature": "AttrChar",
          "source": "src/Game-LambdaHack-Common-Color.html#AttrChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "AttrChar",
          "package": "LambdaHack",
          "partial": "Attr Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:AttrChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Black",
          "package": "LambdaHack",
          "signature": "Black",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Black",
          "package": "LambdaHack",
          "partial": "Black",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Black"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Blue",
          "package": "LambdaHack",
          "signature": "Blue",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Blue",
          "package": "LambdaHack",
          "partial": "Blue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Blue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrBlack",
          "package": "LambdaHack",
          "signature": "BrBlack",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrBlack",
          "package": "LambdaHack",
          "partial": "Br Black",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrBlack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrBlue",
          "package": "LambdaHack",
          "signature": "BrBlue",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrBlue",
          "package": "LambdaHack",
          "partial": "Br Blue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrBlue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrCyan",
          "package": "LambdaHack",
          "signature": "BrCyan",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrCyan",
          "package": "LambdaHack",
          "partial": "Br Cyan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrCyan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrGreen",
          "package": "LambdaHack",
          "signature": "BrGreen",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrGreen",
          "package": "LambdaHack",
          "partial": "Br Green",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrGreen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrMagenta",
          "package": "LambdaHack",
          "signature": "BrMagenta",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrMagenta",
          "package": "LambdaHack",
          "partial": "Br Magenta",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrMagenta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrRed",
          "package": "LambdaHack",
          "signature": "BrRed",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrRed",
          "package": "LambdaHack",
          "partial": "Br Red",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrRed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrWhite",
          "package": "LambdaHack",
          "signature": "BrWhite",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrWhite",
          "package": "LambdaHack",
          "partial": "Br White",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrWhite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrYellow",
          "package": "LambdaHack",
          "signature": "BrYellow",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "BrYellow",
          "package": "LambdaHack",
          "partial": "Br Yellow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:BrYellow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Brown",
          "package": "LambdaHack",
          "signature": "Brown",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Brown",
          "package": "LambdaHack",
          "partial": "Brown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Brown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Cyan",
          "package": "LambdaHack",
          "signature": "Cyan",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Cyan",
          "package": "LambdaHack",
          "partial": "Cyan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Cyan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Green",
          "package": "LambdaHack",
          "signature": "Green",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Green",
          "package": "LambdaHack",
          "partial": "Green",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Green"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Magenta",
          "package": "LambdaHack",
          "signature": "Magenta",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Magenta",
          "package": "LambdaHack",
          "partial": "Magenta",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Magenta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "Red",
          "package": "LambdaHack",
          "signature": "Red",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "Red",
          "package": "LambdaHack",
          "partial": "Red",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:Red"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "White",
          "package": "LambdaHack",
          "signature": "White",
          "source": "src/Game-LambdaHack-Common-Color.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "White",
          "package": "LambdaHack",
          "partial": "White",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:White"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "acAttr",
          "package": "LambdaHack",
          "signature": "Attr",
          "source": "src/Game-LambdaHack-Common-Color.html#AttrChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "acAttr",
          "package": "LambdaHack",
          "partial": "Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:acAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Color",
          "name": "acChar",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Common-Color.html#AttrChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "acChar",
          "package": "LambdaHack",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:acChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebackgroud color\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "bg",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Common-Color.html#Attr",
          "type": "function"
        },
        "index": {
          "description": "backgroud color",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "bg",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:bg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eColour sets.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "brightCol",
          "package": "LambdaHack",
          "signature": "[Color]",
          "source": "src/Game-LambdaHack-Common-Color.html#brightCol",
          "type": "function"
        },
        "index": {
          "description": "Colour sets",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "brightCol",
          "normalized": "[Color]",
          "package": "LambdaHack",
          "partial": "Col",
          "signature": "[Color]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:brightCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslationg to heavily modified Linux console color RGB values.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "colorToRGB",
          "package": "LambdaHack",
          "signature": "Color -\u003e String",
          "source": "src/Game-LambdaHack-Common-Color.html#colorToRGB",
          "type": "function"
        },
        "index": {
          "description": "Translationg to heavily modified Linux console color RGB values",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "colorToRGB",
          "normalized": "Color-\u003eString",
          "package": "LambdaHack",
          "partial": "To RGB",
          "signature": "Color-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:colorToRGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eColour sets.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "darkCol",
          "package": "LambdaHack",
          "signature": "[Color]",
          "source": "src/Game-LambdaHack-Common-Color.html#darkCol",
          "type": "function"
        },
        "index": {
          "description": "Colour sets",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "darkCol",
          "normalized": "[Color]",
          "package": "LambdaHack",
          "partial": "Col",
          "signature": "[Color]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:darkCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default attribute, to optimize attribute setting.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "defAttr",
          "package": "LambdaHack",
          "signature": "Attr",
          "source": "src/Game-LambdaHack-Common-Color.html#defAttr",
          "type": "function"
        },
        "index": {
          "description": "The default attribute to optimize attribute setting",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "defAttr",
          "package": "LambdaHack",
          "partial": "Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:defAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default colours, to optimize attribute setting.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "defBG",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Common-Color.html#defBG",
          "type": "function"
        },
        "index": {
          "description": "The default colours to optimize attribute setting",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "defBG",
          "package": "LambdaHack",
          "partial": "BG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:defBG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default colours, to optimize attribute setting.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "defFG",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Common-Color.html#defFG",
          "type": "function"
        },
        "index": {
          "description": "The default colours to optimize attribute setting",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "defFG",
          "package": "LambdaHack",
          "partial": "FG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:defFG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eforeground colour\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "fg",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Common-Color.html#Attr",
          "type": "function"
        },
        "index": {
          "description": "foreground colour",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "fg",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:fg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA helper for the terminal frontends that display bright via bold.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "isBright",
          "package": "LambdaHack",
          "signature": "Color -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Color.html#isBright",
          "type": "function"
        },
        "index": {
          "description": "helper for the terminal frontends that display bright via bold",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "isBright",
          "normalized": "Color-\u003eBool",
          "package": "LambdaHack",
          "partial": "Bright",
          "signature": "Color-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:isBright"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDue to the limitation of the curses library used in the curses frontend,\n only these are legal backgrounds.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "legalBG",
          "package": "LambdaHack",
          "signature": "[Color]",
          "source": "src/Game-LambdaHack-Common-Color.html#legalBG",
          "type": "function"
        },
        "index": {
          "description": "Due to the limitation of the curses library used in the curses frontend only these are legal backgrounds",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "legalBG",
          "normalized": "[Color]",
          "package": "LambdaHack",
          "partial": "BG",
          "signature": "[Color]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:legalBG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eColour sets.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Color",
          "name": "stdCol",
          "package": "LambdaHack",
          "signature": "[Color]",
          "source": "src/Game-LambdaHack-Common-Color.html#stdCol",
          "type": "function"
        },
        "index": {
          "description": "Colour sets",
          "hierarchy": "Game LambdaHack Common Color",
          "module": "Game.LambdaHack.Common.Color",
          "name": "stdCol",
          "normalized": "[Color]",
          "package": "LambdaHack",
          "partial": "Col",
          "signature": "[Color]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Color.html#v:stdCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA game requires the engine provided by the library, perhaps customized,\n and game content, defined completely afresh for the particular game.\n The general type of the content is \u003ccode\u003eContentDef\u003c/code\u003e and it has instances\n for all content kinds, such as items kinds\n (\u003ccode\u003eGame.LambdaHack.Content.ItemKind\u003c/code\u003e).\n The possible kinds are fixed in the library and all defined in the same\n directory. On the other hand, game content, that is all elements\n of \u003ccode\u003eContentDef\u003c/code\u003e instances, are defined in a directory\n of the game code proper, with names corresponding to their kinds.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "ContentDef",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ContentDef.html",
          "type": "module"
        },
        "index": {
          "description": "game requires the engine provided by the library perhaps customized and game content defined completely afresh for the particular game The general type of the content is ContentDef and it has instances for all content kinds such as items kinds Game.LambdaHack.Content.ItemKind The possible kinds are fixed in the library and all defined in the same directory On the other hand game content that is all elements of ContentDef instances are defined in directory of the game code proper with names corresponding to their kinds",
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "ContentDef",
          "package": "LambdaHack",
          "partial": "Content Def",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe general type of a particular game content, e.g., item kinds.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "ContentDef",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ContentDef.html#ContentDef",
          "type": "data"
        },
        "index": {
          "description": "The general type of particular game content e.g item kinds",
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "ContentDef",
          "package": "LambdaHack",
          "partial": "Content Def",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#t:ContentDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "ContentDef",
          "package": "LambdaHack",
          "signature": "ContentDef",
          "source": "src/Game-LambdaHack-Common-ContentDef.html#ContentDef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "ContentDef",
          "package": "LambdaHack",
          "partial": "Content Def",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#v:ContentDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eall the defined content of this type\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "content",
          "package": "LambdaHack",
          "signature": "[a]",
          "source": "src/Game-LambdaHack-Common-ContentDef.html#ContentDef",
          "type": "function"
        },
        "index": {
          "description": "all the defined content of this type",
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "content",
          "normalized": "[a]",
          "package": "LambdaHack",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#v:content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "getFreq",
          "package": "LambdaHack",
          "signature": "a -\u003e Freqs",
          "source": "src/Game-LambdaHack-Common-ContentDef.html#ContentDef",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "getFreq",
          "normalized": "a-\u003eFreqs",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "a-\u003eFreqs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#v:getFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename, e.g., to show to the player\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "getName",
          "package": "LambdaHack",
          "signature": "a -\u003e Text",
          "source": "src/Game-LambdaHack-Common-ContentDef.html#ContentDef",
          "type": "function"
        },
        "index": {
          "description": "name e.g to show to the player",
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "getName",
          "normalized": "a-\u003eText",
          "package": "LambdaHack",
          "partial": "Name",
          "signature": "a-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#v:getName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esymbol, e.g., to print on the map\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "getSymbol",
          "package": "LambdaHack",
          "signature": "a -\u003e Char",
          "source": "src/Game-LambdaHack-Common-ContentDef.html#ContentDef",
          "type": "function"
        },
        "index": {
          "description": "symbol e.g to print on the map",
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "getSymbol",
          "normalized": "a-\u003eChar",
          "package": "LambdaHack",
          "partial": "Symbol",
          "signature": "a-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#v:getSymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evalidate and catch some offenders, if any\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "validate",
          "package": "LambdaHack",
          "signature": "[a] -\u003e [a]",
          "source": "src/Game-LambdaHack-Common-ContentDef.html#ContentDef",
          "type": "function"
        },
        "index": {
          "description": "validate and catch some offenders if any",
          "hierarchy": "Game LambdaHack Common ContentDef",
          "module": "Game.LambdaHack.Common.ContentDef",
          "name": "validate",
          "normalized": "[a]-\u003e[a]",
          "package": "LambdaHack",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ContentDef.html#v:validate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEffects of content on other content. No operation in this module\n involves the \u003ccode\u003eState\u003c/code\u003e or \u003ccode\u003eAction\u003c/code\u003e type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Effect",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Effect.html",
          "type": "module"
        },
        "index": {
          "description": "Effects of content on other content No operation in this module involves the State or Action type",
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Effect",
          "package": "LambdaHack",
          "partial": "Effect",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Effect",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Effect",
          "package": "LambdaHack",
          "partial": "Effect",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#t:Effect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "ApplyPerfume",
          "package": "LambdaHack",
          "signature": "ApplyPerfume",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "ApplyPerfume",
          "package": "LambdaHack",
          "partial": "Apply Perfume",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:ApplyPerfume"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Ascend",
          "package": "LambdaHack",
          "signature": "Ascend !Int",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Ascend",
          "package": "LambdaHack",
          "partial": "Ascend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Ascend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "CallFriend",
          "package": "LambdaHack",
          "signature": "CallFriend !Int",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "CallFriend",
          "package": "LambdaHack",
          "partial": "Call Friend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:CallFriend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "CreateItem",
          "package": "LambdaHack",
          "signature": "CreateItem !Int",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "CreateItem",
          "package": "LambdaHack",
          "partial": "Create Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:CreateItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Dominate",
          "package": "LambdaHack",
          "signature": "Dominate",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Dominate",
          "package": "LambdaHack",
          "partial": "Dominate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Dominate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Escape",
          "package": "LambdaHack",
          "signature": "Escape !Int",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Escape",
          "package": "LambdaHack",
          "partial": "Escape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Escape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Heal",
          "package": "LambdaHack",
          "signature": "Heal !Int",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Heal",
          "package": "LambdaHack",
          "partial": "Heal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Heal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Hurt",
          "package": "LambdaHack",
          "signature": "Hurt !RollDice !a",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Hurt",
          "package": "LambdaHack",
          "partial": "Hurt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Hurt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Mindprobe",
          "package": "LambdaHack",
          "signature": "Mindprobe Int",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Mindprobe",
          "package": "LambdaHack",
          "partial": "Mindprobe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Mindprobe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "NoEffect",
          "package": "LambdaHack",
          "signature": "NoEffect",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "NoEffect",
          "package": "LambdaHack",
          "partial": "No Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:NoEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Regeneration",
          "package": "LambdaHack",
          "signature": "Regeneration !a",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Regeneration",
          "package": "LambdaHack",
          "partial": "Regeneration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Regeneration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Searching",
          "package": "LambdaHack",
          "signature": "Searching !a",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Searching",
          "package": "LambdaHack",
          "partial": "Searching",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Searching"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Summon",
          "package": "LambdaHack",
          "signature": "Summon !Int",
          "source": "src/Game-LambdaHack-Common-Effect.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "Summon",
          "package": "LambdaHack",
          "partial": "Summon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:Summon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Effect",
          "name": "effectToSuffix",
          "package": "LambdaHack",
          "signature": "Effect Int -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Effect.html#effectToSuffix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "effectToSuffix",
          "normalized": "Effect Int-\u003eText",
          "package": "LambdaHack",
          "partial": "To Suffix",
          "signature": "Effect Int-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:effectToSuffix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform an effect using a stateful function.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "effectTrav",
          "package": "LambdaHack",
          "signature": "Effect a -\u003e (a -\u003e State s b) -\u003e State s (Effect b)",
          "source": "src/Game-LambdaHack-Common-Effect.html#effectTrav",
          "type": "function"
        },
        "index": {
          "description": "Transform an effect using stateful function",
          "hierarchy": "Game LambdaHack Common Effect",
          "module": "Game.LambdaHack.Common.Effect",
          "name": "effectTrav",
          "normalized": "Effect a-\u003e(a-\u003eState b c)-\u003eState b(Effect c)",
          "package": "LambdaHack",
          "partial": "Trav",
          "signature": "Effect a-\u003e(a-\u003eState s b)-\u003eState s(Effect b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Effect.html#v:effectTrav"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFactions taking part in the game: e.g., two human players controlling\n the hero faction battling the monster and the animal factions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Faction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Faction.html",
          "type": "module"
        },
        "index": {
          "description": "Factions taking part in the game e.g two human players controlling the hero faction battling the monster and the animal factions",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Faction",
          "package": "LambdaHack",
          "partial": "Faction",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDiplomacy states. Higher overwrite lower in case of assymetric content.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Diplomacy",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Faction.html#Diplomacy",
          "type": "data"
        },
        "index": {
          "description": "Diplomacy states Higher overwrite lower in case of assymetric content",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Diplomacy",
          "package": "LambdaHack",
          "partial": "Diplomacy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#t:Diplomacy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Faction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Faction",
          "package": "LambdaHack",
          "partial": "Faction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#t:Faction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll factions in the game, indexed by faction identifier.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "FactionDict",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Faction.html#FactionDict",
          "type": "type"
        },
        "index": {
          "description": "All factions in the game indexed by faction identifier",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "FactionDict",
          "package": "LambdaHack",
          "partial": "Faction Dict",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#t:FactionDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA unique identifier of a faction in a game.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "FactionId",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Misc.html#FactionId",
          "type": "data"
        },
        "index": {
          "description": "unique identifier of faction in game",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "FactionId",
          "package": "LambdaHack",
          "partial": "Faction Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#t:FactionId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutcome of a game.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Outcome",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Faction.html#Outcome",
          "type": "data"
        },
        "index": {
          "description": "Outcome of game",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Outcome",
          "package": "LambdaHack",
          "partial": "Outcome",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#t:Outcome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent game status.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Status",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Faction.html#Status",
          "type": "data"
        },
        "index": {
          "description": "Current game status",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Status",
          "package": "LambdaHack",
          "partial": "Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#t:Status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Alliance",
          "package": "LambdaHack",
          "signature": "Alliance",
          "source": "src/Game-LambdaHack-Common-Faction.html#Diplomacy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Alliance",
          "package": "LambdaHack",
          "partial": "Alliance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Alliance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egame is supended\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Camping",
          "package": "LambdaHack",
          "signature": "Camping",
          "source": "src/Game-LambdaHack-Common-Faction.html#Outcome",
          "type": "function"
        },
        "index": {
          "description": "game is supended",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Camping",
          "package": "LambdaHack",
          "partial": "Camping",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Camping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe player won by eliminating all rivals\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Conquer",
          "package": "LambdaHack",
          "signature": "Conquer",
          "source": "src/Game-LambdaHack-Common-Faction.html#Outcome",
          "type": "function"
        },
        "index": {
          "description": "the player won by eliminating all rivals",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Conquer",
          "package": "LambdaHack",
          "partial": "Conquer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Conquer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe faction lost the game in another way\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Defeated",
          "package": "LambdaHack",
          "signature": "Defeated",
          "source": "src/Game-LambdaHack-Common-Faction.html#Outcome",
          "type": "function"
        },
        "index": {
          "description": "the faction lost the game in another way",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Defeated",
          "package": "LambdaHack",
          "partial": "Defeated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Defeated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe player escaped the dungeon alive\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Escape",
          "package": "LambdaHack",
          "signature": "Escape",
          "source": "src/Game-LambdaHack-Common-Faction.html#Outcome",
          "type": "function"
        },
        "index": {
          "description": "the player escaped the dungeon alive",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Escape",
          "package": "LambdaHack",
          "partial": "Escape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Escape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Faction",
          "package": "LambdaHack",
          "signature": "Faction",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Faction",
          "package": "LambdaHack",
          "partial": "Faction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Faction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe faction was eliminated\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Killed",
          "package": "LambdaHack",
          "signature": "Killed",
          "source": "src/Game-LambdaHack-Common-Faction.html#Outcome",
          "type": "function"
        },
        "index": {
          "description": "the faction was eliminated",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Killed",
          "package": "LambdaHack",
          "partial": "Killed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Killed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Neutral",
          "package": "LambdaHack",
          "signature": "Neutral",
          "source": "src/Game-LambdaHack-Common-Faction.html#Diplomacy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Neutral",
          "package": "LambdaHack",
          "partial": "Neutral",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Neutral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egame is restarted\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Restart",
          "package": "LambdaHack",
          "signature": "Restart",
          "source": "src/Game-LambdaHack-Common-Faction.html#Outcome",
          "type": "function"
        },
        "index": {
          "description": "game is restarted",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Restart",
          "package": "LambdaHack",
          "partial": "Restart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Restart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Status",
          "package": "LambdaHack",
          "signature": "Status",
          "source": "src/Game-LambdaHack-Common-Faction.html#Status",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Status",
          "package": "LambdaHack",
          "partial": "Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Unknown",
          "package": "LambdaHack",
          "signature": "Unknown",
          "source": "src/Game-LambdaHack-Common-Faction.html#Diplomacy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "Unknown",
          "package": "LambdaHack",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Faction",
          "name": "War",
          "package": "LambdaHack",
          "signature": "War",
          "source": "src/Game-LambdaHack-Common-Faction.html#Diplomacy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "War",
          "package": "LambdaHack",
          "partial": "War",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:War"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecolor of actors or their frames\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gcolor",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "description": "color of actors or their frames",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gcolor",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:gcolor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ediplomatic mode\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gdipl",
          "package": "LambdaHack",
          "signature": "Dipl",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "description": "diplomatic mode",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gdipl",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:gdipl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe kind of the faction\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gkind",
          "package": "LambdaHack",
          "signature": "(Id FactionKind)",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "description": "the kind of the faction",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gkind",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:gkind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe leader of the faction, if any\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gleader",
          "package": "LambdaHack",
          "signature": "(Maybe ActorId)",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "description": "the leader of the faction if any",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gleader",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:gleader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "description": "individual name",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:gname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe player spec for this faction\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gplayer",
          "package": "LambdaHack",
          "signature": "Player",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "description": "the player spec for this faction",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gplayer",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:gplayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecause of game end/exit\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gquit",
          "package": "LambdaHack",
          "signature": "(Maybe Status)",
          "source": "src/Game-LambdaHack-Common-Faction.html#Faction",
          "type": "function"
        },
        "index": {
          "description": "cause of game end exit",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "gquit",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:gquit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if factions are allied. Assumes symmetry.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isAllied",
          "package": "LambdaHack",
          "signature": "Faction -\u003e FactionId -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Faction.html#isAllied",
          "type": "function"
        },
        "index": {
          "description": "Check if factions are allied Assumes symmetry",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isAllied",
          "normalized": "Faction-\u003eFactionId-\u003eBool",
          "package": "LambdaHack",
          "partial": "Allied",
          "signature": "Faction-\u003eFactionId-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:isAllied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if factions are at war. Assumes symmetry.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isAtWar",
          "package": "LambdaHack",
          "signature": "Faction -\u003e FactionId -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Faction.html#isAtWar",
          "type": "function"
        },
        "index": {
          "description": "Check if factions are at war Assumes symmetry",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isAtWar",
          "normalized": "Faction-\u003eFactionId-\u003eBool",
          "package": "LambdaHack",
          "partial": "At War",
          "signature": "Faction-\u003eFactionId-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:isAtWar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTell whether the faction consists of heroes.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isHeroFact",
          "package": "LambdaHack",
          "signature": "COps -\u003e Faction -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Faction.html#isHeroFact",
          "type": "function"
        },
        "index": {
          "description": "Tell whether the faction consists of heroes",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isHeroFact",
          "normalized": "COps-\u003eFaction-\u003eBool",
          "package": "LambdaHack",
          "partial": "Hero Fact",
          "signature": "COps-\u003eFaction-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:isHeroFact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTell whether the faction consists of summoned horrors only.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isHorrorFact",
          "package": "LambdaHack",
          "signature": "COps -\u003e Faction -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Faction.html#isHorrorFact",
          "type": "function"
        },
        "index": {
          "description": "Tell whether the faction consists of summoned horrors only",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isHorrorFact",
          "normalized": "COps-\u003eFaction-\u003eBool",
          "package": "LambdaHack",
          "partial": "Horror Fact",
          "signature": "COps-\u003eFaction-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:isHorrorFact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTell whether the faction can spawn actors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isSpawnFact",
          "package": "LambdaHack",
          "signature": "Faction -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Faction.html#isSpawnFact",
          "type": "function"
        },
        "index": {
          "description": "Tell whether the faction can spawn actors",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isSpawnFact",
          "normalized": "Faction-\u003eBool",
          "package": "LambdaHack",
          "partial": "Spawn Fact",
          "signature": "Faction-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:isSpawnFact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTell whether actors of the faction can be summoned by items, etc.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isSummonFact",
          "package": "LambdaHack",
          "signature": "COps -\u003e Faction -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Faction.html#isSummonFact",
          "type": "function"
        },
        "index": {
          "description": "Tell whether actors of the faction can be summoned by items etc",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "isSummonFact",
          "normalized": "COps-\u003eFaction-\u003eBool",
          "package": "LambdaHack",
          "partial": "Summon Fact",
          "signature": "COps-\u003eFaction-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:isSummonFact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edepth of the final encounter\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "stDepth",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Faction.html#Status",
          "type": "function"
        },
        "index": {
          "description": "depth of the final encounter",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "stDepth",
          "package": "LambdaHack",
          "partial": "Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:stDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextra information\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "stInfo",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Common-Faction.html#Status",
          "type": "function"
        },
        "index": {
          "description": "extra information",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "stInfo",
          "package": "LambdaHack",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:stInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent game outcome\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "stOutcome",
          "package": "LambdaHack",
          "signature": "Outcome",
          "source": "src/Game-LambdaHack-Common-Faction.html#Status",
          "type": "function"
        },
        "index": {
          "description": "current game outcome",
          "hierarchy": "Game LambdaHack Common Faction",
          "module": "Game.LambdaHack.Common.Faction",
          "name": "stOutcome",
          "package": "LambdaHack",
          "partial": "Outcome",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Faction.html#v:stOutcome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTerrain tile features.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Feature",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Feature.html",
          "type": "module"
        },
        "index": {
          "description": "Terrain tile features",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Feature",
          "package": "LambdaHack",
          "partial": "Feature",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll possible terrain tile features.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Feature",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "data"
        },
        "index": {
          "description": "All possible terrain tile features",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Feature",
          "package": "LambdaHack",
          "partial": "Feature",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#t:Feature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esustains the effect continuously, TODO\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Aura",
          "package": "LambdaHack",
          "signature": "Aura !(Effect Int)",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "sustains the effect continuously TODO",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Aura",
          "package": "LambdaHack",
          "partial": "Aura",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Aura"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eactors and stairs can be generated there\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "CanActor",
          "package": "LambdaHack",
          "signature": "CanActor",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "actors and stairs can be generated there",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "CanActor",
          "package": "LambdaHack",
          "partial": "Can Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:CanActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eitems can be generated there\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "CanItem",
          "package": "LambdaHack",
          "signature": "CanItem",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "items can be generated there",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "CanItem",
          "package": "LambdaHack",
          "partial": "Can Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:CanItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecauses the effect when triggered\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Cause",
          "package": "LambdaHack",
          "signature": "Cause !(Effect Int)",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "causes the effect when triggered",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Cause",
          "package": "LambdaHack",
          "partial": "Cause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Cause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealters tile, but does not change walkability\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "ChangeTo",
          "package": "LambdaHack",
          "signature": "ChangeTo !Text",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "alters tile but does not change walkability",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "ChangeTo",
          "package": "LambdaHack",
          "partial": "Change To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:ChangeTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eactors can see through\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Clear",
          "package": "LambdaHack",
          "signature": "Clear",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "actors can see through",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Clear",
          "package": "LambdaHack",
          "partial": "Clear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Clear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egoes from an open to a closed tile when altered\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "CloseTo",
          "package": "LambdaHack",
          "signature": "CloseTo !Text",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "goes from an open to closed tile when altered",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "CloseTo",
          "package": "LambdaHack",
          "partial": "Close To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:CloseTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis not lit with an ambient shine\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Dark",
          "package": "LambdaHack",
          "signature": "Dark",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "is not lit with an ambient shine",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Dark",
          "package": "LambdaHack",
          "partial": "Dark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Dark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhen hidden, looks as a tile of the group\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "HideAs",
          "package": "LambdaHack",
          "signature": "HideAs !Text",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "when hidden looks as tile of the group",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "HideAs",
          "package": "LambdaHack",
          "partial": "Hide As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:HideAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecan never be excavated nor seen through\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Impenetrable",
          "package": "LambdaHack",
          "signature": "Impenetrable",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "can never be excavated nor seen through",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Impenetrable",
          "package": "LambdaHack",
          "partial": "Impenetrable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Impenetrable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egoes from a closed to an open tile when altered\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "OpenTo",
          "package": "LambdaHack",
          "signature": "OpenTo !Text",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "goes from closed to an open tile when altered",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "OpenTo",
          "package": "LambdaHack",
          "partial": "Open To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:OpenTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif secret, can be revealed to belong to the group\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "RevealAs",
          "package": "LambdaHack",
          "signature": "RevealAs !Text",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "if secret can be revealed to belong to the group",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "RevealAs",
          "package": "LambdaHack",
          "partial": "Reveal As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:RevealAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emay not be what it seems (clients only)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Suspect",
          "package": "LambdaHack",
          "signature": "Suspect",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "may not be what it seems clients only",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Suspect",
          "package": "LambdaHack",
          "partial": "Suspect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Suspect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eused for visible trails throughout the level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Trail",
          "package": "LambdaHack",
          "signature": "Trail",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "used for visible trails throughout the level",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Trail",
          "package": "LambdaHack",
          "partial": "Trail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Trail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eactors can walk through\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Walkable",
          "package": "LambdaHack",
          "signature": "Walkable",
          "source": "src/Game-LambdaHack-Common-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "actors can walk through",
          "hierarchy": "Game LambdaHack Common Feature",
          "module": "Game.LambdaHack.Common.Feature",
          "name": "Walkable",
          "package": "LambdaHack",
          "partial": "Walkable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Feature.html#v:Walkable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe appearance of in-game items, as communicated to the player.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "Flavour",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Flavour.html",
          "type": "module"
        },
        "index": {
          "description": "The appearance of in-game items as communicated to the player",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "Flavour",
          "package": "LambdaHack",
          "partial": "Flavour",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of item flavours.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "Flavour",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Flavour.html#Flavour",
          "type": "data"
        },
        "index": {
          "description": "The type of item flavours",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "Flavour",
          "package": "LambdaHack",
          "partial": "Flavour",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#t:Flavour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHuman-readable names, for item colors. The fancy set.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "colorToFancyName",
          "package": "LambdaHack",
          "signature": "Color -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Flavour.html#colorToFancyName",
          "type": "function"
        },
        "index": {
          "description": "Human-readable names for item colors The fancy set",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "colorToFancyName",
          "normalized": "Color-\u003eText",
          "package": "LambdaHack",
          "partial": "To Fancy Name",
          "signature": "Color-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:colorToFancyName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHuman-readable names, for item colors. The simple set.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "colorToPlainName",
          "package": "LambdaHack",
          "signature": "Color -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Flavour.html#colorToPlainName",
          "type": "function"
        },
        "index": {
          "description": "Human-readable names for item colors The simple set",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "colorToPlainName",
          "normalized": "Color-\u003eText",
          "package": "LambdaHack",
          "partial": "To Plain Name",
          "signature": "Color-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:colorToPlainName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple names for team colors (bright colours preferred).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "colorToTeamName",
          "package": "LambdaHack",
          "signature": "Color -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Flavour.html#colorToTeamName",
          "type": "function"
        },
        "index": {
          "description": "Simple names for team colors bright colours preferred",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "colorToTeamName",
          "normalized": "Color-\u003eText",
          "package": "LambdaHack",
          "partial": "To Team Name",
          "signature": "Color-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:colorToTeamName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the underlying base colour of a flavour.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "flavourToColor",
          "package": "LambdaHack",
          "signature": "Flavour -\u003e Color",
          "source": "src/Game-LambdaHack-Common-Flavour.html#flavourToColor",
          "type": "function"
        },
        "index": {
          "description": "Get the underlying base colour of flavour",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "flavourToColor",
          "normalized": "Flavour-\u003eColor",
          "package": "LambdaHack",
          "partial": "To Color",
          "signature": "Flavour-\u003eColor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:flavourToColor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct the full name of a flavour.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "flavourToName",
          "package": "LambdaHack",
          "signature": "Flavour -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Flavour.html#flavourToName",
          "type": "function"
        },
        "index": {
          "description": "Construct the full name of flavour",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "flavourToName",
          "normalized": "Flavour-\u003eText",
          "package": "LambdaHack",
          "partial": "To Name",
          "signature": "Flavour-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:flavourToName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe standard full set of flavours.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "stdFlav",
          "package": "LambdaHack",
          "signature": "[Flavour]",
          "source": "src/Game-LambdaHack-Common-Flavour.html#stdFlav",
          "type": "function"
        },
        "index": {
          "description": "The standard full set of flavours",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "stdFlav",
          "normalized": "[Flavour]",
          "package": "LambdaHack",
          "partial": "Flav",
          "signature": "[Flavour]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:stdFlav"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a colour set into a flavour set.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "zipFancy",
          "package": "LambdaHack",
          "signature": "[Color] -\u003e [Flavour]",
          "source": "src/Game-LambdaHack-Common-Flavour.html#zipFancy",
          "type": "function"
        },
        "index": {
          "description": "Turn colour set into flavour set",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "zipFancy",
          "normalized": "[Color]-\u003e[Flavour]",
          "package": "LambdaHack",
          "partial": "Fancy",
          "signature": "[Color]-\u003e[Flavour]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:zipFancy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a colour set into a flavour set.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "zipPlain",
          "package": "LambdaHack",
          "signature": "[Color] -\u003e [Flavour]",
          "source": "src/Game-LambdaHack-Common-Flavour.html#zipPlain",
          "type": "function"
        },
        "index": {
          "description": "Turn colour set into flavour set",
          "hierarchy": "Game LambdaHack Common Flavour",
          "module": "Game.LambdaHack.Common.Flavour",
          "name": "zipPlain",
          "normalized": "[Color]-\u003e[Flavour]",
          "package": "LambdaHack",
          "partial": "Plain",
          "signature": "[Color]-\u003e[Flavour]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Flavour.html#v:zipPlain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHigh score table operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "HighScore",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-HighScore.html",
          "type": "module"
        },
        "index": {
          "description": "High score table operations",
          "hierarchy": "Game LambdaHack Common HighScore",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "HighScore",
          "package": "LambdaHack",
          "partial": "High Score",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HighScore.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of scores, in decreasing order.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "ScoreTable",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-HighScore.html#ScoreTable",
          "type": "data"
        },
        "index": {
          "description": "The list of scores in decreasing order",
          "hierarchy": "Game LambdaHack Common HighScore",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "ScoreTable",
          "package": "LambdaHack",
          "partial": "Score Table",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HighScore.html#t:ScoreTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty score table\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "empty",
          "package": "LambdaHack",
          "signature": "ScoreTable",
          "source": "src/Game-LambdaHack-Common-HighScore.html#empty",
          "type": "function"
        },
        "index": {
          "description": "Empty score table",
          "hierarchy": "Game LambdaHack Common HighScore",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "empty",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HighScore.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a slideshow with the current and previous scores.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "highSlideshow",
          "package": "LambdaHack",
          "signature": "ScoreTable-\u003e Int-\u003e Status-\u003e Slideshow",
          "type": "function"
        },
        "index": {
          "description": "Generate slideshow with the current and previous scores",
          "hierarchy": "Game LambdaHack Common HighScore",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "highSlideshow",
          "normalized": "ScoreTable-\u003eInt-\u003eStatus-\u003eSlideshow",
          "package": "LambdaHack",
          "partial": "Slideshow",
          "signature": "ScoreTable-\u003eInt-\u003eStatus-\u003eSlideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HighScore.html#v:highSlideshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegister a new score in a score table.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "register",
          "package": "LambdaHack",
          "signature": "ScoreTable-\u003e Int-\u003e Time-\u003e Status-\u003e ClockTime-\u003e Int-\u003e Maybe (ScoreTable, Int)",
          "type": "function"
        },
        "index": {
          "description": "Register new score in score table",
          "hierarchy": "Game LambdaHack Common HighScore",
          "module": "Game.LambdaHack.Common.HighScore",
          "name": "register",
          "normalized": "ScoreTable-\u003eInt-\u003eTime-\u003eStatus-\u003eClockTime-\u003eInt-\u003eMaybe(ScoreTable,Int)",
          "package": "LambdaHack",
          "signature": "ScoreTable-\u003eInt-\u003eTime-\u003eStatus-\u003eClockTime-\u003eInt-\u003eMaybe(ScoreTable,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HighScore.html#v:register"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstract syntax human player commands.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "HumanCmd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html",
          "type": "module"
        },
        "index": {
          "description": "Abstract syntax human player commands",
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "HumanCmd",
          "package": "LambdaHack",
          "partial": "Human Cmd",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdCategory",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#CmdCategory",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdCategory",
          "package": "LambdaHack",
          "partial": "Cmd Category",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#t:CmdCategory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract syntax of player commands.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "HumanCmd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "data"
        },
        "index": {
          "description": "Abstract syntax of player commands",
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "HumanCmd",
          "package": "LambdaHack",
          "partial": "Human Cmd",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#t:HumanCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Trigger",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Trigger",
          "package": "LambdaHack",
          "partial": "Trigger",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#t:Trigger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Accept",
          "package": "LambdaHack",
          "signature": "Accept",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Accept",
          "package": "LambdaHack",
          "partial": "Accept",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Accept"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "AlterDir",
          "package": "LambdaHack",
          "signature": "AlterDir ![Trigger]",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "AlterDir",
          "normalized": "AlterDir[Trigger]",
          "package": "LambdaHack",
          "partial": "Alter Dir",
          "signature": "AlterDir[Trigger]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:AlterDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "AlterFeature",
          "package": "LambdaHack",
          "signature": "AlterFeature",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "AlterFeature",
          "package": "LambdaHack",
          "partial": "Alter Feature",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:AlterFeature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Apply",
          "package": "LambdaHack",
          "signature": "Apply ![Trigger]",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Apply",
          "normalized": "Apply[Trigger]",
          "package": "LambdaHack",
          "partial": "Apply",
          "signature": "Apply[Trigger]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "ApplyItem",
          "package": "LambdaHack",
          "signature": "ApplyItem",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "ApplyItem",
          "package": "LambdaHack",
          "partial": "Apply Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:ApplyItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Cancel",
          "package": "LambdaHack",
          "signature": "Cancel",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Cancel",
          "package": "LambdaHack",
          "partial": "Cancel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Cancel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Clear",
          "package": "LambdaHack",
          "signature": "Clear",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Clear",
          "package": "LambdaHack",
          "partial": "Clear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Clear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdDebug",
          "package": "LambdaHack",
          "signature": "CmdDebug",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#CmdCategory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdDebug",
          "package": "LambdaHack",
          "partial": "Cmd Debug",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:CmdDebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdItem",
          "package": "LambdaHack",
          "signature": "CmdItem",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#CmdCategory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdItem",
          "package": "LambdaHack",
          "partial": "Cmd Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:CmdItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdMenu",
          "package": "LambdaHack",
          "signature": "CmdMenu",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#CmdCategory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdMenu",
          "package": "LambdaHack",
          "partial": "Cmd Menu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:CmdMenu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdMeta",
          "package": "LambdaHack",
          "signature": "CmdMeta",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#CmdCategory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdMeta",
          "package": "LambdaHack",
          "partial": "Cmd Meta",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:CmdMeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdMove",
          "package": "LambdaHack",
          "signature": "CmdMove",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#CmdCategory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdMove",
          "package": "LambdaHack",
          "partial": "Cmd Move",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:CmdMove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdTgt",
          "package": "LambdaHack",
          "signature": "CmdTgt",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#CmdCategory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "CmdTgt",
          "package": "LambdaHack",
          "partial": "Cmd Tgt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:CmdTgt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Drop",
          "package": "LambdaHack",
          "signature": "Drop",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Drop",
          "package": "LambdaHack",
          "partial": "Drop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "EpsIncr",
          "package": "LambdaHack",
          "signature": "EpsIncr !Bool",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "EpsIncr",
          "package": "LambdaHack",
          "partial": "Eps Incr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:EpsIncr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameDifficultyCycle",
          "package": "LambdaHack",
          "signature": "GameDifficultyCycle",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameDifficultyCycle",
          "package": "LambdaHack",
          "partial": "Game Difficulty Cycle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:GameDifficultyCycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameExit",
          "package": "LambdaHack",
          "signature": "GameExit",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameExit",
          "package": "LambdaHack",
          "partial": "Game Exit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:GameExit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameRestart",
          "package": "LambdaHack",
          "signature": "GameRestart !Text",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameRestart",
          "package": "LambdaHack",
          "partial": "Game Restart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:GameRestart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameSave",
          "package": "LambdaHack",
          "signature": "GameSave",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "GameSave",
          "package": "LambdaHack",
          "partial": "Game Save",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:GameSave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Help",
          "package": "LambdaHack",
          "signature": "Help",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Help",
          "package": "LambdaHack",
          "partial": "Help",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Help"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "History",
          "package": "LambdaHack",
          "signature": "History",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "History",
          "package": "LambdaHack",
          "partial": "History",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:History"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Inventory",
          "package": "LambdaHack",
          "signature": "Inventory",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Inventory",
          "package": "LambdaHack",
          "partial": "Inventory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Inventory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Macro",
          "package": "LambdaHack",
          "signature": "Macro !Text ![String]",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Macro",
          "normalized": "Macro Text[String]",
          "package": "LambdaHack",
          "partial": "Macro",
          "signature": "Macro Text[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Macro"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MainMenu",
          "package": "LambdaHack",
          "signature": "MainMenu",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MainMenu",
          "package": "LambdaHack",
          "partial": "Main Menu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:MainMenu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MarkSmell",
          "package": "LambdaHack",
          "signature": "MarkSmell",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MarkSmell",
          "package": "LambdaHack",
          "partial": "Mark Smell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:MarkSmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MarkSuspect",
          "package": "LambdaHack",
          "signature": "MarkSuspect",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MarkSuspect",
          "package": "LambdaHack",
          "partial": "Mark Suspect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:MarkSuspect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MarkVision",
          "package": "LambdaHack",
          "signature": "MarkVision",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MarkVision",
          "package": "LambdaHack",
          "partial": "Mark Vision",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:MarkVision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MemberBack",
          "package": "LambdaHack",
          "signature": "MemberBack",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MemberBack",
          "package": "LambdaHack",
          "partial": "Member Back",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:MemberBack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MemberCycle",
          "package": "LambdaHack",
          "signature": "MemberCycle",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MemberCycle",
          "package": "LambdaHack",
          "partial": "Member Cycle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:MemberCycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Move",
          "package": "LambdaHack",
          "signature": "Move !Vector",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Move",
          "package": "LambdaHack",
          "partial": "Move",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Move"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MoveCursor",
          "package": "LambdaHack",
          "signature": "MoveCursor !Vector !Int",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "MoveCursor",
          "package": "LambdaHack",
          "partial": "Move Cursor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:MoveCursor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "PickLeader",
          "package": "LambdaHack",
          "signature": "PickLeader !Int",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "PickLeader",
          "package": "LambdaHack",
          "partial": "Pick Leader",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:PickLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Pickup",
          "package": "LambdaHack",
          "signature": "Pickup",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Pickup",
          "package": "LambdaHack",
          "partial": "Pickup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Pickup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Project",
          "package": "LambdaHack",
          "signature": "Project ![Trigger]",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Project",
          "normalized": "Project[Trigger]",
          "package": "LambdaHack",
          "partial": "Project",
          "signature": "Project[Trigger]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Project"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Record",
          "package": "LambdaHack",
          "signature": "Record",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Record",
          "package": "LambdaHack",
          "partial": "Record",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Record"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Repeat",
          "package": "LambdaHack",
          "signature": "Repeat !Int",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Repeat",
          "package": "LambdaHack",
          "partial": "Repeat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Resend",
          "package": "LambdaHack",
          "signature": "Resend",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Resend",
          "package": "LambdaHack",
          "partial": "Resend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Resend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Run",
          "package": "LambdaHack",
          "signature": "Run !Vector",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Run",
          "package": "LambdaHack",
          "partial": "Run",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Run"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "SelectActor",
          "package": "LambdaHack",
          "signature": "SelectActor",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "SelectActor",
          "package": "LambdaHack",
          "partial": "Select Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:SelectActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "SelectNone",
          "package": "LambdaHack",
          "signature": "SelectNone",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "SelectNone",
          "package": "LambdaHack",
          "partial": "Select None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:SelectNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "StepToTarget",
          "package": "LambdaHack",
          "signature": "StepToTarget",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "StepToTarget",
          "package": "LambdaHack",
          "partial": "Step To Target",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:StepToTarget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtAscend",
          "package": "LambdaHack",
          "signature": "TgtAscend !Int",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtAscend",
          "package": "LambdaHack",
          "partial": "Tgt Ascend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TgtAscend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtClear",
          "package": "LambdaHack",
          "signature": "TgtClear",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtClear",
          "package": "LambdaHack",
          "partial": "Tgt Clear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TgtClear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtEnemy",
          "package": "LambdaHack",
          "signature": "TgtEnemy",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtEnemy",
          "package": "LambdaHack",
          "partial": "Tgt Enemy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TgtEnemy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtFloor",
          "package": "LambdaHack",
          "signature": "TgtFloor",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtFloor",
          "package": "LambdaHack",
          "partial": "Tgt Floor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TgtFloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtItem",
          "package": "LambdaHack",
          "signature": "TgtItem",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtItem",
          "package": "LambdaHack",
          "partial": "Tgt Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TgtItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtStair",
          "package": "LambdaHack",
          "signature": "TgtStair !Bool",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtStair",
          "package": "LambdaHack",
          "partial": "Tgt Stair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TgtStair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtUnknown",
          "package": "LambdaHack",
          "signature": "TgtUnknown",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TgtUnknown",
          "package": "LambdaHack",
          "partial": "Tgt Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TgtUnknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TriggerFeature",
          "package": "LambdaHack",
          "signature": "TriggerFeature",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TriggerFeature",
          "package": "LambdaHack",
          "partial": "Trigger Feature",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TriggerFeature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TriggerTile",
          "package": "LambdaHack",
          "signature": "TriggerTile ![Trigger]",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "TriggerTile",
          "normalized": "TriggerTile[Trigger]",
          "package": "LambdaHack",
          "partial": "Trigger Tile",
          "signature": "TriggerTile[Trigger]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:TriggerTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Wait",
          "package": "LambdaHack",
          "signature": "Wait",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#HumanCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "Wait",
          "package": "LambdaHack",
          "partial": "Wait",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:Wait"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "categoryDescription",
          "package": "LambdaHack",
          "signature": "CmdCategory -\u003e Text",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#categoryDescription",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "categoryDescription",
          "normalized": "CmdCategory-\u003eText",
          "package": "LambdaHack",
          "partial": "Description",
          "signature": "CmdCategory-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:categoryDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescription of player commands.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "cmdDescription",
          "package": "LambdaHack",
          "signature": "HumanCmd -\u003e Text",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#cmdDescription",
          "type": "function"
        },
        "index": {
          "description": "Description of player commands",
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "cmdDescription",
          "normalized": "HumanCmd-\u003eText",
          "package": "LambdaHack",
          "partial": "Description",
          "signature": "HumanCmd-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:cmdDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "feature",
          "package": "LambdaHack",
          "signature": "Feature",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "feature",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:feature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommands that are forbidden on a remote level, because they\n would usually take time when invoked on one.\n Note that some commands that take time are not included,\n because they don't take time in targeting mode.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "noRemoteHumanCmd",
          "package": "LambdaHack",
          "signature": "HumanCmd -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#noRemoteHumanCmd",
          "type": "function"
        },
        "index": {
          "description": "Commands that are forbidden on remote level because they would usually take time when invoked on one Note that some commands that take time are not included because they don take time in targeting mode",
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "noRemoteHumanCmd",
          "normalized": "HumanCmd-\u003eBool",
          "package": "LambdaHack",
          "partial": "Remote Human Cmd",
          "signature": "HumanCmd-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:noRemoteHumanCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "object",
          "package": "LambdaHack",
          "signature": "Part",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "object",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "symbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "symbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "verb",
          "package": "LambdaHack",
          "signature": "Part",
          "source": "src/Game-LambdaHack-Common-HumanCmd.html#Trigger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common HumanCmd",
          "module": "Game.LambdaHack.Common.HumanCmd",
          "name": "verb",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-HumanCmd.html#v:verb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eWeapons, treasure and all the other items in the game.\n No operation in this module\n involves the \u003ccode\u003eState\u003c/code\u003e or \u003ccode\u003eAction\u003c/code\u003e type.\n TODO: Document after it's rethought and rewritten wrt separating\n inventory manangement and items proper.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "Item",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Item.html",
          "type": "module"
        },
        "index": {
          "description": "Weapons treasure and all the other items in the game No operation in this module involves the State or Action type TODO Document after it rethought and rewritten wrt separating inventory manangement and items proper",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "Item",
          "package": "LambdaHack",
          "partial": "Item",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe reverse map to \u003ccode\u003eDiscovery\u003c/code\u003e, needed for item creation.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "DiscoRev",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Item.html#DiscoRev",
          "type": "type"
        },
        "index": {
          "description": "The reverse map to Discovery needed for item creation",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "DiscoRev",
          "package": "LambdaHack",
          "partial": "Disco Rev",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#t:DiscoRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe map of item kind indexes to item kind ids.\n The full map, as known by the server, is a bijection.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "Discovery",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Item.html#Discovery",
          "type": "type"
        },
        "index": {
          "description": "The map of item kind indexes to item kind ids The full map as known by the server is bijection",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "Discovery",
          "package": "LambdaHack",
          "partial": "Discovery",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#t:Discovery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlavours assigned by the server to item kinds, in this particular game.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "FlavourMap",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Item.html#FlavourMap",
          "type": "data"
        },
        "index": {
          "description": "Flavours assigned by the server to item kinds in this particular game",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "FlavourMap",
          "package": "LambdaHack",
          "partial": "Flavour Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#t:FlavourMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGame items in inventories or strewn around the dungeon.\n The fields \u003ccode\u003ejsymbol\u003c/code\u003e, \u003ccode\u003ejname\u003c/code\u003e and \u003ccode\u003ejflavour\u003c/code\u003e make it possible to refer to\n and draw an unidentified item. Full information about item is available\n through the \u003ccode\u003ejkindIx\u003c/code\u003e index as soon as the item is identified.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "Item",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "data"
        },
        "index": {
          "description": "Game items in inventories or strewn around the dungeon The fields jsymbol jname and jflavour make it possible to refer to and draw an unidentified item Full information about item is available through the jkindIx index as soon as the item is identified",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "Item",
          "package": "LambdaHack",
          "partial": "Item",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#t:Item"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA unique identifier of an item in the dungeon.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "ItemId",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Item.html#ItemId",
          "type": "data"
        },
        "index": {
          "description": "unique identifier of an item in the dungeon",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "ItemId",
          "package": "LambdaHack",
          "partial": "Item Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#t:ItemId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn index of the kind id of an item. Clients have partial knowledge\n how these idexes map to kind ids. They gain knowledge by identifying items.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "ItemKindIx",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Item.html#ItemKindIx",
          "type": "data"
        },
        "index": {
          "description": "An index of the kind id of an item Clients have partial knowledge how these idexes map to kind ids They gain knowledge by identifying items",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "ItemKindIx",
          "package": "LambdaHack",
          "partial": "Item Kind Ix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#t:ItemKindIx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "Item",
          "package": "LambdaHack",
          "signature": "Item",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "Item",
          "package": "LambdaHack",
          "partial": "Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:Item"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an item with the given stats.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "buildItem",
          "package": "LambdaHack",
          "signature": "FlavourMap -\u003e DiscoRev -\u003e Id ItemKind -\u003e ItemKind -\u003e Effect Int -\u003e Item",
          "source": "src/Game-LambdaHack-Common-Item.html#buildItem",
          "type": "function"
        },
        "index": {
          "description": "Build an item with the given stats",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "buildItem",
          "normalized": "FlavourMap-\u003eDiscoRev-\u003eId ItemKind-\u003eItemKind-\u003eEffect Int-\u003eItem",
          "package": "LambdaHack",
          "partial": "Item",
          "signature": "FlavourMap-\u003eDiscoRev-\u003eId ItemKind-\u003eItemKind-\u003eEffect Int-\u003eItem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:buildItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "causeIEffects",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Id ItemKind -\u003e [Effect RollDeep]",
          "source": "src/Game-LambdaHack-Common-Item.html#causeIEffects",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "causeIEffects",
          "normalized": "Ops ItemKind-\u003eId ItemKind-\u003e[Effect RollDeep]",
          "package": "LambdaHack",
          "partial": "IEffects",
          "signature": "Ops ItemKind-\u003eId ItemKind-\u003e[Effect RollDeep]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:causeIEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRandomly chooses flavour for all item kinds for this game.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "dungeonFlavourMap",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Rnd FlavourMap",
          "source": "src/Game-LambdaHack-Common-Item.html#dungeonFlavourMap",
          "type": "function"
        },
        "index": {
          "description": "Randomly chooses flavour for all item kinds for this game",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "dungeonFlavourMap",
          "normalized": "Ops ItemKind-\u003eRnd FlavourMap",
          "package": "LambdaHack",
          "partial": "Flavour Map",
          "signature": "Ops ItemKind-\u003eRnd FlavourMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:dungeonFlavourMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "emptyFlavourMap",
          "package": "LambdaHack",
          "signature": "FlavourMap",
          "source": "src/Game-LambdaHack-Common-Item.html#emptyFlavourMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "emptyFlavourMap",
          "package": "LambdaHack",
          "partial": "Flavour Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:emptyFlavourMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "isExplosive",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Discovery -\u003e Item -\u003e Maybe Text",
          "source": "src/Game-LambdaHack-Common-Item.html#isExplosive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "isExplosive",
          "normalized": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003eMaybe Text",
          "package": "LambdaHack",
          "partial": "Explosive",
          "signature": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:isExplosive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "isFragile",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Discovery -\u003e Item -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Item.html#isFragile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "isFragile",
          "normalized": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003eBool",
          "package": "LambdaHack",
          "partial": "Fragile",
          "signature": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:isFragile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "isLingering",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Discovery -\u003e Item -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Item.html#isLingering",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "isLingering",
          "normalized": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003eInt",
          "package": "LambdaHack",
          "partial": "Lingering",
          "signature": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:isLingering"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe effect when activated\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jeffect",
          "package": "LambdaHack",
          "signature": "(Effect Int)",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "function"
        },
        "index": {
          "description": "the effect when activated",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jeffect",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:jeffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual flavour\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jflavour",
          "package": "LambdaHack",
          "signature": "Flavour",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "function"
        },
        "index": {
          "description": "individual flavour",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jflavour",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:jflavour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecover a kind id of an item, if identified.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jkind",
          "package": "LambdaHack",
          "signature": "Discovery -\u003e Item -\u003e Maybe (Id ItemKind)",
          "source": "src/Game-LambdaHack-Common-Item.html#jkind",
          "type": "function"
        },
        "index": {
          "description": "Recover kind id of an item if identified",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jkind",
          "normalized": "Discovery-\u003eItem-\u003eMaybe(Id ItemKind)",
          "package": "LambdaHack",
          "signature": "Discovery-\u003eItem-\u003eMaybe(Id ItemKind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:jkind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindex pointing to the kind of the item\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jkindIx",
          "package": "LambdaHack",
          "signature": "ItemKindIx",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "function"
        },
        "index": {
          "description": "index pointing to the kind of the item",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jkindIx",
          "package": "LambdaHack",
          "partial": "Ix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:jkindIx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual generic name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "function"
        },
        "index": {
          "description": "individual generic name",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:jname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindividual map symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jsymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "function"
        },
        "index": {
          "description": "individual map symbol",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jsymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:jsymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eweight in grams, obvious enough\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jweight",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Item.html#Item",
          "type": "function"
        },
        "index": {
          "description": "weight in grams obvious enough",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "jweight",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:jweight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate an item based on level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "newItem",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e FlavourMap -\u003e DiscoRev -\u003e Frequency Text -\u003e Int -\u003e Int -\u003e Rnd (Item, Int, ItemKind)",
          "source": "src/Game-LambdaHack-Common-Item.html#newItem",
          "type": "function"
        },
        "index": {
          "description": "Generate an item based on level",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "newItem",
          "normalized": "Ops ItemKind-\u003eFlavourMap-\u003eDiscoRev-\u003eFrequency Text-\u003eInt-\u003eInt-\u003eRnd(Item,Int,ItemKind)",
          "package": "LambdaHack",
          "partial": "Item",
          "signature": "Ops ItemKind-\u003eFlavourMap-\u003eDiscoRev-\u003eFrequency Text-\u003eInt-\u003eInt-\u003eRnd(Item,Int,ItemKind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:newItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe part of speech describing the item.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Item",
          "name": "partItem",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Discovery -\u003e Item -\u003e (Part, Part)",
          "source": "src/Game-LambdaHack-Common-Item.html#partItem",
          "type": "function"
        },
        "index": {
          "description": "The part of speech describing the item",
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "partItem",
          "normalized": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003e(Part,Part)",
          "package": "LambdaHack",
          "partial": "Item",
          "signature": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003e(Part,Part)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:partItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "partItemAW",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Discovery -\u003e Item -\u003e Part",
          "source": "src/Game-LambdaHack-Common-Item.html#partItemAW",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "partItemAW",
          "normalized": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003ePart",
          "package": "LambdaHack",
          "partial": "Item AW",
          "signature": "Ops ItemKind-\u003eDiscovery-\u003eItem-\u003ePart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:partItemAW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "partItemWs",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Discovery -\u003e Int -\u003e Item -\u003e Part",
          "source": "src/Game-LambdaHack-Common-Item.html#partItemWs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "partItemWs",
          "normalized": "Ops ItemKind-\u003eDiscovery-\u003eInt-\u003eItem-\u003ePart",
          "package": "LambdaHack",
          "partial": "Item Ws",
          "signature": "Ops ItemKind-\u003eDiscovery-\u003eInt-\u003eItem-\u003ePart",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:partItemWs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "serverDiscos",
          "package": "LambdaHack",
          "signature": "Ops ItemKind -\u003e Rnd (Discovery, DiscoRev)",
          "source": "src/Game-LambdaHack-Common-Item.html#serverDiscos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "serverDiscos",
          "normalized": "Ops ItemKind-\u003eRnd(Discovery,DiscoRev)",
          "package": "LambdaHack",
          "partial": "Discos",
          "signature": "Ops ItemKind-\u003eRnd(Discovery,DiscoRev)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:serverDiscos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "strongestRegen",
          "package": "LambdaHack",
          "signature": "[(ItemId, Item)] -\u003e Maybe (Int, (ItemId, Item))",
          "source": "src/Game-LambdaHack-Common-Item.html#strongestRegen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "strongestRegen",
          "normalized": "[(ItemId,Item)]-\u003eMaybe(Int,(ItemId,Item))",
          "package": "LambdaHack",
          "partial": "Regen",
          "signature": "[(ItemId,Item)]-\u003eMaybe(Int,(ItemId,Item))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:strongestRegen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "strongestSearch",
          "package": "LambdaHack",
          "signature": "[(ItemId, Item)] -\u003e Maybe (Int, (ItemId, Item))",
          "source": "src/Game-LambdaHack-Common-Item.html#strongestSearch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "strongestSearch",
          "normalized": "[(ItemId,Item)]-\u003eMaybe(Int,(ItemId,Item))",
          "package": "LambdaHack",
          "partial": "Search",
          "signature": "[(ItemId,Item)]-\u003eMaybe(Int,(ItemId,Item))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:strongestSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Item",
          "name": "strongestSword",
          "package": "LambdaHack",
          "signature": "COps -\u003e [(ItemId, Item)] -\u003e Maybe (Int, (ItemId, Item))",
          "source": "src/Game-LambdaHack-Common-Item.html#strongestSword",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Item",
          "module": "Game.LambdaHack.Common.Item",
          "name": "strongestSword",
          "normalized": "COps-\u003e[(ItemId,Item)]-\u003eMaybe(Int,(ItemId,Item))",
          "package": "LambdaHack",
          "partial": "Sword",
          "signature": "COps-\u003e[(ItemId,Item)]-\u003eMaybe(Int,(ItemId,Item))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Item.html#v:strongestSword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eItem features.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "ItemFeature",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ItemFeature.html",
          "type": "module"
        },
        "index": {
          "description": "Item features",
          "hierarchy": "Game LambdaHack Common ItemFeature",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "ItemFeature",
          "package": "LambdaHack",
          "partial": "Item Feature",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ItemFeature.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll possible item features.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Feature",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ItemFeature.html#Feature",
          "type": "data"
        },
        "index": {
          "description": "All possible item features",
          "hierarchy": "Game LambdaHack Common ItemFeature",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Feature",
          "package": "LambdaHack",
          "partial": "Feature",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ItemFeature.html#t:Feature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecauses the effect when triggered\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Cause",
          "package": "LambdaHack",
          "signature": "Cause !(Effect RollDeep)",
          "source": "src/Game-LambdaHack-Common-ItemFeature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "causes the effect when triggered",
          "hierarchy": "Game LambdaHack Common ItemFeature",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Cause",
          "package": "LambdaHack",
          "partial": "Cause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ItemFeature.html#v:Cause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echanges to this item kind group when altered\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "ChangeTo",
          "package": "LambdaHack",
          "signature": "ChangeTo !Text",
          "source": "src/Game-LambdaHack-Common-ItemFeature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "changes to this item kind group when altered",
          "hierarchy": "Game LambdaHack Common ItemFeature",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "ChangeTo",
          "package": "LambdaHack",
          "partial": "Change To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ItemFeature.html#v:ChangeTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexplode, producing this group of shrapnel\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Explode",
          "package": "LambdaHack",
          "signature": "Explode !Text",
          "source": "src/Game-LambdaHack-Common-ItemFeature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "explode producing this group of shrapnel",
          "hierarchy": "Game LambdaHack Common ItemFeature",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Explode",
          "package": "LambdaHack",
          "partial": "Explode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ItemFeature.html#v:Explode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebreaks even when not hitting an enemy\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Fragile",
          "package": "LambdaHack",
          "signature": "Fragile",
          "source": "src/Game-LambdaHack-Common-ItemFeature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "breaks even when not hitting an enemy",
          "hierarchy": "Game LambdaHack Common ItemFeature",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Fragile",
          "package": "LambdaHack",
          "partial": "Fragile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ItemFeature.html#v:Fragile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efly for this percentage of 2 turns\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Linger",
          "package": "LambdaHack",
          "signature": "Linger !Int",
          "source": "src/Game-LambdaHack-Common-ItemFeature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "fly for this percentage of turns",
          "hierarchy": "Game LambdaHack Common ItemFeature",
          "module": "Game.LambdaHack.Common.ItemFeature",
          "name": "Linger",
          "package": "LambdaHack",
          "partial": "Linger",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ItemFeature.html#v:Linger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFrontend-independent keyboard input operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Key",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Key.html",
          "type": "module"
        },
        "index": {
          "description": "Frontend-independent keyboard input operations",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Key",
          "package": "LambdaHack",
          "partial": "Key",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "KM",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Key.html#KM",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "KM",
          "package": "LambdaHack",
          "partial": "KM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#t:KM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrontend-independent datatype to represent keys.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Key",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "data"
        },
        "index": {
          "description": "Frontend-independent datatype to represent keys",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Key",
          "package": "LambdaHack",
          "partial": "Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOur own encoding of modifiers. Incomplete.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Modifier",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Key.html#Modifier",
          "type": "data"
        },
        "index": {
          "description": "Our own encoding of modifiers Incomplete",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Modifier",
          "package": "LambdaHack",
          "partial": "Modifier",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#t:Modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "BackSpace",
          "package": "LambdaHack",
          "signature": "BackSpace",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "BackSpace",
          "package": "LambdaHack",
          "partial": "Back Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:BackSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "BackTab",
          "package": "LambdaHack",
          "signature": "BackTab",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "BackTab",
          "package": "LambdaHack",
          "partial": "Back Tab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:BackTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Begin",
          "package": "LambdaHack",
          "signature": "Begin",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Begin",
          "package": "LambdaHack",
          "partial": "Begin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Begin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea single printable character\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Char",
          "package": "LambdaHack",
          "signature": "Char !Char",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "description": "single printable character",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Char",
          "package": "LambdaHack",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Control",
          "package": "LambdaHack",
          "signature": "Control",
          "source": "src/Game-LambdaHack-Common-Key.html#Modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Control",
          "package": "LambdaHack",
          "partial": "Control",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Down",
          "package": "LambdaHack",
          "signature": "Down",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Down",
          "package": "LambdaHack",
          "partial": "Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "End",
          "package": "LambdaHack",
          "signature": "End",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "End",
          "package": "LambdaHack",
          "partial": "End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:End"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Esc",
          "package": "LambdaHack",
          "signature": "Esc",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Esc",
          "package": "LambdaHack",
          "partial": "Esc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Esc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Home",
          "package": "LambdaHack",
          "signature": "Home",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Home",
          "package": "LambdaHack",
          "partial": "Home",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Home"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "KM",
          "package": "LambdaHack",
          "signature": "KM",
          "source": "src/Game-LambdaHack-Common-Key.html#KM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "KM",
          "package": "LambdaHack",
          "partial": "KM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:KM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea keypad key for a character (digits and operators)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "KP",
          "package": "LambdaHack",
          "signature": "KP !Char",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "description": "keypad key for character digits and operators",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "KP",
          "package": "LambdaHack",
          "partial": "KP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:KP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Left",
          "package": "LambdaHack",
          "signature": "Left",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Left",
          "package": "LambdaHack",
          "partial": "Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "NoModifier",
          "package": "LambdaHack",
          "signature": "NoModifier",
          "source": "src/Game-LambdaHack-Common-Key.html#Modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "NoModifier",
          "package": "LambdaHack",
          "partial": "No Modifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:NoModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "PgDn",
          "package": "LambdaHack",
          "signature": "PgDn",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "PgDn",
          "package": "LambdaHack",
          "partial": "Pg Dn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:PgDn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "PgUp",
          "package": "LambdaHack",
          "signature": "PgUp",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "PgUp",
          "package": "LambdaHack",
          "partial": "Pg Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:PgUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Return",
          "package": "LambdaHack",
          "signature": "Return",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Return",
          "package": "LambdaHack",
          "partial": "Return",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Right",
          "package": "LambdaHack",
          "signature": "Right",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Right",
          "package": "LambdaHack",
          "partial": "Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Space",
          "package": "LambdaHack",
          "signature": "Space",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Space",
          "package": "LambdaHack",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Tab",
          "package": "LambdaHack",
          "signature": "Tab",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Tab",
          "package": "LambdaHack",
          "partial": "Tab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Tab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean unknown key, registered to warn the user\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Unknown",
          "package": "LambdaHack",
          "signature": "Unknown !Text",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "description": "an unknown key registered to warn the user",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Unknown",
          "package": "LambdaHack",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "Up",
          "package": "LambdaHack",
          "signature": "Up",
          "source": "src/Game-LambdaHack-Common-Key.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "Up",
          "package": "LambdaHack",
          "partial": "Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:Up"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "dirAllMoveKey",
          "package": "LambdaHack",
          "signature": "[Key]",
          "source": "src/Game-LambdaHack-Common-Key.html#dirAllMoveKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "dirAllMoveKey",
          "normalized": "[Key]",
          "package": "LambdaHack",
          "partial": "All Move Key",
          "signature": "[Key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:dirAllMoveKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "escKey",
          "package": "LambdaHack",
          "signature": "KM",
          "source": "src/Game-LambdaHack-Common-Key.html#escKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "escKey",
          "package": "LambdaHack",
          "partial": "Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:escKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConfigurable event handler for the direction keys.\n Used for directed commands such as close door.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "handleDir",
          "package": "LambdaHack",
          "signature": "KM -\u003e (Vector -\u003e a) -\u003e a -\u003e a",
          "source": "src/Game-LambdaHack-Common-Key.html#handleDir",
          "type": "function"
        },
        "index": {
          "description": "Configurable event handler for the direction keys Used for directed commands such as close door",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "handleDir",
          "normalized": "KM-\u003e(Vector-\u003ea)-\u003ea-\u003ea",
          "package": "LambdaHack",
          "partial": "Dir",
          "signature": "KM-\u003e(Vector-\u003ea)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:handleDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "key",
          "package": "LambdaHack",
          "signature": "Key",
          "source": "src/Game-LambdaHack-Common-Key.html#KM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "key",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate key from a GTK string description to our internal key type.\n To be used, in particular, for the command bindings and macros\n in the config file.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "keyTranslate",
          "package": "LambdaHack",
          "signature": "String -\u003e Key",
          "source": "src/Game-LambdaHack-Common-Key.html#keyTranslate",
          "type": "function"
        },
        "index": {
          "description": "Translate key from GTK string description to our internal key type To be used in particular for the command bindings and macros in the config file",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "keyTranslate",
          "normalized": "String-\u003eKey",
          "package": "LambdaHack",
          "partial": "Translate",
          "signature": "String-\u003eKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:keyTranslate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "mkKM",
          "package": "LambdaHack",
          "signature": "String -\u003e KM",
          "source": "src/Game-LambdaHack-Common-Key.html#mkKM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "mkKM",
          "normalized": "String-\u003eKM",
          "package": "LambdaHack",
          "partial": "KM",
          "signature": "String-\u003eKM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:mkKM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Key",
          "name": "modifier",
          "package": "LambdaHack",
          "signature": "Modifier",
          "source": "src/Game-LambdaHack-Common-Key.html#KM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "modifier",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinding of both sets of movement keys.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "moveBinding",
          "package": "LambdaHack",
          "signature": "(Vector -\u003e a) -\u003e (Vector -\u003e a) -\u003e [(KM, a)]",
          "source": "src/Game-LambdaHack-Common-Key.html#moveBinding",
          "type": "function"
        },
        "index": {
          "description": "Binding of both sets of movement keys",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "moveBinding",
          "normalized": "(Vector-\u003ea)-\u003e(Vector-\u003ea)-\u003e[(KM,a)]",
          "package": "LambdaHack",
          "partial": "Binding",
          "signature": "(Vector-\u003ea)-\u003e(Vector-\u003ea)-\u003e[(KM,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:moveBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a key with a modifier, if any.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Key",
          "name": "showKM",
          "package": "LambdaHack",
          "signature": "KM -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Key.html#showKM",
          "type": "function"
        },
        "index": {
          "description": "Show key with modifier if any",
          "hierarchy": "Game LambdaHack Common Key",
          "module": "Game.LambdaHack.Common.Key",
          "name": "showKM",
          "normalized": "KM-\u003eText",
          "package": "LambdaHack",
          "partial": "KM",
          "signature": "KM-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Key.html#v:showKM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneral content types and operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Kind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Kind.html",
          "type": "module"
        },
        "index": {
          "description": "General content types and operations",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Kind",
          "package": "LambdaHack",
          "partial": "Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperations for all content types, gathered together.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "COps",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "data"
        },
        "index": {
          "description": "Operations for all content types gathered together",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "COps",
          "package": "LambdaHack",
          "partial": "COps",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#t:COps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContent identifiers for the content type \u003ccode\u003ec\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Id",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Kind.html#Id",
          "type": "data"
        },
        "index": {
          "description": "Content identifiers for the content type",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Id",
          "package": "LambdaHack",
          "partial": "Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#t:Id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContent operations for the content of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Ops",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "data"
        },
        "index": {
          "description": "Content operations for the content of type",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Ops",
          "package": "LambdaHack",
          "partial": "Ops",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#t:Ops"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType family for auxiliary data structures for speeding up\n content operations.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Speedup",
          "package": "LambdaHack",
          "signature": "Speedup",
          "type": "function"
        },
        "index": {
          "description": "Type family for auxiliary data structures for speeding up content operations",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Speedup",
          "package": "LambdaHack",
          "partial": "Speedup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#t:Speedup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Tab",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Kind.html#Tab",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Tab",
          "package": "LambdaHack",
          "partial": "Tab",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#t:Tab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "COps",
          "package": "LambdaHack",
          "signature": "COps",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "COps",
          "package": "LambdaHack",
          "partial": "COps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:COps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Ops",
          "package": "LambdaHack",
          "signature": "Ops",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "Ops",
          "package": "LambdaHack",
          "partial": "Ops",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:Ops"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "accessTab",
          "package": "LambdaHack",
          "signature": "Tab -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Kind.html#accessTab",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "accessTab",
          "normalized": "Tab-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Tab",
          "signature": "Tab-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:accessTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "coactor",
          "package": "LambdaHack",
          "signature": "(Ops ActorKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "coactor",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:coactor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "cocave",
          "package": "LambdaHack",
          "signature": "(Ops CaveKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "cocave",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:cocave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "cofaction",
          "package": "LambdaHack",
          "signature": "(Ops FactionKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "cofaction",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:cofaction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "coitem",
          "package": "LambdaHack",
          "signature": "(Ops ItemKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "coitem",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:coitem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "comode",
          "package": "LambdaHack",
          "signature": "(Ops ModeKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "comode",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:comode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "coplace",
          "package": "LambdaHack",
          "signature": "(Ops PlaceKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "coplace",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:coplace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "corule",
          "package": "LambdaHack",
          "signature": "(Ops RuleKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "corule",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:corule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "cotile",
          "package": "LambdaHack",
          "signature": "(Ops TileKind)",
          "source": "src/Game-LambdaHack-Common-Kind.html#COps",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "cotile",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:cotile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate content operations for type \u003ccode\u003ea\u003c/code\u003e from definition of content\n of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "createOps",
          "package": "LambdaHack",
          "signature": "ContentDef a -\u003e Ops a",
          "source": "src/Game-LambdaHack-Common-Kind.html#createOps",
          "type": "function"
        },
        "index": {
          "description": "Create content operations for type from definition of content of type",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "createOps",
          "normalized": "ContentDef a-\u003eOps a",
          "package": "LambdaHack",
          "partial": "Ops",
          "signature": "ContentDef a-\u003eOps a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:createOps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Kind",
          "name": "createTab",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e (TileKind -\u003e Bool) -\u003e Tab",
          "source": "src/Game-LambdaHack-Common-Kind.html#createTab",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "createTab",
          "normalized": "Ops TileKind-\u003e(TileKind-\u003eBool)-\u003eTab",
          "package": "LambdaHack",
          "partial": "Tab",
          "signature": "Ops TileKind-\u003e(TileKind-\u003eBool)-\u003eTab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:createTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebounds of identifiers of content \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "obounds",
          "package": "LambdaHack",
          "signature": "(Id a, Id a)",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "function"
        },
        "index": {
          "description": "bounds of identifiers of content",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "obounds",
          "normalized": "(Id a,Id a)",
          "package": "LambdaHack",
          "signature": "(Id a,Id a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:obounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efold over all content elements of \u003ccode\u003ea\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "ofoldrWithKey",
          "package": "LambdaHack",
          "signature": "forall b.  (Id a -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e b",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "function"
        },
        "index": {
          "description": "fold over all content elements of",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "ofoldrWithKey",
          "normalized": "a b(Id c-\u003ec-\u003ed-\u003ed)-\u003ed-\u003ed",
          "package": "LambdaHack",
          "partial": "With Key",
          "signature": "forall b.(Id a-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:ofoldrWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe content element at given id\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "okind",
          "package": "LambdaHack",
          "signature": "Id a -\u003e a",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "function"
        },
        "index": {
          "description": "the content element at given id",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "okind",
          "normalized": "Id a-\u003ea",
          "package": "LambdaHack",
          "signature": "Id a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:okind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epick a random id belonging to a group\n   and satisfying a predicate\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "opick",
          "package": "LambdaHack",
          "signature": "Text -\u003e (a -\u003e Bool) -\u003e Rnd (Maybe (Id a))",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "function"
        },
        "index": {
          "description": "pick random id belonging to group and satisfying predicate",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "opick",
          "normalized": "Text-\u003e(a-\u003eBool)-\u003eRnd(Maybe(Id a))",
          "package": "LambdaHack",
          "signature": "Text-\u003e(a-\u003eBool)-\u003eRnd(Maybe(Id a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:opick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eauxiliary speedup components\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "ospeedup",
          "package": "LambdaHack",
          "signature": "(Maybe (Speedup a))",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "function"
        },
        "index": {
          "description": "auxiliary speedup components",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "ospeedup",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:ospeedup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe id of the unique member of\n   a singleton content group\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "ouniqGroup",
          "package": "LambdaHack",
          "signature": "Text -\u003e Id a",
          "source": "src/Game-LambdaHack-Common-Kind.html#Ops",
          "type": "function"
        },
        "index": {
          "description": "the id of the unique member of singleton content group",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "ouniqGroup",
          "normalized": "Text-\u003eId a",
          "package": "LambdaHack",
          "partial": "Group",
          "signature": "Text-\u003eId a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:ouniqGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe standard ruleset used for level operations.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "stdRuleset",
          "package": "LambdaHack",
          "signature": "Ops RuleKind -\u003e RuleKind",
          "source": "src/Game-LambdaHack-Common-Kind.html#stdRuleset",
          "type": "function"
        },
        "index": {
          "description": "The standard ruleset used for level operations",
          "hierarchy": "Game LambdaHack Common Kind",
          "module": "Game.LambdaHack.Common.Kind",
          "name": "stdRuleset",
          "normalized": "Ops RuleKind-\u003eRuleKind",
          "package": "LambdaHack",
          "partial": "Ruleset",
          "signature": "Ops RuleKind-\u003eRuleKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Kind.html#v:stdRuleset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInhabited dungeon levels and the operations to query and change them\n as the game progresses.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Level",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Level.html",
          "type": "module"
        },
        "index": {
          "description": "Inhabited dungeon levels and the operations to query and change them as the game progresses",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Level",
          "package": "LambdaHack",
          "partial": "Level",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eItem container type.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Container",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Level.html#Container",
          "type": "data"
        },
        "index": {
          "description": "Item container type",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Container",
          "package": "LambdaHack",
          "partial": "Container",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#t:Container"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe complete dungeon is a map from level names to levels.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Dungeon",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Level.html#Dungeon",
          "type": "type"
        },
        "index": {
          "description": "The complete dungeon is map from level names to levels",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Dungeon",
          "package": "LambdaHack",
          "partial": "Dungeon",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#t:Dungeon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eItems located on map tiles.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ItemFloor",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Level.html#ItemFloor",
          "type": "type"
        },
        "index": {
          "description": "Items located on map tiles",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ItemFloor",
          "package": "LambdaHack",
          "partial": "Item Floor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#t:ItemFloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA view on single, inhabited dungeon level. \u003ca\u003eRemembered\u003c/a\u003e fields\n carry a subset of the info in the client copies of levels.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Level",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "data"
        },
        "index": {
          "description": "view on single inhabited dungeon level Remembered fields carry subset of the info in the client copies of levels",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Level",
          "package": "LambdaHack",
          "partial": "Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#t:Level"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract level identifiers.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "LevelId",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Misc.html#LevelId",
          "type": "data"
        },
        "index": {
          "description": "Abstract level identifiers",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "LevelId",
          "package": "LambdaHack",
          "partial": "Level Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#t:LevelId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent smell on map tiles.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "SmellMap",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Level.html#SmellMap",
          "type": "type"
        },
        "index": {
          "description": "Current smell on map tiles",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "SmellMap",
          "package": "LambdaHack",
          "partial": "Smell Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#t:SmellMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTile kinds on the map.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "TileMap",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Level.html#TileMap",
          "type": "type"
        },
        "index": {
          "description": "Tile kinds on the map",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "TileMap",
          "package": "LambdaHack",
          "partial": "Tile Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#t:TileMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "CActor",
          "package": "LambdaHack",
          "signature": "CActor !ActorId !InvChar",
          "source": "src/Game-LambdaHack-Common-Level.html#Container",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "CActor",
          "package": "LambdaHack",
          "partial": "CActor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:CActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "CFloor",
          "package": "LambdaHack",
          "signature": "CFloor !LevelId !Point",
          "source": "src/Game-LambdaHack-Common-Level.html#Container",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "CFloor",
          "package": "LambdaHack",
          "partial": "CFloor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:CFloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "Level",
          "package": "LambdaHack",
          "signature": "Level",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "Level",
          "package": "LambdaHack",
          "partial": "Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:Level"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether one position is accessible from another,\n using the formula from the standard ruleset.\n Precondition: the two positions are next to each other.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "accessible",
          "package": "LambdaHack",
          "signature": "COps -\u003e Level -\u003e Point -\u003e Point -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Level.html#accessible",
          "type": "function"
        },
        "index": {
          "description": "Check whether one position is accessible from another using the formula from the standard ruleset Precondition the two positions are next to each other",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "accessible",
          "normalized": "COps-\u003eLevel-\u003ePoint-\u003ePoint-\u003eBool",
          "package": "LambdaHack",
          "signature": "COps-\u003eLevel-\u003ePoint-\u003ePoint-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:accessible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether actors can move from a position along a unit vector,\n using the formula from the standard ruleset.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "accessibleDir",
          "package": "LambdaHack",
          "signature": "COps -\u003e Level -\u003e Point -\u003e Vector -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Level.html#accessibleDir",
          "type": "function"
        },
        "index": {
          "description": "Check whether actors can move from position along unit vector using the formula from the standard ruleset",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "accessibleDir",
          "normalized": "COps-\u003eLevel-\u003ePoint-\u003eVector-\u003eBool",
          "package": "LambdaHack",
          "partial": "Dir",
          "signature": "COps-\u003eLevel-\u003ePoint-\u003eVector-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:accessibleDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLevels in the current branch, \u003ccode\u003ek\u003c/code\u003e levels shallower than the current.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ascendInBranch",
          "package": "LambdaHack",
          "signature": "Dungeon -\u003e Int -\u003e LevelId -\u003e [LevelId]",
          "source": "src/Game-LambdaHack-Common-Level.html#ascendInBranch",
          "type": "function"
        },
        "index": {
          "description": "Levels in the current branch levels shallower than the current",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ascendInBranch",
          "normalized": "Dungeon-\u003eInt-\u003eLevelId-\u003e[LevelId]",
          "package": "LambdaHack",
          "partial": "In Branch",
          "signature": "Dungeon-\u003eInt-\u003eLevelId-\u003e[LevelId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:ascendInBranch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuery for tile kinds on the map.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "at",
          "package": "LambdaHack",
          "signature": "Level -\u003e Point -\u003e Id TileKind",
          "source": "src/Game-LambdaHack-Common-Level.html#at",
          "type": "function"
        },
        "index": {
          "description": "Query for tile kinds on the map",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "at",
          "normalized": "Level-\u003ePoint-\u003eId TileKind",
          "package": "LambdaHack",
          "signature": "Level-\u003ePoint-\u003eId TileKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:at"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuery for items on the ground.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "atI",
          "package": "LambdaHack",
          "signature": "Level -\u003e Point -\u003e ItemBag",
          "source": "src/Game-LambdaHack-Common-Level.html#atI",
          "type": "function"
        },
        "index": {
          "description": "Query for items on the ground",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "atI",
          "normalized": "Level-\u003ePoint-\u003eItemBag",
          "package": "LambdaHack",
          "signature": "Level-\u003ePoint-\u003eItemBag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:atI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "checkAccess",
          "package": "LambdaHack",
          "signature": "COps -\u003e Level -\u003e Maybe (Point -\u003e Point -\u003e Bool)",
          "source": "src/Game-LambdaHack-Common-Level.html#checkAccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "checkAccess",
          "normalized": "COps-\u003eLevel-\u003eMaybe(Point-\u003ePoint-\u003eBool)",
          "package": "LambdaHack",
          "partial": "Access",
          "signature": "COps-\u003eLevel-\u003eMaybe(Point-\u003ePoint-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:checkAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "checkDoorAccess",
          "package": "LambdaHack",
          "signature": "COps -\u003e Level -\u003e Maybe (Point -\u003e Point -\u003e Bool)",
          "source": "src/Game-LambdaHack-Common-Level.html#checkDoorAccess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "checkDoorAccess",
          "normalized": "COps-\u003eLevel-\u003eMaybe(Point-\u003ePoint-\u003eBool)",
          "package": "LambdaHack",
          "partial": "Door Access",
          "signature": "COps-\u003eLevel-\u003eMaybe(Point-\u003ePoint-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:checkDoorAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a random position on the map satisfying a predicate.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "findPos",
          "package": "LambdaHack",
          "signature": "TileMap -\u003e (Point -\u003e Id TileKind -\u003e Bool) -\u003e Rnd Point",
          "source": "src/Game-LambdaHack-Common-Level.html#findPos",
          "type": "function"
        },
        "index": {
          "description": "Find random position on the map satisfying predicate",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "findPos",
          "normalized": "TileMap-\u003e(Point-\u003eId TileKind-\u003eBool)-\u003eRnd Point",
          "package": "LambdaHack",
          "partial": "Pos",
          "signature": "TileMap-\u003e(Point-\u003eId TileKind-\u003eBool)-\u003eRnd Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:findPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to find a random position on the map satisfying\n the conjunction of the list of predicates.\n If the permitted number of attempts is not enough,\n try again the same number of times without the first predicate,\n then without the first two, etc., until only one predicate remains,\n at which point try as many times, as needed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "findPosTry",
          "package": "LambdaHack",
          "signature": "Int-\u003e TileMap-\u003e (Point -\u003e Id TileKind -\u003e Bool)-\u003e [Point -\u003e Id TileKind -\u003e Bool]-\u003e Rnd Point",
          "type": "function"
        },
        "index": {
          "description": "Try to find random position on the map satisfying the conjunction of the list of predicates If the permitted number of attempts is not enough try again the same number of times without the first predicate then without the first two etc until only one predicate remains at which point try as many times as needed",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "findPosTry",
          "normalized": "Int-\u003eTileMap-\u003e(Point-\u003eId TileKind-\u003eBool)-\u003e[Point-\u003eId TileKind-\u003eBool]-\u003eRnd Point",
          "package": "LambdaHack",
          "partial": "Pos Try",
          "signature": "Int-\u003eTileMap-\u003e(Point-\u003eId TileKind-\u003eBool)-\u003e[Point-\u003eId TileKind-\u003eBool]-\u003eRnd Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:findPosTry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "hideTile",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Level -\u003e Point -\u003e Id TileKind",
          "source": "src/Game-LambdaHack-Common-Level.html#hideTile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "hideTile",
          "normalized": "Ops TileKind-\u003eLevel-\u003ePoint-\u003eId TileKind",
          "package": "LambdaHack",
          "partial": "Tile",
          "signature": "Ops TileKind-\u003eLevel-\u003ePoint-\u003eId TileKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:hideTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "isSecretPos",
          "package": "LambdaHack",
          "signature": "Level -\u003e Point -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Level.html#isSecretPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "isSecretPos",
          "normalized": "Level-\u003ePoint-\u003eBool",
          "package": "LambdaHack",
          "partial": "Secret Pos",
          "signature": "Level-\u003ePoint-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:isSecretPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etotal number of initially clear tiles;\n   set to 1 on clients when fully explored\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lclear",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "total number of initially clear tiles set to on clients when fully explored",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lclear",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lclear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edepth of the level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ldepth",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "depth of the level",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ldepth",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:ldepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elevel description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ldesc",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "level description",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ldesc",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:ldesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehas an Effect.Escape tile\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lescape",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "has an Effect.Escape tile",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lescape",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lescape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremembered items lying on the floor\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lfloor",
          "package": "LambdaHack",
          "signature": "ItemFloor",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "remembered items lying on the floor",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lfloor",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lfloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esecret tile density\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lhidden",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "secret tile density",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lhidden",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lhidden"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency of initial items,\n   [] for clients\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "litemFreq",
          "package": "LambdaHack",
          "signature": "(Frequency Text)",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "frequency of initial items for clients",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "litemFreq",
          "package": "LambdaHack",
          "partial": "Freq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:litemFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of initial items, 0 for clients\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "litemNum",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "number of initial items for clients",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "litemNum",
          "package": "LambdaHack",
          "partial": "Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:litemNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremembered actor times on the level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lprio",
          "package": "LambdaHack",
          "signature": "ActorPrio",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "remembered actor times on the level",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lprio",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lprio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esecret tile seed\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lsecret",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "secret tile seed",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lsecret",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lsecret"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrently remembered clear tiles\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lseen",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "currently remembered clear tiles",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lseen",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lseen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremembered smells on the level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lsmell",
          "package": "LambdaHack",
          "signature": "SmellMap",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "remembered smells on the level",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lsmell",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lsmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edestinations of (up, down) stairs\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lstair",
          "package": "LambdaHack",
          "signature": "([Point], [Point])",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "destinations of up down stairs",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lstair",
          "normalized": "([Point],[Point])",
          "package": "LambdaHack",
          "signature": "([Point],[Point])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lstair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremembered level map\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ltile",
          "package": "LambdaHack",
          "signature": "TileMap",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "remembered level map",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ltile",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:ltile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edate of the last activity on the level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ltime",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "date of the last activity on the level",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "ltime",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:ltime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewidth of the level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lxsize",
          "package": "LambdaHack",
          "signature": "X",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "width of the level",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lxsize",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lxsize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eheight of the level\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lysize",
          "package": "LambdaHack",
          "signature": "Y",
          "source": "src/Game-LambdaHack-Common-Level.html#Level",
          "type": "function"
        },
        "index": {
          "description": "height of the level",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "lysize",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:lysize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "mapDungeonActors_",
          "package": "LambdaHack",
          "signature": "(ActorId -\u003e m a) -\u003e Dungeon -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Level.html#mapDungeonActors_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "mapDungeonActors_",
          "normalized": "(ActorId-\u003ea b)-\u003eDungeon-\u003ea()",
          "package": "LambdaHack",
          "partial": "Dungeon Actors",
          "signature": "(ActorId-\u003em a)-\u003eDungeon-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:mapDungeonActors_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Level",
          "name": "mapLevelActors_",
          "package": "LambdaHack",
          "signature": "(ActorId -\u003e m a) -\u003e Level -\u003e m ()",
          "source": "src/Game-LambdaHack-Common-Level.html#mapLevelActors_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "mapLevelActors_",
          "normalized": "(ActorId-\u003ea b)-\u003eLevel-\u003ea()",
          "package": "LambdaHack",
          "partial": "Level Actors",
          "signature": "(ActorId-\u003em a)-\u003eLevel-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:mapLevelActors_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the items on the ground map.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updateFloor",
          "package": "LambdaHack",
          "signature": "(ItemFloor -\u003e ItemFloor) -\u003e Level -\u003e Level",
          "source": "src/Game-LambdaHack-Common-Level.html#updateFloor",
          "type": "function"
        },
        "index": {
          "description": "Update the items on the ground map",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updateFloor",
          "normalized": "(ItemFloor-\u003eItemFloor)-\u003eLevel-\u003eLevel",
          "package": "LambdaHack",
          "partial": "Floor",
          "signature": "(ItemFloor-\u003eItemFloor)-\u003eLevel-\u003eLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:updateFloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the actor time priority queue.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updatePrio",
          "package": "LambdaHack",
          "signature": "(ActorPrio -\u003e ActorPrio) -\u003e Level -\u003e Level",
          "source": "src/Game-LambdaHack-Common-Level.html#updatePrio",
          "type": "function"
        },
        "index": {
          "description": "Update the actor time priority queue",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updatePrio",
          "normalized": "(ActorPrio-\u003eActorPrio)-\u003eLevel-\u003eLevel",
          "package": "LambdaHack",
          "partial": "Prio",
          "signature": "(ActorPrio-\u003eActorPrio)-\u003eLevel-\u003eLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:updatePrio"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the smell map.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updateSmell",
          "package": "LambdaHack",
          "signature": "(SmellMap -\u003e SmellMap) -\u003e Level -\u003e Level",
          "source": "src/Game-LambdaHack-Common-Level.html#updateSmell",
          "type": "function"
        },
        "index": {
          "description": "Update the smell map",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updateSmell",
          "normalized": "(SmellMap-\u003eSmellMap)-\u003eLevel-\u003eLevel",
          "package": "LambdaHack",
          "partial": "Smell",
          "signature": "(SmellMap-\u003eSmellMap)-\u003eLevel-\u003eLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:updateSmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the tile map.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updateTile",
          "package": "LambdaHack",
          "signature": "(TileMap -\u003e TileMap) -\u003e Level -\u003e Level",
          "source": "src/Game-LambdaHack-Common-Level.html#updateTile",
          "type": "function"
        },
        "index": {
          "description": "Update the tile map",
          "hierarchy": "Game LambdaHack Common Level",
          "module": "Game.LambdaHack.Common.Level",
          "name": "updateTile",
          "normalized": "(TileMap-\u003eTileMap)-\u003eLevel-\u003eLevel",
          "package": "LambdaHack",
          "partial": "Tile",
          "signature": "(TileMap-\u003eTileMap)-\u003eLevel-\u003eLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Level.html#v:updateTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHacks that haven't found their home yet.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "Misc",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Misc.html",
          "type": "module"
        },
        "index": {
          "description": "Hacks that haven found their home yet",
          "hierarchy": "Game LambdaHack Common Misc",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "Misc",
          "package": "LambdaHack",
          "partial": "Misc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Misc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA unique identifier of a faction in a game.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "FactionId",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Misc.html#FactionId",
          "type": "data"
        },
        "index": {
          "description": "unique identifier of faction in game",
          "hierarchy": "Game LambdaHack Common Misc",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "FactionId",
          "package": "LambdaHack",
          "partial": "Faction Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Misc.html#t:FactionId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor each group that the kind belongs to, denoted by a \u003ccode\u003eText\u003c/code\u003e name\n in the first component of a pair, the second component of a pair shows\n how common the kind is within the group.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "Freqs",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Misc.html#Freqs",
          "type": "type"
        },
        "index": {
          "description": "For each group that the kind belongs to denoted by Text name in the first component of pair the second component of pair shows how common the kind is within the group",
          "hierarchy": "Game LambdaHack Common Misc",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "Freqs",
          "package": "LambdaHack",
          "partial": "Freqs",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Misc.html#t:Freqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract level identifiers.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "LevelId",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Misc.html#LevelId",
          "type": "data"
        },
        "index": {
          "description": "Abstract level identifiers",
          "hierarchy": "Game LambdaHack Common Misc",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "LevelId",
          "package": "LambdaHack",
          "partial": "Level Id",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Misc.html#t:LevelId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003ebreturn b a = [a | b]\u003c/pre\u003e",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "breturn",
          "package": "LambdaHack",
          "signature": "Bool -\u003e a -\u003e m a",
          "source": "src/Game-LambdaHack-Common-Misc.html#breturn",
          "type": "function"
        },
        "index": {
          "description": "breturn",
          "hierarchy": "Game LambdaHack Common Misc",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "breturn",
          "normalized": "Bool-\u003ea-\u003eb a",
          "package": "LambdaHack",
          "signature": "Bool-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Misc.html#v:breturn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInteger division, rounding up.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "divUp",
          "package": "LambdaHack",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Game-LambdaHack-Common-Misc.html#divUp",
          "type": "function"
        },
        "index": {
          "description": "Integer division rounding up",
          "hierarchy": "Game LambdaHack Common Misc",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "divUp",
          "normalized": "a-\u003ea-\u003ea",
          "package": "LambdaHack",
          "partial": "Up",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Misc.html#v:divUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLevel bounds. TODO: query terminal size instead and scroll view.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "normalLevelBound",
          "package": "LambdaHack",
          "signature": "(Int, Int)",
          "source": "src/Game-LambdaHack-Common-Misc.html#normalLevelBound",
          "type": "function"
        },
        "index": {
          "description": "Level bounds TODO query terminal size instead and scroll view",
          "hierarchy": "Game LambdaHack Common Misc",
          "module": "Game.LambdaHack.Common.Misc",
          "name": "normalLevelBound",
          "normalized": "(Int,Int)",
          "package": "LambdaHack",
          "partial": "Level Bound",
          "signature": "(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Misc.html#v:normalLevelBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGame messages displayed on top of the screen for the player to read.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Msg",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Msg.html",
          "type": "module"
        },
        "index": {
          "description": "Game messages displayed on top of the screen for the player to read",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Msg",
          "package": "LambdaHack",
          "partial": "Msg",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe history of reports.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "History",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Msg.html#History",
          "type": "data"
        },
        "index": {
          "description": "The history of reports",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "History",
          "package": "LambdaHack",
          "partial": "History",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#t:History"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a single message.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Msg",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Msg.html#Msg",
          "type": "type"
        },
        "index": {
          "description": "The type of single message",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Msg",
          "package": "LambdaHack",
          "partial": "Msg",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#t:Msg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA series of screen lines that may or may not fit the width nor height\n of the screen. An overlay may be transformed by adding the first line\n and/or by splitting into a slideshow of smaller overlays.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Overlay",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Msg.html#Overlay",
          "type": "data"
        },
        "index": {
          "description": "series of screen lines that may or may not fit the width nor height of the screen An overlay may be transformed by adding the first line and or by splitting into slideshow of smaller overlays",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Overlay",
          "package": "LambdaHack",
          "partial": "Overlay",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#t:Overlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a set of messages to show at the screen at once.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Report",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Msg.html#Report",
          "type": "data"
        },
        "index": {
          "description": "The type of set of messages to show at the screen at once",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Report",
          "package": "LambdaHack",
          "partial": "Report",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#t:Report"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA few overlays, displayed one by one upon keypress.\n When displayed, they are trimmed, not wrapped\n and any lines below the lower screen edge are not visible.\n If the boolean flag is set, the overlay is displayed over a blank screen,\n including the bottom lines.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Slideshow",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Msg.html#Slideshow",
          "type": "data"
        },
        "index": {
          "description": "few overlays displayed one by one upon keypress When displayed they are trimmed not wrapped and any lines below the lower screen edge are not visible If the boolean flag is set the overlay is displayed over blank screen including the bottom lines",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "Slideshow",
          "package": "LambdaHack",
          "partial": "Slideshow",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#t:Slideshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "(\u003c+\u003e)",
          "package": "LambdaHack",
          "signature": "Text -\u003e Text -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Msg.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "Text-\u003eText-\u003eText",
          "package": "LambdaHack",
          "signature": "Text-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "(\u003c\u003e)",
          "package": "LambdaHack",
          "signature": "m -\u003e m -\u003e m",
          "type": "function"
        },
        "index": {
          "description": "An infix synonym for mappend",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "LambdaHack",
          "signature": "m-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd message to the end of report.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "addMsg",
          "package": "LambdaHack",
          "signature": "Report -\u003e Msg -\u003e Report",
          "source": "src/Game-LambdaHack-Common-Msg.html#addMsg",
          "type": "function"
        },
        "index": {
          "description": "Add message to the end of report",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "addMsg",
          "normalized": "Report-\u003eMsg-\u003eReport",
          "package": "LambdaHack",
          "partial": "Msg",
          "signature": "Report-\u003eMsg-\u003eReport",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:addMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a report to history, handling repetitions.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "addReport",
          "package": "LambdaHack",
          "signature": "Report -\u003e History -\u003e History",
          "source": "src/Game-LambdaHack-Common-Msg.html#addReport",
          "type": "function"
        },
        "index": {
          "description": "Add report to history handling repetitions",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "addReport",
          "normalized": "Report-\u003eHistory-\u003eHistory",
          "package": "LambdaHack",
          "partial": "Report",
          "signature": "Report-\u003eHistory-\u003eHistory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:addReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty history of reports.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "emptyHistory",
          "package": "LambdaHack",
          "signature": "History",
          "source": "src/Game-LambdaHack-Common-Msg.html#emptyHistory",
          "type": "function"
        },
        "index": {
          "description": "Empty history of reports",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "emptyHistory",
          "package": "LambdaHack",
          "partial": "History",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:emptyHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "emptyOverlay",
          "package": "LambdaHack",
          "signature": "Overlay",
          "source": "src/Game-LambdaHack-Common-Msg.html#emptyOverlay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "emptyOverlay",
          "package": "LambdaHack",
          "partial": "Overlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:emptyOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty set of messages.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "emptyReport",
          "package": "LambdaHack",
          "signature": "Report",
          "source": "src/Game-LambdaHack-Common-Msg.html#emptyReport",
          "type": "function"
        },
        "index": {
          "description": "Empty set of messages",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "emptyReport",
          "package": "LambdaHack",
          "partial": "Report",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:emptyReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "findInReport",
          "package": "LambdaHack",
          "signature": "(ByteString -\u003e Bool) -\u003e Report -\u003e Maybe ByteString",
          "source": "src/Game-LambdaHack-Common-Msg.html#findInReport",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "findInReport",
          "normalized": "(ByteString-\u003eBool)-\u003eReport-\u003eMaybe ByteString",
          "package": "LambdaHack",
          "partial": "In Report",
          "signature": "(ByteString-\u003eBool)-\u003eReport-\u003eMaybe ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:findInReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRe-exported English phrase creation functions, applied to default\n irregular word sets.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "makePhrase",
          "package": "LambdaHack",
          "signature": "[Part] -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Msg.html#makePhrase",
          "type": "function"
        },
        "index": {
          "description": "Re-exported English phrase creation functions applied to default irregular word sets",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "makePhrase",
          "normalized": "[Part]-\u003eText",
          "package": "LambdaHack",
          "partial": "Phrase",
          "signature": "[Part]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:makePhrase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRe-exported English phrase creation functions, applied to default\n irregular word sets.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "makeSentence",
          "package": "LambdaHack",
          "signature": "[Part] -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Msg.html#makeSentence",
          "type": "function"
        },
        "index": {
          "description": "Re-exported English phrase creation functions applied to default irregular word sets",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "makeSentence",
          "normalized": "[Part]-\u003eText",
          "package": "LambdaHack",
          "partial": "Sentence",
          "signature": "[Part]-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:makeSentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "mergeHistory",
          "package": "LambdaHack",
          "signature": "[(Msg, History)] -\u003e History",
          "source": "src/Game-LambdaHack-Common-Msg.html#mergeHistory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "mergeHistory",
          "normalized": "[(Msg,History)]-\u003eHistory",
          "package": "LambdaHack",
          "partial": "History",
          "signature": "[(Msg,History)]-\u003eHistory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:mergeHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \"press something to see more\" mark.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "moreMsg",
          "package": "LambdaHack",
          "signature": "Msg",
          "source": "src/Game-LambdaHack-Common-Msg.html#moreMsg",
          "type": "function"
        },
        "index": {
          "description": "The press something to see more mark",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "moreMsg",
          "package": "LambdaHack",
          "partial": "Msg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:moreMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if the set of messages is empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "nullReport",
          "package": "LambdaHack",
          "signature": "Report -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Msg.html#nullReport",
          "type": "function"
        },
        "index": {
          "description": "Test if the set of messages is empty",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "nullReport",
          "normalized": "Report-\u003eBool",
          "package": "LambdaHack",
          "partial": "Report",
          "signature": "Report-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:nullReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender history as many lines of text, wrapping if necessary.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "renderHistory",
          "package": "LambdaHack",
          "signature": "History -\u003e Overlay",
          "source": "src/Game-LambdaHack-Common-Msg.html#renderHistory",
          "type": "function"
        },
        "index": {
          "description": "Render history as many lines of text wrapping if necessary",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "renderHistory",
          "normalized": "History-\u003eOverlay",
          "package": "LambdaHack",
          "partial": "History",
          "signature": "History-\u003eOverlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:renderHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRender a report as a (possibly very long) string.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "renderReport",
          "package": "LambdaHack",
          "signature": "Report -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Msg.html#renderReport",
          "type": "function"
        },
        "index": {
          "description": "Render report as possibly very long string",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "renderReport",
          "normalized": "Report-\u003eText",
          "package": "LambdaHack",
          "partial": "Report",
          "signature": "Report-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:renderReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a singleton history of reports.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "singletonHistory",
          "package": "LambdaHack",
          "signature": "Report -\u003e History",
          "source": "src/Game-LambdaHack-Common-Msg.html#singletonHistory",
          "type": "function"
        },
        "index": {
          "description": "Construct singleton history of reports",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "singletonHistory",
          "normalized": "Report-\u003eHistory",
          "package": "LambdaHack",
          "partial": "History",
          "signature": "Report-\u003eHistory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:singletonHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a singleton set of messages.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "singletonReport",
          "package": "LambdaHack",
          "signature": "Msg -\u003e Report",
          "source": "src/Game-LambdaHack-Common-Msg.html#singletonReport",
          "type": "function"
        },
        "index": {
          "description": "Construct singleton set of messages",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "singletonReport",
          "normalized": "Msg-\u003eReport",
          "package": "LambdaHack",
          "partial": "Report",
          "signature": "Msg-\u003eReport",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:singletonReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit an overlay into a slideshow in which each overlay,\n prefixed by \u003ccode\u003emsg\u003c/code\u003e and postfixed by \u003ccode\u003emoreMsg\u003c/code\u003e except for the last one,\n fits on the screen wrt height (but lines may be too wide).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "splitOverlay",
          "package": "LambdaHack",
          "signature": "Bool -\u003e Y -\u003e Overlay -\u003e Overlay -\u003e Slideshow",
          "source": "src/Game-LambdaHack-Common-Msg.html#splitOverlay",
          "type": "function"
        },
        "index": {
          "description": "Split an overlay into slideshow in which each overlay prefixed by msg and postfixed by moreMsg except for the last one fits on the screen wrt height but lines may be too wide",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "splitOverlay",
          "normalized": "Bool-\u003eY-\u003eOverlay-\u003eOverlay-\u003eSlideshow",
          "package": "LambdaHack",
          "partial": "Overlay",
          "signature": "Bool-\u003eY-\u003eOverlay-\u003eOverlay-\u003eSlideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:splitOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a messages into chunks that fit in one line.\n We assume the width of the messages line is the same as of level map.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "splitReport",
          "package": "LambdaHack",
          "signature": "X -\u003e Report -\u003e Overlay",
          "source": "src/Game-LambdaHack-Common-Msg.html#splitReport",
          "type": "function"
        },
        "index": {
          "description": "Split messages into chunks that fit in one line We assume the width of the messages line is the same as of level map",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "splitReport",
          "normalized": "X-\u003eReport-\u003eOverlay",
          "package": "LambdaHack",
          "partial": "Report",
          "signature": "X-\u003eReport-\u003eOverlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:splitReport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the given prefix of reports from a history.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "takeHistory",
          "package": "LambdaHack",
          "signature": "Int -\u003e History -\u003e History",
          "source": "src/Game-LambdaHack-Common-Msg.html#takeHistory",
          "type": "function"
        },
        "index": {
          "description": "Take the given prefix of reports from history",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "takeHistory",
          "normalized": "Int-\u003eHistory-\u003eHistory",
          "package": "LambdaHack",
          "partial": "History",
          "signature": "Int-\u003eHistory-\u003eHistory",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:takeHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "toOverlay",
          "package": "LambdaHack",
          "signature": "[Text] -\u003e Overlay",
          "source": "src/Game-LambdaHack-Common-Msg.html#toOverlay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "toOverlay",
          "normalized": "[Text]-\u003eOverlay",
          "package": "LambdaHack",
          "partial": "Overlay",
          "signature": "[Text]-\u003eOverlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:toOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclare the list of raw overlays to be fit for display on the screen.\n In particular, current \u003ccode\u003eReport\u003c/code\u003e is eiter empty or unimportant\n or contained in the overlays and if any vertical or horizontal\n trimming of the overlays happens, this is intended.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "toSlideshow",
          "package": "LambdaHack",
          "signature": "Bool -\u003e [[Text]] -\u003e Slideshow",
          "source": "src/Game-LambdaHack-Common-Msg.html#toSlideshow",
          "type": "function"
        },
        "index": {
          "description": "Declare the list of raw overlays to be fit for display on the screen In particular current Report is eiter empty or unimportant or contained in the overlays and if any vertical or horizontal trimming of the overlays happens this is intended",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "toSlideshow",
          "normalized": "Bool-\u003e[[Text]]-\u003eSlideshow",
          "package": "LambdaHack",
          "partial": "Slideshow",
          "signature": "Bool-\u003e[[Text]]-\u003eSlideshow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:toSlideshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "toWidth",
          "package": "LambdaHack",
          "signature": "Int -\u003e Text -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Msg.html#toWidth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "toWidth",
          "normalized": "Int-\u003eText-\u003eText",
          "package": "LambdaHack",
          "partial": "Width",
          "signature": "Int-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:toWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a space at the message end, for display overlayed over the level map.\n Also trims (does not wrap!) too long lines. In case of newlines,\n displays only the first line, but marks the message as partial.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "truncateMsg",
          "package": "LambdaHack",
          "signature": "X -\u003e Text -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Msg.html#truncateMsg",
          "type": "function"
        },
        "index": {
          "description": "Add space at the message end for display overlayed over the level map Also trims does not wrap too long lines In case of newlines displays only the first line but marks the message as partial",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "truncateMsg",
          "normalized": "X-\u003eText-\u003eText",
          "package": "LambdaHack",
          "partial": "Msg",
          "signature": "X-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:truncateMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "truncateToOverlay",
          "package": "LambdaHack",
          "signature": "X -\u003e Text -\u003e Overlay",
          "source": "src/Game-LambdaHack-Common-Msg.html#truncateToOverlay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "truncateToOverlay",
          "normalized": "X-\u003eText-\u003eOverlay",
          "package": "LambdaHack",
          "partial": "To Overlay",
          "signature": "X-\u003eText-\u003eOverlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:truncateToOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Msg",
          "name": "tshow",
          "package": "LambdaHack",
          "signature": "a -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Msg.html#tshow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "tshow",
          "normalized": "a-\u003eText",
          "package": "LambdaHack",
          "signature": "a-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:tshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe confirmation request message.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "yesnoMsg",
          "package": "LambdaHack",
          "signature": "Msg",
          "source": "src/Game-LambdaHack-Common-Msg.html#yesnoMsg",
          "type": "function"
        },
        "index": {
          "description": "The confirmation request message",
          "hierarchy": "Game LambdaHack Common Msg",
          "module": "Game.LambdaHack.Common.Msg",
          "name": "yesnoMsg",
          "package": "LambdaHack",
          "partial": "Msg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Msg.html#v:yesnoMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eActors perceiving other actors and the dungeon level.\n\u003c/p\u003e\u003cp\u003eVisibility works according to KISS. Everything that player sees is real.\n There are no unmarked hidden tiles and only solid tiles can be marked,\n so there are no invisible walls and to pass through an illusory wall,\n you have use a turn bumping into it first. Only tiles marked with Suspect\n can turn out to be another tile. (So, if all tiles are marked with\n Suspect, the player knows nothing for sure, but this should be avoided,\n because searching becomes too time-consuming.)\n Each actor sees adjacent tiles, even when blind, so adjacent tiles are\n known, so the actor can decide accurately whether to pass thorugh\n or alter, etc.\n\u003c/p\u003e\u003cp\u003eItems are always real and visible. Actors are real, but can be invisible.\n Invisible actors in walls can't be hit, but are hinted at when altering\n the tile, so the player can flee or block. Invisible actors in open\n space can be hit.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Perception",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Perception.html",
          "type": "module"
        },
        "index": {
          "description": "Actors perceiving other actors and the dungeon level Visibility works according to KISS Everything that player sees is real There are no unmarked hidden tiles and only solid tiles can be marked so there are no invisible walls and to pass through an illusory wall you have use turn bumping into it first Only tiles marked with Suspect can turn out to be another tile So if all tiles are marked with Suspect the player knows nothing for sure but this should be avoided because searching becomes too time-consuming Each actor sees adjacent tiles even when blind so adjacent tiles are known so the actor can decide accurately whether to pass thorugh or alter etc Items are always real and visible Actors are real but can be invisible Invisible actors in walls can be hit but are hinted at when altering the tile so the player can flee or block Invisible actors in open space can be hit",
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Perception",
          "package": "LambdaHack",
          "partial": "Perception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerception of a single faction, indexed by level identifier.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "FactionPers",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Perception.html#FactionPers",
          "type": "type"
        },
        "index": {
          "description": "Perception of single faction indexed by level identifier",
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "FactionPers",
          "package": "LambdaHack",
          "partial": "Faction Pers",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#t:FactionPers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type representing the perception of a faction on a level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Perception",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Perception.html#Perception",
          "type": "data"
        },
        "index": {
          "description": "The type representing the perception of faction on level",
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Perception",
          "package": "LambdaHack",
          "partial": "Perception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#t:Perception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Perception",
          "name": "PerceptionVisible",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Perception.html#PerceptionVisible",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "PerceptionVisible",
          "package": "LambdaHack",
          "partial": "Perception Visible",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#t:PerceptionVisible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerception indexed by faction identifier.\n This can't be added to \u003ccode\u003eFactionDict\u003c/code\u003e, because clients can't see it.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Pers",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Perception.html#Pers",
          "type": "type"
        },
        "index": {
          "description": "Perception indexed by faction identifier This can be added to FactionDict because clients can see it",
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Pers",
          "package": "LambdaHack",
          "partial": "Pers",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#t:Pers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Perception",
          "package": "LambdaHack",
          "signature": "Perception !PerceptionVisible !PerceptionVisible",
          "source": "src/Game-LambdaHack-Common-Perception.html#Perception",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "Perception",
          "package": "LambdaHack",
          "partial": "Perception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#v:Perception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Perception",
          "name": "PerceptionVisible",
          "package": "LambdaHack",
          "signature": "PerceptionVisible (EnumSet Point)",
          "source": "src/Game-LambdaHack-Common-Perception.html#PerceptionVisible",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "PerceptionVisible",
          "package": "LambdaHack",
          "partial": "Perception Visible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#v:PerceptionVisible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Perception",
          "name": "addPer",
          "package": "LambdaHack",
          "signature": "Perception -\u003e Perception -\u003e Perception",
          "source": "src/Game-LambdaHack-Common-Perception.html#addPer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "addPer",
          "normalized": "Perception-\u003ePerception-\u003ePerception",
          "package": "LambdaHack",
          "partial": "Per",
          "signature": "Perception-\u003ePerception-\u003ePerception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#v:addPer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Perception",
          "name": "diffPer",
          "package": "LambdaHack",
          "signature": "Perception -\u003e Perception -\u003e Perception",
          "source": "src/Game-LambdaHack-Common-Perception.html#diffPer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "diffPer",
          "normalized": "Perception-\u003ePerception-\u003ePerception",
          "package": "LambdaHack",
          "partial": "Per",
          "signature": "Perception-\u003ePerception-\u003ePerception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#v:diffPer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Perception",
          "name": "nullPer",
          "package": "LambdaHack",
          "signature": "Perception -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Perception.html#nullPer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "nullPer",
          "normalized": "Perception-\u003eBool",
          "package": "LambdaHack",
          "partial": "Per",
          "signature": "Perception-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#v:nullPer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of tiles smelled by at least one hero.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "smellVisible",
          "package": "LambdaHack",
          "signature": "Perception -\u003e EnumSet Point",
          "source": "src/Game-LambdaHack-Common-Perception.html#smellVisible",
          "type": "function"
        },
        "index": {
          "description": "The set of tiles smelled by at least one hero",
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "smellVisible",
          "normalized": "Perception-\u003eEnumSet Point",
          "package": "LambdaHack",
          "partial": "Visible",
          "signature": "Perception-\u003eEnumSet Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#v:smellVisible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe set of tiles visible by at least one hero.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "totalVisible",
          "package": "LambdaHack",
          "signature": "Perception -\u003e EnumSet Point",
          "source": "src/Game-LambdaHack-Common-Perception.html#totalVisible",
          "type": "function"
        },
        "index": {
          "description": "The set of tiles visible by at least one hero",
          "hierarchy": "Game LambdaHack Common Perception",
          "module": "Game.LambdaHack.Common.Perception",
          "name": "totalVisible",
          "normalized": "Perception-\u003eEnumSet Point",
          "package": "LambdaHack",
          "partial": "Visible",
          "signature": "Perception-\u003eEnumSet Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Perception.html#v:totalVisible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic operations on 2D points represented as linear offsets.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "Point",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Point.html",
          "type": "module"
        },
        "index": {
          "description": "Basic operations on points represented as linear offsets",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "Point",
          "package": "LambdaHack",
          "partial": "Point",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2D points in cartesian representation. Coordinates grow to the right\n and down, so that the (0, 0) point is in the top-left corner of the screen.\n Coordinates are never negative.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "Point",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Point.html#Point",
          "type": "data"
        },
        "index": {
          "description": "points in cartesian representation Coordinates grow to the right and down so that the point is in the top-left corner of the screen Coordinates are never negative",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "Point",
          "package": "LambdaHack",
          "partial": "Point",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#t:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpacial dimension for points and vectors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "X",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Point.html#X",
          "type": "type"
        },
        "index": {
          "description": "Spacial dimension for points and vectors",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "X",
          "package": "LambdaHack",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#t:X"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpacial dimension for points and vectors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "Y",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Point.html#Y",
          "type": "type"
        },
        "index": {
          "description": "Spacial dimension for points and vectors",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "Y",
          "package": "LambdaHack",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#t:Y"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Point",
          "name": "Point",
          "package": "LambdaHack",
          "signature": "Point",
          "source": "src/Game-LambdaHack-Common-Point.html#Point",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "Point",
          "package": "LambdaHack",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks whether two points are adjacent on the map\n (horizontally, vertically or diagonally).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "adjacent",
          "package": "LambdaHack",
          "signature": "Point -\u003e Point -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Point.html#adjacent",
          "type": "function"
        },
        "index": {
          "description": "Checks whether two points are adjacent on the map horizontally vertically or diagonally",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "adjacent",
          "normalized": "Point-\u003ePoint-\u003eBool",
          "package": "LambdaHack",
          "signature": "Point-\u003ePoint-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:adjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBresenham's line algorithm generalized to arbitrary starting \u003ccode\u003eeps\u003c/code\u003e\n (\u003ccode\u003eeps\u003c/code\u003e value of 0 gives the standard BLA).\n Skips the source point and goes through the second point\n to the edge of the level. GIves \u003ccode\u003eNothing\u003c/code\u003e if the points are equal.\n The target is given as \u003ccode\u003ePoint\u003c/code\u003e to permit aiming out of the level,\n e.g., to get uniform distributions of directions for explosions\n close to the edge of the level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "bla",
          "package": "LambdaHack",
          "signature": "X -\u003e Y -\u003e Int -\u003e Point -\u003e Point -\u003e Maybe [Point]",
          "source": "src/Game-LambdaHack-Common-Point.html#bla",
          "type": "function"
        },
        "index": {
          "description": "Bresenham line algorithm generalized to arbitrary starting eps eps value of gives the standard BLA Skips the source point and goes through the second point to the edge of the level GIves Nothing if the points are equal The target is given as Point to permit aiming out of the level e.g to get uniform distributions of directions for explosions close to the edge of the level",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "bla",
          "normalized": "X-\u003eY-\u003eInt-\u003ePoint-\u003ePoint-\u003eMaybe[Point]",
          "package": "LambdaHack",
          "signature": "X-\u003eY-\u003eInt-\u003ePoint-\u003ePoint-\u003eMaybe[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:bla"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe distance between two points in the chessboard metric.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "chessDist",
          "package": "LambdaHack",
          "signature": "Point -\u003e Point -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Point.html#chessDist",
          "type": "function"
        },
        "index": {
          "description": "The distance between two points in the chessboard metric",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "chessDist",
          "normalized": "Point-\u003ePoint-\u003eInt",
          "package": "LambdaHack",
          "partial": "Dist",
          "signature": "Point-\u003ePoint-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:chessDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquared euclidean distance between two points.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "euclidDistSq",
          "package": "LambdaHack",
          "signature": "Point -\u003e Point -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Point.html#euclidDistSq",
          "type": "function"
        },
        "index": {
          "description": "Squared euclidean distance between two points",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "euclidDistSq",
          "normalized": "Point-\u003ePoint-\u003eInt",
          "package": "LambdaHack",
          "partial": "Dist Sq",
          "signature": "Point-\u003ePoint-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:euclidDistSq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of all points on a straight vertical or straight horizontal line\n between two points. Fails if no such line exists.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "fromTo",
          "package": "LambdaHack",
          "signature": "Point -\u003e Point -\u003e [Point]",
          "source": "src/Game-LambdaHack-Common-Point.html#fromTo",
          "type": "function"
        },
        "index": {
          "description": "list of all points on straight vertical or straight horizontal line between two points Fails if no such line exists",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "fromTo",
          "normalized": "Point-\u003ePoint-\u003e[Point]",
          "package": "LambdaHack",
          "partial": "To",
          "signature": "Point-\u003ePoint-\u003e[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:fromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks that a point belongs to an area.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "inside",
          "package": "LambdaHack",
          "signature": "Point -\u003e (X, Y, X, Y) -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Point.html#inside",
          "type": "function"
        },
        "index": {
          "description": "Checks that point belongs to an area",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "inside",
          "normalized": "Point-\u003e(X,Y,X,Y)-\u003eBool",
          "package": "LambdaHack",
          "signature": "Point-\u003e(X,Y,X,Y)-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:inside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe maximum number of bits for level X and Y dimension (16).\n The value is chosen to support architectures with 32-bit Ints.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Point",
          "name": "maxLevelDimExponent",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Common-Point.html#maxLevelDimExponent",
          "type": "function"
        },
        "index": {
          "description": "The maximum number of bits for level and dimension The value is chosen to support architectures with bit Ints",
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "maxLevelDimExponent",
          "package": "LambdaHack",
          "partial": "Level Dim Exponent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:maxLevelDimExponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Point",
          "name": "px",
          "package": "LambdaHack",
          "signature": "X",
          "source": "src/Game-LambdaHack-Common-Point.html#Point",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "px",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:px"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Point",
          "name": "py",
          "package": "LambdaHack",
          "signature": "Y",
          "source": "src/Game-LambdaHack-Common-Point.html#Point",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Point",
          "module": "Game.LambdaHack.Common.Point",
          "name": "py",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Point.html#v:py"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArrays, based on Data.Vector.Unboxed, indexed by \u003ccode\u003ePoint\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "PointArray",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-PointArray.html",
          "type": "module"
        },
        "index": {
          "description": "Arrays based on Data.Vector.Unboxed indexed by Point",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "PointArray",
          "package": "LambdaHack",
          "partial": "Point Array",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrays indexed by \u003ccode\u003ePoint\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "Array",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-PointArray.html#Array",
          "type": "data"
        },
        "index": {
          "description": "Arrays indexed by Point",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "Array",
          "package": "LambdaHack",
          "partial": "Array",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#t:Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArray lookup.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "(!)",
          "package": "LambdaHack",
          "signature": "Array c -\u003e Point -\u003e c",
          "source": "src/Game-LambdaHack-Common-PointArray.html#%21",
          "type": "function"
        },
        "index": {
          "description": "Array lookup",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "(!) !",
          "normalized": "Array a-\u003ePoint-\u003ea",
          "package": "LambdaHack",
          "signature": "Array c-\u003ePoint-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an array updated with the association list.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "(//)",
          "package": "LambdaHack",
          "signature": "Array c -\u003e [(Point, c)] -\u003e Array c",
          "source": "src/Game-LambdaHack-Common-PointArray.html#%2F%2F",
          "type": "function"
        },
        "index": {
          "description": "Construct an array updated with the association list",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "(//) //",
          "normalized": "Array a-\u003e[(Point,a)]-\u003eArray a",
          "package": "LambdaHack",
          "signature": "Array c-\u003e[(Point,c)]-\u003eArray c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:-47--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold left strictly over an array.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "foldlA",
          "package": "LambdaHack",
          "signature": "(a -\u003e c -\u003e a) -\u003e a -\u003e Array c -\u003e a",
          "source": "src/Game-LambdaHack-Common-PointArray.html#foldlA",
          "type": "function"
        },
        "index": {
          "description": "Fold left strictly over an array",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "foldlA",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eArray b-\u003ea",
          "package": "LambdaHack",
          "signature": "(a-\u003ec-\u003ea)-\u003ea-\u003eArray c-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:foldlA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an array from a monadic function.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "generateMA",
          "package": "LambdaHack",
          "signature": "X -\u003e Y -\u003e (Point -\u003e m c) -\u003e m (Array c)",
          "source": "src/Game-LambdaHack-Common-PointArray.html#generateMA",
          "type": "function"
        },
        "index": {
          "description": "Create an array from monadic function",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "generateMA",
          "normalized": "X-\u003eY-\u003e(Point-\u003ea b)-\u003ea(Array b)",
          "package": "LambdaHack",
          "partial": "MA",
          "signature": "X-\u003eY-\u003e(Point-\u003em c)-\u003em(Array c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:generateMA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold left strictly over an array\n (function applied to each element and its index).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "ifoldlA",
          "package": "LambdaHack",
          "signature": "(a -\u003e Point -\u003e c -\u003e a) -\u003e a -\u003e Array c -\u003e a",
          "source": "src/Game-LambdaHack-Common-PointArray.html#ifoldlA",
          "type": "function"
        },
        "index": {
          "description": "Fold left strictly over an array function applied to each element and its index",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "ifoldlA",
          "normalized": "(a-\u003ePoint-\u003eb-\u003ea)-\u003ea-\u003eArray b-\u003ea",
          "package": "LambdaHack",
          "signature": "(a-\u003ePoint-\u003ec-\u003ea)-\u003ea-\u003eArray c-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:ifoldlA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the point coordinates of the first maximum element of the array.\n The array may not be empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "maxIndexA",
          "package": "LambdaHack",
          "signature": "Array c -\u003e Point",
          "source": "src/Game-LambdaHack-Common-PointArray.html#maxIndexA",
          "type": "function"
        },
        "index": {
          "description": "Yield the point coordinates of the first maximum element of the array The array may not be empty",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "maxIndexA",
          "normalized": "Array a-\u003ePoint",
          "package": "LambdaHack",
          "partial": "Index",
          "signature": "Array c-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:maxIndexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the point coordinates of the last maximum element of the array.\n The array may not be empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "maxLastIndexA",
          "package": "LambdaHack",
          "signature": "Array c -\u003e Point",
          "source": "src/Game-LambdaHack-Common-PointArray.html#maxLastIndexA",
          "type": "function"
        },
        "index": {
          "description": "Yield the point coordinates of the last maximum element of the array The array may not be empty",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "maxLastIndexA",
          "normalized": "Array a-\u003ePoint",
          "package": "LambdaHack",
          "partial": "Last Index",
          "signature": "Array c-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:maxLastIndexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the point coordinates of a minimum element of the array.\n The array may not be empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "minIndexA",
          "package": "LambdaHack",
          "signature": "Array c -\u003e Point",
          "source": "src/Game-LambdaHack-Common-PointArray.html#minIndexA",
          "type": "function"
        },
        "index": {
          "description": "Yield the point coordinates of minimum element of the array The array may not be empty",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "minIndexA",
          "normalized": "Array a-\u003ePoint",
          "package": "LambdaHack",
          "partial": "Index",
          "signature": "Array c-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:minIndexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the point coordinates of the last minimum element of the array.\n The array may not be empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "minLastIndexA",
          "package": "LambdaHack",
          "signature": "Array c -\u003e Point",
          "source": "src/Game-LambdaHack-Common-PointArray.html#minLastIndexA",
          "type": "function"
        },
        "index": {
          "description": "Yield the point coordinates of the last minimum element of the array The array may not be empty",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "minLastIndexA",
          "normalized": "Array a-\u003ePoint",
          "package": "LambdaHack",
          "partial": "Last Index",
          "signature": "Array c-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:minLastIndexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an array from a replicated element.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "replicateA",
          "package": "LambdaHack",
          "signature": "X -\u003e Y -\u003e c -\u003e Array c",
          "source": "src/Game-LambdaHack-Common-PointArray.html#replicateA",
          "type": "function"
        },
        "index": {
          "description": "Create an array from replicated element",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "replicateA",
          "normalized": "X-\u003eY-\u003ea-\u003eArray a",
          "package": "LambdaHack",
          "signature": "X-\u003eY-\u003ec-\u003eArray c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:replicateA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an  array from a replicated monadic action.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "replicateMA",
          "package": "LambdaHack",
          "signature": "X -\u003e Y -\u003e m c -\u003e m (Array c)",
          "source": "src/Game-LambdaHack-Common-PointArray.html#replicateMA",
          "type": "function"
        },
        "index": {
          "description": "Create an array from replicated monadic action",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "replicateMA",
          "normalized": "X-\u003eY-\u003ea b-\u003ea(Array b)",
          "package": "LambdaHack",
          "partial": "MA",
          "signature": "X-\u003eY-\u003em c-\u003em(Array c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:replicateMA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContent identifiers array size.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "sizeA",
          "package": "LambdaHack",
          "signature": "Array c -\u003e (X, Y)",
          "source": "src/Game-LambdaHack-Common-PointArray.html#sizeA",
          "type": "function"
        },
        "index": {
          "description": "Content identifiers array size",
          "hierarchy": "Game LambdaHack Common PointArray",
          "module": "Game.LambdaHack.Common.PointArray",
          "name": "sizeA",
          "normalized": "Array a-\u003e(X,Y)",
          "package": "LambdaHack",
          "signature": "Array c-\u003e(X,Y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-PointArray.html#v:sizeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRepresentation of probabilities and random computations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "Random",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Random.html",
          "type": "module"
        },
        "index": {
          "description": "Representation of probabilities and random computations",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "Random",
          "package": "LambdaHack",
          "partial": "Random",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFractional chance.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "Chance",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Random.html#Chance",
          "type": "type"
        },
        "index": {
          "description": "Fractional chance",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "Chance",
          "package": "LambdaHack",
          "partial": "Chance",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#t:Chance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe monad of computations with random generator state.\n The lazy state monad is OK here: the state is small and regularly forced.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "Rnd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Random.html#Rnd",
          "type": "type"
        },
        "index": {
          "description": "The monad of computations with random generator state The lazy state monad is OK here the state is small and regularly forced",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "Rnd",
          "package": "LambdaHack",
          "partial": "Rnd",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#t:Rnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDice for parameters scaled with current level depth.\n To the result of rolling the first set of dice we add the second,\n scaled in proportion to current depth divided by maximal dungeon depth.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "RollDeep",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Random.html#RollDeep",
          "type": "data"
        },
        "index": {
          "description": "Dice for parameters scaled with current level depth To the result of rolling the first set of dice we add the second scaled in proportion to current depth divided by maximal dungeon depth",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "RollDeep",
          "package": "LambdaHack",
          "partial": "Roll Deep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#t:RollDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDice: 1d7, 3d3, 1d0, etc.\n \u003ccode\u003eRollDice a b\u003c/code\u003e represents \u003ccode\u003ea\u003c/code\u003e rolls of \u003ccode\u003eb\u003c/code\u003e-sided die.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "RollDice",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Random.html#RollDice",
          "type": "data"
        },
        "index": {
          "description": "Dice d7 d3 d0 etc RollDice represents rolls of sided die",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "RollDice",
          "package": "LambdaHack",
          "partial": "Roll Dice",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#t:RollDice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDice for rolling a pair of integer parameters pertaining to,\n respectively, the X and Y cartesian 2D coordinates.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "RollDiceXY",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Random.html#RollDiceXY",
          "type": "data"
        },
        "index": {
          "description": "Dice for rolling pair of integer parameters pertaining to respectively the and cartesian coordinates",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "RollDiceXY",
          "package": "LambdaHack",
          "partial": "Roll Dice XY",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#t:RollDiceXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast a single die.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "cast",
          "package": "LambdaHack",
          "signature": "Int -\u003e Rnd Int",
          "source": "src/Game-LambdaHack-Common-Random.html#cast",
          "type": "function"
        },
        "index": {
          "description": "Cast single die",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "cast",
          "normalized": "Int-\u003eRnd Int",
          "package": "LambdaHack",
          "signature": "Int-\u003eRnd Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast dice scaled with current level depth.\n Note that at the first level, the scaled dice are always ignored.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "castDeep",
          "package": "LambdaHack",
          "signature": "Int -\u003e Int -\u003e RollDeep -\u003e Rnd Int",
          "source": "src/Game-LambdaHack-Common-Random.html#castDeep",
          "type": "function"
        },
        "index": {
          "description": "Cast dice scaled with current level depth Note that at the first level the scaled dice are always ignored",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "castDeep",
          "normalized": "Int-\u003eInt-\u003eRollDeep-\u003eRnd Int",
          "package": "LambdaHack",
          "partial": "Deep",
          "signature": "Int-\u003eInt-\u003eRollDeep-\u003eRnd Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:castDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast dice and sum the results.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "castDice",
          "package": "LambdaHack",
          "signature": "RollDice -\u003e Rnd Int",
          "source": "src/Game-LambdaHack-Common-Random.html#castDice",
          "type": "function"
        },
        "index": {
          "description": "Cast dice and sum the results",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "castDice",
          "normalized": "RollDice-\u003eRnd Int",
          "package": "LambdaHack",
          "partial": "Dice",
          "signature": "RollDice-\u003eRnd Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:castDice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast the two sets of dice.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "castDiceXY",
          "package": "LambdaHack",
          "signature": "RollDiceXY -\u003e Rnd (Int, Int)",
          "source": "src/Game-LambdaHack-Common-Random.html#castDiceXY",
          "type": "function"
        },
        "index": {
          "description": "Cast the two sets of dice",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "castDiceXY",
          "normalized": "RollDiceXY-\u003eRnd(Int,Int)",
          "package": "LambdaHack",
          "partial": "Dice XY",
          "signature": "RollDiceXY-\u003eRnd(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:castDiceXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGive \u003ccode\u003eTrue\u003c/code\u003e, with probability determined by the fraction.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "chance",
          "package": "LambdaHack",
          "signature": "Chance -\u003e Rnd Bool",
          "source": "src/Game-LambdaHack-Common-Random.html#chance",
          "type": "function"
        },
        "index": {
          "description": "Give True with probability determined by the fraction",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "chance",
          "normalized": "Chance-\u003eRnd Bool",
          "package": "LambdaHack",
          "signature": "Chance-\u003eRnd Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:chance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast dice scaled with current level depth and return \u003ccode\u003eTrue\u003c/code\u003e\n if the results if greater than 50.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "chanceDeep",
          "package": "LambdaHack",
          "signature": "Int -\u003e Int -\u003e RollDeep -\u003e Rnd Bool",
          "source": "src/Game-LambdaHack-Common-Random.html#chanceDeep",
          "type": "function"
        },
        "index": {
          "description": "Cast dice scaled with current level depth and return True if the results if greater than",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "chanceDeep",
          "normalized": "Int-\u003eInt-\u003eRollDeep-\u003eRnd Bool",
          "package": "LambdaHack",
          "partial": "Deep",
          "signature": "Int-\u003eInt-\u003eRollDeep-\u003eRnd Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:chanceDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGen an element according to a frequency distribution.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "frequency",
          "package": "LambdaHack",
          "signature": "Frequency a -\u003e Rnd a",
          "source": "src/Game-LambdaHack-Common-Random.html#frequency",
          "type": "function"
        },
        "index": {
          "description": "Gen an element according to frequency distribution",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "frequency",
          "normalized": "Frequency a-\u003eRnd a",
          "package": "LambdaHack",
          "signature": "Frequency a-\u003eRnd a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:frequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003eRollDeep\u003c/code\u003e that always gives a constant integer.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "intToDeep",
          "package": "LambdaHack",
          "signature": "Int -\u003e RollDeep",
          "source": "src/Game-LambdaHack-Common-Random.html#intToDeep",
          "type": "function"
        },
        "index": {
          "description": "Generate RollDeep that always gives constant integer",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "intToDeep",
          "normalized": "Int-\u003eRollDeep",
          "package": "LambdaHack",
          "partial": "To Deep",
          "signature": "Int-\u003eRollDeep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:intToDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximal value of scaled dice.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "maxDeep",
          "package": "LambdaHack",
          "signature": "RollDeep -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Random.html#maxDeep",
          "type": "function"
        },
        "index": {
          "description": "Maximal value of scaled dice",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "maxDeep",
          "normalized": "RollDeep-\u003eInt",
          "package": "LambdaHack",
          "partial": "Deep",
          "signature": "RollDeep-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:maxDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximal value of dice.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "maxDice",
          "package": "LambdaHack",
          "signature": "RollDice -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Random.html#maxDice",
          "type": "function"
        },
        "index": {
          "description": "Maximal value of dice",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "maxDice",
          "normalized": "RollDice-\u003eInt",
          "package": "LambdaHack",
          "partial": "Dice",
          "signature": "RollDice-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:maxDice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximal value of RollDiceXY.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "maxDiceXY",
          "package": "LambdaHack",
          "signature": "RollDiceXY -\u003e (Int, Int)",
          "source": "src/Game-LambdaHack-Common-Random.html#maxDiceXY",
          "type": "function"
        },
        "index": {
          "description": "Maximal value of RollDiceXY",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "maxDiceXY",
          "normalized": "RollDiceXY-\u003e(Int,Int)",
          "package": "LambdaHack",
          "partial": "Dice XY",
          "signature": "RollDiceXY-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:maxDiceXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMean value of dice.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "meanDice",
          "package": "LambdaHack",
          "signature": "RollDice -\u003e Rational",
          "source": "src/Game-LambdaHack-Common-Random.html#meanDice",
          "type": "function"
        },
        "index": {
          "description": "Mean value of dice",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "meanDice",
          "normalized": "RollDice-\u003eRational",
          "package": "LambdaHack",
          "partial": "Dice",
          "signature": "RollDice-\u003eRational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:meanDice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMean value of RollDiceXY.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "meanDiceXY",
          "package": "LambdaHack",
          "signature": "RollDiceXY -\u003e (Rational, Rational)",
          "source": "src/Game-LambdaHack-Common-Random.html#meanDiceXY",
          "type": "function"
        },
        "index": {
          "description": "Mean value of RollDiceXY",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "meanDiceXY",
          "normalized": "RollDiceXY-\u003e(Rational,Rational)",
          "package": "LambdaHack",
          "partial": "Dice XY",
          "signature": "RollDiceXY-\u003e(Rational,Rational)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:meanDiceXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal value of dice.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "minDice",
          "package": "LambdaHack",
          "signature": "RollDice -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Random.html#minDice",
          "type": "function"
        },
        "index": {
          "description": "Minimal value of dice",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "minDice",
          "normalized": "RollDice-\u003eInt",
          "package": "LambdaHack",
          "partial": "Dice",
          "signature": "RollDice-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:minDice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal value of RollDiceXY.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "minDiceXY",
          "package": "LambdaHack",
          "signature": "RollDiceXY -\u003e (Int, Int)",
          "source": "src/Game-LambdaHack-Common-Random.html#minDiceXY",
          "type": "function"
        },
        "index": {
          "description": "Minimal value of RollDiceXY",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "minDiceXY",
          "normalized": "RollDiceXY-\u003e(Int,Int)",
          "package": "LambdaHack",
          "partial": "Dice XY",
          "signature": "RollDiceXY-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:minDiceXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet any element of a list with equal probability.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "oneOf",
          "package": "LambdaHack",
          "signature": "[a] -\u003e Rnd a",
          "source": "src/Game-LambdaHack-Common-Random.html#oneOf",
          "type": "function"
        },
        "index": {
          "description": "Get any element of list with equal probability",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "oneOf",
          "normalized": "[a]-\u003eRnd a",
          "package": "LambdaHack",
          "partial": "Of",
          "signature": "[a]-\u003eRnd a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:oneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a random object of a given type with a uniform distribution.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "random",
          "package": "LambdaHack",
          "signature": "Rnd a",
          "source": "src/Game-LambdaHack-Common-Random.html#random",
          "type": "function"
        },
        "index": {
          "description": "Get random object of given type with uniform distribution",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "random",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:random"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a random object within a range with a uniform distribution.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Random",
          "name": "randomR",
          "package": "LambdaHack",
          "signature": "(a, a) -\u003e Rnd a",
          "source": "src/Game-LambdaHack-Common-Random.html#randomR",
          "type": "function"
        },
        "index": {
          "description": "Get random object within range with uniform distribution",
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "randomR",
          "normalized": "(a,a)-\u003eRnd a",
          "package": "LambdaHack",
          "signature": "(a,a)-\u003eRnd a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:randomR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Random",
          "name": "rndToIO",
          "package": "LambdaHack",
          "signature": "Rnd a -\u003e IO a",
          "source": "src/Game-LambdaHack-Common-Random.html#rndToIO",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "rndToIO",
          "normalized": "Rnd a-\u003eIO a",
          "package": "LambdaHack",
          "partial": "To IO",
          "signature": "Rnd a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:rndToIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Random",
          "name": "rollDeep",
          "package": "LambdaHack",
          "signature": "(Int, Int) -\u003e (Int, Int) -\u003e RollDeep",
          "source": "src/Game-LambdaHack-Common-Random.html#rollDeep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "rollDeep",
          "normalized": "(Int,Int)-\u003e(Int,Int)-\u003eRollDeep",
          "package": "LambdaHack",
          "partial": "Deep",
          "signature": "(Int,Int)-\u003e(Int,Int)-\u003eRollDeep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:rollDeep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Random",
          "name": "rollDice",
          "package": "LambdaHack",
          "signature": "Int -\u003e Int -\u003e RollDice",
          "source": "src/Game-LambdaHack-Common-Random.html#rollDice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "rollDice",
          "normalized": "Int-\u003eInt-\u003eRollDice",
          "package": "LambdaHack",
          "partial": "Dice",
          "signature": "Int-\u003eInt-\u003eRollDice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:rollDice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Random",
          "name": "rollDiceXY",
          "package": "LambdaHack",
          "signature": "[(Int, Int)] -\u003e [(Int, Int)] -\u003e RollDiceXY",
          "source": "src/Game-LambdaHack-Common-Random.html#rollDiceXY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Random",
          "module": "Game.LambdaHack.Common.Random",
          "name": "rollDiceXY",
          "normalized": "[(Int,Int)]-\u003e[(Int,Int)]-\u003eRollDiceXY",
          "package": "LambdaHack",
          "partial": "Dice XY",
          "signature": "[(Int,Int)]-\u003e[(Int,Int)]-\u003eRollDiceXY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Random.html#v:rollDiceXY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSaving and restoring server game state.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Save",
          "name": "Save",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Save.html",
          "type": "module"
        },
        "index": {
          "description": "Saving and restoring server game state",
          "hierarchy": "Game LambdaHack Common Save",
          "module": "Game.LambdaHack.Common.Save",
          "name": "Save",
          "package": "LambdaHack",
          "partial": "Save",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Save.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Save",
          "name": "ChanSave",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Save.html#ChanSave",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Save",
          "module": "Game.LambdaHack.Common.Save",
          "name": "ChanSave",
          "package": "LambdaHack",
          "partial": "Chan Save",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Save.html#t:ChanSave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Save",
          "name": "delayPrint",
          "package": "LambdaHack",
          "signature": "Text -\u003e IO ()",
          "source": "src/Game-LambdaHack-Common-Save.html#delayPrint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Save",
          "module": "Game.LambdaHack.Common.Save",
          "name": "delayPrint",
          "normalized": "Text-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Print",
          "signature": "Text-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Save.html#v:delayPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRestore a saved game, if it exists. Initialize directory structure\n and cope over data files, if needed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Save",
          "name": "restoreGame",
          "package": "LambdaHack",
          "signature": "String -\u003e [(FilePath, FilePath)] -\u003e (FilePath -\u003e IO FilePath) -\u003e IO (Maybe a)",
          "source": "src/Game-LambdaHack-Common-Save.html#restoreGame",
          "type": "function"
        },
        "index": {
          "description": "Restore saved game if it exists Initialize directory structure and cope over data files if needed",
          "hierarchy": "Game LambdaHack Common Save",
          "module": "Game.LambdaHack.Common.Save",
          "name": "restoreGame",
          "normalized": "String-\u003e[(FilePath,FilePath)]-\u003e(FilePath-\u003eIO FilePath)-\u003eIO(Maybe a)",
          "package": "LambdaHack",
          "partial": "Game",
          "signature": "String-\u003e[(FilePath,FilePath)]-\u003e(FilePath-\u003eIO FilePath)-\u003eIO(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Save.html#v:restoreGame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Save",
          "name": "saveToChan",
          "package": "LambdaHack",
          "signature": "ChanSave a -\u003e a -\u003e IO ()",
          "source": "src/Game-LambdaHack-Common-Save.html#saveToChan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Save",
          "module": "Game.LambdaHack.Common.Save",
          "name": "saveToChan",
          "normalized": "ChanSave a-\u003ea-\u003eIO()",
          "package": "LambdaHack",
          "partial": "To Chan",
          "signature": "ChanSave a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Save.html#v:saveToChan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Save",
          "name": "wrapInSaves",
          "package": "LambdaHack",
          "signature": "(a -\u003e FilePath) -\u003e (ChanSave a -\u003e IO ()) -\u003e IO ()",
          "source": "src/Game-LambdaHack-Common-Save.html#wrapInSaves",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Save",
          "module": "Game.LambdaHack.Common.Save",
          "name": "wrapInSaves",
          "normalized": "(a-\u003eFilePath)-\u003e(ChanSave a-\u003eIO())-\u003eIO()",
          "package": "LambdaHack",
          "partial": "In Saves",
          "signature": "(a-\u003eFilePath)-\u003e(ChanSave a-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Save.html#v:wrapInSaves"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstract syntax of server commands.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ServerCmd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html",
          "type": "module"
        },
        "index": {
          "description": "Abstract syntax of server commands See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ServerCmd",
          "package": "LambdaHack",
          "partial": "Server Cmd",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract syntax of server commands.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "CmdSer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdSer",
          "type": "data"
        },
        "index": {
          "description": "Abstract syntax of server commands",
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "CmdSer",
          "package": "LambdaHack",
          "partial": "Cmd Ser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#t:CmdSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "CmdTakeTimeSer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "CmdTakeTimeSer",
          "package": "LambdaHack",
          "partial": "Cmd Take Time Ser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#t:CmdTakeTimeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "FailureSer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "FailureSer",
          "package": "LambdaHack",
          "partial": "Failure Ser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#t:FailureSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterBlockActor",
          "package": "LambdaHack",
          "signature": "AlterBlockActor",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterBlockActor",
          "package": "LambdaHack",
          "partial": "Alter Block Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:AlterBlockActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterBlockItem",
          "package": "LambdaHack",
          "signature": "AlterBlockItem",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterBlockItem",
          "package": "LambdaHack",
          "partial": "Alter Block Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:AlterBlockItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterDistant",
          "package": "LambdaHack",
          "signature": "AlterDistant",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterDistant",
          "package": "LambdaHack",
          "partial": "Alter Distant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:AlterDistant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterNothing",
          "package": "LambdaHack",
          "signature": "AlterNothing",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterNothing",
          "package": "LambdaHack",
          "partial": "Alter Nothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:AlterNothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterSer",
          "package": "LambdaHack",
          "signature": "AlterSer !ActorId !Point !(Maybe Feature)",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "AlterSer",
          "package": "LambdaHack",
          "partial": "Alter Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:AlterSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ApplySer",
          "package": "LambdaHack",
          "signature": "ApplySer !ActorId !ItemId !Container",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ApplySer",
          "package": "LambdaHack",
          "partial": "Apply Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:ApplySer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "CmdTakeTimeSer",
          "package": "LambdaHack",
          "signature": "CmdTakeTimeSer !CmdTakeTimeSer",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "CmdTakeTimeSer",
          "package": "LambdaHack",
          "partial": "Cmd Take Time Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:CmdTakeTimeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceAccess",
          "package": "LambdaHack",
          "signature": "DisplaceAccess",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceAccess",
          "package": "LambdaHack",
          "partial": "Displace Access",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:DisplaceAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceDistant",
          "package": "LambdaHack",
          "signature": "DisplaceDistant",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceDistant",
          "package": "LambdaHack",
          "partial": "Displace Distant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:DisplaceDistant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceProjectiles",
          "package": "LambdaHack",
          "signature": "DisplaceProjectiles",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceProjectiles",
          "package": "LambdaHack",
          "partial": "Displace Projectiles",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:DisplaceProjectiles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceSer",
          "package": "LambdaHack",
          "signature": "DisplaceSer !ActorId !ActorId",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DisplaceSer",
          "package": "LambdaHack",
          "partial": "Displace Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:DisplaceSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DropSer",
          "package": "LambdaHack",
          "signature": "DropSer !ActorId !ItemId !Int",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "DropSer",
          "package": "LambdaHack",
          "partial": "Drop Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:DropSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "GameExitSer",
          "package": "LambdaHack",
          "signature": "GameExitSer !ActorId !Int",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "GameExitSer",
          "package": "LambdaHack",
          "partial": "Game Exit Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:GameExitSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "GameRestartSer",
          "package": "LambdaHack",
          "signature": "GameRestartSer !ActorId !Text !Int ![(Int, Text)]",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "GameRestartSer",
          "normalized": "GameRestartSer ActorId Text Int[(Int,Text)]",
          "package": "LambdaHack",
          "partial": "Game Restart Ser",
          "signature": "GameRestartSer ActorId Text Int[(Int,Text)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:GameRestartSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "GameSaveSer",
          "package": "LambdaHack",
          "signature": "GameSaveSer !ActorId",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "GameSaveSer",
          "package": "LambdaHack",
          "partial": "Game Save Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:GameSaveSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MeleeDistant",
          "package": "LambdaHack",
          "signature": "MeleeDistant",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MeleeDistant",
          "package": "LambdaHack",
          "partial": "Melee Distant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:MeleeDistant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MeleeSelf",
          "package": "LambdaHack",
          "signature": "MeleeSelf",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MeleeSelf",
          "package": "LambdaHack",
          "partial": "Melee Self",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:MeleeSelf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MeleeSer",
          "package": "LambdaHack",
          "signature": "MeleeSer !ActorId !ActorId",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MeleeSer",
          "package": "LambdaHack",
          "partial": "Melee Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:MeleeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MoveNothing",
          "package": "LambdaHack",
          "signature": "MoveNothing",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MoveNothing",
          "package": "LambdaHack",
          "partial": "Move Nothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:MoveNothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MoveSer",
          "package": "LambdaHack",
          "signature": "MoveSer !ActorId !Vector",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "MoveSer",
          "package": "LambdaHack",
          "partial": "Move Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:MoveSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "PickupOverfull",
          "package": "LambdaHack",
          "signature": "PickupOverfull",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "PickupOverfull",
          "package": "LambdaHack",
          "partial": "Pickup Overfull",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:PickupOverfull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "PickupSer",
          "package": "LambdaHack",
          "signature": "PickupSer !ActorId !ItemId !Int",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "PickupSer",
          "package": "LambdaHack",
          "partial": "Pickup Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:PickupSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectAimOnself",
          "package": "LambdaHack",
          "signature": "ProjectAimOnself",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectAimOnself",
          "package": "LambdaHack",
          "partial": "Project Aim Onself",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:ProjectAimOnself"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlind",
          "package": "LambdaHack",
          "signature": "ProjectBlind",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlind",
          "package": "LambdaHack",
          "partial": "Project Blind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:ProjectBlind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlockActor",
          "package": "LambdaHack",
          "signature": "ProjectBlockActor",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlockActor",
          "package": "LambdaHack",
          "partial": "Project Block Actor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:ProjectBlockActor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlockFoes",
          "package": "LambdaHack",
          "signature": "ProjectBlockFoes",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlockFoes",
          "package": "LambdaHack",
          "partial": "Project Block Foes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:ProjectBlockFoes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlockTerrain",
          "package": "LambdaHack",
          "signature": "ProjectBlockTerrain",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectBlockTerrain",
          "package": "LambdaHack",
          "partial": "Project Block Terrain",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:ProjectBlockTerrain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectSer",
          "package": "LambdaHack",
          "signature": "ProjectSer !ActorId !Point !Int !ItemId !Container",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "ProjectSer",
          "package": "LambdaHack",
          "partial": "Project Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:ProjectSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "SetTrajectorySer",
          "package": "LambdaHack",
          "signature": "SetTrajectorySer !ActorId",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "SetTrajectorySer",
          "package": "LambdaHack",
          "partial": "Set Trajectory Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:SetTrajectorySer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "TriggerNothing",
          "package": "LambdaHack",
          "signature": "TriggerNothing",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#FailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "TriggerNothing",
          "package": "LambdaHack",
          "partial": "Trigger Nothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:TriggerNothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "TriggerSer",
          "package": "LambdaHack",
          "signature": "TriggerSer !ActorId !(Maybe Feature)",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "TriggerSer",
          "package": "LambdaHack",
          "partial": "Trigger Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:TriggerSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "WaitSer",
          "package": "LambdaHack",
          "signature": "WaitSer !ActorId",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#CmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "WaitSer",
          "package": "LambdaHack",
          "partial": "Wait Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:WaitSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe actor that starts performing the command (may be dead, after\n the command is performed).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "aidCmdSer",
          "package": "LambdaHack",
          "signature": "CmdSer -\u003e ActorId",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#aidCmdSer",
          "type": "function"
        },
        "index": {
          "description": "The actor that starts performing the command may be dead after the command is performed",
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "aidCmdSer",
          "normalized": "CmdSer-\u003eActorId",
          "package": "LambdaHack",
          "partial": "Cmd Ser",
          "signature": "CmdSer-\u003eActorId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:aidCmdSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "aidCmdTakeTimeSer",
          "package": "LambdaHack",
          "signature": "CmdTakeTimeSer -\u003e ActorId",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#aidCmdTakeTimeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "aidCmdTakeTimeSer",
          "normalized": "CmdTakeTimeSer-\u003eActorId",
          "package": "LambdaHack",
          "partial": "Cmd Take Time Ser",
          "signature": "CmdTakeTimeSer-\u003eActorId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:aidCmdTakeTimeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "showFailureSer",
          "package": "LambdaHack",
          "signature": "FailureSer -\u003e Msg",
          "source": "src/Game-LambdaHack-Common-ServerCmd.html#showFailureSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common ServerCmd",
          "module": "Game.LambdaHack.Common.ServerCmd",
          "name": "showFailureSer",
          "normalized": "FailureSer-\u003eMsg",
          "package": "LambdaHack",
          "partial": "Failure Ser",
          "signature": "FailureSer-\u003eMsg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-ServerCmd.html#v:showFailureSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServer and client game state types and operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "State",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-State.html",
          "type": "module"
        },
        "index": {
          "description": "Server and client game state types and operations",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "State",
          "package": "LambdaHack",
          "partial": "State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView on game state. \u003ca\u003eRemembered\u003c/a\u003e fields carry a subset of the info\n in the client copies of the state. Clients never directly change\n their \u003ccode\u003eState\u003c/code\u003e, but apply atomic actions sent by the server to do so.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "State",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-State.html#State",
          "type": "data"
        },
        "index": {
          "description": "View on game state Remembered fields carry subset of the info in the client copies of the state Clients never directly change their State but apply atomic actions sent by the server to do so",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "State",
          "package": "LambdaHack",
          "partial": "State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#t:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitial complete global game state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "defStateGlobal",
          "package": "LambdaHack",
          "signature": "Dungeon -\u003e Int -\u003e FactionDict -\u003e COps -\u003e ScoreTable -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#defStateGlobal",
          "type": "function"
        },
        "index": {
          "description": "Initial complete global game state",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "defStateGlobal",
          "normalized": "Dungeon-\u003eInt-\u003eFactionDict-\u003eCOps-\u003eScoreTable-\u003eState",
          "package": "LambdaHack",
          "partial": "State Global",
          "signature": "Dungeon-\u003eInt-\u003eFactionDict-\u003eCOps-\u003eScoreTable-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:defStateGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitial empty state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "emptyState",
          "package": "LambdaHack",
          "signature": "State",
          "source": "src/Game-LambdaHack-Common-State.html#emptyState",
          "type": "function"
        },
        "index": {
          "description": "Initial empty state",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "emptyState",
          "package": "LambdaHack",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:emptyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet current time from the dungeon data.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "getLocalTime",
          "package": "LambdaHack",
          "signature": "LevelId -\u003e State -\u003e Time",
          "source": "src/Game-LambdaHack-Common-State.html#getLocalTime",
          "type": "function"
        },
        "index": {
          "description": "Get current time from the dungeon data",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "getLocalTime",
          "normalized": "LevelId-\u003eState-\u003eTime",
          "package": "LambdaHack",
          "partial": "Local Time",
          "signature": "LevelId-\u003eState-\u003eTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:getLocalTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTell whether the faction can spawn actors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "isSpawnFaction",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e State -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-State.html#isSpawnFaction",
          "type": "function"
        },
        "index": {
          "description": "Tell whether the faction can spawn actors",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "isSpawnFaction",
          "normalized": "FactionId-\u003eState-\u003eBool",
          "package": "LambdaHack",
          "partial": "Spawn Faction",
          "signature": "FactionId-\u003eState-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:isSpawnFaction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal state created by removing secret information from global\n state components.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "localFromGlobal",
          "package": "LambdaHack",
          "signature": "State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#localFromGlobal",
          "type": "function"
        },
        "index": {
          "description": "Local state created by removing secret information from global state components",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "localFromGlobal",
          "normalized": "State-\u003eState",
          "package": "LambdaHack",
          "partial": "From Global",
          "signature": "State-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:localFromGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "sactorD",
          "package": "LambdaHack",
          "signature": "State -\u003e ActorDict",
          "source": "src/Game-LambdaHack-Common-State.html#sactorD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "sactorD",
          "normalized": "State-\u003eActorDict",
          "package": "LambdaHack",
          "signature": "State-\u003eActorDict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:sactorD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "scops",
          "package": "LambdaHack",
          "signature": "State -\u003e COps",
          "source": "src/Game-LambdaHack-Common-State.html#scops",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "scops",
          "normalized": "State-\u003eCOps",
          "package": "LambdaHack",
          "signature": "State-\u003eCOps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:scops"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "sdepth",
          "package": "LambdaHack",
          "signature": "State -\u003e Int",
          "source": "src/Game-LambdaHack-Common-State.html#sdepth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "sdepth",
          "normalized": "State-\u003eInt",
          "package": "LambdaHack",
          "signature": "State-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:sdepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "sdungeon",
          "package": "LambdaHack",
          "signature": "State -\u003e Dungeon",
          "source": "src/Game-LambdaHack-Common-State.html#sdungeon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "sdungeon",
          "normalized": "State-\u003eDungeon",
          "package": "LambdaHack",
          "signature": "State-\u003eDungeon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:sdungeon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "sfactionD",
          "package": "LambdaHack",
          "signature": "State -\u003e FactionDict",
          "source": "src/Game-LambdaHack-Common-State.html#sfactionD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "sfactionD",
          "normalized": "State-\u003eFactionDict",
          "package": "LambdaHack",
          "signature": "State-\u003eFactionDict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:sfactionD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "shigh",
          "package": "LambdaHack",
          "signature": "State -\u003e ScoreTable",
          "source": "src/Game-LambdaHack-Common-State.html#shigh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "shigh",
          "normalized": "State-\u003eScoreTable",
          "package": "LambdaHack",
          "signature": "State-\u003eScoreTable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:shigh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "sitemD",
          "package": "LambdaHack",
          "signature": "State -\u003e ItemDict",
          "source": "src/Game-LambdaHack-Common-State.html#sitemD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "sitemD",
          "normalized": "State-\u003eItemDict",
          "package": "LambdaHack",
          "signature": "State-\u003eItemDict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:sitemD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.State",
          "name": "stime",
          "package": "LambdaHack",
          "signature": "State -\u003e Time",
          "source": "src/Game-LambdaHack-Common-State.html#stime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "stime",
          "normalized": "State-\u003eTime",
          "package": "LambdaHack",
          "signature": "State-\u003eTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:stime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the actor dictionary.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateActorD",
          "package": "LambdaHack",
          "signature": "(ActorDict -\u003e ActorDict) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#updateActorD",
          "type": "function"
        },
        "index": {
          "description": "Update the actor dictionary",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateActorD",
          "normalized": "(ActorDict-\u003eActorDict)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "Actor",
          "signature": "(ActorDict-\u003eActorDict)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:updateActorD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate content data within state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateCOps",
          "package": "LambdaHack",
          "signature": "(COps -\u003e COps) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#updateCOps",
          "type": "function"
        },
        "index": {
          "description": "Update content data within state",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateCOps",
          "normalized": "(COps-\u003eCOps)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "COps",
          "signature": "(COps-\u003eCOps)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:updateCOps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate dungeon depth.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateDepth",
          "package": "LambdaHack",
          "signature": "(Int -\u003e Int) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#updateDepth",
          "type": "function"
        },
        "index": {
          "description": "Update dungeon depth",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateDepth",
          "normalized": "(Int-\u003eInt)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "Depth",
          "signature": "(Int-\u003eInt)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:updateDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate dungeon data within state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateDungeon",
          "package": "LambdaHack",
          "signature": "(Dungeon -\u003e Dungeon) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#updateDungeon",
          "type": "function"
        },
        "index": {
          "description": "Update dungeon data within state",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateDungeon",
          "normalized": "(Dungeon-\u003eDungeon)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "Dungeon",
          "signature": "(Dungeon-\u003eDungeon)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:updateDungeon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate faction data within state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateFaction",
          "package": "LambdaHack",
          "signature": "(FactionDict -\u003e FactionDict) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#updateFaction",
          "type": "function"
        },
        "index": {
          "description": "Update faction data within state",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateFaction",
          "normalized": "(FactionDict-\u003eFactionDict)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "Faction",
          "signature": "(FactionDict-\u003eFactionDict)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:updateFaction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the item dictionary.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateItemD",
          "package": "LambdaHack",
          "signature": "(ItemDict -\u003e ItemDict) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#updateItemD",
          "type": "function"
        },
        "index": {
          "description": "Update the item dictionary",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateItemD",
          "normalized": "(ItemDict-\u003eItemDict)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "Item",
          "signature": "(ItemDict-\u003eItemDict)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:updateItemD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate global time within state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateTime",
          "package": "LambdaHack",
          "signature": "(Time -\u003e Time) -\u003e State -\u003e State",
          "source": "src/Game-LambdaHack-Common-State.html#updateTime",
          "type": "function"
        },
        "index": {
          "description": "Update global time within state",
          "hierarchy": "Game LambdaHack Common State",
          "module": "Game.LambdaHack.Common.State",
          "name": "updateTime",
          "normalized": "(Time-\u003eTime)-\u003eState-\u003eState",
          "package": "LambdaHack",
          "partial": "Time",
          "signature": "(Time-\u003eTime)-\u003eState-\u003eState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-State.html#v:updateTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOperations concerning dungeon level tiles.\n\u003c/p\u003e\u003cp\u003eUnlike for many other content types, there is no type \u003ccode\u003eTile\u003c/code\u003e,\n of particular concrete tiles in the dungeon,\n corresponding to \u003ccode\u003e\u003ca\u003eTileKind\u003c/a\u003e\u003c/code\u003e (the type of kinds of terrain tiles).\n This is because the tiles are too numerous and there's not enough\n storage space for a well-rounded \u003ccode\u003eTile\u003c/code\u003e type, on one hand,\n and on the other hand, tiles are accessed\n too often in performance critical code\n to try to compress their representation and/or recompute them.\n Instead, of defining a \u003ccode\u003eTile\u003c/code\u003e type, we express various properties\n of concrete tiles by arrays or sparse EnumMaps, as appropriate.\n\u003c/p\u003e\u003cp\u003eActors at normal speed (2 m/s) take one turn to move one tile (1 m by 1 m).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "Tile",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Tile.html",
          "type": "module"
        },
        "index": {
          "description": "Operations concerning dungeon level tiles Unlike for many other content types there is no type Tile of particular concrete tiles in the dungeon corresponding to TileKind the type of kinds of terrain tiles This is because the tiles are too numerous and there not enough storage space for well-rounded Tile type on one hand and on the other hand tiles are accessed too often in performance critical code to try to compress their representation and or recompute them Instead of defining Tile type we express various properties of concrete tiles by arrays or sparse EnumMaps as appropriate Actors at normal speed take one turn to move one tile by",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "Tile",
          "package": "LambdaHack",
          "partial": "Tile",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe last time a hero left a smell in a given tile. To be used\n by monsters that hunt by smell.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "SmellTime",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Tile.html#SmellTime",
          "type": "type"
        },
        "index": {
          "description": "The last time hero left smell in given tile To be used by monsters that hunt by smell",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "SmellTime",
          "package": "LambdaHack",
          "partial": "Smell Time",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#t:SmellTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "causeEffects",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e [Effect Int]",
          "source": "src/Game-LambdaHack-Common-Tile.html#causeEffects",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "causeEffects",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003e[Effect Int]",
          "package": "LambdaHack",
          "partial": "Effects",
          "signature": "Ops TileKind-\u003eId TileKind-\u003e[Effect Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:causeEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "closeTo",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Rnd (Id TileKind)",
          "source": "src/Game-LambdaHack-Common-Tile.html#closeTo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "closeTo",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eRnd(Id TileKind)",
          "package": "LambdaHack",
          "partial": "To",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eRnd(Id TileKind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:closeTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile kind (specified by its id) has the given feature.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "hasFeature",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Feature -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#hasFeature",
          "type": "function"
        },
        "index": {
          "description": "Whether tile kind specified by its id has the given feature",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "hasFeature",
          "normalized": "Ops TileKind-\u003eFeature-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Feature",
          "signature": "Ops TileKind-\u003eFeature-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:hasFeature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "hideAs",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Id TileKind",
          "source": "src/Game-LambdaHack-Common-Tile.html#hideAs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "hideAs",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eId TileKind",
          "package": "LambdaHack",
          "partial": "As",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eId TileKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:hideAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile kind (specified by its id) has a ChangeTo feature.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isChangeable",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isChangeable",
          "type": "function"
        },
        "index": {
          "description": "Whether tile kind specified by its id has ChangeTo feature",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isChangeable",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Changeable",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isChangeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile does not block vision.\n Essential for efficiency of \u003ca\u003eFOV\u003c/a\u003e, hence tabulated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isClear",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isClear",
          "type": "function"
        },
        "index": {
          "description": "Whether tile does not block vision Essential for efficiency of FOV hence tabulated",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isClear",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Clear",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isClear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile kind (specified by its id) has a CloseTo feature.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isClosable",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isClosable",
          "type": "function"
        },
        "index": {
          "description": "Whether tile kind specified by its id has CloseTo feature",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isClosable",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Closable",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isClosable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile is a door, open or closed.\n Essential for efficiency of pathfinding, hence tabulated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isDoor",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isDoor",
          "type": "function"
        },
        "index": {
          "description": "Whether tile is door open or closed Essential for efficiency of pathfinding hence tabulated",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isDoor",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Door",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isDoor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isEscape",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isEscape",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isEscape",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Escape",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile can be explored, possibly yielding a treasure.\n Note that non-walkable tiles can hold treasure, e.g., caches.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isExplorable",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isExplorable",
          "type": "function"
        },
        "index": {
          "description": "Whether tile can be explored possibly yielding treasure Note that non-walkable tiles can hold treasure e.g caches",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isExplorable",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Explorable",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isExplorable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile is lit on its own.\n Essential for efficiency of \u003ca\u003ePerception\u003c/a\u003e, hence tabulated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isLit",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isLit",
          "type": "function"
        },
        "index": {
          "description": "Whether tile is lit on its own Essential for efficiency of Perception hence tabulated",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isLit",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Lit",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile kind (specified by its id) has an OpenTo feature.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isOpenable",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isOpenable",
          "type": "function"
        },
        "index": {
          "description": "Whether tile kind specified by its id has an OpenTo feature",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isOpenable",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Openable",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isOpenable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether actors can walk into a tile, perhaps opening a door first.\n Essential for efficiency of pathfinding, hence tabulated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isPassable",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isPassable",
          "type": "function"
        },
        "index": {
          "description": "Whether actors can walk into tile perhaps opening door first Essential for efficiency of pathfinding hence tabulated",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isPassable",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Passable",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isPassable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isStair",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isStair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isStair",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Stair",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isStair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile is suspect.\n Essential for efficiency of pathfinding, hence tabulated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isSuspect",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isSuspect",
          "type": "function"
        },
        "index": {
          "description": "Whether tile is suspect Essential for efficiency of pathfinding hence tabulated",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isSuspect",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Suspect",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isSuspect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether actors can walk into a tile.\n Essential for efficiency of pathfinding, hence tabulated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isWalkable",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#isWalkable",
          "type": "function"
        },
        "index": {
          "description": "Whether actors can walk into tile Essential for efficiency of pathfinding hence tabulated",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "isWalkable",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Walkable",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:isWalkable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhether a tile kind has the given feature.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "kindHasFeature",
          "package": "LambdaHack",
          "signature": "Feature -\u003e TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#kindHasFeature",
          "type": "function"
        },
        "index": {
          "description": "Whether tile kind has the given feature",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "kindHasFeature",
          "normalized": "Feature-\u003eTileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Has Feature",
          "signature": "Feature-\u003eTileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:kindHasFeature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe player can't tell one tile from the other.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "lookSimilar",
          "package": "LambdaHack",
          "signature": "TileKind -\u003e TileKind -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Tile.html#lookSimilar",
          "type": "function"
        },
        "index": {
          "description": "The player can tell one tile from the other",
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "lookSimilar",
          "normalized": "TileKind-\u003eTileKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Similar",
          "signature": "TileKind-\u003eTileKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:lookSimilar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "openTo",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Rnd (Id TileKind)",
          "source": "src/Game-LambdaHack-Common-Tile.html#openTo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "openTo",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eRnd(Id TileKind)",
          "package": "LambdaHack",
          "partial": "To",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eRnd(Id TileKind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:openTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "revealAs",
          "package": "LambdaHack",
          "signature": "Ops TileKind -\u003e Id TileKind -\u003e Rnd (Id TileKind)",
          "source": "src/Game-LambdaHack-Common-Tile.html#revealAs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "revealAs",
          "normalized": "Ops TileKind-\u003eId TileKind-\u003eRnd(Id TileKind)",
          "package": "LambdaHack",
          "partial": "As",
          "signature": "Ops TileKind-\u003eId TileKind-\u003eRnd(Id TileKind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:revealAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Tile",
          "name": "speedup",
          "package": "LambdaHack",
          "signature": "Bool -\u003e Ops TileKind -\u003e Speedup TileKind",
          "source": "src/Game-LambdaHack-Common-Tile.html#speedup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Tile",
          "module": "Game.LambdaHack.Common.Tile",
          "name": "speedup",
          "normalized": "Bool-\u003eOps TileKind-\u003eSpeedup TileKind",
          "package": "LambdaHack",
          "signature": "Bool-\u003eOps TileKind-\u003eSpeedup TileKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Tile.html#v:speedup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGame time and speed.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "Time",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Time.html",
          "type": "module"
        },
        "index": {
          "description": "Game time and speed",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "Time",
          "package": "LambdaHack",
          "partial": "Time",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpeed in meters per 1 million seconds (m/Ms).\n Actors at normal speed (2 m/s) take one time turn (0.5 s)\n to move one tile (1 m by 1 m).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "Speed",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Time.html#Speed",
          "type": "data"
        },
        "index": {
          "description": "Speed in meters per million seconds Ms Actors at normal speed take one time turn to move one tile by",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "Speed",
          "package": "LambdaHack",
          "partial": "Speed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#t:Speed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGame time in ticks. The time dimension.\n One tick is 1 microsecond (one millionth of a second),\n one turn is 0.5 s.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "Time",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Time.html#Time",
          "type": "data"
        },
        "index": {
          "description": "Game time in ticks The time dimension One tick is microsecond one millionth of second one turn is",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "Time",
          "package": "LambdaHack",
          "partial": "Time",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#t:Time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate maximum range in meters of a projectile from its speed.\n See \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Item-statistics\u003c/a\u003e.\n With this formula, each projectile flies for at most 1 second,\n that is 2 turns, and then drops to the ground.\n We round down to the nearest multiple of 2 (unless the speed\n is very low), to ensure both turns of flight cover the same distance.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "rangeFromSpeed",
          "package": "LambdaHack",
          "signature": "Speed -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Time.html#rangeFromSpeed",
          "type": "function"
        },
        "index": {
          "description": "Calculate maximum range in meters of projectile from its speed See https github.com kosmikus LambdaHack wiki Item-statistics With this formula each projectile flies for at most second that is turns and then drops to the ground We round down to the nearest multiple of unless the speed is very low to ensure both turns of flight cover the same distance",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "rangeFromSpeed",
          "normalized": "Speed-\u003eInt",
          "package": "LambdaHack",
          "partial": "From Speed",
          "signature": "Speed-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:rangeFromSpeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpeed addition.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedAdd",
          "package": "LambdaHack",
          "signature": "Speed -\u003e Speed -\u003e Speed",
          "source": "src/Game-LambdaHack-Common-Time.html#speedAdd",
          "type": "function"
        },
        "index": {
          "description": "Speed addition",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedAdd",
          "normalized": "Speed-\u003eSpeed-\u003eSpeed",
          "package": "LambdaHack",
          "partial": "Add",
          "signature": "Speed-\u003eSpeed-\u003eSpeed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:speedAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate projectile speed from item weight in grams\n and speed bonus in percents.\n See \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Item-statistics\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedFromWeight",
          "package": "LambdaHack",
          "signature": "Int -\u003e Int -\u003e Speed",
          "source": "src/Game-LambdaHack-Common-Time.html#speedFromWeight",
          "type": "function"
        },
        "index": {
          "description": "Calculate projectile speed from item weight in grams and speed bonus in percents See https github.com kosmikus LambdaHack wiki Item-statistics",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedFromWeight",
          "normalized": "Int-\u003eInt-\u003eSpeed",
          "package": "LambdaHack",
          "partial": "From Weight",
          "signature": "Int-\u003eInt-\u003eSpeed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:speedFromWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpeed negation.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedNegate",
          "package": "LambdaHack",
          "signature": "Speed -\u003e Speed",
          "source": "src/Game-LambdaHack-Common-Time.html#speedNegate",
          "type": "function"
        },
        "index": {
          "description": "Speed negation",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedNegate",
          "normalized": "Speed-\u003eSpeed",
          "package": "LambdaHack",
          "partial": "Negate",
          "signature": "Speed-\u003eSpeed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:speedNegate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal speed (2 m/s) that suffices to move one tile in one turn.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedNormal",
          "package": "LambdaHack",
          "signature": "Speed",
          "source": "src/Game-LambdaHack-Common-Time.html#speedNormal",
          "type": "function"
        },
        "index": {
          "description": "Normal speed that suffices to move one tile in one turn",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedNormal",
          "package": "LambdaHack",
          "partial": "Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:speedNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale speed by an \u003ccode\u003eInt\u003c/code\u003e scalar value.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedScale",
          "package": "LambdaHack",
          "signature": "Rational -\u003e Speed -\u003e Speed",
          "source": "src/Game-LambdaHack-Common-Time.html#speedScale",
          "type": "function"
        },
        "index": {
          "description": "Scale speed by an Int scalar value",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedScale",
          "normalized": "Rational-\u003eSpeed-\u003eSpeed",
          "package": "LambdaHack",
          "partial": "Scale",
          "signature": "Rational-\u003eSpeed-\u003eSpeed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:speedScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo movement possible at that speed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedZero",
          "package": "LambdaHack",
          "signature": "Speed",
          "source": "src/Game-LambdaHack-Common-Time.html#speedZero",
          "type": "function"
        },
        "index": {
          "description": "No movement possible at that speed",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "speedZero",
          "package": "LambdaHack",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:speedZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of time ticks it takes to walk 1 meter at the given speed.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "ticksPerMeter",
          "package": "LambdaHack",
          "signature": "Speed -\u003e Time",
          "source": "src/Game-LambdaHack-Common-Time.html#ticksPerMeter",
          "type": "function"
        },
        "index": {
          "description": "The number of time ticks it takes to walk meter at the given speed",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "ticksPerMeter",
          "normalized": "Speed-\u003eTime",
          "package": "LambdaHack",
          "partial": "Per Meter",
          "signature": "Speed-\u003eTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:ticksPerMeter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTime addition.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeAdd",
          "package": "LambdaHack",
          "signature": "Time -\u003e Time -\u003e Time",
          "source": "src/Game-LambdaHack-Common-Time.html#timeAdd",
          "type": "function"
        },
        "index": {
          "description": "Time addition",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeAdd",
          "normalized": "Time-\u003eTime-\u003eTime",
          "package": "LambdaHack",
          "partial": "Add",
          "signature": "Time-\u003eTime-\u003eTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAt least once per clip all moves are resolved and a frame\n or a frame delay is generated.\n Currently one clip is 0.1 s, but it may change,\n and the code should not depend on this fixed value.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeClip",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Common-Time.html#timeClip",
          "type": "function"
        },
        "index": {
          "description": "At least once per clip all moves are resolved and frame or frame delay is generated Currently one clip is but it may change and the code should not depend on this fixed value",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeClip",
          "package": "LambdaHack",
          "partial": "Clip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeClip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infinitesimal time period.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeEpsilon",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Common-Time.html#timeEpsilon",
          "type": "function"
        },
        "index": {
          "description": "An infinitesimal time period",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeEpsilon",
          "package": "LambdaHack",
          "partial": "Epsilon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeEpsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow many time intervals of the latter kind fits in an interval\n of the former kind.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeFit",
          "package": "LambdaHack",
          "signature": "Time -\u003e Time -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Time.html#timeFit",
          "type": "function"
        },
        "index": {
          "description": "How many time intervals of the latter kind fits in an interval of the former kind",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeFit",
          "normalized": "Time-\u003eTime-\u003eInt",
          "package": "LambdaHack",
          "partial": "Fit",
          "signature": "Time-\u003eTime-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeFit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegate a time interval. Can be used to subtract from a time\n or to reverse the ordering on time.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeNegate",
          "package": "LambdaHack",
          "signature": "Time -\u003e Time",
          "source": "src/Game-LambdaHack-Common-Time.html#timeNegate",
          "type": "function"
        },
        "index": {
          "description": "Negate time interval Can be used to subtract from time or to reverse the ordering on time",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeNegate",
          "normalized": "Time-\u003eTime",
          "package": "LambdaHack",
          "partial": "Negate",
          "signature": "Time-\u003eTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeNegate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale time by an \u003ccode\u003eInt\u003c/code\u003e scalar value.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeScale",
          "package": "LambdaHack",
          "signature": "Time -\u003e Int -\u003e Time",
          "source": "src/Game-LambdaHack-Common-Time.html#timeScale",
          "type": "function"
        },
        "index": {
          "description": "Scale time by an Int scalar value",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeScale",
          "normalized": "Time-\u003eInt-\u003eTime",
          "package": "LambdaHack",
          "partial": "Scale",
          "signature": "Time-\u003eInt-\u003eTime",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeScale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresent the main 10 thresholds of a time range by digits,\n given the total length of the time range.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeToDigit",
          "package": "LambdaHack",
          "signature": "Time -\u003e Time -\u003e Char",
          "source": "src/Game-LambdaHack-Common-Time.html#timeToDigit",
          "type": "function"
        },
        "index": {
          "description": "Represent the main thresholds of time range by digits given the total length of the time range",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeToDigit",
          "normalized": "Time-\u003eTime-\u003eChar",
          "package": "LambdaHack",
          "partial": "To Digit",
          "signature": "Time-\u003eTime-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeToDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne turn is 0.5 s. The code may depend on that.\n Actors at normal speed (2 m/s) take one turn to move one tile (1 m by 1 m).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeTurn",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Common-Time.html#timeTurn",
          "type": "function"
        },
        "index": {
          "description": "One turn is The code may depend on that Actors at normal speed take one turn to move one tile by",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeTurn",
          "package": "LambdaHack",
          "partial": "Turn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeTurn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart of the game time, or zero lenght time interval.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeZero",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Common-Time.html#timeZero",
          "type": "function"
        },
        "index": {
          "description": "Start of the game time or zero lenght time interval",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "timeZero",
          "package": "LambdaHack",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:timeZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructor for content definitions.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Time",
          "name": "toSpeed",
          "package": "LambdaHack",
          "signature": "Double -\u003e Speed",
          "source": "src/Game-LambdaHack-Common-Time.html#toSpeed",
          "type": "function"
        },
        "index": {
          "description": "Constructor for content definitions",
          "hierarchy": "Game LambdaHack Common Time",
          "module": "Game.LambdaHack.Common.Time",
          "name": "toSpeed",
          "normalized": "Double-\u003eSpeed",
          "package": "LambdaHack",
          "partial": "Speed",
          "signature": "Double-\u003eSpeed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Time.html#v:toSpeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic operations on 2D vectors represented in an efficient,\n but not unique, way.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "Vector",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Vector.html",
          "type": "module"
        },
        "index": {
          "description": "Basic operations on vectors represented in an efficient but not unique way",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "Vector",
          "package": "LambdaHack",
          "partial": "Vector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "BfsDistance",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Vector.html#BfsDistance",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "BfsDistance",
          "package": "LambdaHack",
          "partial": "Bfs Distance",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#t:BfsDistance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveLegal",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Vector.html#MoveLegal",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveLegal",
          "package": "LambdaHack",
          "partial": "Move Legal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#t:MoveLegal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "RadianAngle",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Vector.html#RadianAngle",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "RadianAngle",
          "package": "LambdaHack",
          "partial": "Radian Angle",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#t:RadianAngle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2D vectors in cartesian representation. Coordinates grow to the right\n and down, so that the (1, 1) vector points to the bottom-right corner\n of the screen.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "Vector",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Common-Vector.html#Vector",
          "type": "data"
        },
        "index": {
          "description": "vectors in cartesian representation Coordinates grow to the right and down so that the vector points to the bottom-right corner of the screen",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "Vector",
          "package": "LambdaHack",
          "partial": "Vector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveBlocked",
          "package": "LambdaHack",
          "signature": "MoveBlocked",
          "source": "src/Game-LambdaHack-Common-Vector.html#MoveLegal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveBlocked",
          "package": "LambdaHack",
          "partial": "Move Blocked",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:MoveBlocked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveToOpen",
          "package": "LambdaHack",
          "signature": "MoveToOpen",
          "source": "src/Game-LambdaHack-Common-Vector.html#MoveLegal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveToOpen",
          "package": "LambdaHack",
          "partial": "Move To Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:MoveToOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveToUnknown",
          "package": "LambdaHack",
          "signature": "MoveToUnknown",
          "source": "src/Game-LambdaHack-Common-Vector.html#MoveLegal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "MoveToUnknown",
          "package": "LambdaHack",
          "partial": "Move To Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:MoveToUnknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "Vector",
          "package": "LambdaHack",
          "signature": "Vector",
          "source": "src/Game-LambdaHack-Common-Vector.html#Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "Vector",
          "package": "LambdaHack",
          "partial": "Vector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "accessBfs",
          "package": "LambdaHack",
          "signature": "Array BfsDistance -\u003e Point -\u003e Maybe Int",
          "source": "src/Game-LambdaHack-Common-Vector.html#accessBfs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "accessBfs",
          "normalized": "Array BfsDistance-\u003ePoint-\u003eMaybe Int",
          "package": "LambdaHack",
          "partial": "Bfs",
          "signature": "Array BfsDistance-\u003ePoint-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:accessBfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "apartBfs",
          "package": "LambdaHack",
          "signature": "BfsDistance",
          "source": "src/Game-LambdaHack-Common-Vector.html#apartBfs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "apartBfs",
          "package": "LambdaHack",
          "partial": "Bfs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:apartBfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe lenght of a vector in the chessboard metric,\n where diagonal moves cost 1.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "chessDistVector",
          "package": "LambdaHack",
          "signature": "Vector -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Vector.html#chessDistVector",
          "type": "function"
        },
        "index": {
          "description": "The lenght of vector in the chessboard metric where diagonal moves cost",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "chessDistVector",
          "normalized": "Vector-\u003eInt",
          "package": "LambdaHack",
          "partial": "Dist Vector",
          "signature": "Vector-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:chessDistVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "compassText",
          "package": "LambdaHack",
          "signature": "Vector -\u003e Text",
          "source": "src/Game-LambdaHack-Common-Vector.html#compassText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "compassText",
          "normalized": "Vector-\u003eText",
          "package": "LambdaHack",
          "partial": "Text",
          "signature": "Vector-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:compassText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA vector from a point to another. We have\n\u003c/p\u003e\u003cpre\u003e shift pos1 (displacement pos1 pos2) == pos2\n\u003c/pre\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "displacement",
          "package": "LambdaHack",
          "signature": "Point -\u003e Point -\u003e Vector",
          "source": "src/Game-LambdaHack-Common-Vector.html#displacement",
          "type": "function"
        },
        "index": {
          "description": "vector from point to another We have shift pos1 displacement pos1 pos2 pos2",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "displacement",
          "normalized": "Point-\u003ePoint-\u003eVector",
          "package": "LambdaHack",
          "signature": "Point-\u003ePoint-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:displacement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSquared euclidean distance between two vectors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "euclidDistSqVector",
          "package": "LambdaHack",
          "signature": "Vector -\u003e Vector -\u003e Int",
          "source": "src/Game-LambdaHack-Common-Vector.html#euclidDistSqVector",
          "type": "function"
        },
        "index": {
          "description": "Squared euclidean distance between two vectors",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "euclidDistSqVector",
          "normalized": "Vector-\u003eVector-\u003eInt",
          "package": "LambdaHack",
          "partial": "Dist Sq Vector",
          "signature": "Vector-\u003eVector-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:euclidDistSqVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "fillBfs",
          "package": "LambdaHack",
          "signature": "(Point -\u003e Point -\u003e MoveLegal)-\u003e (Point -\u003e Point -\u003e Bool)-\u003e Point-\u003e Array BfsDistance-\u003e Array BfsDistance",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "fillBfs",
          "normalized": "(Point-\u003ePoint-\u003eMoveLegal)-\u003e(Point-\u003ePoint-\u003eBool)-\u003ePoint-\u003eArray BfsDistance-\u003eArray BfsDistance",
          "package": "LambdaHack",
          "partial": "Bfs",
          "signature": "(Point-\u003ePoint-\u003eMoveLegal)-\u003e(Point-\u003ePoint-\u003eBool)-\u003ePoint-\u003eArray BfsDistance-\u003eArray BfsDistance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:fillBfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a path, without the source position, with the smallest length.\n The \u003ccode\u003eeps\u003c/code\u003e coefficient determines which direction (or the closest\n directions available) that path should prefer, where 0 means north-west\n and 1 means north.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "findPathBfs",
          "package": "LambdaHack",
          "signature": "(Point -\u003e Point -\u003e MoveLegal) -\u003e (Point -\u003e Point -\u003e Bool) -\u003e Point -\u003e Point -\u003e Int -\u003e Array BfsDistance -\u003e Maybe [Point]",
          "source": "src/Game-LambdaHack-Common-Vector.html#findPathBfs",
          "type": "function"
        },
        "index": {
          "description": "Find path without the source position with the smallest length The eps coefficient determines which direction or the closest directions available that path should prefer where means north-west and means north",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "findPathBfs",
          "normalized": "(Point-\u003ePoint-\u003eMoveLegal)-\u003e(Point-\u003ePoint-\u003eBool)-\u003ePoint-\u003ePoint-\u003eInt-\u003eArray BfsDistance-\u003eMaybe[Point]",
          "package": "LambdaHack",
          "partial": "Path Bfs",
          "signature": "(Point-\u003ePoint-\u003eMoveLegal)-\u003e(Point-\u003ePoint-\u003eBool)-\u003ePoint-\u003ePoint-\u003eInt-\u003eArray BfsDistance-\u003eMaybe[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:findPathBfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks whether a unit vector is a diagonal direction,\n as opposed to cardinal. If the vector is not unit,\n it checks that the vector is not horizontal nor vertical.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "isDiagonal",
          "package": "LambdaHack",
          "signature": "Vector -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Vector.html#isDiagonal",
          "type": "function"
        },
        "index": {
          "description": "Checks whether unit vector is diagonal direction as opposed to cardinal If the vector is not unit it checks that the vector is not horizontal nor vertical",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "isDiagonal",
          "normalized": "Vector-\u003eBool",
          "package": "LambdaHack",
          "partial": "Diagonal",
          "signature": "Vector-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:isDiagonal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTells if a vector has length 1 in the chessboard metric.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "isUnit",
          "package": "LambdaHack",
          "signature": "Vector -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Vector.html#isUnit",
          "type": "function"
        },
        "index": {
          "description": "Tells if vector has length in the chessboard metric",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "isUnit",
          "normalized": "Vector-\u003eBool",
          "package": "LambdaHack",
          "partial": "Unit",
          "signature": "Vector-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:isUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVectors of all unit moves in the chessboard metric,\n clockwise, starting north-west.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "moves",
          "package": "LambdaHack",
          "signature": "[Vector]",
          "source": "src/Game-LambdaHack-Common-Vector.html#moves",
          "type": "function"
        },
        "index": {
          "description": "Vectors of all unit moves in the chessboard metric clockwise starting north-west",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "moves",
          "normalized": "[Vector]",
          "package": "LambdaHack",
          "signature": "[Vector]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:moves"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse an arbirary vector.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "neg",
          "package": "LambdaHack",
          "signature": "Vector -\u003e Vector",
          "source": "src/Game-LambdaHack-Common-Vector.html#neg",
          "type": "function"
        },
        "index": {
          "description": "Reverse an arbirary vector",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "neg",
          "normalized": "Vector-\u003eVector",
          "package": "LambdaHack",
          "signature": "Vector-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of vectors between a list of points.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "pathToTrajectory",
          "package": "LambdaHack",
          "signature": "[Point] -\u003e [Vector]",
          "source": "src/Game-LambdaHack-Common-Vector.html#pathToTrajectory",
          "type": "function"
        },
        "index": {
          "description": "list of vectors between list of points",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "pathToTrajectory",
          "normalized": "[Point]-\u003e[Vector]",
          "package": "LambdaHack",
          "partial": "To Trajectory",
          "signature": "[Point]-\u003e[Vector]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:pathToTrajectory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "posAimsPos",
          "package": "LambdaHack",
          "signature": "Array BfsDistance -\u003e Point -\u003e Point -\u003e Bool",
          "source": "src/Game-LambdaHack-Common-Vector.html#posAimsPos",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "posAimsPos",
          "normalized": "Array BfsDistance-\u003ePoint-\u003ePoint-\u003eBool",
          "package": "LambdaHack",
          "partial": "Aims Pos",
          "signature": "Array BfsDistance-\u003ePoint-\u003ePoint-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:posAimsPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate a vector by the given angle (expressed in radians)\n counterclockwise and return a unit vector approximately in the resulting\n direction.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "rotate",
          "package": "LambdaHack",
          "signature": "RadianAngle -\u003e Vector -\u003e Vector",
          "source": "src/Game-LambdaHack-Common-Vector.html#rotate",
          "type": "function"
        },
        "index": {
          "description": "Rotate vector by the given angle expressed in radians counterclockwise and return unit vector approximately in the resulting direction",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "rotate",
          "normalized": "RadianAngle-\u003eVector-\u003eVector",
          "package": "LambdaHack",
          "signature": "RadianAngle-\u003eVector-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:rotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate a point by a vector.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "shift",
          "package": "LambdaHack",
          "signature": "Point -\u003e Vector -\u003e Point",
          "source": "src/Game-LambdaHack-Common-Vector.html#shift",
          "type": "function"
        },
        "index": {
          "description": "Translate point by vector",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "shift",
          "normalized": "Point-\u003eVector-\u003ePoint",
          "package": "LambdaHack",
          "signature": "Point-\u003eVector-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate a point by a vector, but only if the result fits in an area.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "shiftBounded",
          "package": "LambdaHack",
          "signature": "X -\u003e Y -\u003e Point -\u003e Vector -\u003e Point",
          "source": "src/Game-LambdaHack-Common-Vector.html#shiftBounded",
          "type": "function"
        },
        "index": {
          "description": "Translate point by vector but only if the result fits in an area",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "shiftBounded",
          "normalized": "X-\u003eY-\u003ePoint-\u003eVector-\u003ePoint",
          "package": "LambdaHack",
          "partial": "Bounded",
          "signature": "X-\u003eY-\u003ePoint-\u003eVector-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:shiftBounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven two distinct positions, determine the direction (a unit vector)\n in which one should move from the first in order to get closer\n to the second. Ignores obstacles. Of several equally good directions\n (in the chessboard metric) it picks one of those that visually\n (in the euclidean metric) maximally align with the vector between\n the two points.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "towards",
          "package": "LambdaHack",
          "signature": "Point -\u003e Point -\u003e Vector",
          "source": "src/Game-LambdaHack-Common-Vector.html#towards",
          "type": "function"
        },
        "index": {
          "description": "Given two distinct positions determine the direction unit vector in which one should move from the first in order to get closer to the second Ignores obstacles Of several equally good directions in the chessboard metric it picks one of those that visually in the euclidean metric maximally align with the vector between the two points",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "towards",
          "normalized": "Point-\u003ePoint-\u003eVector",
          "package": "LambdaHack",
          "signature": "Point-\u003ePoint-\u003eVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:towards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of points that a list of vectors leads to.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "trajectoryToPath",
          "package": "LambdaHack",
          "signature": "Point -\u003e [Vector] -\u003e [Point]",
          "source": "src/Game-LambdaHack-Common-Vector.html#trajectoryToPath",
          "type": "function"
        },
        "index": {
          "description": "list of points that list of vectors leads to",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "trajectoryToPath",
          "normalized": "Point-\u003e[Vector]-\u003e[Point]",
          "package": "LambdaHack",
          "partial": "To Path",
          "signature": "Point-\u003e[Vector]-\u003e[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:trajectoryToPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll (8 at most) closest neighbours of a point within an area.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vicinity",
          "package": "LambdaHack",
          "signature": "X-\u003e Y-\u003e Point-\u003e [Point]",
          "type": "function"
        },
        "index": {
          "description": "All at most closest neighbours of point within an area",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vicinity",
          "normalized": "X-\u003eY-\u003ePoint-\u003e[Point]",
          "package": "LambdaHack",
          "signature": "X-\u003eY-\u003ePoint-\u003e[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:vicinity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll (4 at most) cardinal direction neighbours of a point within an area.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vicinityCardinal",
          "package": "LambdaHack",
          "signature": "X-\u003e Y-\u003e Point-\u003e [Point]",
          "type": "function"
        },
        "index": {
          "description": "All at most cardinal direction neighbours of point within an area",
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vicinityCardinal",
          "normalized": "X-\u003eY-\u003ePoint-\u003e[Point]",
          "package": "LambdaHack",
          "partial": "Cardinal",
          "signature": "X-\u003eY-\u003ePoint-\u003e[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:vicinityCardinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vx",
          "package": "LambdaHack",
          "signature": "X",
          "source": "src/Game-LambdaHack-Common-Vector.html#Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vx",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:vx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vy",
          "package": "LambdaHack",
          "signature": "Y",
          "source": "src/Game-LambdaHack-Common-Vector.html#Vector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Common Vector",
          "module": "Game.LambdaHack.Common.Vector",
          "name": "vy",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Common-Vector.html#v:vy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of kinds of monsters and heroes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ActorKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ActorKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of kinds of monsters and heroes",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ActorKind",
          "package": "LambdaHack",
          "partial": "Actor Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActor properties that are fixed for a given kind of actors.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ActorKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "data"
        },
        "index": {
          "description": "Actor properties that are fixed for given kind of actors",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ActorKind",
          "package": "LambdaHack",
          "partial": "Actor Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#t:ActorKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ActorKind",
          "package": "LambdaHack",
          "signature": "ActorKind",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ActorKind",
          "package": "LambdaHack",
          "partial": "Actor Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:ActorKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe set of supported abilities\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "acanDo",
          "package": "LambdaHack",
          "signature": "[Ability]",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "the set of supported abilities",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "acanDo",
          "normalized": "[Ability]",
          "package": "LambdaHack",
          "partial": "Do",
          "signature": "[Ability]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:acanDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap color\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "acolor",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "map color",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "acolor",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:acolor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "afreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "afreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:afreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eencodes initial and maximal hp\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ahp",
          "package": "LambdaHack",
          "signature": "RollDice",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "encodes initial and maximal hp",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "ahp",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:ahp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eintelligence\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aiq",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "intelligence",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aiq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:aiq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "short description",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:aname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of turns to regenerate 1 HP\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aregen",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "number of turns to regenerate HP",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aregen",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:aregen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecan it see?\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "asight",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "can it see",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "asight",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:asight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecan it smell?\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "asmell",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "can it smell",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "asmell",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:asmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enatural speed in m/s\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aspeed",
          "package": "LambdaHack",
          "signature": "Speed",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "natural speed in",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "aspeed",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:aspeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "asymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#ActorKind",
          "type": "function"
        },
        "index": {
          "description": "map symbol",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "asymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:asymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter a list of kinds, passing through only the incorrect ones, if any.\n\u003c/p\u003e\u003cp\u003eMake sure actor kinds can be told apart on the level map.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "validateActorKind",
          "package": "LambdaHack",
          "signature": "[ActorKind] -\u003e [ActorKind]",
          "source": "src/Game-LambdaHack-Content-ActorKind.html#validateActorKind",
          "type": "function"
        },
        "index": {
          "description": "Filter list of kinds passing through only the incorrect ones if any Make sure actor kinds can be told apart on the level map",
          "hierarchy": "Game LambdaHack Content ActorKind",
          "module": "Game.LambdaHack.Content.ActorKind",
          "name": "validateActorKind",
          "normalized": "[ActorKind]-\u003e[ActorKind]",
          "package": "LambdaHack",
          "partial": "Actor Kind",
          "signature": "[ActorKind]-\u003e[ActorKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ActorKind.html#v:validateActorKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of cave layout kinds.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "CaveKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-CaveKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of cave layout kinds",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "CaveKind",
          "package": "LambdaHack",
          "partial": "Cave Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParameters for the generation of dungeon levels.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "CaveKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "data"
        },
        "index": {
          "description": "Parameters for the generation of dungeon levels",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "CaveKind",
          "package": "LambdaHack",
          "partial": "Cave Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#t:CaveKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "CaveKind",
          "package": "LambdaHack",
          "signature": "CaveKind",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "CaveKind",
          "package": "LambdaHack",
          "partial": "Cave Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:CaveKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea proportion of extra connections\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cauxConnects",
          "package": "LambdaHack",
          "signature": "Rational",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "proportion of extra connections",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cauxConnects",
          "package": "LambdaHack",
          "partial": "Connects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cauxConnects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe chance a place is dark\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdarkChance",
          "package": "LambdaHack",
          "signature": "RollDeep",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the chance place is dark",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdarkChance",
          "package": "LambdaHack",
          "partial": "Chance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cdarkChance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe dark cave corridor tile group name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdarkCorTile",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the dark cave corridor tile group name",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdarkCorTile",
          "package": "LambdaHack",
          "partial": "Cor Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cdarkCorTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe default cave tile group name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdefTile",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the default cave tile group name",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdefTile",
          "package": "LambdaHack",
          "partial": "Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cdefTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe chance of a door in an opening\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdoorChance",
          "package": "LambdaHack",
          "signature": "Chance",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the chance of door in an opening",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cdoorChance",
          "package": "LambdaHack",
          "partial": "Chance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cdoorChance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe filler wall group name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cfillerTile",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the filler wall group name",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cfillerTile",
          "package": "LambdaHack",
          "partial": "Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cfillerTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cfreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cfreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cfreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe dimensions of the grid of places\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cgrid",
          "package": "LambdaHack",
          "signature": "RollDiceXY",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the dimensions of the grid of places",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cgrid",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cgrid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif not open, hidden one in n times\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "chidden",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "if not open hidden one in times",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "chidden",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:chidden"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eitem groups to consider\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "citemFreq",
          "package": "LambdaHack",
          "signature": "[(Int, Text)]",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "item groups to consider",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "citemFreq",
          "normalized": "[(Int,Text)]",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "[(Int,Text)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:citemFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe number of items in the cave\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "citemNum",
          "package": "LambdaHack",
          "signature": "RollDice",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the number of items in the cave",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "citemNum",
          "package": "LambdaHack",
          "partial": "Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:citemNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe dark place plan legend group name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "clegendDarkTile",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the dark place plan legend group name",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "clegendDarkTile",
          "package": "LambdaHack",
          "partial": "Dark Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:clegendDarkTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe lit place plan legend group name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "clegendLitTile",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the lit place plan legend group name",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "clegendLitTile",
          "package": "LambdaHack",
          "partial": "Lit Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:clegendLitTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe lit cave corridor tile group name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "clitCorTile",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the lit cave corridor tile group name",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "clitCorTile",
          "package": "LambdaHack",
          "partial": "Cor Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:clitCorTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaximal size of places\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cmaxPlaceSize",
          "package": "LambdaHack",
          "signature": "RollDiceXY",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "maximal size of places",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cmaxPlaceSize",
          "package": "LambdaHack",
          "partial": "Place Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cmaxPlaceSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eat most this proportion of rooms void\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cmaxVoid",
          "package": "LambdaHack",
          "signature": "Rational",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "at most this proportion of rooms void",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cmaxVoid",
          "package": "LambdaHack",
          "partial": "Void",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cmaxVoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eminimal size of places\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cminPlaceSize",
          "package": "LambdaHack",
          "signature": "RollDiceXY",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "minimal size of places",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cminPlaceSize",
          "package": "LambdaHack",
          "partial": "Place Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cminPlaceSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eminimal distance between stairs\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cminStairDist",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "minimal distance between stairs",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cminStairDist",
          "package": "LambdaHack",
          "partial": "Stair Dist",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cminStairDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "short description",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe chance the cave is dark\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cnightChance",
          "package": "LambdaHack",
          "signature": "RollDeep",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the chance the cave is dark",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cnightChance",
          "package": "LambdaHack",
          "partial": "Chance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cnightChance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif there's a door, is it open?\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "copenChance",
          "package": "LambdaHack",
          "signature": "Chance",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "if there door is it open",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "copenChance",
          "package": "LambdaHack",
          "partial": "Chance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:copenChance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe outer fence wall group name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "couterFenceTile",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "the outer fence wall group name",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "couterFenceTile",
          "package": "LambdaHack",
          "partial": "Fence Tile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:couterFenceTile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "csymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "symbol",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "csymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:csymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eX size of the whole cave\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cxsize",
          "package": "LambdaHack",
          "signature": "X",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "size of the whole cave",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cxsize",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cxsize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eY size of the whole cave\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cysize",
          "package": "LambdaHack",
          "signature": "Y",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#CaveKind",
          "type": "function"
        },
        "index": {
          "description": "size of the whole cave",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "cysize",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:cysize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter a list of kinds, passing through only the incorrect ones, if any.\n\u003c/p\u003e\u003cp\u003eCatch caves with not enough space for all the places. Check the size\n of the cave descriptions to make sure they fit on screen.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "validateCaveKind",
          "package": "LambdaHack",
          "signature": "[CaveKind] -\u003e [CaveKind]",
          "source": "src/Game-LambdaHack-Content-CaveKind.html#validateCaveKind",
          "type": "function"
        },
        "index": {
          "description": "Filter list of kinds passing through only the incorrect ones if any Catch caves with not enough space for all the places Check the size of the cave descriptions to make sure they fit on screen",
          "hierarchy": "Game LambdaHack Content CaveKind",
          "module": "Game.LambdaHack.Content.CaveKind",
          "name": "validateCaveKind",
          "normalized": "[CaveKind]-\u003e[CaveKind]",
          "package": "LambdaHack",
          "partial": "Cave Kind",
          "signature": "[CaveKind]-\u003e[CaveKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-CaveKind.html#v:validateCaveKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of kinds of game factions (heroes, enemies, NPCs, etc.).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "FactionKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-FactionKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of kinds of game factions heroes enemies NPCs etc",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "FactionKind",
          "package": "LambdaHack",
          "partial": "Faction Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFaction properties that are fixed for a given kind of factions.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "FactionKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#FactionKind",
          "type": "data"
        },
        "index": {
          "description": "Faction properties that are fixed for given kind of factions",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "FactionKind",
          "package": "LambdaHack",
          "partial": "Faction Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#t:FactionKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "FactionKind",
          "package": "LambdaHack",
          "signature": "FactionKind",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#FactionKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "FactionKind",
          "package": "LambdaHack",
          "partial": "Faction Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#v:FactionKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eabilities of the picked leader\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fAbilityLeader",
          "package": "LambdaHack",
          "signature": "[Ability]",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#FactionKind",
          "type": "function"
        },
        "index": {
          "description": "abilities of the picked leader",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fAbilityLeader",
          "normalized": "[Ability]",
          "package": "LambdaHack",
          "partial": "Ability Leader",
          "signature": "[Ability]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#v:fAbilityLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eabilities of the other actors\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fAbilityOther",
          "package": "LambdaHack",
          "signature": "[Ability]",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#FactionKind",
          "type": "function"
        },
        "index": {
          "description": "abilities of the other actors",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fAbilityOther",
          "normalized": "[Ability]",
          "package": "LambdaHack",
          "partial": "Ability Other",
          "signature": "[Ability]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#v:fAbilityOther"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "ffreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#FactionKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "ffreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#v:ffreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#FactionKind",
          "type": "function"
        },
        "index": {
          "description": "short description",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#v:fname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fsymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#FactionKind",
          "type": "function"
        },
        "index": {
          "description": "symbol",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "fsymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#v:fsymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo specific possible problems for the content of this kind, so far,\n so the validation function always returns the empty list of offending kinds.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "validateFactionKind",
          "package": "LambdaHack",
          "signature": "[FactionKind] -\u003e [FactionKind]",
          "source": "src/Game-LambdaHack-Content-FactionKind.html#validateFactionKind",
          "type": "function"
        },
        "index": {
          "description": "No specific possible problems for the content of this kind so far so the validation function always returns the empty list of offending kinds",
          "hierarchy": "Game LambdaHack Content FactionKind",
          "module": "Game.LambdaHack.Content.FactionKind",
          "name": "validateFactionKind",
          "normalized": "[FactionKind]-\u003e[FactionKind]",
          "package": "LambdaHack",
          "partial": "Faction Kind",
          "signature": "[FactionKind]-\u003e[FactionKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-FactionKind.html#v:validateFactionKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of kinds of weapons and treasure.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ItemKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ItemKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of kinds of weapons and treasure",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ItemKind",
          "package": "LambdaHack",
          "partial": "Item Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eItem properties that are fixed for a given kind of items.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ItemKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "data"
        },
        "index": {
          "description": "Item properties that are fixed for given kind of items",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ItemKind",
          "package": "LambdaHack",
          "partial": "Item Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#t:ItemKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ItemKind",
          "package": "LambdaHack",
          "signature": "ItemKind",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ItemKind",
          "package": "LambdaHack",
          "partial": "Item Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:ItemKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreated in that quantify\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "icount",
          "package": "LambdaHack",
          "signature": "RollDeep",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "created in that quantify",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "icount",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:icount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eproperties\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ifeature",
          "package": "LambdaHack",
          "signature": "[Feature]",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "properties",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ifeature",
          "normalized": "[Feature]",
          "package": "LambdaHack",
          "signature": "[Feature]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:ifeature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epossible flavours\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iflavour",
          "package": "LambdaHack",
          "signature": "[Flavour]",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "possible flavours",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iflavour",
          "normalized": "[Flavour]",
          "package": "LambdaHack",
          "signature": "[Flavour]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:iflavour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ifreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "ifreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:ifreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneric name\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "generic name",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:iname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "isymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "map symbol",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "isymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:isymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epercentage bonus to throw speed\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "itoThrow",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "percentage bonus to throw speed",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "itoThrow",
          "package": "LambdaHack",
          "partial": "Throw",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:itoThrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe verb for applying and combat\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iverbApply",
          "package": "LambdaHack",
          "signature": "Part",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "the verb for applying and combat",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iverbApply",
          "package": "LambdaHack",
          "partial": "Apply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:iverbApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe verb for projecting\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iverbProject",
          "package": "LambdaHack",
          "signature": "Part",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "the verb for projecting",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iverbProject",
          "package": "LambdaHack",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:iverbProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eweight in grams\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iweight",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#ItemKind",
          "type": "function"
        },
        "index": {
          "description": "weight in grams",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "iweight",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:iweight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo specific possible problems for the content of this kind, so far,\n so the validation function always returns the empty list of offending kinds.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "validateItemKind",
          "package": "LambdaHack",
          "signature": "[ItemKind] -\u003e [ItemKind]",
          "source": "src/Game-LambdaHack-Content-ItemKind.html#validateItemKind",
          "type": "function"
        },
        "index": {
          "description": "No specific possible problems for the content of this kind so far so the validation function always returns the empty list of offending kinds",
          "hierarchy": "Game LambdaHack Content ItemKind",
          "module": "Game.LambdaHack.Content.ItemKind",
          "name": "validateItemKind",
          "normalized": "[ItemKind]-\u003e[ItemKind]",
          "package": "LambdaHack",
          "partial": "Item Kind",
          "signature": "[ItemKind]-\u003e[ItemKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ItemKind.html#v:validateItemKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of kinds of game modes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "ModeKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ModeKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of kinds of game modes",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "ModeKind",
          "package": "LambdaHack",
          "partial": "Mode Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRequested cave groups for particular levels. The default is\n the \u003ca\u003edng\u003c/a\u003e group, which means a random choice from all caves\n that can randomly appear. The second component of the pair\n is the \u003ccode\u003eEscape\u003c/code\u003e feature on the level. \u003ccode\u003eTrue\u003c/code\u003e means it's represented\n by \u003ccode\u003e\u003ca\u003e@False@, by @\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Caves",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Caves",
          "type": "type"
        },
        "index": {
          "description": "Requested cave groups for particular levels The default is the dng group which means random choice from all caves that can randomly appear The second component of the pair is the Escape feature on the level True means it represented by False by",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Caves",
          "package": "LambdaHack",
          "partial": "Caves",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#t:Caves"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGame mode specification.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "ModeKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#ModeKind",
          "type": "data"
        },
        "index": {
          "description": "Game mode specification",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "ModeKind",
          "package": "LambdaHack",
          "partial": "Mode Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#t:ModeKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProperties of a particular player.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Player",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "data"
        },
        "index": {
          "description": "Properties of particular player",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Player",
          "package": "LambdaHack",
          "partial": "Player",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#t:Player"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe specification of players for the game mode.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Players",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Players",
          "type": "data"
        },
        "index": {
          "description": "The specification of players for the game mode",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Players",
          "package": "LambdaHack",
          "partial": "Players",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#t:Players"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "ModeKind",
          "package": "LambdaHack",
          "signature": "ModeKind",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#ModeKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "ModeKind",
          "package": "LambdaHack",
          "partial": "Mode Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:ModeKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Player",
          "package": "LambdaHack",
          "signature": "Player",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Player",
          "package": "LambdaHack",
          "partial": "Player",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:Player"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Players",
          "package": "LambdaHack",
          "signature": "Players",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Players",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "Players",
          "package": "LambdaHack",
          "partial": "Players",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:Players"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earena of the game\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mcaves",
          "package": "LambdaHack",
          "signature": "Caves",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#ModeKind",
          "type": "function"
        },
        "index": {
          "description": "arena of the game",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mcaves",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:mcaves"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mfreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#ModeKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mfreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:mfreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#ModeKind",
          "type": "function"
        },
        "index": {
          "description": "short description",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:mname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplayers taking part in the game\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mplayers",
          "package": "LambdaHack",
          "signature": "Players",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#ModeKind",
          "type": "function"
        },
        "index": {
          "description": "players taking part in the game",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "mplayers",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:mplayers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea symbol (matches the keypress, if any)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "msymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#ModeKind",
          "type": "function"
        },
        "index": {
          "description": "symbol matches the keypress if any",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "msymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:msymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis the leader under AI control?\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerAiLeader",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "is the leader under AI control",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerAiLeader",
          "package": "LambdaHack",
          "partial": "Ai Leader",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerAiLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eare the others under AI control?\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerAiOther",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "are the others under AI control",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerAiOther",
          "package": "LambdaHack",
          "partial": "Ai Other",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerAiOther"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elevel where the initial members start\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerEntry",
          "package": "LambdaHack",
          "signature": "LevelId",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "level where the initial members start",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerEntry",
          "package": "LambdaHack",
          "partial": "Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of faction(s) the player can control\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerFaction",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "name of faction the player can control",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerFaction",
          "package": "LambdaHack",
          "partial": "Faction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerFaction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis the player considered human\n and so, e.g., eligible for a high score?\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerHuman",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "is the player considered human and so e.g eligible for high score",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerHuman",
          "package": "LambdaHack",
          "partial": "Human",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerHuman"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of initial members\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerInitial",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "number of initial members",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerInitial",
          "package": "LambdaHack",
          "partial": "Initial",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerInitial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of the player\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerName",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "name of the player",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerName",
          "package": "LambdaHack",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003espawning frequency\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerSpawn",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "spawning frequency",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerSpawn",
          "package": "LambdaHack",
          "partial": "Spawn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerSpawn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edoes the faction have a UI client\n (for control or passive observation)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerUI",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Player",
          "type": "function"
        },
        "index": {
          "description": "does the faction have UI client for control or passive observation",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playerUI",
          "package": "LambdaHack",
          "partial": "UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playerUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe initial aliance matrix\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playersAlly",
          "package": "LambdaHack",
          "signature": "[(Text, Text)]",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Players",
          "type": "function"
        },
        "index": {
          "description": "the initial aliance matrix",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playersAlly",
          "normalized": "[(Text,Text)]",
          "package": "LambdaHack",
          "partial": "Ally",
          "signature": "[(Text,Text)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playersAlly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe initial enmity matrix\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playersEnemy",
          "package": "LambdaHack",
          "signature": "[(Text, Text)]",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Players",
          "type": "function"
        },
        "index": {
          "description": "the initial enmity matrix",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playersEnemy",
          "normalized": "[(Text,Text)]",
          "package": "LambdaHack",
          "partial": "Enemy",
          "signature": "[(Text,Text)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playersEnemy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplayers, both human and computer\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playersList",
          "package": "LambdaHack",
          "signature": "[Player]",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#Players",
          "type": "function"
        },
        "index": {
          "description": "players both human and computer",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "playersList",
          "normalized": "[Player]",
          "package": "LambdaHack",
          "partial": "List",
          "signature": "[Player]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:playersList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo specific possible problems for the content of this kind, so far,\n so the validation function always returns the empty list of offending kinds.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "validateModeKind",
          "package": "LambdaHack",
          "signature": "[ModeKind] -\u003e [ModeKind]",
          "source": "src/Game-LambdaHack-Content-ModeKind.html#validateModeKind",
          "type": "function"
        },
        "index": {
          "description": "No specific possible problems for the content of this kind so far so the validation function always returns the empty list of offending kinds",
          "hierarchy": "Game LambdaHack Content ModeKind",
          "module": "Game.LambdaHack.Content.ModeKind",
          "name": "validateModeKind",
          "normalized": "[ModeKind]-\u003e[ModeKind]",
          "package": "LambdaHack",
          "partial": "Mode Kind",
          "signature": "[ModeKind]-\u003e[ModeKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-ModeKind.html#v:validateModeKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of kinds of rooms, halls and passages.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "PlaceKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of kinds of rooms halls and passages",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "PlaceKind",
          "package": "LambdaHack",
          "partial": "Place Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA method of filling the whole area by transforming a given corner.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "Cover",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Cover",
          "type": "data"
        },
        "index": {
          "description": "method of filling the whole area by transforming given corner",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "Cover",
          "package": "LambdaHack",
          "partial": "Cover",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#t:Cover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe choice of a fence type for the place.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "Fence",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Fence",
          "type": "data"
        },
        "index": {
          "description": "The choice of fence type for the place",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "Fence",
          "package": "LambdaHack",
          "partial": "Fence",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#t:Fence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParameters for the generation of small areas within a dungeon level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "PlaceKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "data"
        },
        "index": {
          "description": "Parameters for the generation of small areas within dungeon level",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "PlaceKind",
          "package": "LambdaHack",
          "partial": "Place Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#t:PlaceKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereflect every other corner, overlapping 1 row and column\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "CAlternate",
          "package": "LambdaHack",
          "signature": "CAlternate",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Cover",
          "type": "function"
        },
        "index": {
          "description": "reflect every other corner overlapping row and column",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "CAlternate",
          "package": "LambdaHack",
          "partial": "CAlternate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:CAlternate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etile separately and symmetrically quarters of the place\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "CReflect",
          "package": "LambdaHack",
          "signature": "CReflect",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Cover",
          "type": "function"
        },
        "index": {
          "description": "tile separately and symmetrically quarters of the place",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "CReflect",
          "package": "LambdaHack",
          "partial": "CReflect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:CReflect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efill symmetrically 4 corners and stretch their borders\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "CStretch",
          "package": "LambdaHack",
          "signature": "CStretch",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Cover",
          "type": "function"
        },
        "index": {
          "description": "fill symmetrically corners and stretch their borders",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "CStretch",
          "package": "LambdaHack",
          "partial": "CStretch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:CStretch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleave an empty floor space around the place\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "FFloor",
          "package": "LambdaHack",
          "signature": "FFloor",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Fence",
          "type": "function"
        },
        "index": {
          "description": "leave an empty floor space around the place",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "FFloor",
          "package": "LambdaHack",
          "partial": "FFloor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:FFloor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eskip the fence and fill all with the place proper\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "FNone",
          "package": "LambdaHack",
          "signature": "FNone",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Fence",
          "type": "function"
        },
        "index": {
          "description": "skip the fence and fill all with the place proper",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "FNone",
          "package": "LambdaHack",
          "partial": "FNone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:FNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eput a solid wall fence around the place\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "FWall",
          "package": "LambdaHack",
          "signature": "FWall",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#Fence",
          "type": "function"
        },
        "index": {
          "description": "put solid wall fence around the place",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "FWall",
          "package": "LambdaHack",
          "partial": "FWall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:FWall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "PlaceKind",
          "package": "LambdaHack",
          "signature": "PlaceKind",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "PlaceKind",
          "package": "LambdaHack",
          "partial": "Place Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:PlaceKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehow to fill whole place based on the corner\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pcover",
          "package": "LambdaHack",
          "signature": "Cover",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "function"
        },
        "index": {
          "description": "how to fill whole place based on the corner",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pcover",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:pcover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhether to fence the place with solid border\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pfence",
          "package": "LambdaHack",
          "signature": "Fence",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "function"
        },
        "index": {
          "description": "whether to fence the place with solid border",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pfence",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:pfence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pfreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pfreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:pfreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "function"
        },
        "index": {
          "description": "short description",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "pname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:pname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "psymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "function"
        },
        "index": {
          "description": "symbol",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "psymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:psymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplan of the top-left corner of the place\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "ptopLeft",
          "package": "LambdaHack",
          "signature": "[Text]",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#PlaceKind",
          "type": "function"
        },
        "index": {
          "description": "plan of the top-left corner of the place",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "ptopLeft",
          "normalized": "[Text]",
          "package": "LambdaHack",
          "partial": "Left",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:ptopLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter a list of kinds, passing through only the incorrect ones, if any.\n\u003c/p\u003e\u003cp\u003eVerify that the top-left corner map is rectangular and not empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "validatePlaceKind",
          "package": "LambdaHack",
          "signature": "[PlaceKind] -\u003e [PlaceKind]",
          "source": "src/Game-LambdaHack-Content-PlaceKind.html#validatePlaceKind",
          "type": "function"
        },
        "index": {
          "description": "Filter list of kinds passing through only the incorrect ones if any Verify that the top-left corner map is rectangular and not empty",
          "hierarchy": "Game LambdaHack Content PlaceKind",
          "module": "Game.LambdaHack.Content.PlaceKind",
          "name": "validatePlaceKind",
          "normalized": "[PlaceKind]-\u003e[PlaceKind]",
          "package": "LambdaHack",
          "partial": "Place Kind",
          "signature": "[PlaceKind]-\u003e[PlaceKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-PlaceKind.html#v:validatePlaceKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of game rule sets and assorted game data.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "RuleKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-RuleKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of game rule sets and assorted game data",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "RuleKind",
          "package": "LambdaHack",
          "partial": "Rule Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField Of View scanning mode.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "FovMode",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#FovMode",
          "type": "data"
        },
        "index": {
          "description": "Field Of View scanning mode",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "FovMode",
          "package": "LambdaHack",
          "partial": "Fov Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#t:FovMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of game rule sets and assorted game data.\n\u003c/p\u003e\u003cp\u003eFor now the rules are immutable througout the game, so there is\n no type \u003ccode\u003eRule\u003c/code\u003e to hold any changing parameters, just \u003ccode\u003eRuleKind\u003c/code\u003e\n for the fixed set.\n However, in the future, if the rules can get changed during gameplay\n based on data mining of player behaviour, we may add such a type\n and then \u003ccode\u003eRuleKind\u003c/code\u003e will become just a starting template, analogously\n as for the other content.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003eraccessible\u003c/code\u003e field hold extra conditions that have to be met\n for a tile to be accessible, on top of being an open tile\n (or openable, in some contexts). The \u003ccode\u003eraccessibleDoor\u003c/code\u003e field\n contains yet additional conditions concerning tiles that are doors,\n whether open or closed.\n Precondition: the two positions are next to each other.\n We assume the predicate is symmetric.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "RuleKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "data"
        },
        "index": {
          "description": "The type of game rule sets and assorted game data For now the rules are immutable througout the game so there is no type Rule to hold any changing parameters just RuleKind for the fixed set However in the future if the rules can get changed during gameplay based on data mining of player behaviour we may add such type and then RuleKind will become just starting template analogously as for the other content The raccessible field hold extra conditions that have to be met for tile to be accessible on top of being an open tile or openable in some contexts The raccessibleDoor field contains yet additional conditions concerning tiles that are doors whether open or closed Precondition the two positions are next to each other We assume the predicate is symmetric",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "RuleKind",
          "package": "LambdaHack",
          "partial": "Rule Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#t:RuleKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eonly feeling out adjacent tiles by touch\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Blind",
          "package": "LambdaHack",
          "signature": "Blind",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#FovMode",
          "type": "function"
        },
        "index": {
          "description": "only feeling out adjacent tiles by touch",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Blind",
          "package": "LambdaHack",
          "partial": "Blind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:Blind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edigital FOV with the given radius\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Digital",
          "package": "LambdaHack",
          "signature": "Digital !Int",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#FovMode",
          "type": "function"
        },
        "index": {
          "description": "digital FOV with the given radius",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Digital",
          "package": "LambdaHack",
          "partial": "Digital",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:Digital"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epermissive FOV\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Permissive",
          "package": "LambdaHack",
          "signature": "Permissive",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#FovMode",
          "type": "function"
        },
        "index": {
          "description": "permissive FOV",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Permissive",
          "package": "LambdaHack",
          "partial": "Permissive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:Permissive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "RuleKind",
          "package": "LambdaHack",
          "signature": "RuleKind",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "RuleKind",
          "package": "LambdaHack",
          "partial": "Rule Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:RuleKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erestrictive shadow casting\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Shadow",
          "package": "LambdaHack",
          "signature": "Shadow",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#FovMode",
          "type": "function"
        },
        "index": {
          "description": "restrictive shadow casting",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "Shadow",
          "package": "LambdaHack",
          "partial": "Shadow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:Shadow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "raccessible",
          "package": "LambdaHack",
          "signature": "(Maybe (Point -\u003e Point -\u003e Bool))",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "raccessible",
          "normalized": "(Maybe(Point-\u003ePoint-\u003eBool))",
          "package": "LambdaHack",
          "signature": "(Maybe(Point-\u003ePoint-\u003eBool))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:raccessible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "raccessibleDoor",
          "package": "LambdaHack",
          "signature": "(Maybe (Point -\u003e Point -\u003e Bool))",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "raccessibleDoor",
          "normalized": "(Maybe(Point-\u003ePoint-\u003eBool))",
          "package": "LambdaHack",
          "partial": "Door",
          "signature": "(Maybe(Point-\u003ePoint-\u003eBool))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:raccessibleDoor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe default UI settings config file\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rcfgUIDefault",
          "package": "LambdaHack",
          "signature": "String",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "the default UI settings config file",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rcfgUIDefault",
          "package": "LambdaHack",
          "partial": "UIDefault",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rcfgUIDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebase name of the UI config file\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rcfgUIName",
          "package": "LambdaHack",
          "signature": "FilePath",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "base name of the UI config file",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rcfgUIName",
          "package": "LambdaHack",
          "partial": "UIName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rcfgUIName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhether first non-spawner actor death\n   ends the game\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rfirstDeathEnds",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "whether first non-spawner actor death ends the game",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rfirstDeathEnds",
          "package": "LambdaHack",
          "partial": "Death Ends",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rfirstDeathEnds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFOV calculation mode\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rfovMode",
          "package": "LambdaHack",
          "signature": "FovMode",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "FOV calculation mode",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rfovMode",
          "package": "LambdaHack",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rfovMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rfreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rfreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rfreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault client commands\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rhumanCommands",
          "package": "LambdaHack",
          "signature": "[(KM, (CmdCategory, HumanCmd))]",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "default client commands",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rhumanCommands",
          "normalized": "[(KM,(CmdCategory,HumanCmd))]",
          "package": "LambdaHack",
          "partial": "Commands",
          "signature": "[(KM,(CmdCategory,HumanCmd))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rhumanCommands"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esymbols of melee weapons\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "ritemMelee",
          "package": "LambdaHack",
          "signature": "[Char]",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "symbols of melee weapons",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "ritemMelee",
          "normalized": "[Char]",
          "package": "LambdaHack",
          "partial": "Melee",
          "signature": "[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:ritemMelee"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esymbols of items AI can project\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "ritemProject",
          "package": "LambdaHack",
          "signature": "[Char]",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "symbols of items AI can project",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "ritemProject",
          "normalized": "[Char]",
          "package": "LambdaHack",
          "partial": "Project",
          "signature": "[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:ritemProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eranged weapons and missiles\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "ritemRanged",
          "package": "LambdaHack",
          "signature": "[Char]",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "ranged weapons and missiles",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "ritemRanged",
          "normalized": "[Char]",
          "package": "LambdaHack",
          "partial": "Ranged",
          "signature": "[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:ritemRanged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAI/spawn leader level flipped that often\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rleadLevelClips",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "AI spawn leader level flipped that often",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rleadLevelClips",
          "package": "LambdaHack",
          "partial": "Level Clips",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rleadLevelClips"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe ASCII art for the Main Menu\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rmainMenuArt",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "the ASCII art for the Main Menu",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rmainMenuArt",
          "package": "LambdaHack",
          "partial": "Menu Art",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rmainMenuArt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "short description",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe path to data files\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rpathsDataFile",
          "package": "LambdaHack",
          "signature": "FilePath -\u003e IO FilePath",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "the path to data files",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rpathsDataFile",
          "normalized": "FilePath-\u003eIO FilePath",
          "package": "LambdaHack",
          "partial": "Data File",
          "signature": "FilePath-\u003eIO FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rpathsDataFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe version of the game\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rpathsVersion",
          "package": "LambdaHack",
          "signature": "Version",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "the version of the game",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rpathsVersion",
          "package": "LambdaHack",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rpathsVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egame backup is saved that often\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rsaveBkpClips",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "game backup is saved that often",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rsaveBkpClips",
          "package": "LambdaHack",
          "partial": "Bkp Clips",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rsaveBkpClips"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of the savefile prefix\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rsavePrefix",
          "package": "LambdaHack",
          "signature": "String",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "name of the savefile prefix",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rsavePrefix",
          "package": "LambdaHack",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rsavePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of the scores file\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rscoresFile",
          "package": "LambdaHack",
          "signature": "FilePath",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "name of the scores file",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rscoresFile",
          "package": "LambdaHack",
          "partial": "File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rscoresFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rsymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "symbol",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rsymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rsymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe title of the game\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rtitle",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#RuleKind",
          "type": "function"
        },
        "index": {
          "description": "the title of the game",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "rtitle",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:rtitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValidates the ASCII art format (TODO).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "validateRuleKind",
          "package": "LambdaHack",
          "signature": "[RuleKind] -\u003e [RuleKind]",
          "source": "src/Game-LambdaHack-Content-RuleKind.html#validateRuleKind",
          "type": "function"
        },
        "index": {
          "description": "Validates the ASCII art format TODO",
          "hierarchy": "Game LambdaHack Content RuleKind",
          "module": "Game.LambdaHack.Content.RuleKind",
          "name": "validateRuleKind",
          "normalized": "[RuleKind]-\u003e[RuleKind]",
          "package": "LambdaHack",
          "partial": "Rule Kind",
          "signature": "[RuleKind]-\u003e[RuleKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-RuleKind.html#v:validateRuleKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe type of kinds of terrain tiles.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "TileKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-TileKind.html",
          "type": "module"
        },
        "index": {
          "description": "The type of kinds of terrain tiles",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "TileKind",
          "package": "LambdaHack",
          "partial": "Tile Kind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of kinds of terrain tiles. See \u003ccode\u003eTile.hs\u003c/code\u003e for explanation\n of the absence of a corresponding type \u003ccode\u003eTile\u003c/code\u003e that would hold\n particular concrete tiles in the dungeon.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "TileKind",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "data"
        },
        "index": {
          "description": "The type of kinds of terrain tiles See Tile.hs for explanation of the absence of corresponding type Tile that would hold particular concrete tiles in the dungeon",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "TileKind",
          "package": "LambdaHack",
          "partial": "Tile Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#t:TileKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "TileKind",
          "package": "LambdaHack",
          "signature": "TileKind",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "TileKind",
          "package": "LambdaHack",
          "partial": "Tile Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:TileKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFeatures of tiles that differentiate them substantially from one another.\n By tile contents validation condition, this means the player\n can tell such tile apart, and only looking at the map, not tile name.\n So if running uses this function, it won't stop at places that the player\n can't himself tell from other places, and so running does not confer\n any advantages, except UI convenience.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "actionFeatures",
          "package": "LambdaHack",
          "signature": "Bool -\u003e TileKind -\u003e Set Feature",
          "source": "src/Game-LambdaHack-Content-TileKind.html#actionFeatures",
          "type": "function"
        },
        "index": {
          "description": "Features of tiles that differentiate them substantially from one another By tile contents validation condition this means the player can tell such tile apart and only looking at the map not tile name So if running uses this function it won stop at places that the player can himself tell from other places and so running does not confer any advantages except UI convenience",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "actionFeatures",
          "normalized": "Bool-\u003eTileKind-\u003eSet Feature",
          "package": "LambdaHack",
          "partial": "Features",
          "signature": "Bool-\u003eTileKind-\u003eSet Feature",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:actionFeatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap color\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tcolor",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "function"
        },
        "index": {
          "description": "map color",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tcolor",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:tcolor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap color when not in FOV\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tcolor2",
          "package": "LambdaHack",
          "signature": "Color",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "function"
        },
        "index": {
          "description": "map color when not in FOV",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tcolor2",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:tcolor2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eproperties\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tfeature",
          "package": "LambdaHack",
          "signature": "[Feature]",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "function"
        },
        "index": {
          "description": "properties",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tfeature",
          "normalized": "[Feature]",
          "package": "LambdaHack",
          "signature": "[Feature]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:tfeature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efrequency within groups\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tfreq",
          "package": "LambdaHack",
          "signature": "Freqs",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "function"
        },
        "index": {
          "description": "frequency within groups",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tfreq",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:tfreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tname",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "function"
        },
        "index": {
          "description": "short description",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tname",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:tname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap symbol\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tsymbol",
          "package": "LambdaHack",
          "signature": "Char",
          "source": "src/Game-LambdaHack-Content-TileKind.html#TileKind",
          "type": "function"
        },
        "index": {
          "description": "map symbol",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "tsymbol",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:tsymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter a list of kinds, passing through only the incorrect ones, if any.\n\u003c/p\u003e\u003cp\u003eIf tiles look the same on the map, the description and the substantial\n features should be the same, too. Otherwise, the player has to inspect\n manually all the tiles of that kind, or even experiment with them,\n to see if any is special. This would be tedious. Note that iiles may freely\n differ wrt dungeon generation, AI preferences, etc.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "validateTileKind",
          "package": "LambdaHack",
          "signature": "[TileKind] -\u003e [TileKind]",
          "source": "src/Game-LambdaHack-Content-TileKind.html#validateTileKind",
          "type": "function"
        },
        "index": {
          "description": "Filter list of kinds passing through only the incorrect ones if any If tiles look the same on the map the description and the substantial features should be the same too Otherwise the player has to inspect manually all the tiles of that kind or even experiment with them to see if any is special This would be tedious Note that iiles may freely differ wrt dungeon generation AI preferences etc",
          "hierarchy": "Game LambdaHack Content TileKind",
          "module": "Game.LambdaHack.Content.TileKind",
          "name": "validateTileKind",
          "normalized": "[TileKind]-\u003e[TileKind]",
          "package": "LambdaHack",
          "partial": "Tile Kind",
          "signature": "[TileKind]-\u003e[TileKind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Content-TileKind.html#v:validateTileKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRe-export the operations of the chosen raw frontend\n (determined at compile time with cabal flags).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "Chosen",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html",
          "type": "module"
        },
        "index": {
          "description": "Re-export the operations of the chosen raw frontend determined at compile time with cabal flags",
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "Chosen",
          "package": "LambdaHack",
          "partial": "Chosen",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "Frontend",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#Frontend",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "Frontend",
          "package": "LambdaHack",
          "partial": "Frontend",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#t:Frontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "Frontend",
          "package": "LambdaHack",
          "signature": "Frontend",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#Frontend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "Frontend",
          "package": "LambdaHack",
          "partial": "Frontend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:Frontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "chosenStartup",
          "package": "LambdaHack",
          "signature": "DebugModeCli -\u003e (Frontend -\u003e IO ()) -\u003e IO ()",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#chosenStartup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "chosenStartup",
          "normalized": "DebugModeCli-\u003e(Frontend-\u003eIO())-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Startup",
          "signature": "DebugModeCli-\u003e(Frontend-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:chosenStartup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "fdebugCli",
          "package": "LambdaHack",
          "signature": "DebugModeCli",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#Frontend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "fdebugCli",
          "package": "LambdaHack",
          "partial": "Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:fdebugCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "fdisplay",
          "package": "LambdaHack",
          "signature": "Bool -\u003e Maybe SingleFrame -\u003e IO ()",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#Frontend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "fdisplay",
          "normalized": "Bool-\u003eMaybe SingleFrame-\u003eIO()",
          "package": "LambdaHack",
          "signature": "Bool-\u003eMaybe SingleFrame-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:fdisplay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "fpromptGetKey",
          "package": "LambdaHack",
          "signature": "SingleFrame -\u003e IO KM",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#Frontend",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "fpromptGetKey",
          "normalized": "SingleFrame-\u003eIO KM",
          "package": "LambdaHack",
          "partial": "Get Key",
          "signature": "SingleFrame-\u003eIO KM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:fpromptGetKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the chosen frontend.\n\u003c/p\u003e",
          "module": "[\"Game.LambdaHack.Frontend.Chosen\",\"Game.LambdaHack.Frontend\"]",
          "name": "frontendName",
          "package": "LambdaHack",
          "signature": "String",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#frontendName",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:frontendName\",\"http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:frontendName\"]"
        },
        "index": {
          "description": "The name of the chosen frontend",
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "frontendName",
          "package": "LambdaHack",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:frontendName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "noStartup",
          "package": "LambdaHack",
          "signature": "DebugModeCli -\u003e (Frontend -\u003e IO ()) -\u003e IO ()",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#noStartup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "noStartup",
          "normalized": "DebugModeCli-\u003e(Frontend-\u003eIO())-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Startup",
          "signature": "DebugModeCli-\u003e(Frontend-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:noStartup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "stdStartup",
          "package": "LambdaHack",
          "signature": "DebugModeCli -\u003e (Frontend -\u003e IO ()) -\u003e IO ()",
          "source": "src/Game-LambdaHack-Frontend-Chosen.html#stdStartup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend Chosen",
          "module": "Game.LambdaHack.Frontend.Chosen",
          "name": "stdStartup",
          "normalized": "DebugModeCli-\u003e(Frontend-\u003eIO())-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Startup",
          "signature": "DebugModeCli-\u003e(Frontend-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Chosen.html#v:stdStartup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eText frontend based on stdin/stdout, intended for bots.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "Std",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend-Std.html",
          "type": "module"
        },
        "index": {
          "description": "Text frontend based on stdin stdout intended for bots",
          "hierarchy": "Game LambdaHack Frontend Std",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "Std",
          "package": "LambdaHack",
          "partial": "Std",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Std.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo session data needs to be maintained by this frontend.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "FrontendSession",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend-Std.html#FrontendSession",
          "type": "data"
        },
        "index": {
          "description": "No session data needs to be maintained by this frontend",
          "hierarchy": "Game LambdaHack Frontend Std",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "FrontendSession",
          "package": "LambdaHack",
          "partial": "Frontend Session",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Std.html#t:FrontendSession"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput to the screen via the frontend.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "fdisplay",
          "package": "LambdaHack",
          "signature": "FrontendSession-\u003e Bool-\u003e Maybe SingleFrame-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Output to the screen via the frontend",
          "hierarchy": "Game LambdaHack Frontend Std",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "fdisplay",
          "normalized": "FrontendSession-\u003eBool-\u003eMaybe SingleFrame-\u003eIO()",
          "package": "LambdaHack",
          "signature": "FrontendSession-\u003eBool-\u003eMaybe SingleFrame-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Std.html#v:fdisplay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay a prompt, wait for any key.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "fpromptGetKey",
          "package": "LambdaHack",
          "signature": "FrontendSession -\u003e SingleFrame -\u003e IO KM",
          "source": "src/Game-LambdaHack-Frontend-Std.html#fpromptGetKey",
          "type": "function"
        },
        "index": {
          "description": "Display prompt wait for any key",
          "hierarchy": "Game LambdaHack Frontend Std",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "fpromptGetKey",
          "normalized": "FrontendSession-\u003eSingleFrame-\u003eIO KM",
          "package": "LambdaHack",
          "partial": "Get Key",
          "signature": "FrontendSession-\u003eSingleFrame-\u003eIO KM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Std.html#v:fpromptGetKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of the frontend.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "frontendName",
          "package": "LambdaHack",
          "signature": "String",
          "source": "src/Game-LambdaHack-Frontend-Std.html#frontendName",
          "type": "function"
        },
        "index": {
          "description": "The name of the frontend",
          "hierarchy": "Game LambdaHack Frontend Std",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "frontendName",
          "package": "LambdaHack",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Std.html#v:frontendName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStarts the main program loop using the frontend input and output.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "startup",
          "package": "LambdaHack",
          "signature": "DebugModeCli -\u003e (FrontendSession -\u003e IO ()) -\u003e IO ()",
          "source": "src/Game-LambdaHack-Frontend-Std.html#startup",
          "type": "function"
        },
        "index": {
          "description": "Starts the main program loop using the frontend input and output",
          "hierarchy": "Game LambdaHack Frontend Std",
          "module": "Game.LambdaHack.Frontend.Std",
          "name": "startup",
          "normalized": "DebugModeCli-\u003e(FrontendSession-\u003eIO())-\u003eIO()",
          "package": "LambdaHack",
          "signature": "DebugModeCli-\u003e(FrontendSession-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend-Std.html#v:startup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDisplay game data on the screen and receive user input\n using one of the available raw frontends and derived  operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Frontend",
          "name": "Frontend",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend.html",
          "type": "module"
        },
        "index": {
          "description": "Display game data on the screen and receive user input using one of the available raw frontends and derived operations",
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "Frontend",
          "package": "LambdaHack",
          "partial": "Frontend",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "ChanFrontend",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend.html#ChanFrontend",
          "type": "type"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "ChanFrontend",
          "package": "LambdaHack",
          "partial": "Chan Frontend",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#t:ChanFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplex connection channels, for the case of a frontend shared\n among clients. This is transparent to the clients themselves.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend",
          "name": "ConnMulti",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend.html#ConnMulti",
          "type": "data"
        },
        "index": {
          "description": "Multiplex connection channels for the case of frontend shared among clients This is transparent to the clients themselves",
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "ConnMulti",
          "package": "LambdaHack",
          "partial": "Conn Multi",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#t:ConnMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontReq",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontReq",
          "package": "LambdaHack",
          "partial": "Front Req",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#t:FrontReq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "ConnMulti",
          "package": "LambdaHack",
          "signature": "ConnMulti",
          "source": "src/Game-LambdaHack-Frontend.html#ConnMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "ConnMulti",
          "package": "LambdaHack",
          "partial": "Conn Multi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:ConnMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexit frontend loop\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontFinish",
          "package": "LambdaHack",
          "signature": "FrontFinish",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "description": "exit frontend loop",
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontFinish",
          "package": "LambdaHack",
          "partial": "Front Finish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:FrontFinish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshow a frame, if the fid acitve, or save it to the client's queue\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontFrame",
          "package": "LambdaHack",
          "signature": "FrontFrame",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "description": "show frame if the fid acitve or save it to the client queue",
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontFrame",
          "package": "LambdaHack",
          "partial": "Front Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:FrontFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eflush frames, possibly show fadeout/fadein and ask for a keypress\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontKey",
          "package": "LambdaHack",
          "signature": "FrontKey",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "description": "flush frames possibly show fadeout fadein and ask for keypress",
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontKey",
          "package": "LambdaHack",
          "partial": "Front Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:FrontKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshow a whole slideshow without interleaving with other clients\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontSlides",
          "package": "LambdaHack",
          "signature": "FrontSlides",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "description": "show whole slideshow without interleaving with other clients",
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "FrontSlides",
          "package": "LambdaHack",
          "partial": "Front Slides",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:FrontSlides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "connMulti",
          "package": "LambdaHack",
          "signature": "ConnMulti",
          "source": "src/Game-LambdaHack-Frontend.html#connMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "connMulti",
          "package": "LambdaHack",
          "partial": "Multi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:connMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "fromMulti",
          "package": "LambdaHack",
          "signature": "FromMulti",
          "source": "src/Game-LambdaHack-Frontend.html#ConnMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "fromMulti",
          "package": "LambdaHack",
          "partial": "Multi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:fromMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "frontAc",
          "package": "LambdaHack",
          "signature": "AcFrame",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "frontAc",
          "package": "LambdaHack",
          "partial": "Ac",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:frontAc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "frontClear",
          "package": "LambdaHack",
          "signature": "[KM]",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "frontClear",
          "normalized": "[KM]",
          "package": "LambdaHack",
          "partial": "Clear",
          "signature": "[KM]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:frontClear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "frontFr",
          "package": "LambdaHack",
          "signature": "SingleFrame",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "frontFr",
          "package": "LambdaHack",
          "partial": "Fr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:frontFr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "frontKM",
          "package": "LambdaHack",
          "signature": "[KM]",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "frontKM",
          "normalized": "[KM]",
          "package": "LambdaHack",
          "partial": "KM",
          "signature": "[KM]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:frontKM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "frontSlides",
          "package": "LambdaHack",
          "signature": "[SingleFrame]",
          "source": "src/Game-LambdaHack-Frontend.html#FrontReq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "frontSlides",
          "normalized": "[SingleFrame]",
          "package": "LambdaHack",
          "partial": "Slides",
          "signature": "[SingleFrame]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:frontSlides"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "startupF",
          "package": "LambdaHack",
          "signature": "DebugModeCli -\u003e IO () -\u003e IO ()",
          "source": "src/Game-LambdaHack-Frontend.html#startupF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "startupF",
          "normalized": "DebugModeCli-\u003eIO()-\u003eIO()",
          "package": "LambdaHack",
          "signature": "DebugModeCli-\u003eIO()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:startupF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Frontend",
          "name": "toMulti",
          "package": "LambdaHack",
          "signature": "ToMulti",
          "source": "src/Game-LambdaHack-Frontend.html#ConnMulti",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Frontend",
          "module": "Game.LambdaHack.Frontend",
          "name": "toMulti",
          "package": "LambdaHack",
          "partial": "Multi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Frontend.html#v:toMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic type classes for server game actions.\n This module should not be imported anywhere except in \u003ccode\u003eAction\u003c/code\u003e\n and \u003ccode\u003eTypeAction\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "ActionClass",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html",
          "type": "module"
        },
        "index": {
          "description": "Basic type classes for server game actions This module should not be imported anywhere except in Action and TypeAction",
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "ActionClass",
          "package": "LambdaHack",
          "partial": "Action Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "MonadConnServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#MonadConnServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "MonadConnServer",
          "package": "LambdaHack",
          "partial": "Monad Conn Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#t:MonadConnServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "MonadServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#MonadServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "MonadServer",
          "package": "LambdaHack",
          "partial": "Monad Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#t:MonadServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getDict",
          "package": "LambdaHack",
          "signature": "m ConnServerDict",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#getDict",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getDict",
          "package": "LambdaHack",
          "partial": "Dict",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:getDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getServer",
          "package": "LambdaHack",
          "signature": "m StateServer",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#getServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getServer",
          "package": "LambdaHack",
          "partial": "Server",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:getServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getsDict",
          "package": "LambdaHack",
          "signature": "(ConnServerDict -\u003e a) -\u003e m a",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#getsDict",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getsDict",
          "normalized": "(ConnServerDict-\u003ea)-\u003eb a",
          "package": "LambdaHack",
          "partial": "Dict",
          "signature": "(ConnServerDict-\u003ea)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:getsDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getsServer",
          "package": "LambdaHack",
          "signature": "(StateServer -\u003e a) -\u003e m a",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#getsServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "getsServer",
          "normalized": "(StateServer-\u003ea)-\u003eb a",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "(StateServer-\u003ea)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:getsServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "liftIO",
          "package": "LambdaHack",
          "signature": "IO a -\u003e m a",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#liftIO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "liftIO",
          "normalized": "IO a-\u003eb a",
          "package": "LambdaHack",
          "partial": "IO",
          "signature": "IO a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:liftIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "modifyDict",
          "package": "LambdaHack",
          "signature": "(ConnServerDict -\u003e ConnServerDict) -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#modifyDict",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "modifyDict",
          "normalized": "(ConnServerDict-\u003eConnServerDict)-\u003ea()",
          "package": "LambdaHack",
          "partial": "Dict",
          "signature": "(ConnServerDict-\u003eConnServerDict)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:modifyDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "modifyServer",
          "package": "LambdaHack",
          "signature": "(StateServer -\u003e StateServer) -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#modifyServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "modifyServer",
          "normalized": "(StateServer-\u003eStateServer)-\u003ea()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "(StateServer-\u003eStateServer)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:modifyServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "putDict",
          "package": "LambdaHack",
          "signature": "ConnServerDict -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#putDict",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "putDict",
          "normalized": "ConnServerDict-\u003ea()",
          "package": "LambdaHack",
          "partial": "Dict",
          "signature": "ConnServerDict-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:putDict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "putServer",
          "package": "LambdaHack",
          "signature": "StateServer -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#putServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "putServer",
          "normalized": "StateServer-\u003ea()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "StateServer-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:putServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "saveName",
          "package": "LambdaHack",
          "signature": "String",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#saveName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "saveName",
          "package": "LambdaHack",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:saveName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "saveServer",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#saveServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action ActionClass",
          "module": "Game.LambdaHack.Server.Action.ActionClass",
          "name": "saveServer",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionClass.html#v:saveServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe main game action monad type implementation. Just as any other\n component of the library, this implementation can be substituted.\n This module should not be imported anywhere except in \u003ccode\u003eAction\u003c/code\u003e\n to expose the executor to any code using the library.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Action.ActionType",
          "name": "ActionType",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action-ActionType.html",
          "type": "module"
        },
        "index": {
          "description": "The main game action monad type implementation Just as any other component of the library this implementation can be substituted This module should not be imported anywhere except in Action to expose the executor to any code using the library",
          "hierarchy": "Game LambdaHack Server Action ActionType",
          "module": "Game.LambdaHack.Server.Action.ActionType",
          "name": "ActionType",
          "package": "LambdaHack",
          "partial": "Action Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionType.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eServer state transformation monad.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action.ActionType",
          "name": "ActionSer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action-ActionType.html#ActionSer",
          "type": "data"
        },
        "index": {
          "description": "Server state transformation monad",
          "hierarchy": "Game LambdaHack Server Action ActionType",
          "module": "Game.LambdaHack.Server.Action.ActionType",
          "name": "ActionSer",
          "package": "LambdaHack",
          "partial": "Action Ser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionType.html#t:ActionSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun an action in the \u003ccode\u003eIO\u003c/code\u003e monad, with undefined state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action.ActionType",
          "name": "executorSer",
          "package": "LambdaHack",
          "signature": "ActionSer () -\u003e IO ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionType.html#executorSer",
          "type": "function"
        },
        "index": {
          "description": "Run an action in the IO monad with undefined state",
          "hierarchy": "Game LambdaHack Server Action ActionType",
          "module": "Game.LambdaHack.Server.Action.ActionType",
          "name": "executorSer",
          "normalized": "ActionSer()-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActionSer()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action-ActionType.html#v:executorSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGame action monads and basic building blocks for human and computer\n player actions. Has no access to the the main action type.\n Does not export the \u003ccode\u003eliftIO\u003c/code\u003e operation nor a few other implementation\n details.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "Action",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action.html",
          "type": "module"
        },
        "index": {
          "description": "Game action monads and basic building blocks for human and computer player actions Has no access to the the main action type Does not export the liftIO operation nor few other implementation details",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "Action",
          "package": "LambdaHack",
          "partial": "Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "MonadConnServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#MonadConnServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "MonadConnServer",
          "package": "LambdaHack",
          "partial": "Monad Conn Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#t:MonadConnServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "MonadServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#MonadServer",
          "type": "class"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "MonadServer",
          "package": "LambdaHack",
          "partial": "Monad Server",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#t:MonadServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "childrenServer",
          "package": "LambdaHack",
          "signature": "MVar [MVar ()]",
          "source": "src/Game-LambdaHack-Server-Action.html#childrenServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "childrenServer",
          "normalized": "MVar[MVar()]",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "MVar[MVar()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:childrenServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "debugPrint",
          "package": "LambdaHack",
          "signature": "Text -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#debugPrint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "debugPrint",
          "normalized": "Text-\u003ea()",
          "package": "LambdaHack",
          "partial": "Print",
          "signature": "Text-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:debugPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "deduceQuits",
          "package": "LambdaHack",
          "signature": "Actor -\u003e Status -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#deduceQuits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "deduceQuits",
          "normalized": "Actor-\u003eStatus-\u003ea()",
          "package": "LambdaHack",
          "partial": "Quits",
          "signature": "Actor-\u003eStatus-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:deduceQuits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDumps RNG states from the start of the game to a file.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "dumpRngs",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#dumpRngs",
          "type": "function"
        },
        "index": {
          "description": "Dumps RNG states from the start of the game to file",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "dumpRngs",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Rngs",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:dumpRngs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "elapsedSessionTimeGT",
          "package": "LambdaHack",
          "signature": "Int -\u003e m Bool",
          "source": "src/Game-LambdaHack-Server-Action.html#elapsedSessionTimeGT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "elapsedSessionTimeGT",
          "normalized": "Int-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "Session Time GT",
          "signature": "Int-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:elapsedSessionTimeGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "getPerFid",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e LevelId -\u003e m Perception",
          "source": "src/Game-LambdaHack-Server-Action.html#getPerFid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "getPerFid",
          "normalized": "FactionId-\u003eLevelId-\u003ea Perception",
          "package": "LambdaHack",
          "partial": "Per Fid",
          "signature": "FactionId-\u003eLevelId-\u003em Perception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:getPerFid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "getServer",
          "package": "LambdaHack",
          "signature": "m StateServer",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#getServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "getServer",
          "package": "LambdaHack",
          "partial": "Server",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:getServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets a random generator from the arguments or, if not present,\n generates one.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "getSetGen",
          "package": "LambdaHack",
          "signature": "Maybe StdGen -\u003e m StdGen",
          "source": "src/Game-LambdaHack-Server-Action.html#getSetGen",
          "type": "function"
        },
        "index": {
          "description": "Gets random generator from the arguments or if not present generates one",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "getSetGen",
          "normalized": "Maybe StdGen-\u003ea StdGen",
          "package": "LambdaHack",
          "partial": "Set Gen",
          "signature": "Maybe StdGen-\u003em StdGen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:getSetGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "getsServer",
          "package": "LambdaHack",
          "signature": "(StateServer -\u003e a) -\u003e m a",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#getsServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "getsServer",
          "normalized": "(StateServer-\u003ea)-\u003eb a",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "(StateServer-\u003ea)-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:getsServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "killAllClients",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#killAllClients",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "killAllClients",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "All Clients",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:killAllClients"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "modifyServer",
          "package": "LambdaHack",
          "signature": "(StateServer -\u003e StateServer) -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#modifyServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "modifyServer",
          "normalized": "(StateServer-\u003eStateServer)-\u003ea()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "(StateServer-\u003eStateServer)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:modifyServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "putServer",
          "package": "LambdaHack",
          "signature": "StateServer -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#putServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "putServer",
          "normalized": "StateServer-\u003ea()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "StateServer-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:putServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the cached perception for the selected level, for a faction.\n The assumption is the level, and only the level, has changed since\n the previous perception calculation.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "resetFidPerception",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e LevelId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#resetFidPerception",
          "type": "function"
        },
        "index": {
          "description": "Update the cached perception for the selected level for faction The assumption is the level and only the level has changed since the previous perception calculation",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "resetFidPerception",
          "normalized": "FactionId-\u003eLevelId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Fid Perception",
          "signature": "FactionId-\u003eLevelId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:resetFidPerception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "resetGameStart",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#resetGameStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "resetGameStart",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Game Start",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:resetGameStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "resetSessionStart",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#resetSessionStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "resetSessionStart",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Session Start",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:resetSessionStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the high scores table. Return the empty table if no file.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "restoreScore",
          "package": "LambdaHack",
          "signature": "COps -\u003e m ScoreTable",
          "source": "src/Game-LambdaHack-Server-Action.html#restoreScore",
          "type": "function"
        },
        "index": {
          "description": "Read the high scores table Return the empty table if no file",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "restoreScore",
          "normalized": "COps-\u003ea ScoreTable",
          "package": "LambdaHack",
          "partial": "Score",
          "signature": "COps-\u003em ScoreTable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:restoreScore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "revealItems",
          "package": "LambdaHack",
          "signature": "Maybe FactionId -\u003e Maybe Actor -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#revealItems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "revealItems",
          "normalized": "Maybe FactionId-\u003eMaybe Actor-\u003ea()",
          "package": "LambdaHack",
          "partial": "Items",
          "signature": "Maybe FactionId-\u003eMaybe Actor-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:revealItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvoke pseudo-random computation with the generator kept in the state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "rndToAction",
          "package": "LambdaHack",
          "signature": "Rnd a -\u003e m a",
          "source": "src/Game-LambdaHack-Server-Action.html#rndToAction",
          "type": "function"
        },
        "index": {
          "description": "Invoke pseudo-random computation with the generator kept in the state",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "rndToAction",
          "normalized": "Rnd a-\u003eb a",
          "package": "LambdaHack",
          "partial": "To Action",
          "signature": "Rnd a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:rndToAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "saveServer",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action-ActionClass.html#saveServer",
          "type": "method"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "saveServer",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Server",
          "signature": "m()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:saveServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendPingAI",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#sendPingAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendPingAI",
          "normalized": "FactionId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ping AI",
          "signature": "FactionId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:sendPingAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendPingUI",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#sendPingUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendPingUI",
          "normalized": "FactionId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ping UI",
          "signature": "FactionId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:sendPingUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendQueryAI",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e ActorId -\u003e m CmdTakeTimeSer",
          "source": "src/Game-LambdaHack-Server-Action.html#sendQueryAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendQueryAI",
          "normalized": "FactionId-\u003eActorId-\u003ea CmdTakeTimeSer",
          "package": "LambdaHack",
          "partial": "Query AI",
          "signature": "FactionId-\u003eActorId-\u003em CmdTakeTimeSer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:sendQueryAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendQueryUI",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e ActorId -\u003e m CmdSer",
          "source": "src/Game-LambdaHack-Server-Action.html#sendQueryUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendQueryUI",
          "normalized": "FactionId-\u003eActorId-\u003ea CmdSer",
          "package": "LambdaHack",
          "partial": "Query UI",
          "signature": "FactionId-\u003eActorId-\u003em CmdSer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:sendQueryUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendUpdateAI",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e CmdClientAI -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#sendUpdateAI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendUpdateAI",
          "normalized": "FactionId-\u003eCmdClientAI-\u003ea()",
          "package": "LambdaHack",
          "partial": "Update AI",
          "signature": "FactionId-\u003eCmdClientAI-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:sendUpdateAI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendUpdateUI",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e CmdClientUI -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#sendUpdateUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "sendUpdateUI",
          "normalized": "FactionId-\u003eCmdClientUI-\u003ea()",
          "package": "LambdaHack",
          "partial": "Update UI",
          "signature": "FactionId-\u003eCmdClientUI-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:sendUpdateUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute and insert auxiliary optimized components into game content,\n to be used in time-critical sections of the code.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "speedupCOps",
          "package": "LambdaHack",
          "signature": "Bool -\u003e COps -\u003e COps",
          "source": "src/Game-LambdaHack-Server-Action.html#speedupCOps",
          "type": "function"
        },
        "index": {
          "description": "Compute and insert auxiliary optimized components into game content to be used in time-critical sections of the code",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "speedupCOps",
          "normalized": "Bool-\u003eCOps-\u003eCOps",
          "package": "LambdaHack",
          "partial": "COps",
          "signature": "Bool-\u003eCOps-\u003eCOps",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:speedupCOps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "tellAllClipPS",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#tellAllClipPS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "tellAllClipPS",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "All Clip PS",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:tellAllClipPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "tellGameClipPS",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#tellGameClipPS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "tellGameClipPS",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Game Clip PS",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:tellGameClipPS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Action",
          "name": "tryRestore",
          "package": "LambdaHack",
          "signature": "COps -\u003e DebugModeSer -\u003e m (Maybe (State, StateServer))",
          "source": "src/Game-LambdaHack-Server-Action.html#tryRestore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "tryRestore",
          "normalized": "COps-\u003eDebugModeSer-\u003ea(Maybe(State,StateServer))",
          "package": "LambdaHack",
          "partial": "Restore",
          "signature": "COps-\u003eDebugModeSer-\u003em(Maybe(State,StateServer))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:tryRestore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate connections to the new definition of factions.\n Connect to clients in old or newly spawned threads\n that read and write directly to the channels.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Action",
          "name": "updateConn",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e ChanFrontend -\u003e ChanServer CmdClientUI CmdSer -\u003e IO ()) -\u003e (FactionId -\u003e ChanServer CmdClientAI CmdTakeTimeSer -\u003e IO ()) -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-Action.html#updateConn",
          "type": "function"
        },
        "index": {
          "description": "Update connections to the new definition of factions Connect to clients in old or newly spawned threads that read and write directly to the channels",
          "hierarchy": "Game LambdaHack Server Action",
          "module": "Game.LambdaHack.Server.Action",
          "name": "updateConn",
          "normalized": "(FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003ea()",
          "package": "LambdaHack",
          "partial": "Conn",
          "signature": "(FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Action.html#v:updateConn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSending atomic commands to clients and executing them on the server.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.AtomicSemSer",
          "name": "AtomicSemSer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-AtomicSemSer.html",
          "type": "module"
        },
        "index": {
          "description": "Sending atomic commands to clients and executing them on the server See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Server AtomicSemSer",
          "module": "Game.LambdaHack.Server.AtomicSemSer",
          "name": "AtomicSemSer",
          "package": "LambdaHack",
          "partial": "Atomic Sem Ser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-AtomicSemSer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend an atomic action to all clients that can see it.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.AtomicSemSer",
          "name": "atomicSendSem",
          "package": "LambdaHack",
          "signature": "Atomic -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-AtomicSemSer.html#atomicSendSem",
          "type": "function"
        },
        "index": {
          "description": "Send an atomic action to all clients that can see it",
          "hierarchy": "Game LambdaHack Server AtomicSemSer",
          "module": "Game.LambdaHack.Server.AtomicSemSer",
          "name": "atomicSendSem",
          "normalized": "Atomic-\u003ea()",
          "package": "LambdaHack",
          "partial": "Send Sem",
          "signature": "Atomic-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-AtomicSemSer.html#v:atomicSendSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRectangular areas of levels and their basic operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "Area",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Area.html",
          "type": "module"
        },
        "index": {
          "description": "Rectangular areas of levels and their basic operations",
          "hierarchy": "Game LambdaHack Server DungeonGen Area",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "Area",
          "package": "LambdaHack",
          "partial": "Area",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Area.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of areas. The bottom left and the top right points.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "Area",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Area.html#Area",
          "type": "data"
        },
        "index": {
          "description": "The type of areas The bottom left and the top right points",
          "hierarchy": "Game LambdaHack Server DungeonGen Area",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "Area",
          "package": "LambdaHack",
          "partial": "Area",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Area.html#t:Area"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "fromArea",
          "package": "LambdaHack",
          "signature": "Area -\u003e (X, Y, X, Y)",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Area.html#fromArea",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Area",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "fromArea",
          "normalized": "Area-\u003e(X,Y,X,Y)",
          "package": "LambdaHack",
          "partial": "Area",
          "signature": "Area-\u003e(X,Y,X,Y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Area.html#v:fromArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide uniformly a larger area into the given number of smaller areas\n overlapping at the edges.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "grid",
          "package": "LambdaHack",
          "signature": "(X, Y) -\u003e Area -\u003e [(Point, Area)]",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Area.html#grid",
          "type": "function"
        },
        "index": {
          "description": "Divide uniformly larger area into the given number of smaller areas overlapping at the edges",
          "hierarchy": "Game LambdaHack Server DungeonGen Area",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "grid",
          "normalized": "(X,Y)-\u003eArea-\u003e[(Point,Area)]",
          "package": "LambdaHack",
          "signature": "(X,Y)-\u003eArea-\u003e[(Point,Area)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Area.html#v:grid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnlarge (or shrink) the given area on all fours sides by the amount.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "shrink",
          "package": "LambdaHack",
          "signature": "Area -\u003e Maybe Area",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Area.html#shrink",
          "type": "function"
        },
        "index": {
          "description": "Enlarge or shrink the given area on all fours sides by the amount",
          "hierarchy": "Game LambdaHack Server DungeonGen Area",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "shrink",
          "normalized": "Area-\u003eMaybe Area",
          "package": "LambdaHack",
          "signature": "Area-\u003eMaybe Area",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Area.html#v:shrink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if it's an area with at least one field.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "toArea",
          "package": "LambdaHack",
          "signature": "(X, Y, X, Y) -\u003e Maybe Area",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Area.html#toArea",
          "type": "function"
        },
        "index": {
          "description": "Checks if it an area with at least one field",
          "hierarchy": "Game LambdaHack Server DungeonGen Area",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "toArea",
          "normalized": "(X,Y,X,Y)-\u003eMaybe Area",
          "package": "LambdaHack",
          "partial": "Area",
          "signature": "(X,Y,X,Y)-\u003eMaybe Area",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Area.html#v:toArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "trivialArea",
          "package": "LambdaHack",
          "signature": "Point -\u003e Area",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Area.html#trivialArea",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Area",
          "module": "Game.LambdaHack.Server.DungeonGen.Area",
          "name": "trivialArea",
          "normalized": "Point-\u003eArea",
          "package": "LambdaHack",
          "partial": "Area",
          "signature": "Point-\u003eArea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Area.html#v:trivialArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOperations on the \u003ccode\u003e\u003ca\u003eArea\u003c/a\u003e\u003c/code\u003e type that involve random numbers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "AreaRnd",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-AreaRnd.html",
          "type": "module"
        },
        "index": {
          "description": "Operations on the Area type that involve random numbers",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "AreaRnd",
          "package": "LambdaHack",
          "partial": "Area Rnd",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe coordinates of consecutive fields of a corridor.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "Corridor",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#Corridor",
          "type": "type"
        },
        "index": {
          "description": "The coordinates of consecutive fields of corridor",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "Corridor",
          "package": "LambdaHack",
          "partial": "Corridor",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#t:Corridor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePick a subset of connections between adjacent areas within a grid until\n there is only one connected component in the graph of all areas.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "connectGrid",
          "package": "LambdaHack",
          "signature": "(X, Y) -\u003e Rnd [(Point, Point)]",
          "source": "src/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#connectGrid",
          "type": "function"
        },
        "index": {
          "description": "Pick subset of connections between adjacent areas within grid until there is only one connected component in the graph of all areas",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "connectGrid",
          "normalized": "(X,Y)-\u003eRnd[(Point,Point)]",
          "package": "LambdaHack",
          "partial": "Grid",
          "signature": "(X,Y)-\u003eRnd[(Point,Point)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#v:connectGrid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to connect two interiors of places with a corridor.\n Choose entrances at least 4 or 3 tiles distant from the edges, if the place\n is big enough. Note that with \u003ccode\u003epfence == FNone\u003c/code\u003e, the area considered\n is the strict interior of the place, without the outermost tiles.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "connectPlaces",
          "package": "LambdaHack",
          "signature": "(Area, Area) -\u003e (Area, Area) -\u003e Rnd Corridor",
          "source": "src/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#connectPlaces",
          "type": "function"
        },
        "index": {
          "description": "Try to connect two interiors of places with corridor Choose entrances at least or tiles distant from the edges if the place is big enough Note that with pfence FNone the area considered is the strict interior of the place without the outermost tiles",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "connectPlaces",
          "normalized": "(Area,Area)-\u003e(Area,Area)-\u003eRnd Corridor",
          "package": "LambdaHack",
          "partial": "Places",
          "signature": "(Area,Area)-\u003e(Area,Area)-\u003eRnd Corridor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#v:connectPlaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a random room according to given parameters.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "mkRoom",
          "package": "LambdaHack",
          "signature": "(X, Y)-\u003e (X, Y)-\u003e Area-\u003e Rnd Area",
          "type": "function"
        },
        "index": {
          "description": "Create random room according to given parameters",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "mkRoom",
          "normalized": "(X,Y)-\u003e(X,Y)-\u003eArea-\u003eRnd Area",
          "package": "LambdaHack",
          "partial": "Room",
          "signature": "(X,Y)-\u003e(X,Y)-\u003eArea-\u003eRnd Area",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#v:mkRoom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a void room, i.e., a single point area within the designated area.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "mkVoidRoom",
          "package": "LambdaHack",
          "signature": "Area -\u003e Rnd Area",
          "source": "src/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#mkVoidRoom",
          "type": "function"
        },
        "index": {
          "description": "Create void room i.e single point area within the designated area",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "mkVoidRoom",
          "normalized": "Area-\u003eRnd Area",
          "package": "LambdaHack",
          "partial": "Void Room",
          "signature": "Area-\u003eRnd Area",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#v:mkVoidRoom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePick a single random connection between adjacent areas within a grid.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "randomConnection",
          "package": "LambdaHack",
          "signature": "(X, Y) -\u003e Rnd (Point, Point)",
          "source": "src/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#randomConnection",
          "type": "function"
        },
        "index": {
          "description": "Pick single random connection between adjacent areas within grid",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "randomConnection",
          "normalized": "(X,Y)-\u003eRnd(Point,Point)",
          "package": "LambdaHack",
          "partial": "Connection",
          "signature": "(X,Y)-\u003eRnd(Point,Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#v:randomConnection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePick a random point within an area.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "xyInArea",
          "package": "LambdaHack",
          "signature": "Area -\u003e Rnd Point",
          "source": "src/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#xyInArea",
          "type": "function"
        },
        "index": {
          "description": "Pick random point within an area",
          "hierarchy": "Game LambdaHack Server DungeonGen AreaRnd",
          "module": "Game.LambdaHack.Server.DungeonGen.AreaRnd",
          "name": "xyInArea",
          "normalized": "Area-\u003eRnd Point",
          "package": "LambdaHack",
          "partial": "In Area",
          "signature": "Area-\u003eRnd Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-AreaRnd.html#v:xyInArea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneration of caves (not yet inhabited dungeon levels) from cave kinds.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "Cave",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Cave.html",
          "type": "module"
        },
        "index": {
          "description": "Generation of caves not yet inhabited dungeon levels from cave kinds",
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "Cave",
          "package": "LambdaHack",
          "partial": "Cave",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of caves (not yet inhabited dungeon levels).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "Cave",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Cave.html#Cave",
          "type": "data"
        },
        "index": {
          "description": "The type of caves not yet inhabited dungeon levels",
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "Cave",
          "package": "LambdaHack",
          "partial": "Cave",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#t:Cave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "Cave",
          "package": "LambdaHack",
          "signature": "Cave",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Cave.html#Cave",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "Cave",
          "package": "LambdaHack",
          "partial": "Cave",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#v:Cave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCave generation by an algorithm inspired by the original Rogue,\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "buildCave",
          "package": "LambdaHack",
          "signature": "COps-\u003e Int-\u003e Int-\u003e Id CaveKind-\u003e Rnd Cave",
          "type": "function"
        },
        "index": {
          "description": "Cave generation by an algorithm inspired by the original Rogue",
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "buildCave",
          "normalized": "COps-\u003eInt-\u003eInt-\u003eId CaveKind-\u003eRnd Cave",
          "package": "LambdaHack",
          "partial": "Cave",
          "signature": "COps-\u003eInt-\u003eInt-\u003eId CaveKind-\u003eRnd Cave",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#v:buildCave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe kind of the cave\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dkind",
          "package": "LambdaHack",
          "signature": "(Id CaveKind)",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Cave.html#Cave",
          "type": "function"
        },
        "index": {
          "description": "the kind of the cave",
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dkind",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#v:dkind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etile kinds in the cave\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dmap",
          "package": "LambdaHack",
          "signature": "TileMapEM",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Cave.html#Cave",
          "type": "function"
        },
        "index": {
          "description": "tile kinds in the cave",
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dmap",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#v:dmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewhether the cave is dark\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dnight",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Cave.html#Cave",
          "type": "function"
        },
        "index": {
          "description": "whether the cave is dark",
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dnight",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#v:dnight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplaces generated in the cave\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dplaces",
          "package": "LambdaHack",
          "signature": "[Place]",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Cave.html#Cave",
          "type": "function"
        },
        "index": {
          "description": "places generated in the cave",
          "hierarchy": "Game LambdaHack Server DungeonGen Cave",
          "module": "Game.LambdaHack.Server.DungeonGen.Cave",
          "name": "dplaces",
          "normalized": "[Place]",
          "package": "LambdaHack",
          "signature": "[Place]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Cave.html#v:dplaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneration of places from place kinds.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "Place",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html",
          "type": "module"
        },
        "index": {
          "description": "Generation of places from place kinds",
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "Place",
          "package": "LambdaHack",
          "partial": "Place",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parameters of a place. Most are immutable and set\n at the time when a place is generated.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "Place",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "data"
        },
        "index": {
          "description": "The parameters of place Most are immutable and set at the time when place is generated",
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "Place",
          "package": "LambdaHack",
          "partial": "Place",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#t:Place"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe map of tile kinds in a place (and generally anywhere in a cave).\n The map is sparse. The default tile that eventually fills the empty spaces\n is specified in the cave kind specification with \u003ccode\u003ecdefTile\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "TileMapEM",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#TileMapEM",
          "type": "type"
        },
        "index": {
          "description": "The map of tile kinds in place and generally anywhere in cave The map is sparse The default tile that eventually fills the empty spaces is specified in the cave kind specification with cdefTile",
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "TileMapEM",
          "package": "LambdaHack",
          "partial": "Tile Map EM",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#t:TileMapEM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "Place",
          "package": "LambdaHack",
          "signature": "Place",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "Place",
          "package": "LambdaHack",
          "partial": "Place",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:Place"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a fence around an area, with the given tile group.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "buildFenceRnd",
          "package": "LambdaHack",
          "signature": "COps -\u003e Text -\u003e Area -\u003e Rnd TileMapEM",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#buildFenceRnd",
          "type": "function"
        },
        "index": {
          "description": "Construct fence around an area with the given tile group",
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "buildFenceRnd",
          "normalized": "COps-\u003eText-\u003eArea-\u003eRnd TileMapEM",
          "package": "LambdaHack",
          "partial": "Fence Rnd",
          "signature": "COps-\u003eText-\u003eArea-\u003eRnd TileMapEM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:buildFenceRnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a few parameters, roll and construct a \u003ccode\u003e\u003ca\u003ePlace\u003c/a\u003e\u003c/code\u003e datastructure\n and fill a cave section acccording to it.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "buildPlace",
          "package": "LambdaHack",
          "signature": "COps-\u003e CaveKind-\u003e Bool-\u003e Id TileKind-\u003e Id TileKind-\u003e Int-\u003e Int-\u003e Area-\u003e Rnd (TileMapEM, Place)",
          "type": "function"
        },
        "index": {
          "description": "Given few parameters roll and construct Place datastructure and fill cave section acccording to it",
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "buildPlace",
          "normalized": "COps-\u003eCaveKind-\u003eBool-\u003eId TileKind-\u003eId TileKind-\u003eInt-\u003eInt-\u003eArea-\u003eRnd(TileMapEM,Place)",
          "package": "LambdaHack",
          "partial": "Place",
          "signature": "COps-\u003eCaveKind-\u003eBool-\u003eId TileKind-\u003eId TileKind-\u003eInt-\u003eInt-\u003eArea-\u003eRnd(TileMapEM,Place)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:buildPlace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor \u003ccode\u003eCAlternate\u003c/code\u003e tiling, require the place be comprised\n of an even number of whole corners, with exactly one square\n overlap between consecutive coners and no trimming.\n For other tiling methods, check that the area is large enough for tiling\n the corner twice in each direction, with a possible one row/column overlap.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "placeCheck",
          "package": "LambdaHack",
          "signature": "Area-\u003e PlaceKind-\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "For CAlternate tiling require the place be comprised of an even number of whole corners with exactly one square overlap between consecutive coners and no trimming For other tiling methods check that the area is large enough for tiling the corner twice in each direction with possible one row column overlap",
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "placeCheck",
          "normalized": "Area-\u003ePlaceKind-\u003eBool",
          "package": "LambdaHack",
          "partial": "Check",
          "signature": "Area-\u003ePlaceKind-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:placeCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qarea",
          "package": "LambdaHack",
          "signature": "Area",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qarea",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:qarea"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qhollowFence",
          "package": "LambdaHack",
          "signature": "(Id TileKind)",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qhollowFence",
          "package": "LambdaHack",
          "partial": "Fence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:qhollowFence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qkind",
          "package": "LambdaHack",
          "signature": "(Id PlaceKind)",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qkind",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:qkind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qlegend",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qlegend",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:qlegend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qseen",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qseen",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:qseen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qsolidFence",
          "package": "LambdaHack",
          "signature": "(Id TileKind)",
          "source": "src/Game-LambdaHack-Server-DungeonGen-Place.html#Place",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen Place",
          "module": "Game.LambdaHack.Server.DungeonGen.Place",
          "name": "qsolidFence",
          "package": "LambdaHack",
          "partial": "Fence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen-Place.html#v:qsolidFence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe main dungeon generation routine.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "DungeonGen",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen.html",
          "type": "module"
        },
        "index": {
          "description": "The main dungeon generation routine",
          "hierarchy": "Game LambdaHack Server DungeonGen",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "DungeonGen",
          "package": "LambdaHack",
          "partial": "Dungeon Gen",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFreshly generated and not yet populated dungeon.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "FreshDungeon",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-DungeonGen.html#FreshDungeon",
          "type": "data"
        },
        "index": {
          "description": "Freshly generated and not yet populated dungeon",
          "hierarchy": "Game LambdaHack Server DungeonGen",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "FreshDungeon",
          "package": "LambdaHack",
          "partial": "Fresh Dungeon",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen.html#t:FreshDungeon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "FreshDungeon",
          "package": "LambdaHack",
          "signature": "FreshDungeon",
          "source": "src/Game-LambdaHack-Server-DungeonGen.html#FreshDungeon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server DungeonGen",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "FreshDungeon",
          "package": "LambdaHack",
          "partial": "Fresh Dungeon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen.html#v:FreshDungeon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate the dungeon for a new game.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "dungeonGen",
          "package": "LambdaHack",
          "signature": "COps -\u003e Caves -\u003e Rnd FreshDungeon",
          "source": "src/Game-LambdaHack-Server-DungeonGen.html#dungeonGen",
          "type": "function"
        },
        "index": {
          "description": "Generate the dungeon for new game",
          "hierarchy": "Game LambdaHack Server DungeonGen",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "dungeonGen",
          "normalized": "COps-\u003eCaves-\u003eRnd FreshDungeon",
          "package": "LambdaHack",
          "partial": "Gen",
          "signature": "COps-\u003eCaves-\u003eRnd FreshDungeon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen.html#v:dungeonGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edungeon depth (can be different than size)\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "freshDepth",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Server-DungeonGen.html#FreshDungeon",
          "type": "function"
        },
        "index": {
          "description": "dungeon depth can be different than size",
          "hierarchy": "Game LambdaHack Server DungeonGen",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "freshDepth",
          "package": "LambdaHack",
          "partial": "Depth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen.html#v:freshDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaps for all levels\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "freshDungeon",
          "package": "LambdaHack",
          "signature": "Dungeon",
          "source": "src/Game-LambdaHack-Server-DungeonGen.html#FreshDungeon",
          "type": "function"
        },
        "index": {
          "description": "maps for all levels",
          "hierarchy": "Game LambdaHack Server DungeonGen",
          "module": "Game.LambdaHack.Server.DungeonGen",
          "name": "freshDungeon",
          "package": "LambdaHack",
          "partial": "Dungeon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-DungeonGen.html#v:freshDungeon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEffect semantics.\n TODO: document\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "EffectSem",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-EffectSem.html",
          "type": "module"
        },
        "index": {
          "description": "Effect semantics TODO document",
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "EffectSem",
          "package": "LambdaHack",
          "partial": "Effect Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new hero on the current level, close to the given position.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "addHero",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e Point -\u003e LevelId -\u003e [(Int, Text)] -\u003e Maybe Int -\u003e Time -\u003e m ActorId",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#addHero",
          "type": "function"
        },
        "index": {
          "description": "Create new hero on the current level close to the given position",
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "addHero",
          "normalized": "FactionId-\u003ePoint-\u003eLevelId-\u003e[(Int,Text)]-\u003eMaybe Int-\u003eTime-\u003ea ActorId",
          "package": "LambdaHack",
          "partial": "Hero",
          "signature": "FactionId-\u003ePoint-\u003eLevelId-\u003e[(Int,Text)]-\u003eMaybe Int-\u003eTime-\u003em ActorId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:addHero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "createItems",
          "package": "LambdaHack",
          "signature": "Int -\u003e Point -\u003e LevelId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#createItems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "createItems",
          "normalized": "Int-\u003ePoint-\u003eLevelId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Items",
          "signature": "Int-\u003ePoint-\u003eLevelId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:createItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "deduceKilled",
          "package": "LambdaHack",
          "signature": "Actor -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#deduceKilled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "deduceKilled",
          "normalized": "Actor-\u003ea()",
          "package": "LambdaHack",
          "partial": "Killed",
          "signature": "Actor-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:deduceKilled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe source actor affects the target actor, with a given effect and power.\n Both actors are on the current level and can be the same actor.\n The boolean result indicates if the effect was spectacular enough\n for the actors to identify it (and the item that caused it, if any).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "effectSem",
          "package": "LambdaHack",
          "signature": "Effect Int -\u003e ActorId -\u003e ActorId -\u003e m Bool",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#effectSem",
          "type": "function"
        },
        "index": {
          "description": "The source actor affects the target actor with given effect and power Both actors are on the current level and can be the same actor The boolean result indicates if the effect was spectacular enough for the actors to identify it and the item that caused it if any",
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "effectSem",
          "normalized": "Effect Int-\u003eActorId-\u003eActorId-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "Sem",
          "signature": "Effect Int-\u003eActorId-\u003eActorId-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:effectSem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "electLeader",
          "package": "LambdaHack",
          "signature": "FactionId -\u003e LevelId -\u003e ActorId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#electLeader",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "electLeader",
          "normalized": "FactionId-\u003eLevelId-\u003eActorId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Leader",
          "signature": "FactionId-\u003eLevelId-\u003eActorId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:electLeader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe source actor affects the target actor, with a given item.\n If the event is seen, the item may get identified. This function\n is mutually recursive with \u003ccode\u003eeffect\u003c/code\u003e and so it's a part of \u003ccode\u003eEffect\u003c/code\u003e\n semantics.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "itemEffect",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e ActorId -\u003e Maybe ItemId -\u003e Item -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#itemEffect",
          "type": "function"
        },
        "index": {
          "description": "The source actor affects the target actor with given item If the event is seen the item may get identified This function is mutually recursive with effect and so it part of Effect semantics",
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "itemEffect",
          "normalized": "ActorId-\u003eActorId-\u003eMaybe ItemId-\u003eItem-\u003ea()",
          "package": "LambdaHack",
          "partial": "Effect",
          "signature": "ActorId-\u003eActorId-\u003eMaybe ItemId-\u003eItem-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:itemEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "registerItem",
          "package": "LambdaHack",
          "signature": "Item -\u003e Int -\u003e Container -\u003e Bool -\u003e m ItemId",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#registerItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "registerItem",
          "normalized": "Item-\u003eInt-\u003eContainer-\u003eBool-\u003ea ItemId",
          "package": "LambdaHack",
          "partial": "Item",
          "signature": "Item-\u003eInt-\u003eContainer-\u003eBool-\u003em ItemId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:registerItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpawn non-hero actors of any faction, friendly or not.\n To be used for initial dungeon population, spontaneous spawning\n of monsters and for the summon effect.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "spawnMonsters",
          "package": "LambdaHack",
          "signature": "[Point] -\u003e LevelId -\u003e Time -\u003e FactionId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-EffectSem.html#spawnMonsters",
          "type": "function"
        },
        "index": {
          "description": "Spawn non-hero actors of any faction friendly or not To be used for initial dungeon population spontaneous spawning of monsters and for the summon effect",
          "hierarchy": "Game LambdaHack Server EffectSem",
          "module": "Game.LambdaHack.Server.EffectSem",
          "name": "spawnMonsters",
          "normalized": "[Point]-\u003eLevelId-\u003eTime-\u003eFactionId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Monsters",
          "signature": "[Point]-\u003eLevelId-\u003eTime-\u003eFactionId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-EffectSem.html#v:spawnMonsters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCommon definitions for the Field of View algorithms.\n See \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Fov-and-los\u003c/a\u003e\n for some more context and references.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Common",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html",
          "type": "module"
        },
        "index": {
          "description": "Common definitions for the Field of View algorithms See https github.com kosmikus LambdaHack wiki Fov-and-los for some more context and references",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Common",
          "package": "LambdaHack",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotated and translated coordinates of 2D points, so that the points fit\n in a single quadrant area (e, g., quadrant I for Permissive FOV, hence both\n coordinates positive; adjacent diagonal halves of quadrant I and II\n for Digital FOV, hence y positive).\n The special coordinates are written using the standard mathematical\n coordinate setup, where quadrant I, with x and y positive,\n is on the upper right.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Bump",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Bump",
          "type": "data"
        },
        "index": {
          "description": "Rotated and translated coordinates of points so that the points fit in single quadrant area quadrant for Permissive FOV hence both coordinates positive adjacent diagonal halves of quadrant and II for Digital FOV hence positive The special coordinates are written using the standard mathematical coordinate setup where quadrant with and positive is on the upper right",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Bump",
          "package": "LambdaHack",
          "partial": "Bump",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#t:Bump"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvex hull represented as a list of points.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "ConvexHull",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#ConvexHull",
          "type": "type"
        },
        "index": {
          "description": "Convex hull represented as list of points",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "ConvexHull",
          "package": "LambdaHack",
          "partial": "Convex Hull",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#t:ConvexHull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistance from the (0, 0) point where FOV originates.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Distance",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Distance",
          "type": "type"
        },
        "index": {
          "description": "Distance from the point where FOV originates",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Distance",
          "package": "LambdaHack",
          "partial": "Distance",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#t:Distance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn edge (comprising of a line and a convex hull)\n of the area to be scanned.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Edge",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Edge",
          "type": "type"
        },
        "index": {
          "description": "An edge comprising of line and convex hull of the area to be scanned",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Edge",
          "package": "LambdaHack",
          "partial": "Edge",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#t:Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe area left to be scanned, delimited by edges.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "EdgeInterval",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#EdgeInterval",
          "type": "type"
        },
        "index": {
          "description": "The area left to be scanned delimited by edges",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "EdgeInterval",
          "package": "LambdaHack",
          "partial": "Edge Interval",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#t:EdgeInterval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStraight line between points.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Line",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Line",
          "type": "data"
        },
        "index": {
          "description": "Straight line between points",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Line",
          "package": "LambdaHack",
          "partial": "Line",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#t:Line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProgress along an arc with a constant distance from (0, 0).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Progress",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Progress",
          "type": "type"
        },
        "index": {
          "description": "Progress along an arc with constant distance from",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Progress",
          "package": "LambdaHack",
          "partial": "Progress",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#t:Progress"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "B",
          "package": "LambdaHack",
          "signature": "B",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Bump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "B",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#v:B"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Line",
          "package": "LambdaHack",
          "signature": "Line !Bump !Bump",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Line",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "Line",
          "package": "LambdaHack",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#v:Line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtends a convex hull of bumps with a new bump. Nothing needs to be done\n if the new bump already lies within the hull. The first argument is\n typically \u003ccode\u003e\u003ca\u003esteeper\u003c/a\u003e\u003c/code\u003e, optionally negated, applied to the second argument.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "addHull",
          "package": "LambdaHack",
          "signature": "(Bump -\u003e Bump -\u003e Bool)-\u003e Bump-\u003e ConvexHull-\u003e ConvexHull",
          "type": "function"
        },
        "index": {
          "description": "Extends convex hull of bumps with new bump Nothing needs to be done if the new bump already lies within the hull The first argument is typically steeper optionally negated applied to the second argument",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "addHull",
          "normalized": "(Bump-\u003eBump-\u003eBool)-\u003eBump-\u003eConvexHull-\u003eConvexHull",
          "package": "LambdaHack",
          "partial": "Hull",
          "signature": "(Bump-\u003eBump-\u003eBool)-\u003eBump-\u003eConvexHull-\u003eConvexHull",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#v:addHull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "bx",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Bump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "bx",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#v:bx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "by",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#Bump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "by",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#v:by"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximal element of a non-empty list. Prefers elements from the rear,\n which is essential for PFOV, to avoid ill-defined lines.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "maximal",
          "package": "LambdaHack",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e a",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#maximal",
          "type": "function"
        },
        "index": {
          "description": "Maximal element of non-empty list Prefers elements from the rear which is essential for PFOV to avoid ill-defined lines",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "maximal",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003ea",
          "package": "LambdaHack",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#v:maximal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the line from the second point to the first is more steep\n than the line from the third point to the first. This is related\n to the formal notion of gradient (or angle), but hacked wrt signs\n to work fast in this particular setup. Returns True for ill-defined lines.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "steeper",
          "package": "LambdaHack",
          "signature": "Bump -\u003e Bump -\u003e Bump -\u003e Bool",
          "source": "src/Game-LambdaHack-Server-Fov-Common.html#steeper",
          "type": "function"
        },
        "index": {
          "description": "Check if the line from the second point to the first is more steep than the line from the third point to the first This is related to the formal notion of gradient or angle but hacked wrt signs to work fast in this particular setup Returns True for ill-defined lines",
          "hierarchy": "Game LambdaHack Server Fov Common",
          "module": "Game.LambdaHack.Server.Fov.Common",
          "name": "steeper",
          "normalized": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "package": "LambdaHack",
          "signature": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Common.html#v:steeper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDFOV (Digital Field of View) implemented according to specification at \u003ca\u003ehttp://roguebasin.roguelikedevelopment.org/index.php?title=Digital_field_of_view_implementation\u003c/a\u003e.\n This fast version of the algorithm, based on \u003ca\u003ePFOV\u003c/a\u003e, has AFAIK\n never been described nor implemented before.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "Digital",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Digital.html",
          "type": "module"
        },
        "index": {
          "description": "DFOV Digital Field of View implemented according to specification at http roguebasin.roguelikedevelopment.org index.php title Digital field of view implementation This fast version of the algorithm based on PFOV has AFAIK never been described nor implemented before",
          "hierarchy": "Game LambdaHack Server Fov Digital",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "Digital",
          "package": "LambdaHack",
          "partial": "Digital",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Digital.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebug: check if a view border line for DFOV is legal.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "debugLine",
          "package": "LambdaHack",
          "signature": "Line -\u003e (Bool, String)",
          "source": "src/Game-LambdaHack-Server-Fov-Digital.html#debugLine",
          "type": "function"
        },
        "index": {
          "description": "Debug check if view border line for DFOV is legal",
          "hierarchy": "Game LambdaHack Server Fov Digital",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "debugLine",
          "normalized": "Line-\u003e(Bool,String)",
          "package": "LambdaHack",
          "partial": "Line",
          "signature": "Line-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Digital.html#v:debugLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebug functions for DFOV:\n\u003c/p\u003e\u003cp\u003eDebug: calculate steeper for DFOV in another way and compare results.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "debugSteeper",
          "package": "LambdaHack",
          "signature": "Bump -\u003e Bump -\u003e Bump -\u003e Bool",
          "source": "src/Game-LambdaHack-Server-Fov-Digital.html#debugSteeper",
          "type": "function"
        },
        "index": {
          "description": "Debug functions for DFOV Debug calculate steeper for DFOV in another way and compare results",
          "hierarchy": "Game LambdaHack Server Fov Digital",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "debugSteeper",
          "normalized": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "package": "LambdaHack",
          "partial": "Steeper",
          "signature": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Digital.html#v:debugSteeper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a line from two points. Debug: check if well-defined.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "dline",
          "package": "LambdaHack",
          "signature": "Bump -\u003e Bump -\u003e Line",
          "source": "src/Game-LambdaHack-Server-Fov-Digital.html#dline",
          "type": "function"
        },
        "index": {
          "description": "Create line from two points Debug check if well-defined",
          "hierarchy": "Game LambdaHack Server Fov Digital",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "dline",
          "normalized": "Bump-\u003eBump-\u003eLine",
          "package": "LambdaHack",
          "signature": "Bump-\u003eBump-\u003eLine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Digital.html#v:dline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare steepness of \u003ccode\u003e(p1, f)\u003c/code\u003e and \u003ccode\u003e(p2, f)\u003c/code\u003e.\n Debug: Verify that the results of 2 independent checks are equal.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "dsteeper",
          "package": "LambdaHack",
          "signature": "Bump -\u003e Bump -\u003e Bump -\u003e Bool",
          "source": "src/Game-LambdaHack-Server-Fov-Digital.html#dsteeper",
          "type": "function"
        },
        "index": {
          "description": "Compare steepness of p1 and p2 Debug Verify that the results of independent checks are equal",
          "hierarchy": "Game LambdaHack Server Fov Digital",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "dsteeper",
          "normalized": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "package": "LambdaHack",
          "signature": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Digital.html#v:dsteeper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe X coordinate, represented as a fraction, of the intersection of\n a given line and the line of diagonals of diamonds at distance\n \u003ccode\u003ed\u003c/code\u003e from (0, 0).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "intersect",
          "package": "LambdaHack",
          "signature": "Line -\u003e Distance -\u003e (Int, Int)",
          "source": "src/Game-LambdaHack-Server-Fov-Digital.html#intersect",
          "type": "function"
        },
        "index": {
          "description": "The coordinate represented as fraction of the intersection of given line and the line of diagonals of diamonds at distance from",
          "hierarchy": "Game LambdaHack Server Fov Digital",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "intersect",
          "normalized": "Line-\u003eDistance-\u003e(Int,Int)",
          "package": "LambdaHack",
          "signature": "Line-\u003eDistance-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Digital.html#v:intersect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculates the list of tiles, in \u003ccode\u003eBump\u003c/code\u003e coordinates, visible from (0, 0),\n within the given sight range.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "scan",
          "package": "LambdaHack",
          "signature": "Distance-\u003e (Bump -\u003e Bool)-\u003e [Bump]",
          "type": "function"
        },
        "index": {
          "description": "Calculates the list of tiles in Bump coordinates visible from within the given sight range",
          "hierarchy": "Game LambdaHack Server Fov Digital",
          "module": "Game.LambdaHack.Server.Fov.Digital",
          "name": "scan",
          "normalized": "Distance-\u003e(Bump-\u003eBool)-\u003e[Bump]",
          "package": "LambdaHack",
          "signature": "Distance-\u003e(Bump-\u003eBool)-\u003e[Bump]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Digital.html#v:scan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePFOV (Permissive Field of View) clean-room reimplemented based on the algorithm described in \u003ca\u003ehttp://roguebasin.roguelikedevelopment.org/index.php?title=Precise_Permissive_Field_of_View\u003c/a\u003e,\n though the general structure is more influenced by recursive shadow casting,\n as implemented in Shadow.hs. In the result, this algorithm is much faster\n than the original algorithm on dense maps, since it does not scan\n areas blocked by shadows.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "Permissive",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Permissive.html",
          "type": "module"
        },
        "index": {
          "description": "PFOV Permissive Field of View clean-room reimplemented based on the algorithm described in http roguebasin.roguelikedevelopment.org index.php title Precise Permissive Field of View though the general structure is more influenced by recursive shadow casting as implemented in Shadow.hs In the result this algorithm is much faster than the original algorithm on dense maps since it does not scan areas blocked by shadows",
          "hierarchy": "Game LambdaHack Server Fov Permissive",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "Permissive",
          "package": "LambdaHack",
          "partial": "Permissive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Permissive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebug: checks postconditions of borderLine.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "debugLine",
          "package": "LambdaHack",
          "signature": "Line -\u003e (Bool, String)",
          "source": "src/Game-LambdaHack-Server-Fov-Permissive.html#debugLine",
          "type": "function"
        },
        "index": {
          "description": "Debug checks postconditions of borderLine",
          "hierarchy": "Game LambdaHack Server Fov Permissive",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "debugLine",
          "normalized": "Line-\u003e(Bool,String)",
          "package": "LambdaHack",
          "partial": "Line",
          "signature": "Line-\u003e(Bool,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Permissive.html#v:debugLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebug functions for PFOV:\n\u003c/p\u003e\u003cp\u003eDebug: calculate steeper for PFOV in another way and compare results.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "debugSteeper",
          "package": "LambdaHack",
          "signature": "Bump -\u003e Bump -\u003e Bump -\u003e Bool",
          "source": "src/Game-LambdaHack-Server-Fov-Permissive.html#debugSteeper",
          "type": "function"
        },
        "index": {
          "description": "Debug functions for PFOV Debug calculate steeper for PFOV in another way and compare results",
          "hierarchy": "Game LambdaHack Server Fov Permissive",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "debugSteeper",
          "normalized": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "package": "LambdaHack",
          "partial": "Steeper",
          "signature": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Permissive.html#v:debugSteeper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a line from two points. Debug: check if well-defined.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "dline",
          "package": "LambdaHack",
          "signature": "Bump -\u003e Bump -\u003e Line",
          "source": "src/Game-LambdaHack-Server-Fov-Permissive.html#dline",
          "type": "function"
        },
        "index": {
          "description": "Create line from two points Debug check if well-defined",
          "hierarchy": "Game LambdaHack Server Fov Permissive",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "dline",
          "normalized": "Bump-\u003eBump-\u003eLine",
          "package": "LambdaHack",
          "signature": "Bump-\u003eBump-\u003eLine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Permissive.html#v:dline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare steepness of \u003ccode\u003e(p1, f)\u003c/code\u003e and \u003ccode\u003e(p2, f)\u003c/code\u003e.\n Debug: Verify that the results of 2 independent checks are equal.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "dsteeper",
          "package": "LambdaHack",
          "signature": "Bump -\u003e Bump -\u003e Bump -\u003e Bool",
          "source": "src/Game-LambdaHack-Server-Fov-Permissive.html#dsteeper",
          "type": "function"
        },
        "index": {
          "description": "Compare steepness of p1 and p2 Debug Verify that the results of independent checks are equal",
          "hierarchy": "Game LambdaHack Server Fov Permissive",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "dsteeper",
          "normalized": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "package": "LambdaHack",
          "signature": "Bump-\u003eBump-\u003eBump-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Permissive.html#v:dsteeper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Y coordinate, represented as a fraction, of the intersection of\n a given line and the line of diagonals of squares at distance\n \u003ccode\u003ed\u003c/code\u003e from (0, 0).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "intersect",
          "package": "LambdaHack",
          "signature": "Line -\u003e Distance -\u003e (Int, Int)",
          "source": "src/Game-LambdaHack-Server-Fov-Permissive.html#intersect",
          "type": "function"
        },
        "index": {
          "description": "The coordinate represented as fraction of the intersection of given line and the line of diagonals of squares at distance from",
          "hierarchy": "Game LambdaHack Server Fov Permissive",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "intersect",
          "normalized": "Line-\u003eDistance-\u003e(Int,Int)",
          "package": "LambdaHack",
          "signature": "Line-\u003eDistance-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Permissive.html#v:intersect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculates the list of tiles, in \u003ccode\u003eBump\u003c/code\u003e coordinates, visible from (0, 0).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "scan",
          "package": "LambdaHack",
          "signature": "(Bump -\u003e Bool)-\u003e [Bump]",
          "type": "function"
        },
        "index": {
          "description": "Calculates the list of tiles in Bump coordinates visible from",
          "hierarchy": "Game LambdaHack Server Fov Permissive",
          "module": "Game.LambdaHack.Server.Fov.Permissive",
          "name": "scan",
          "normalized": "(Bump-\u003eBool)-\u003e[Bump]",
          "package": "LambdaHack",
          "signature": "(Bump-\u003eBool)-\u003e[Bump]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Permissive.html#v:scan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA restrictive variant of Recursive Shadow Casting FOV with infinite range.\n It's not designed for dungeons with diagonal walls and so here\n they block visibility, though they don't block movement.\n The main advantage of the algorithm is that it's very simple and fast.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "Shadow",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Shadow.html",
          "type": "module"
        },
        "index": {
          "description": "restrictive variant of Recursive Shadow Casting FOV with infinite range It not designed for dungeons with diagonal walls and so here they block visibility though they don block movement The main advantage of the algorithm is that it very simple and fast",
          "hierarchy": "Game LambdaHack Server Fov Shadow",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "Shadow",
          "package": "LambdaHack",
          "partial": "Shadow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Shadow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe area left to be scanned, delimited by fractions of the original arc.\n Interval \u003ccode\u003e(0, 1)\u003c/code\u003e means the whole 45 degrees arc of the processed octant\n is to be scanned.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "Interval",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Shadow.html#Interval",
          "type": "type"
        },
        "index": {
          "description": "The area left to be scanned delimited by fractions of the original arc Interval means the whole degrees arc of the processed octant is to be scanned",
          "hierarchy": "Game LambdaHack Server Fov Shadow",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "Interval",
          "package": "LambdaHack",
          "partial": "Interval",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Shadow.html#t:Interval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotated and translated coordinates of 2D points, so that they fit\n in the same single octant area.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "SBump",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov-Shadow.html#SBump",
          "type": "type"
        },
        "index": {
          "description": "Rotated and translated coordinates of points so that they fit in the same single octant area",
          "hierarchy": "Game LambdaHack Server Fov Shadow",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "SBump",
          "package": "LambdaHack",
          "partial": "SBump",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Shadow.html#t:SBump"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculates the list of tiles, in \u003ccode\u003eSBump\u003c/code\u003e coordinates, visible from (0, 0).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "scan",
          "package": "LambdaHack",
          "signature": "(SBump -\u003e Bool)-\u003e Distance-\u003e Interval-\u003e [SBump]",
          "type": "function"
        },
        "index": {
          "description": "Calculates the list of tiles in SBump coordinates visible from",
          "hierarchy": "Game LambdaHack Server Fov Shadow",
          "module": "Game.LambdaHack.Server.Fov.Shadow",
          "name": "scan",
          "normalized": "(SBump-\u003eBool)-\u003eDistance-\u003eInterval-\u003e[SBump]",
          "package": "LambdaHack",
          "signature": "(SBump-\u003eBool)-\u003eDistance-\u003eInterval-\u003e[SBump]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov-Shadow.html#v:scan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eField Of View scanning with a variety of algorithms.\n See \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Fov-and-los\u003c/a\u003e\n for discussion.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "Fov",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-Fov.html",
          "type": "module"
        },
        "index": {
          "description": "Field Of View scanning with variety of algorithms See https github.com kosmikus LambdaHack wiki Fov-and-los for discussion",
          "hierarchy": "Game LambdaHack Server Fov",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "Fov",
          "package": "LambdaHack",
          "partial": "Fov",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the perception of the whole dungeon.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "dungeonPerception",
          "package": "LambdaHack",
          "signature": "COps -\u003e FovMode -\u003e State -\u003e Pers",
          "source": "src/Game-LambdaHack-Server-Fov.html#dungeonPerception",
          "type": "function"
        },
        "index": {
          "description": "Calculate the perception of the whole dungeon",
          "hierarchy": "Game LambdaHack Server Fov",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "dungeonPerception",
          "normalized": "COps-\u003eFovMode-\u003eState-\u003ePers",
          "package": "LambdaHack",
          "partial": "Perception",
          "signature": "COps-\u003eFovMode-\u003eState-\u003ePers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov.html#v:dungeonPerception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a full scan for a given position. Returns the positions\n that are currently in the field of view. The Field of View\n algorithm to use, passed in the second argument, is set in the config file.\n The actor's own position is considred reachable by him.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "fullscan",
          "package": "LambdaHack",
          "signature": "Ops TileKind-\u003e FovMode-\u003e Point-\u003e Level-\u003e [Point]",
          "type": "function"
        },
        "index": {
          "description": "Perform full scan for given position Returns the positions that are currently in the field of view The Field of View algorithm to use passed in the second argument is set in the config file The actor own position is considred reachable by him",
          "hierarchy": "Game LambdaHack Server Fov",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "fullscan",
          "normalized": "Ops TileKind-\u003eFovMode-\u003ePoint-\u003eLevel-\u003e[Point]",
          "package": "LambdaHack",
          "signature": "Ops TileKind-\u003eFovMode-\u003ePoint-\u003eLevel-\u003e[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov.html#v:fullscan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate perception of the level.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "levelPerception",
          "package": "LambdaHack",
          "signature": "COps -\u003e FovMode -\u003e FactionId -\u003e LevelId -\u003e Level -\u003e State -\u003e Perception",
          "source": "src/Game-LambdaHack-Server-Fov.html#levelPerception",
          "type": "function"
        },
        "index": {
          "description": "Calculate perception of the level",
          "hierarchy": "Game LambdaHack Server Fov",
          "module": "Game.LambdaHack.Server.Fov",
          "name": "levelPerception",
          "normalized": "COps-\u003eFovMode-\u003eFactionId-\u003eLevelId-\u003eLevel-\u003eState-\u003ePerception",
          "package": "LambdaHack",
          "partial": "Perception",
          "signature": "COps-\u003eFovMode-\u003eFactionId-\u003eLevelId-\u003eLevel-\u003eState-\u003ePerception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-Fov.html#v:levelPerception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe main loop of the server, processing human and computer player\n moves turn by turn.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.LoopAction",
          "name": "LoopAction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-LoopAction.html",
          "type": "module"
        },
        "index": {
          "description": "The main loop of the server processing human and computer player moves turn by turn",
          "hierarchy": "Game LambdaHack Server LoopAction",
          "module": "Game.LambdaHack.Server.LoopAction",
          "name": "LoopAction",
          "package": "LambdaHack",
          "partial": "Loop Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-LoopAction.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart a game session. Loop, communicating with clients.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.LoopAction",
          "name": "loopSer",
          "package": "LambdaHack",
          "signature": "DebugModeSer -\u003e (CmdSer -\u003e m Bool) -\u003e (FactionId -\u003e ChanFrontend -\u003e ChanServer CmdClientUI CmdSer -\u003e IO ()) -\u003e (FactionId -\u003e ChanServer CmdClientAI CmdTakeTimeSer -\u003e IO ()) -\u003e COps -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-LoopAction.html#loopSer",
          "type": "function"
        },
        "index": {
          "description": "Start game session Loop communicating with clients",
          "hierarchy": "Game LambdaHack Server LoopAction",
          "module": "Game.LambdaHack.Server.LoopAction",
          "name": "loopSer",
          "normalized": "DebugModeSer-\u003e(CmdSer-\u003ea Bool)-\u003e(FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eCOps-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "DebugModeSer-\u003e(CmdSer-\u003em Bool)-\u003e(FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eCOps-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-LoopAction.html#v:loopSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of \u003ccode\u003e\u003ca\u003eCmdSer\u003c/a\u003e\u003c/code\u003e server commands.\n A couple of them do not take time, the rest does.\n Note that since the results are atomic commands, which are executed\n only later (on the server and some of the clients), all condition\n are checkd by the semantic functions in the context of the state\n before the server command. Even if one or more atomic actions\n are already issued by the point an expression is evaluated, they do not\n influence the outcome of the evaluation.\n TODO: document\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "ServerSem",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-ServerSem.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of CmdSer server commands couple of them do not take time the rest does Note that since the results are atomic commands which are executed only later on the server and some of the clients all condition are checkd by the semantic functions in the context of the state before the server command Even if one or more atomic actions are already issued by the point an expression is evaluated they do not influence the outcome of the evaluation TODO document",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "ServerSem",
          "package": "LambdaHack",
          "partial": "Server Sem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a projectile actor containing the given missile.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "addProjectile",
          "package": "LambdaHack",
          "signature": "Point -\u003e [Point] -\u003e ItemId -\u003e LevelId -\u003e FactionId -\u003e Time -\u003e m ActorId",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#addProjectile",
          "type": "function"
        },
        "index": {
          "description": "Create projectile actor containing the given missile",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "addProjectile",
          "normalized": "Point-\u003e[Point]-\u003eItemId-\u003eLevelId-\u003eFactionId-\u003eTime-\u003ea ActorId",
          "package": "LambdaHack",
          "partial": "Projectile",
          "signature": "Point-\u003e[Point]-\u003eItemId-\u003eLevelId-\u003eFactionId-\u003eTime-\u003em ActorId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:addProjectile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a smell trace for the actor to the level. For now, only heroes\n leave smell.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "addSmell",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#addSmell",
          "type": "function"
        },
        "index": {
          "description": "Add smell trace for the actor to the level For now only heroes leave smell",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "addSmell",
          "normalized": "ActorId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Smell",
          "signature": "ActorId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:addSmell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch and/or alter the tile.\n\u003c/p\u003e\u003cp\u003eNote that if \u003ccode\u003eserverTile /= freshClientTile\u003c/code\u003e, \u003ccode\u003efreshClientTile\u003c/code\u003e\n should not be alterable (but \u003ccode\u003eserverTile\u003c/code\u003e may be).\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "alterSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Point -\u003e Maybe Feature -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#alterSer",
          "type": "function"
        },
        "index": {
          "description": "Search and or alter the tile Note that if serverTile freshClientTile freshClientTile should not be alterable but serverTile may be",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "alterSer",
          "normalized": "ActorId-\u003ePoint-\u003eMaybe Feature-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003ePoint-\u003eMaybe Feature-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:alterSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "applySer",
          "package": "LambdaHack",
          "signature": "ActorId-\u003e ItemId-\u003e Container-\u003e m ()",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "applySer",
          "normalized": "ActorId-\u003eItemId-\u003eContainer-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003eItemId-\u003eContainer-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:applySer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "broadcastCmdAtomic",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e CmdAtomic) -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#broadcastCmdAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "broadcastCmdAtomic",
          "normalized": "(FactionId-\u003eCmdAtomic)-\u003ea()",
          "package": "LambdaHack",
          "partial": "Cmd Atomic",
          "signature": "(FactionId-\u003eCmdAtomic)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:broadcastCmdAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "broadcastSfxAtomic",
          "package": "LambdaHack",
          "signature": "(FactionId -\u003e SfxAtomic) -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#broadcastSfxAtomic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "broadcastSfxAtomic",
          "normalized": "(FactionId-\u003eSfxAtomic)-\u003ea()",
          "package": "LambdaHack",
          "partial": "Sfx Atomic",
          "signature": "(FactionId-\u003eSfxAtomic)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:broadcastSfxAtomic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActor tries to swap positions with another.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "displaceSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e ActorId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#displaceSer",
          "type": "function"
        },
        "index": {
          "description": "Actor tries to swap positions with another",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "displaceSer",
          "normalized": "ActorId-\u003eActorId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003eActorId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:displaceSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "dropSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e ItemId -\u003e Int -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#dropSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "dropSer",
          "normalized": "ActorId-\u003eItemId-\u003eInt-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003eItemId-\u003eInt-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:dropSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "execFailure",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e FailureSer -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#execFailure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "execFailure",
          "normalized": "ActorId-\u003eFailureSer-\u003ea()",
          "package": "LambdaHack",
          "partial": "Failure",
          "signature": "ActorId-\u003eFailureSer-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:execFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "gameExitSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Int -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#gameExitSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "gameExitSer",
          "normalized": "ActorId-\u003eInt-\u003ea()",
          "package": "LambdaHack",
          "partial": "Exit Ser",
          "signature": "ActorId-\u003eInt-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:gameExitSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "gameRestartSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Text -\u003e Int -\u003e [(Int, Text)] -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#gameRestartSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "gameRestartSer",
          "normalized": "ActorId-\u003eText-\u003eInt-\u003e[(Int,Text)]-\u003ea()",
          "package": "LambdaHack",
          "partial": "Restart Ser",
          "signature": "ActorId-\u003eText-\u003eInt-\u003e[(Int,Text)]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:gameRestartSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "gameSaveSer",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#gameSaveSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "gameSaveSer",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Save Ser",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:gameSaveSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResolves the result of an actor moving into another.\n Actors on blocked positions can be attacked without any restrictions.\n For instance, an actor embedded in a wall can be attacked from\n an adjacent position. This function is analogous to projectGroupItem,\n but for melee and not using up the weapon.\n No problem if there are many projectiles at the spot. We just\n attack the one specified.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "meleeSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e ActorId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#meleeSer",
          "type": "function"
        },
        "index": {
          "description": "Resolves the result of an actor moving into another Actors on blocked positions can be attacked without any restrictions For instance an actor embedded in wall can be attacked from an adjacent position This function is analogous to projectGroupItem but for melee and not using up the weapon No problem if there are many projectiles at the spot We just attack the one specified",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "meleeSer",
          "normalized": "ActorId-\u003eActorId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003eActorId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:meleeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActor moves or attacks.\n Note that client may not be able to see an invisible monster\n so it's the server that determines if melee took place, etc.\n Also, only the server is authorized to check if a move is legal\n and it needs full context for that, e.g., the initial actor position\n to check if melee attack does not try to reach to a distant tile.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "moveSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Vector -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#moveSer",
          "type": "function"
        },
        "index": {
          "description": "Actor moves or attacks Note that client may not be able to see an invisible monster so it the server that determines if melee took place etc Also only the server is authorized to check if move is legal and it needs full context for that e.g the initial actor position to check if melee attack does not try to reach to distant tile",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "moveSer",
          "normalized": "ActorId-\u003eVector-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003eVector-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:moveSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "pickupSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e ItemId -\u003e Int -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#pickupSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "pickupSer",
          "normalized": "ActorId-\u003eItemId-\u003eInt-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003eItemId-\u003eInt-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:pickupSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "projectBla",
          "package": "LambdaHack",
          "signature": "ActorId-\u003e Point-\u003e [Point]-\u003e ItemId-\u003e Container-\u003e m ()",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "projectBla",
          "normalized": "ActorId-\u003ePoint-\u003e[Point]-\u003eItemId-\u003eContainer-\u003ea()",
          "package": "LambdaHack",
          "partial": "Bla",
          "signature": "ActorId-\u003ePoint-\u003e[Point]-\u003eItemId-\u003eContainer-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:projectBla"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "projectFail",
          "package": "LambdaHack",
          "signature": "ActorId-\u003e Point-\u003e Int-\u003e ItemId-\u003e Container-\u003e Bool-\u003e m (Maybe FailureSer)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "projectFail",
          "normalized": "ActorId-\u003ePoint-\u003eInt-\u003eItemId-\u003eContainer-\u003eBool-\u003ea(Maybe FailureSer)",
          "package": "LambdaHack",
          "partial": "Fail",
          "signature": "ActorId-\u003ePoint-\u003eInt-\u003eItemId-\u003eContainer-\u003eBool-\u003em(Maybe FailureSer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:projectFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "projectSer",
          "package": "LambdaHack",
          "signature": "ActorId-\u003e Point-\u003e Int-\u003e ItemId-\u003e Container-\u003e m ()",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "projectSer",
          "normalized": "ActorId-\u003ePoint-\u003eInt-\u003eItemId-\u003eContainer-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003ePoint-\u003eInt-\u003eItemId-\u003eContainer-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:projectSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "setTrajectorySer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#setTrajectorySer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "setTrajectorySer",
          "normalized": "ActorId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Trajectory Ser",
          "signature": "ActorId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:setTrajectorySer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "triggerEffect",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e [Feature] -\u003e m Bool",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#triggerEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "triggerEffect",
          "normalized": "ActorId-\u003e[Feature]-\u003ea Bool",
          "package": "LambdaHack",
          "partial": "Effect",
          "signature": "ActorId-\u003e[Feature]-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:triggerEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform the effect specified for the tile in case it's triggered.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "triggerSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e Maybe Feature -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#triggerSer",
          "type": "function"
        },
        "index": {
          "description": "Perform the effect specified for the tile in case it triggered",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "triggerSer",
          "normalized": "ActorId-\u003eMaybe Feature-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003eMaybe Feature-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:triggerSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo nothing.\n\u003c/p\u003e\u003cp\u003eSomething is sometimes done in \u003ccode\u003e\u003ca\u003esetBWait\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "waitSer",
          "package": "LambdaHack",
          "signature": "ActorId -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-ServerSem.html#waitSer",
          "type": "function"
        },
        "index": {
          "description": "Do nothing Something is sometimes done in setBWait",
          "hierarchy": "Game LambdaHack Server ServerSem",
          "module": "Game.LambdaHack.Server.ServerSem",
          "name": "waitSer",
          "normalized": "ActorId-\u003ea()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "ActorId-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-ServerSem.html#v:waitSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOperations for starting and restarting the game.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "StartAction",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-StartAction.html",
          "type": "module"
        },
        "index": {
          "description": "Operations for starting and restarting the game",
          "hierarchy": "Game LambdaHack Server StartAction",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "StartAction",
          "package": "LambdaHack",
          "partial": "Start Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-StartAction.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply debug options that don't need a new game.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "applyDebug",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-StartAction.html#applyDebug",
          "type": "function"
        },
        "index": {
          "description": "Apply debug options that don need new game",
          "hierarchy": "Game LambdaHack Server StartAction",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "applyDebug",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Debug",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-StartAction.html#v:applyDebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "gameReset",
          "package": "LambdaHack",
          "signature": "COps -\u003e DebugModeSer -\u003e Maybe StdGen -\u003e m State",
          "source": "src/Game-LambdaHack-Server-StartAction.html#gameReset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server StartAction",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "gameReset",
          "normalized": "COps-\u003eDebugModeSer-\u003eMaybe StdGen-\u003ea State",
          "package": "LambdaHack",
          "partial": "Reset",
          "signature": "COps-\u003eDebugModeSer-\u003eMaybe StdGen-\u003em State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-StartAction.html#v:gameReset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "initPer",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-StartAction.html#initPer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server StartAction",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "initPer",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Per",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-StartAction.html#v:initPer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "reinitGame",
          "package": "LambdaHack",
          "signature": "m ()",
          "source": "src/Game-LambdaHack-Server-StartAction.html#reinitGame",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server StartAction",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "reinitGame",
          "normalized": "a()",
          "package": "LambdaHack",
          "partial": "Game",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-StartAction.html#v:reinitGame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSave game on server and all clients. Clients are pinged first,\n which greatly reduced the chance of saves being out of sync.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "saveBkpAll",
          "package": "LambdaHack",
          "signature": "Bool -\u003e m ()",
          "source": "src/Game-LambdaHack-Server-StartAction.html#saveBkpAll",
          "type": "function"
        },
        "index": {
          "description": "Save game on server and all clients Clients are pinged first which greatly reduced the chance of saves being out of sync",
          "hierarchy": "Game LambdaHack Server StartAction",
          "module": "Game.LambdaHack.Server.StartAction",
          "name": "saveBkpAll",
          "normalized": "Bool-\u003ea()",
          "package": "LambdaHack",
          "partial": "Bkp All",
          "signature": "Bool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-StartAction.html#v:saveBkpAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eServer and client game state types and operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "State",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-State.html",
          "type": "module"
        },
        "index": {
          "description": "Server and client game state types and operations",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "State",
          "package": "LambdaHack",
          "partial": "State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebug commands. See \u003ccode\u003e\u003ca\u003edebugArgs\u003c/a\u003e\u003c/code\u003e for the descriptions.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "DebugModeSer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "data"
        },
        "index": {
          "description": "Debug commands See debugArgs for the descriptions",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "DebugModeSer",
          "package": "LambdaHack",
          "partial": "Debug Mode Ser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#t:DebugModeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "RNGs",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-State.html#RNGs",
          "type": "data"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "RNGs",
          "package": "LambdaHack",
          "partial": "RNGs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#t:RNGs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlobal, server state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "StateServer",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "data"
        },
        "index": {
          "description": "Global server state",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "StateServer",
          "package": "LambdaHack",
          "partial": "State Server",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#t:StateServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "DebugModeSer",
          "package": "LambdaHack",
          "signature": "DebugModeSer",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "DebugModeSer",
          "package": "LambdaHack",
          "partial": "Debug Mode Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:DebugModeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "RNGs",
          "package": "LambdaHack",
          "signature": "RNGs",
          "source": "src/Game-LambdaHack-Server-State.html#RNGs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "RNGs",
          "package": "LambdaHack",
          "partial": "RNGs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:RNGs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "StateServer",
          "package": "LambdaHack",
          "signature": "StateServer",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "StateServer",
          "package": "LambdaHack",
          "partial": "State Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:StateServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "defDebugModeSer",
          "package": "LambdaHack",
          "signature": "DebugModeSer",
          "source": "src/Game-LambdaHack-Server-State.html#defDebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "defDebugModeSer",
          "package": "LambdaHack",
          "partial": "Debug Mode Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:defDebugModeSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "dungeonRandomGenerator",
          "package": "LambdaHack",
          "signature": "(Maybe StdGen)",
          "source": "src/Game-LambdaHack-Server-State.html#RNGs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "dungeonRandomGenerator",
          "package": "LambdaHack",
          "partial": "Random Generator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:dungeonRandomGenerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitial, empty game server state.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "emptyStateServer",
          "package": "LambdaHack",
          "signature": "StateServer",
          "source": "src/Game-LambdaHack-Server-State.html#emptyStateServer",
          "type": "function"
        },
        "index": {
          "description": "Initial empty game server state",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "emptyStateServer",
          "package": "LambdaHack",
          "partial": "State Server",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:emptyStateServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estores next actor index\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sacounter",
          "package": "LambdaHack",
          "signature": "ActorId",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "stores next actor index",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sacounter",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sacounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sallClear",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sallClear",
          "package": "LambdaHack",
          "partial": "Clear",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sallClear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclips since the start of the session\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sallTime",
          "package": "LambdaHack",
          "signature": "Time",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "clips since the start of the session",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sallTime",
          "package": "LambdaHack",
          "partial": "Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sallTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sbenchmark",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sbenchmark",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sbenchmark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emake backup savefile now\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sbkpSave",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "make backup savefile now",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sbkpSave",
          "package": "LambdaHack",
          "partial": "Save",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sbkpSave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sdbgMsgSer",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdbgMsgSer",
          "package": "LambdaHack",
          "partial": "Msg Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdbgMsgSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sdebugCli",
          "package": "LambdaHack",
          "signature": "DebugModeCli",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdebugCli",
          "package": "LambdaHack",
          "partial": "Cli",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdebugCli"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edebugging mode for the next game\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdebugNxt",
          "package": "LambdaHack",
          "signature": "DebugModeSer",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "debugging mode for the next game",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdebugNxt",
          "package": "LambdaHack",
          "partial": "Nxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdebugNxt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent debugging mode\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdebugSer",
          "package": "LambdaHack",
          "signature": "DebugModeSer",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "current debugging mode",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdebugSer",
          "package": "LambdaHack",
          "partial": "Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdebugSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sdifficultySer",
          "package": "LambdaHack",
          "signature": "Int",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdifficultySer",
          "package": "LambdaHack",
          "partial": "Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdifficultySer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efull item discoveries data\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdisco",
          "package": "LambdaHack",
          "signature": "Discovery",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "full item discoveries data",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdisco",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdisco"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereverse disco map, used for item creation\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdiscoRev",
          "package": "LambdaHack",
          "signature": "DiscoRev",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "reverse disco map used for item creation",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdiscoRev",
          "package": "LambdaHack",
          "partial": "Rev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdiscoRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sdumpInitRngs",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdumpInitRngs",
          "package": "LambdaHack",
          "partial": "Init Rngs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdumpInitRngs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sdungeonRng",
          "package": "LambdaHack",
          "signature": "(Maybe StdGen)",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sdungeonRng",
          "package": "LambdaHack",
          "partial": "Rng",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sdungeonRng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eassociation of flavour to items\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sflavour",
          "package": "LambdaHack",
          "signature": "FlavourMap",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "association of flavour to items",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sflavour",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sflavour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sfovMode",
          "package": "LambdaHack",
          "signature": "(Maybe FovMode)",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sfovMode",
          "package": "LambdaHack",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sfovMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sgameMode",
          "package": "LambdaHack",
          "signature": "Text",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sgameMode",
          "package": "LambdaHack",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sgameMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethis game start time\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sgstart",
          "package": "LambdaHack",
          "signature": "ClockTime",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "this game start time",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sgstart",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sgstart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehero names sent by clients\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sheroNames",
          "package": "LambdaHack",
          "signature": "(EnumMap FactionId [(Int, Text)])",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "hero names sent by clients",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sheroNames",
          "normalized": "(EnumMap FactionId[(Int,Text)])",
          "package": "LambdaHack",
          "partial": "Names",
          "signature": "(EnumMap FactionId[(Int,Text)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sheroNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estores next item index\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sicounter",
          "package": "LambdaHack",
          "signature": "ItemId",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "stores next item index",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sicounter",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sicounter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereverse id map, used for item creation\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sitemRev",
          "package": "LambdaHack",
          "signature": "ItemRev",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "reverse id map used for item creation",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sitemRev",
          "package": "LambdaHack",
          "partial": "Rev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sitemRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sknowEvents",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sknowEvents",
          "package": "LambdaHack",
          "partial": "Events",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sknowEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sknowMap",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sknowMap",
          "package": "LambdaHack",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sknowMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "smainRng",
          "package": "LambdaHack",
          "signature": "(Maybe StdGen)",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "smainRng",
          "package": "LambdaHack",
          "partial": "Rng",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:smainRng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "snewGameSer",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "snewGameSer",
          "package": "LambdaHack",
          "partial": "Game Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:snewGameSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sniffIn",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sniffIn",
          "package": "LambdaHack",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sniffIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sniffOut",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sniffOut",
          "package": "LambdaHack",
          "partial": "Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sniffOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eperception of all factions\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sper",
          "package": "LambdaHack",
          "signature": "Pers",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "perception of all factions",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sper",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexit the game loop\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "squit",
          "package": "LambdaHack",
          "signature": "Bool",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "exit the game loop",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "squit",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:squit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent random generator\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "srandom",
          "package": "LambdaHack",
          "signature": "StdGen",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "current random generator",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "srandom",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:srandom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einitial random generators\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "srngs",
          "package": "LambdaHack",
          "signature": "RNGs",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "initial random generators",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "srngs",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:srngs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "ssavePrefixSer",
          "package": "LambdaHack",
          "signature": "(Maybe String)",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "ssavePrefixSer",
          "package": "LambdaHack",
          "partial": "Prefix Ser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:ssavePrefixSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethis session start time\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sstart",
          "package": "LambdaHack",
          "signature": "ClockTime",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "this session start time",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sstart",
          "package": "LambdaHack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sstart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "sstopAfter",
          "package": "LambdaHack",
          "signature": "(Maybe Int)",
          "source": "src/Game-LambdaHack-Server-State.html#DebugModeSer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sstopAfter",
          "package": "LambdaHack",
          "partial": "After",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sstopAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Server.State",
          "name": "startingRandomGenerator",
          "package": "LambdaHack",
          "signature": "(Maybe StdGen)",
          "source": "src/Game-LambdaHack-Server-State.html#RNGs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "startingRandomGenerator",
          "package": "LambdaHack",
          "partial": "Random Generator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:startingRandomGenerator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eatomic commands performed to date\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server.State",
          "name": "sundo",
          "package": "LambdaHack",
          "signature": "[Atomic]",
          "source": "src/Game-LambdaHack-Server-State.html#StateServer",
          "type": "function"
        },
        "index": {
          "description": "atomic commands performed to date",
          "hierarchy": "Game LambdaHack Server State",
          "module": "Game.LambdaHack.Server.State",
          "name": "sundo",
          "normalized": "[Atomic]",
          "package": "LambdaHack",
          "signature": "[Atomic]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server-State.html#v:sundo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSemantics of server commands.\n See\n \u003ca\u003ehttps://github.com/kosmikus/LambdaHack/wiki/Client-server-architecture\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Server",
          "name": "Server",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Server.html",
          "type": "module"
        },
        "index": {
          "description": "Semantics of server commands See https github.com kosmikus LambdaHack wiki Client-server-architecture",
          "hierarchy": "Game LambdaHack Server",
          "module": "Game.LambdaHack.Server",
          "name": "Server",
          "package": "LambdaHack",
          "partial": "Server",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFire up the frontend with the engine fueled by content.\n The action monad types to be used are determined by the \u003ccode\u003eexeSer\u003c/code\u003e\n and \u003ccode\u003eexecutorCli\u003c/code\u003e calls. If other functions are used in their place\n the types are different and so the whole pattern of computation\n is different. Which of the frontends is run depends on the flags supplied\n when compiling the engine library.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Server",
          "name": "mainSer",
          "package": "LambdaHack",
          "signature": "COps -\u003e (m () -\u003e IO ()) -\u003e (COps -\u003e DebugModeCli -\u003e ((FactionId -\u003e ChanFrontend -\u003e ChanServer CmdClientUI CmdSer -\u003e IO ()) -\u003e (FactionId -\u003e ChanServer CmdClientAI CmdTakeTimeSer -\u003e IO ()) -\u003e IO ()) -\u003e IO ()) -\u003e IO ()",
          "source": "src/Game-LambdaHack-Server.html#mainSer",
          "type": "function"
        },
        "index": {
          "description": "Fire up the frontend with the engine fueled by content The action monad types to be used are determined by the exeSer and executorCli calls If other functions are used in their place the types are different and so the whole pattern of computation is different Which of the frontends is run depends on the flags supplied when compiling the engine library",
          "hierarchy": "Game LambdaHack Server",
          "module": "Game.LambdaHack.Server",
          "name": "mainSer",
          "normalized": "COps-\u003e(a()-\u003eIO())-\u003e(COps-\u003eDebugModeCli-\u003e((FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eIO())-\u003eIO())-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Ser",
          "signature": "COps-\u003e(m()-\u003eIO())-\u003e(COps-\u003eDebugModeCli-\u003e((FactionId-\u003eChanFrontend-\u003eChanServer CmdClientUI CmdSer-\u003eIO())-\u003e(FactionId-\u003eChanServer CmdClientAI CmdTakeTimeSer-\u003eIO())-\u003eIO())-\u003eIO())-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Server.html#v:mainSer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSaving/loading with serialization and compression.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Utils.File",
          "name": "File",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Utils-File.html",
          "type": "module"
        },
        "index": {
          "description": "Saving loading with serialization and compression",
          "hierarchy": "Game LambdaHack Utils File",
          "module": "Game.LambdaHack.Utils.File",
          "name": "File",
          "package": "LambdaHack",
          "partial": "File",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-File.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePersonal data directory for the game. Depends on the OS and the game,\n e.g., for LambdaHack under Linux it's \u003ccode\u003e~/.LambdaHack/\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.File",
          "name": "appDataDir",
          "package": "LambdaHack",
          "signature": "IO FilePath",
          "source": "src/Game-LambdaHack-Utils-File.html#appDataDir",
          "type": "function"
        },
        "index": {
          "description": "Personal data directory for the game Depends on the OS and the game e.g for LambdaHack under Linux it LambdaHack",
          "hierarchy": "Game LambdaHack Utils File",
          "module": "Game.LambdaHack.Utils.File",
          "name": "appDataDir",
          "package": "LambdaHack",
          "partial": "Data Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-File.html#v:appDataDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSerialize, compress and save data with an EOF marker.\n The \u003ccode\u003eOK\u003c/code\u003e is used as an EOF marker to ensure any apparent problems with\n corrupted files are reported to the user ASAP.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.File",
          "name": "encodeEOF",
          "package": "LambdaHack",
          "signature": "FilePath -\u003e a -\u003e IO ()",
          "source": "src/Game-LambdaHack-Utils-File.html#encodeEOF",
          "type": "function"
        },
        "index": {
          "description": "Serialize compress and save data with an EOF marker The OK is used as an EOF marker to ensure any apparent problems with corrupted files are reported to the user ASAP",
          "hierarchy": "Game LambdaHack Utils File",
          "module": "Game.LambdaHack.Utils.File",
          "name": "encodeEOF",
          "normalized": "FilePath-\u003ea-\u003eIO()",
          "package": "LambdaHack",
          "partial": "EOF",
          "signature": "FilePath-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-File.html#v:encodeEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead, decompress and deserialize data with an EOF marker.\n The \u003ccode\u003eOK\u003c/code\u003e EOF marker ensures any easily detectable file corruption\n is discovered and reported before the function returns.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.File",
          "name": "strictDecodeEOF",
          "package": "LambdaHack",
          "signature": "FilePath -\u003e IO a",
          "source": "src/Game-LambdaHack-Utils-File.html#strictDecodeEOF",
          "type": "function"
        },
        "index": {
          "description": "Read decompress and deserialize data with an EOF marker The OK EOF marker ensures any easily detectable file corruption is discovered and reported before the function returns",
          "hierarchy": "Game LambdaHack Utils File",
          "module": "Game.LambdaHack.Utils.File",
          "name": "strictDecodeEOF",
          "normalized": "FilePath-\u003eIO a",
          "package": "LambdaHack",
          "partial": "Decode EOF",
          "signature": "FilePath-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-File.html#v:strictDecodeEOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to copy over data files, if not already there.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.File",
          "name": "tryCopyDataFiles",
          "package": "LambdaHack",
          "signature": "FilePath -\u003e (FilePath -\u003e IO FilePath) -\u003e [(FilePath, FilePath)] -\u003e IO ()",
          "source": "src/Game-LambdaHack-Utils-File.html#tryCopyDataFiles",
          "type": "function"
        },
        "index": {
          "description": "Try to copy over data files if not already there",
          "hierarchy": "Game LambdaHack Utils File",
          "module": "Game.LambdaHack.Utils.File",
          "name": "tryCopyDataFiles",
          "normalized": "FilePath-\u003e(FilePath-\u003eIO FilePath)-\u003e[(FilePath,FilePath)]-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Copy Data Files",
          "signature": "FilePath-\u003e(FilePath-\u003eIO FilePath)-\u003e[(FilePath,FilePath)]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-File.html#v:tryCopyDataFiles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to create a directory, if it doesn't exist. Terminate the program\n with an exception if the directory does not exist, but can't be created.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.File",
          "name": "tryCreateDir",
          "package": "LambdaHack",
          "signature": "FilePath -\u003e IO ()",
          "source": "src/Game-LambdaHack-Utils-File.html#tryCreateDir",
          "type": "function"
        },
        "index": {
          "description": "Try to create directory if it doesn exist Terminate the program with an exception if the directory does not exist but can be created",
          "hierarchy": "Game LambdaHack Utils File",
          "module": "Game.LambdaHack.Utils.File",
          "name": "tryCreateDir",
          "normalized": "FilePath-\u003eIO()",
          "package": "LambdaHack",
          "partial": "Create Dir",
          "signature": "FilePath-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-File.html#v:tryCreateDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA list of items with relative frequencies of appearance.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "Frequency",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Utils-Frequency.html",
          "type": "module"
        },
        "index": {
          "description": "list of items with relative frequencies of appearance",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "Frequency",
          "package": "LambdaHack",
          "partial": "Frequency",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe frequency distribution type.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "Frequency",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#Frequency",
          "type": "data"
        },
        "index": {
          "description": "The frequency distribution type",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "Frequency",
          "package": "LambdaHack",
          "partial": "Frequency",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#t:Frequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshort description for debug, etc.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "nameFrequency",
          "package": "LambdaHack",
          "signature": "Frequency a -\u003e Text",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#nameFrequency",
          "type": "function"
        },
        "index": {
          "description": "short description for debug etc",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "nameFrequency",
          "normalized": "Frequency a-\u003eText",
          "package": "LambdaHack",
          "partial": "Frequency",
          "signature": "Frequency a-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:nameFrequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if the frequency distribution is empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "nullFreq",
          "package": "LambdaHack",
          "signature": "Frequency a -\u003e Bool",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#nullFreq",
          "type": "function"
        },
        "index": {
          "description": "Test if the frequency distribution is empty",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "nullFreq",
          "normalized": "Frequency a-\u003eBool",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "Frequency a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:nullFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the description of the frequency.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "renameFreq",
          "package": "LambdaHack",
          "signature": "Text -\u003e Frequency a -\u003e Frequency a",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#renameFreq",
          "type": "function"
        },
        "index": {
          "description": "Change the description of the frequency",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "renameFreq",
          "normalized": "Text-\u003eFrequency a-\u003eFrequency a",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "Text-\u003eFrequency a-\u003eFrequency a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:renameFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRandomly choose an item according to the distribution.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "rollFreq",
          "package": "LambdaHack",
          "signature": "Frequency a -\u003e StdGen -\u003e (a, StdGen)",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#rollFreq",
          "type": "function"
        },
        "index": {
          "description": "Randomly choose an item according to the distribution",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "rollFreq",
          "normalized": "Frequency a-\u003eStdGen-\u003e(a,StdGen)",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "Frequency a-\u003eStdGen-\u003e(a,StdGen)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:rollFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egive acces to raw frequency values\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "runFrequency",
          "package": "LambdaHack",
          "signature": "Frequency a -\u003e [(Int, a)]",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#runFrequency",
          "type": "function"
        },
        "index": {
          "description": "give acces to raw frequency values",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "runFrequency",
          "normalized": "Frequency a-\u003e[(Int,a)]",
          "package": "LambdaHack",
          "partial": "Frequency",
          "signature": "Frequency a-\u003e[(Int,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:runFrequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScale frequecy distribution, multiplying it\n by a positive integer constant.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "scaleFreq",
          "package": "LambdaHack",
          "signature": "Int -\u003e Frequency a -\u003e Frequency a",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#scaleFreq",
          "type": "function"
        },
        "index": {
          "description": "Scale frequecy distribution multiplying it by positive integer constant",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "scaleFreq",
          "normalized": "Int-\u003eFrequency a-\u003eFrequency a",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "Int-\u003eFrequency a-\u003eFrequency a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:scaleFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet frequency of an element.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "setFreq",
          "package": "LambdaHack",
          "signature": "Frequency a -\u003e a -\u003e Int -\u003e Frequency a",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#setFreq",
          "type": "function"
        },
        "index": {
          "description": "Set frequency of an element",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "setFreq",
          "normalized": "Frequency a-\u003ea-\u003eInt-\u003eFrequency a",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "Frequency a-\u003ea-\u003eInt-\u003eFrequency a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:setFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a name and a list of frequencies and items\n into the frequency distribution.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "toFreq",
          "package": "LambdaHack",
          "signature": "Text -\u003e [(Int, a)] -\u003e Frequency a",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#toFreq",
          "type": "function"
        },
        "index": {
          "description": "Takes name and list of frequencies and items into the frequency distribution",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "toFreq",
          "normalized": "Text-\u003e[(Int,a)]-\u003eFrequency a",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "Text-\u003e[(Int,a)]-\u003eFrequency a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:toFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniform discrete frequency distribution.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "uniformFreq",
          "package": "LambdaHack",
          "signature": "Text -\u003e [a] -\u003e Frequency a",
          "source": "src/Game-LambdaHack-Utils-Frequency.html#uniformFreq",
          "type": "function"
        },
        "index": {
          "description": "Uniform discrete frequency distribution",
          "hierarchy": "Game LambdaHack Utils Frequency",
          "module": "Game.LambdaHack.Utils.Frequency",
          "name": "uniformFreq",
          "normalized": "Text-\u003e[a]-\u003eFrequency a",
          "package": "LambdaHack",
          "partial": "Freq",
          "signature": "Text-\u003e[a]-\u003eFrequency a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Frequency.html#v:uniformFreq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eQueues implemented with two stacks to ensure fast writes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "LQueue",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Utils-LQueue.html",
          "type": "module"
        },
        "index": {
          "description": "Queues implemented with two stacks to ensure fast writes",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "LQueue",
          "package": "LambdaHack",
          "partial": "LQueue",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQueues implemented with two stacks.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "LQueue",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#LQueue",
          "type": "type"
        },
        "index": {
          "description": "Queues implemented with two stacks",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "LQueue",
          "package": "LambdaHack",
          "partial": "LQueue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#t:LQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove frames up to and including the first segment of \u003ccode\u003eNothing\u003c/code\u003e frames.\n | If the resulting queue is empty, apply trimLQueue instead.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "dropStartLQueue",
          "package": "LambdaHack",
          "signature": "LQueue (Maybe a) -\u003e LQueue (Maybe a)",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#dropStartLQueue",
          "type": "function"
        },
        "index": {
          "description": "Remove frames up to and including the first segment of Nothing frames If the resulting queue is empty apply trimLQueue instead",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "dropStartLQueue",
          "normalized": "LQueue(Maybe a)-\u003eLQueue(Maybe a)",
          "package": "LambdaHack",
          "partial": "Start LQueue",
          "signature": "LQueue(Maybe a)-\u003eLQueue(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:dropStartLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDump all but the last written non-\u003ccode\u003eNothing\u003c/code\u003e element of the queue, if any.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "lastLQueue",
          "package": "LambdaHack",
          "signature": "LQueue (Maybe a) -\u003e Maybe a",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#lastLQueue",
          "type": "function"
        },
        "index": {
          "description": "Dump all but the last written non Nothing element of the queue if any",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "lastLQueue",
          "normalized": "LQueue(Maybe a)-\u003eMaybe a",
          "package": "LambdaHack",
          "partial": "LQueue",
          "signature": "LQueue(Maybe a)-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:lastLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe length of the queue.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "lengthLQueue",
          "package": "LambdaHack",
          "signature": "LQueue a -\u003e Int",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#lengthLQueue",
          "type": "function"
        },
        "index": {
          "description": "The length of the queue",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "lengthLQueue",
          "normalized": "LQueue a-\u003eInt",
          "package": "LambdaHack",
          "partial": "LQueue",
          "signature": "LQueue a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:lengthLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new empty mutable queue.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "newLQueue",
          "package": "LambdaHack",
          "signature": "LQueue a",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#newLQueue",
          "type": "function"
        },
        "index": {
          "description": "Create new empty mutable queue",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "newLQueue",
          "package": "LambdaHack",
          "partial": "LQueue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:newLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the queue is empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "nullLQueue",
          "package": "LambdaHack",
          "signature": "LQueue a -\u003e Bool",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#nullLQueue",
          "type": "function"
        },
        "index": {
          "description": "Check if the queue is empty",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "nullLQueue",
          "normalized": "LQueue a-\u003eBool",
          "package": "LambdaHack",
          "partial": "LQueue",
          "signature": "LQueue a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:nullLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "toListLQueue",
          "package": "LambdaHack",
          "signature": "LQueue a -\u003e [a]",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#toListLQueue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "toListLQueue",
          "normalized": "LQueue a-\u003e[a]",
          "package": "LambdaHack",
          "partial": "List LQueue",
          "signature": "LQueue a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:toListLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all but the last written non-\u003ccode\u003eNothing\u003c/code\u003e element of the queue.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "trimLQueue",
          "package": "LambdaHack",
          "signature": "LQueue (Maybe a) -\u003e LQueue (Maybe a)",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#trimLQueue",
          "type": "function"
        },
        "index": {
          "description": "Remove all but the last written non Nothing element of the queue",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "trimLQueue",
          "normalized": "LQueue(Maybe a)-\u003eLQueue(Maybe a)",
          "package": "LambdaHack",
          "partial": "LQueue",
          "signature": "LQueue(Maybe a)-\u003eLQueue(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:trimLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry reading a queue. Return \u003ccode\u003eNothing\u003c/code\u003e if empty.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "tryReadLQueue",
          "package": "LambdaHack",
          "signature": "LQueue a -\u003e Maybe (a, LQueue a)",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#tryReadLQueue",
          "type": "function"
        },
        "index": {
          "description": "Try reading queue Return Nothing if empty",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "tryReadLQueue",
          "normalized": "LQueue a-\u003eMaybe(a,LQueue a)",
          "package": "LambdaHack",
          "partial": "Read LQueue",
          "signature": "LQueue a-\u003eMaybe(a,LQueue a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:tryReadLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite to the queue. Faster than reading.\n\u003c/p\u003e",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "writeLQueue",
          "package": "LambdaHack",
          "signature": "LQueue a -\u003e a -\u003e LQueue a",
          "source": "src/Game-LambdaHack-Utils-LQueue.html#writeLQueue",
          "type": "function"
        },
        "index": {
          "description": "Write to the queue Faster than reading",
          "hierarchy": "Game LambdaHack Utils LQueue",
          "module": "Game.LambdaHack.Utils.LQueue",
          "name": "writeLQueue",
          "normalized": "LQueue a-\u003ea-\u003eLQueue a",
          "package": "LambdaHack",
          "partial": "LQueue",
          "signature": "LQueue a-\u003ea-\u003eLQueue a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-LQueue.html#v:writeLQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eKeeping track of forked threads.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Game.LambdaHack.Utils.Thread",
          "name": "Thread",
          "package": "LambdaHack",
          "source": "src/Game-LambdaHack-Utils-Thread.html",
          "type": "module"
        },
        "index": {
          "description": "Keeping track of forked threads",
          "hierarchy": "Game LambdaHack Utils Thread",
          "module": "Game.LambdaHack.Utils.Thread",
          "name": "Thread",
          "package": "LambdaHack",
          "partial": "Thread",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Thread.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Utils.Thread",
          "name": "forkChild",
          "package": "LambdaHack",
          "signature": "MVar [MVar ()] -\u003e IO () -\u003e IO ThreadId",
          "source": "src/Game-LambdaHack-Utils-Thread.html#forkChild",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Utils Thread",
          "module": "Game.LambdaHack.Utils.Thread",
          "name": "forkChild",
          "normalized": "MVar[MVar()]-\u003eIO()-\u003eIO ThreadId",
          "package": "LambdaHack",
          "partial": "Child",
          "signature": "MVar[MVar()]-\u003eIO()-\u003eIO ThreadId",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Thread.html#v:forkChild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Game.LambdaHack.Utils.Thread",
          "name": "waitForChildren",
          "package": "LambdaHack",
          "signature": "MVar [MVar ()] -\u003e IO ()",
          "source": "src/Game-LambdaHack-Utils-Thread.html#waitForChildren",
          "type": "function"
        },
        "index": {
          "hierarchy": "Game LambdaHack Utils Thread",
          "module": "Game.LambdaHack.Utils.Thread",
          "name": "waitForChildren",
          "normalized": "MVar[MVar()]-\u003eIO()",
          "package": "LambdaHack",
          "partial": "For Children",
          "signature": "MVar[MVar()]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/LambdaHack/docs/Game-LambdaHack-Utils-Thread.html#v:waitForChildren"
      }
    }
  ]
]