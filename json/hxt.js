[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hxt"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe exception arrow class\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowExc",
          "name": "ArrowExc",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowExc.html",
          "type": "module"
        },
        "index": {
          "description": "The exception arrow class",
          "hierarchy": "Control Arrow ArrowExc",
          "module": "Control.Arrow.ArrowExc",
          "name": "ArrowExc",
          "package": "hxt",
          "partial": "Arrow Exc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowExc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowExc",
          "name": "ArrowExc",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowExc.html#ArrowExc",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowExc",
          "module": "Control.Arrow.ArrowExc",
          "name": "ArrowExc",
          "package": "hxt",
          "partial": "Arrow Exc",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowExc.html#t:ArrowExc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowExc",
          "name": "catchA",
          "package": "hxt",
          "signature": "a b c -\u003e a SomeException c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowExc.html#catchA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowExc",
          "module": "Control.Arrow.ArrowExc",
          "name": "catchA",
          "normalized": "a b c-\u003ea SomeException c-\u003ea b c",
          "package": "hxt",
          "signature": "a b c-\u003ea SomeException c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowExc.html#v:catchA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowExc",
          "name": "tryA",
          "package": "hxt",
          "signature": "a b c -\u003e a b (Either SomeException c)",
          "source": "src/Control-Arrow-ArrowExc.html#tryA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowExc",
          "module": "Control.Arrow.ArrowExc",
          "name": "tryA",
          "normalized": "a b c-\u003ea b(Either SomeException c)",
          "package": "hxt",
          "signature": "a b c-\u003ea b(Either SomeException c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowExc.html#v:tryA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLifting of IO actions to arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "ArrowIO",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowIO.html",
          "type": "module"
        },
        "index": {
          "description": "Lifting of IO actions to arrows",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "ArrowIO",
          "package": "hxt",
          "partial": "Arrow IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe interface for converting an IO action into an arrow\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "ArrowIO",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowIO.html#ArrowIO",
          "type": "class"
        },
        "index": {
          "description": "the interface for converting an IO action into an arrow",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "ArrowIO",
          "package": "hxt",
          "partial": "Arrow IO",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#t:ArrowIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe interface for converting an IO predicate into a list arrow\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "ArrowIOIf",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowIO.html#ArrowIOIf",
          "type": "class"
        },
        "index": {
          "description": "the interface for converting an IO predicate into list arrow",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "ArrowIOIf",
          "package": "hxt",
          "partial": "Arrow IOIf",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#t:ArrowIOIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an arrow from an IO action\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO",
          "package": "hxt",
          "signature": "(b -\u003e IO c) -\u003e a b c",
          "source": "src/Control-Arrow-ArrowIO.html#arrIO",
          "type": "method"
        },
        "index": {
          "description": "construct an arrow from an IO action",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO",
          "normalized": "(a-\u003eIO b)-\u003ec a b",
          "package": "hxt",
          "partial": "IO",
          "signature": "(b-\u003eIO c)-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#v:arrIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an arrow from an IO action without any parameter\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO0",
          "package": "hxt",
          "signature": "IO c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowIO.html#arrIO0",
          "type": "method"
        },
        "index": {
          "description": "construct an arrow from an IO action without any parameter",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO0",
          "normalized": "IO a-\u003eb c a",
          "package": "hxt",
          "partial": "IO",
          "signature": "IO c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#v:arrIO0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of a 2 argument arrow from a binary IO action\n |\n | example: \u003ccode\u003e a1 &&& a2 \u003e\u003e\u003e arr2 f \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO2",
          "package": "hxt",
          "signature": "(b1 -\u003e b2 -\u003e IO c) -\u003e a (b1, b2) c",
          "source": "src/Control-Arrow-ArrowIO.html#arrIO2",
          "type": "method"
        },
        "index": {
          "description": "construction of argument arrow from binary IO action example a1 a2 arr2",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO2",
          "normalized": "(a-\u003ea-\u003eIO b)-\u003ec(a,a)b",
          "package": "hxt",
          "partial": "IO",
          "signature": "(b-\u003eb-\u003eIO c)-\u003ea(b,b)c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#v:arrIO2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of a 3 argument arrow from a 3-ary IO action\n |\n | example: \u003ccode\u003e a1 &&& a2 &&& a3 \u003e\u003e\u003e arr3 f \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO3",
          "package": "hxt",
          "signature": "(b1 -\u003e b2 -\u003e b3 -\u003e IO c) -\u003e a (b1, (b2, b3)) c",
          "source": "src/Control-Arrow-ArrowIO.html#arrIO3",
          "type": "method"
        },
        "index": {
          "description": "construction of argument arrow from ary IO action example a1 a2 a3 arr3",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO3",
          "normalized": "(a-\u003ea-\u003ea-\u003eIO b)-\u003ec(a,(a,a))b",
          "package": "hxt",
          "partial": "IO",
          "signature": "(b-\u003eb-\u003eb-\u003eIO c)-\u003ea(b,(b,b))c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#v:arrIO3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of a 4 argument arrow from a 4-ary IO action\n |\n | example: \u003ccode\u003e a1 &&& a2 &&& a3 &&& a4 \u003e\u003e\u003e arr4 f \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO4",
          "package": "hxt",
          "signature": "(b1 -\u003e b2 -\u003e b3 -\u003e b4 -\u003e IO c) -\u003e a (b1, (b2, (b3, b4))) c",
          "source": "src/Control-Arrow-ArrowIO.html#arrIO4",
          "type": "method"
        },
        "index": {
          "description": "construction of argument arrow from ary IO action example a1 a2 a3 a4 arr4",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "arrIO4",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003eIO b)-\u003ec(a,(a,(a,a)))b",
          "package": "hxt",
          "partial": "IO",
          "signature": "(b-\u003eb-\u003eb-\u003eb-\u003eIO c)-\u003ea(b,(b,(b,b)))c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#v:arrIO4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilds an arrow from an IO predicate\n\u003c/p\u003e\u003cp\u003eif the predicate holds, the single list containing the input is returned, else the empty list,\n similar to \u003ccode\u003e\u003ca\u003eisA\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIO",
          "name": "isIOA",
          "package": "hxt",
          "signature": "(b -\u003e IO Bool) -\u003e a b b",
          "source": "src/Control-Arrow-ArrowIO.html#isIOA",
          "type": "method"
        },
        "index": {
          "description": "builds an arrow from an IO predicate if the predicate holds the single list containing the input is returned else the empty list similar to isA",
          "hierarchy": "Control Arrow ArrowIO",
          "module": "Control.Arrow.ArrowIO",
          "name": "isIOA",
          "normalized": "(a-\u003eIO Bool)-\u003eb a a",
          "package": "hxt",
          "partial": "IOA",
          "signature": "(b-\u003eIO Bool)-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIO.html#v:isIOA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConditionals for List Arrows\n\u003c/p\u003e\u003cp\u003eThis module defines conditional combinators for list arrows.\n\u003c/p\u003e\u003cp\u003eThe empty list as result represents False, none empty lists True.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "ArrowIf",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowIf.html",
          "type": "module"
        },
        "index": {
          "description": "Conditionals for List Arrows This module defines conditional combinators for list arrows The empty list as result represents False none empty lists True",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "ArrowIf",
          "package": "hxt",
          "partial": "Arrow If",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for arrows as conditionals.\n\u003c/p\u003e\u003cp\u003eRequires list arrows because False is represented as empty list, True as none empty lists.\n\u003c/p\u003e\u003cp\u003eOnly \u003ccode\u003e\u003ca\u003eifA\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eorElse\u003c/a\u003e\u003c/code\u003e don't have default implementations\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "ArrowIf",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowIf.html#ArrowIf",
          "type": "class"
        },
        "index": {
          "description": "The interface for arrows as conditionals Requires list arrows because False is represented as empty list True as none empty lists Only ifA and orElse don have default implementations",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "ArrowIf",
          "package": "hxt",
          "partial": "Arrow If",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#t:ArrowIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean auxiliary data type for \u003ccode\u003e\u003ca\u003echoiceA\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "IfThen",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowIf.html#IfThen",
          "type": "data"
        },
        "index": {
          "description": "an auxiliary data type for choiceA",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "IfThen",
          "package": "hxt",
          "partial": "If Then",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#t:IfThen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowIf",
          "name": ":-\u003e",
          "package": "hxt",
          "signature": "a :-\u003e b",
          "source": "src/Control-Arrow-ArrowIf.html#IfThen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": ":-\u003e",
          "normalized": "a-\u003eb",
          "package": "hxt",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v::-45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralisation of \u003ccode\u003e\u003ca\u003eorElse\u003c/a\u003e\u003c/code\u003e for multi way branches like in case expressions.\n\u003c/p\u003e\u003cp\u003eAn auxiliary data type \u003ccode\u003e\u003ca\u003eIfThen\u003c/a\u003e\u003c/code\u003e with an infix constructor \u003ccode\u003e\u003ca\u003e:-\u003e\u003c/a\u003e\u003c/code\u003e is used for writing multi way branches\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e choiceA [ p1 :-\u003e e1, p2 :-\u003e e2, this :-\u003e default ] \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "choiceA",
          "package": "hxt",
          "signature": "[IfThen (a b c) (a b d)] -\u003e a b d",
          "source": "src/Control-Arrow-ArrowIf.html#choiceA",
          "type": "method"
        },
        "index": {
          "description": "generalisation of orElse for multi way branches like in case expressions An auxiliary data type IfThen with an infix constructor is used for writing multi way branches example choiceA p1 e1 p2 e2 this default",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "choiceA",
          "normalized": "[IfThen(a b c)(a b d)]-\u003ea b d",
          "package": "hxt",
          "signature": "[IfThen(a b c)(a b d)]-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:choiceA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e f `containing` g \u003c/code\u003e : keep only those results from f for which g holds\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e f `containing` g = f \u003e\u003e\u003e g `guards` this \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "containing",
          "package": "hxt",
          "signature": "a b c -\u003e a c d -\u003e a b c",
          "source": "src/Control-Arrow-ArrowIf.html#containing",
          "type": "method"
        },
        "index": {
          "description": "containing keep only those results from for which holds definition containing guards this",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "containing",
          "normalized": "a b c-\u003ea c d-\u003ea b c",
          "package": "hxt",
          "signature": "a b c-\u003ea c d-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:containing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshortcut for \u003ccode\u003e f \u003ccode\u003e\u003ca\u003eguards\u003c/a\u003e\u003c/code\u003e this \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "filterA",
          "package": "hxt",
          "signature": "a b c -\u003e a b b",
          "source": "src/Control-Arrow-ArrowIf.html#filterA",
          "type": "method"
        },
        "index": {
          "description": "shortcut for guards this",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "filterA",
          "normalized": "a b c-\u003ea b b",
          "package": "hxt",
          "signature": "a b c-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:filterA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e g `guards` f \u003c/code\u003e : when the predicate g holds, f is applied, else none\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "guards",
          "package": "hxt",
          "signature": "a b c -\u003e a b d -\u003e a b d",
          "source": "src/Control-Arrow-ArrowIf.html#guards",
          "type": "method"
        },
        "index": {
          "description": "guards when the predicate holds is applied else none",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "guards",
          "normalized": "a b c-\u003ea b d-\u003ea b d",
          "package": "hxt",
          "signature": "a b c-\u003ea b d-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:guards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003ewhenP\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "guardsP",
          "package": "hxt",
          "signature": "(b -\u003e Bool) -\u003e a b d -\u003e a b d",
          "source": "src/Control-Arrow-ArrowIf.html#guardsP",
          "type": "method"
        },
        "index": {
          "description": "like whenP",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "guardsP",
          "normalized": "(a-\u003eBool)-\u003eb a c-\u003eb a c",
          "package": "hxt",
          "signature": "(b-\u003eBool)-\u003ea b d-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:guardsP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif lifted to arrows\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "ifA",
          "package": "hxt",
          "signature": "a b c -\u003e a b d -\u003e a b d -\u003e a b d",
          "source": "src/Control-Arrow-ArrowIf.html#ifA",
          "type": "method"
        },
        "index": {
          "description": "if lifted to arrows",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "ifA",
          "normalized": "a b c-\u003ea b d-\u003ea b d-\u003ea b d",
          "package": "hxt",
          "signature": "a b c-\u003ea b d-\u003ea b d-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:ifA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshortcut: \u003ccode\u003e ifP p = ifA (isA p) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "ifP",
          "package": "hxt",
          "signature": "(b -\u003e Bool) -\u003e a b d -\u003e a b d -\u003e a b d",
          "source": "src/Control-Arrow-ArrowIf.html#ifP",
          "type": "method"
        },
        "index": {
          "description": "shortcut ifP ifA isA",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "ifP",
          "normalized": "(a-\u003eBool)-\u003eb a c-\u003eb a c-\u003eb a c",
          "package": "hxt",
          "signature": "(b-\u003eBool)-\u003ea b d-\u003ea b d-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:ifP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegation: \u003ccode\u003e neg f = ifA f none this \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "neg",
          "package": "hxt",
          "signature": "a b c -\u003e a b b",
          "source": "src/Control-Arrow-ArrowIf.html#neg",
          "type": "method"
        },
        "index": {
          "description": "negation neg ifA none this",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "neg",
          "normalized": "a b c-\u003ea b b",
          "package": "hxt",
          "signature": "a b c-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:neg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e f `notContaining` g \u003c/code\u003e : keep only those results from f for which g does not hold\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e f `notContaining` g = f \u003e\u003e\u003e ifA g none this \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "notContaining",
          "package": "hxt",
          "signature": "a b c -\u003e a c d -\u003e a b c",
          "source": "src/Control-Arrow-ArrowIf.html#notContaining",
          "type": "method"
        },
        "index": {
          "description": "notContaining keep only those results from for which does not hold definition notContaining ifA none this",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "notContaining",
          "normalized": "a b c-\u003ea c d-\u003ea b c",
          "package": "hxt",
          "partial": "Containing",
          "signature": "a b c-\u003ea c d-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:notContaining"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e f `orElse` g \u003c/code\u003e : directional choice: if f succeeds, the result of f is the result, else g is applied\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "orElse",
          "package": "hxt",
          "signature": "a b c -\u003e a b c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowIf.html#orElse",
          "type": "method"
        },
        "index": {
          "description": "orElse directional choice if succeeds the result of is the result else is applied",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "orElse",
          "normalized": "a b c-\u003ea b c-\u003ea b c",
          "package": "hxt",
          "partial": "Else",
          "signature": "a b c-\u003ea b c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:orElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epartition a list of values into a pair of lists\n\u003c/p\u003e\u003cp\u003eThis is the arrow Version of \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "partitionA",
          "package": "hxt",
          "signature": "a b b -\u003e a [b] ([b], [b])",
          "source": "src/Control-Arrow-ArrowIf.html#partitionA",
          "type": "method"
        },
        "index": {
          "description": "partition list of values into pair of lists This is the arrow Version of partition",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "partitionA",
          "normalized": "a b b-\u003ea[b]([b],[b])",
          "package": "hxt",
          "signature": "a b b-\u003ea[b]([b],[b])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:partitionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a list value with an arrow and returns a pair of lists.\n This is the arrow version of \u003ccode\u003e\u003ca\u003espan\u003c/a\u003e\u003c/code\u003e. The arrow is deterministic.\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e runLA (spanA (isA (/= '-'))) \"abc-def\" \u003c/code\u003e gives \u003ccode\u003e [(\"abc\",\"-def\")] \u003c/code\u003e as result\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "spanA",
          "package": "hxt",
          "signature": "a b b -\u003e a [b] ([b], [b])",
          "source": "src/Control-Arrow-ArrowIf.html#spanA",
          "type": "method"
        },
        "index": {
          "description": "split list value with an arrow and returns pair of lists This is the arrow version of span The arrow is deterministic example runLA spanA isA abc-def gives abc def as result",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "spanA",
          "normalized": "a b b-\u003ea[b]([b],[b])",
          "package": "hxt",
          "signature": "a b b-\u003ea[b]([b],[b])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:spanA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etag a value with Left or Right, if arrow has success, input is tagged with Left, else with Right\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "tagA",
          "package": "hxt",
          "signature": "a b c -\u003e a b (Either b b)",
          "source": "src/Control-Arrow-ArrowIf.html#tagA",
          "type": "method"
        },
        "index": {
          "description": "tag value with Left or Right if arrow has success input is tagged with Left else with Right",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "tagA",
          "normalized": "a b c-\u003ea b(Either b b)",
          "package": "hxt",
          "signature": "a b c-\u003ea b(Either b b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:tagA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e f `when` g \u003c/code\u003e : when the predicate g holds, f is applied, else the identity filter this\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "when",
          "package": "hxt",
          "signature": "a b b -\u003e a b c -\u003e a b b",
          "source": "src/Control-Arrow-ArrowIf.html#when",
          "type": "method"
        },
        "index": {
          "description": "when when the predicate holds is applied else the identity filter this",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "when",
          "normalized": "a b b-\u003ea b c-\u003ea b b",
          "package": "hxt",
          "signature": "a b b-\u003ea b c-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:when"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e f `whenNot` g \u003c/code\u003e : when the predicate g does not hold, f is applied, else the identity filter this\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "whenNot",
          "package": "hxt",
          "signature": "a b b -\u003e a b c -\u003e a b b",
          "source": "src/Control-Arrow-ArrowIf.html#whenNot",
          "type": "method"
        },
        "index": {
          "description": "whenNot when the predicate does not hold is applied else the identity filter this",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "whenNot",
          "normalized": "a b b-\u003ea b c-\u003ea b b",
          "package": "hxt",
          "partial": "Not",
          "signature": "a b b-\u003ea b c-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:whenNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003ewhenP\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "whenNotP",
          "package": "hxt",
          "signature": "a b b -\u003e (b -\u003e Bool) -\u003e a b b",
          "source": "src/Control-Arrow-ArrowIf.html#whenNotP",
          "type": "method"
        },
        "index": {
          "description": "like whenP",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "whenNotP",
          "normalized": "a b b-\u003e(b-\u003eBool)-\u003ea b b",
          "package": "hxt",
          "partial": "Not",
          "signature": "a b b-\u003e(b-\u003eBool)-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:whenNotP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshortcut: \u003ccode\u003e f `whenP` p = f `when` (isA p) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowIf",
          "name": "whenP",
          "package": "hxt",
          "signature": "a b b -\u003e (b -\u003e Bool) -\u003e a b b",
          "source": "src/Control-Arrow-ArrowIf.html#whenP",
          "type": "method"
        },
        "index": {
          "description": "shortcut whenP when isA",
          "hierarchy": "Control Arrow ArrowIf",
          "module": "Control.Arrow.ArrowIf",
          "name": "whenP",
          "normalized": "a b b-\u003e(b-\u003eBool)-\u003ea b b",
          "package": "hxt",
          "signature": "a b b-\u003e(b-\u003eBool)-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowIf.html#v:whenP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe list arrow class\n\u003c/p\u003e\u003cp\u003eThis module defines the interface for list arrows.\n\u003c/p\u003e\u003cp\u003eA list arrow is a function, that gives a list of results\n   for a given argument. A single element result represents a normal function.\n   An empty list oven indicates, the function is undefined for the given argument.\n   The empty list may also represent False, none empty lists True.\n   A list with more than one element gives all results for a nondeterministic function.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "ArrowList",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowList.html",
          "type": "module"
        },
        "index": {
          "description": "The list arrow class This module defines the interface for list arrows list arrow is function that gives list of results for given argument single element result represents normal function An empty list oven indicates the function is undefined for the given argument The empty list may also represent False none empty lists True list with more than one element gives all results for nondeterministic function",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "ArrowList",
          "package": "hxt",
          "partial": "Arrow List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for list arrows\n\u003c/p\u003e\u003cp\u003eOnly \u003ccode\u003emkA\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisA\u003c/a\u003e\u003c/code\u003e '(\u003e\u003e.)' don't have default implementations\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "ArrowList",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowList.html#ArrowList",
          "type": "class"
        },
        "index": {
          "description": "The interface for list arrows Only mkA isA don have default implementations",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "ArrowList",
          "package": "hxt",
          "partial": "Arrow List",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#t:ArrowList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompute the parameter for an arrow with extra parameters from the input\n and apply the arrow for all parameter values to the input\n\u003c/p\u003e\u003cp\u003ea kind of \"function call\" for arrows, useful for joining arrows\n\u003c/p\u003e\u003cpre\u003e infixl 2 ($\u003c)\n\u003c/pre\u003e\u003cp\u003edefinition:\n\u003c/p\u003e\u003cpre\u003e g $\u003c f = applyA (f \u003e\u003e\u003e arr g)\n\u003c/pre\u003e\u003cp\u003eif \u003ccode\u003ef\u003c/code\u003e fails, the whole arrow fails, e.g. \u003ccode\u003e g $\u003c none == none \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eif \u003ccode\u003ef\u003c/code\u003e computes n values and \u003ccode\u003eg\u003c/code\u003e is deterministic, the whole arrow computes n values\n\u003c/p\u003e\u003cp\u003eexamples with simple list arrows with strings\n\u003c/p\u003e\u003cpre\u003e prefixString   :: String -\u003e a String String\n prefixString s =  arr (s++)\n\n runLA ( prefixString $\u003c none           ) \"x\" == []\n runLA ( prefixString $\u003c constA \"y\"     ) \"x\" == [\"yx\"]\n runLA ( prefixString $\u003c this           ) \"x\" == [\"xx\"]\n runLA ( prefixString $\u003c constA \"y\"\n                         \u003c+\u003e constA \"z\" ) \"x\" == [\"yx\",\"zx\"]\n runLA ( prefixString $\u003c constA \"y\"\n                         \u003c+\u003e this\n                         \u003c+\u003e constA \"z\" ) \"x\" == [\"yx\",\"xx\",\"zx\"]\n\u003c/pre\u003e\u003cp\u003esee also: \u003ccode\u003e\u003ca\u003eapplyA\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c\u003c\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c\u003c\u003c\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c$\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c)",
          "package": "hxt",
          "signature": "(c -\u003e a b d) -\u003e a b c -\u003e a b d",
          "source": "src/Control-Arrow-ArrowList.html#%24%3C",
          "type": "method"
        },
        "index": {
          "description": "compute the parameter for an arrow with extra parameters from the input and apply the arrow for all parameter values to the input kind of function call for arrows useful for joining arrows infixl definition applyA arr if fails the whole arrow fails e.g none none if computes values and is deterministic the whole arrow computes values examples with simple list arrows with strings prefixString String String String prefixString arr runLA prefixString none runLA prefixString constA yx runLA prefixString this xx runLA prefixString constA constA yx zx runLA prefixString constA this constA yx xx zx see also applyA",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c) $\u003c",
          "normalized": "(a-\u003eb c d)-\u003eb c a-\u003eb c d",
          "package": "hxt",
          "signature": "(c-\u003ea b d)-\u003ea b c-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:-36--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompute the parameter for an arrow \u003ccode\u003ef\u003c/code\u003e with an extra parameter by an arrow \u003ccode\u003eg\u003c/code\u003e\n and apply all the results from \u003ccode\u003eg\u003c/code\u003e sequentially to the input\n\u003c/p\u003e\u003cpre\u003e infixl 2 ($\u003c$)\n\u003c/pre\u003e\u003cp\u003etypical usage:\n\u003c/p\u003e\u003cpre\u003e g :: a b c\n g = ...\n\n f :: c -\u003e a b b\n f x = ... x ...\n\n f $\u003c$ g\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ef\u003c/code\u003e computes the extra parameters for \u003ccode\u003eg\u003c/code\u003e from the input of type \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e is applied with this\n parameter to the input. This allows programming in a point wise style in \u003ccode\u003eg\u003c/code\u003e, which becomes\n neccessary, when a value is needed more than once.\n\u003c/p\u003e\u003cp\u003ethis combinator is useful, when transforming a single value (document) step by step,\n with \u003ccode\u003eg\u003c/code\u003e for collecting the data for all steps, and \u003ccode\u003ef\u003c/code\u003e for transforming the input step by step\n\u003c/p\u003e\u003cp\u003eif \u003ccode\u003eg\u003c/code\u003e is deterministic (computes exactly one result),\n \u003ccode\u003e g $\u003c$ f == g $\u003c f \u003c/code\u003e holds\n\u003c/p\u003e\u003cp\u003eif \u003ccode\u003eg\u003c/code\u003e fails, \u003ccode\u003e f $\u003c$ g == this \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eif \u003ccode\u003eg\u003c/code\u003e computes more than one result, \u003ccode\u003ef\u003c/code\u003e is applied sequentially to the input for every result from \u003ccode\u003eg\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexamples with simple list arrows with strings\n\u003c/p\u003e\u003cpre\u003e prefixString   :: String -\u003e a String String\n prefixString s =  arr (s++)\n\n runLA ( prefixString $\u003c$ none                      ) \"x\" == [\"x\"]\n runLA ( prefixString $\u003c$ constA \"y\"                ) \"x\" == [\"yx\"]\n runLA ( prefixString $\u003c$ constA \"y\" \u003c+\u003e constA \"z\" ) \"x\" == [\"zyx\"]\n runLA ( prefixString $\u003c$ constA \"y\" \u003c+\u003e this\n                          \u003c+\u003e constA \"z\"            ) \"x\" == [\"zxyx\"]\n\u003c/pre\u003e\u003cp\u003eexample with two extra parameter\n\u003c/p\u003e\u003cpre\u003e g1 :: a b c1\n g2 :: a b c2\n\n f          :: (c1, c2) -\u003e a b b\n f (x1, x2) =  ... x1 ... x2 ...\n\n f $\u003c$ g1 &&& g2\n\u003c/pre\u003e\u003cp\u003esee also: \u003ccode\u003e\u003ca\u003eapplyA\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c$)",
          "package": "hxt",
          "signature": "(c -\u003e a b b) -\u003e a b c -\u003e a b b",
          "source": "src/Control-Arrow-ArrowList.html#%24%3C%24",
          "type": "method"
        },
        "index": {
          "description": "compute the parameter for an arrow with an extra parameter by an arrow and apply all the results from sequentially to the input infixl typical usage computes the extra parameters for from the input of type and is applied with this parameter to the input This allows programming in point wise style in which becomes neccessary when value is needed more than once this combinator is useful when transforming single value document step by step with for collecting the data for all steps and for transforming the input step by step if is deterministic computes exactly one result holds if fails this if computes more than one result is applied sequentially to the input for every result from examples with simple list arrows with strings prefixString String String String prefixString arr runLA prefixString none runLA prefixString constA yx runLA prefixString constA constA zyx runLA prefixString constA this constA zxyx example with two extra parameter g1 c1 g2 c2 c1 c2 x1 x2 x1 x2 g1 g2 see also applyA",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c$) $\u003c$",
          "normalized": "(a-\u003eb c c)-\u003eb c a-\u003eb c c",
          "package": "hxt",
          "signature": "(c-\u003ea b b)-\u003ea b c-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:-36--60--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebinary version of \u003ccode\u003e\u003ca\u003e$\u003c\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexample with simple list arrows with strings\n\u003c/p\u003e\u003cpre\u003e infixString    :: String -\u003e String -\u003e a String String\n infixString s1 s2\n                = arr (\\ s -\u003e s1 ++ s ++ s2)\n\n runLA ( infixString $\u003c\u003c constA \"y\" &&& constA \"z\" ) \"x\" = [\"yxz\"]\n runLA ( infixString $\u003c\u003c this &&& this             ) \"x\" = [\"xxx\"]\n runLA ( infixString $\u003c\u003c constA \"y\"\n                         &&& (constA \"z\" \u003c+\u003e this) ) \"x\" = [\"yxz\", \"yxx\"]\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c\u003c)",
          "package": "hxt",
          "signature": "(c1 -\u003e c2 -\u003e a b d) -\u003e a b (c1, c2) -\u003e a b d",
          "source": "src/Control-Arrow-ArrowList.html#%24%3C%3C",
          "type": "method"
        },
        "index": {
          "description": "binary version of example with simple list arrows with strings infixString String String String String infixString s1 s2 arr s1 s2 runLA infixString constA constA yxz runLA infixString this this xxx runLA infixString constA constA this yxz yxx",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c\u003c) $\u003c\u003c",
          "normalized": "(a-\u003ea-\u003eb c d)-\u003eb c(a,a)-\u003eb c d",
          "package": "hxt",
          "signature": "(c-\u003ec-\u003ea b d)-\u003ea b(c,c)-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:-36--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eversion of \u003ccode\u003e\u003ca\u003e$\u003c\u003c/a\u003e\u003c/code\u003e for arrows with 3 extra parameters\n\u003c/p\u003e\u003cp\u003etypical usage\n\u003c/p\u003e\u003cpre\u003e f $\u003c\u003c\u003c g1 &&& g2 &&& g3\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c\u003c\u003c)",
          "package": "hxt",
          "signature": "(c1 -\u003e c2 -\u003e c3 -\u003e a b d) -\u003e a b (c1, (c2, c3)) -\u003e a b d",
          "source": "src/Control-Arrow-ArrowList.html#%24%3C%3C%3C",
          "type": "method"
        },
        "index": {
          "description": "version of for arrows with extra parameters typical usage g1 g2 g3",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c\u003c\u003c) $\u003c\u003c\u003c",
          "normalized": "(a-\u003ea-\u003ea-\u003eb c d)-\u003eb c(a,(a,a))-\u003eb c d",
          "package": "hxt",
          "signature": "(c-\u003ec-\u003ec-\u003ea b d)-\u003ea b(c,(c,c))-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:-36--60--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eversion of \u003ccode\u003e\u003ca\u003e$\u003c\u003c/a\u003e\u003c/code\u003e for arrows with 4 extra parameters\n\u003c/p\u003e\u003cp\u003etypical usage\n\u003c/p\u003e\u003cpre\u003e f $\u003c\u003c\u003c\u003c g1 &&& g2 &&& g3 &&& g4\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c\u003c\u003c\u003c)",
          "package": "hxt",
          "signature": "(c1 -\u003e c2 -\u003e c3 -\u003e c4 -\u003e a b d) -\u003e a b (c1, (c2, (c3, c4))) -\u003e a b d",
          "source": "src/Control-Arrow-ArrowList.html#%24%3C%3C%3C%3C",
          "type": "method"
        },
        "index": {
          "description": "version of for arrows with extra parameters typical usage g1 g2 g3 g4",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "($\u003c\u003c\u003c\u003c) $\u003c\u003c\u003c\u003c",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003eb c d)-\u003eb c(a,(a,(a,a)))-\u003eb c d",
          "package": "hxt",
          "signature": "(c-\u003ec-\u003ec-\u003ec-\u003ea b d)-\u003ea b(c,(c,(c,c)))-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:-36--60--60--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecombinator for converting the result of a list arrow into another list\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e foo \u003e\u003e. reverse \u003c/code\u003e reverses the the result of foo\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e foo \u003e\u003e. take 1 \u003c/code\u003e constructs a deterministic version of foo by deleting all further results\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "(\u003e\u003e.)",
          "package": "hxt",
          "signature": "a b c -\u003e ([c] -\u003e [d]) -\u003e a b d",
          "source": "src/Control-Arrow-ArrowList.html#%3E%3E.",
          "type": "method"
        },
        "index": {
          "description": "combinator for converting the result of list arrow into another list example foo reverse reverses the the result of foo example foo take constructs deterministic version of foo by deleting all further results",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "(\u003e\u003e.) \u003e\u003e.",
          "normalized": "a b c-\u003e([c]-\u003e[d])-\u003ea b d",
          "package": "hxt",
          "signature": "a b c-\u003e([c]-\u003e[d])-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:-62--62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecombinator for converting the result of an arrow into a single element result\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "(\u003e.)",
          "package": "hxt",
          "signature": "a b c -\u003e ([c] -\u003e d) -\u003e a b d",
          "source": "src/Control-Arrow-ArrowList.html#%3E.",
          "type": "method"
        },
        "index": {
          "description": "combinator for converting the result of an arrow into single element result",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "(\u003e.) \u003e.",
          "normalized": "a b c-\u003e([c]-\u003ed)-\u003ea b d",
          "package": "hxt",
          "signature": "a b c-\u003e([c]-\u003ed)-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:-62-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompute an arrow from the input and apply the arrow to this input\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e (f &&& this) \u003e\u003e\u003e app \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003ein a point free style, there is no way to use an argument in 2 places,\n this is a combinator for simulating this. first the argument is used to compute an arrow,\n then this new arrow is applied to the input\n\u003c/p\u003e\u003cp\u003eapplyA coresponds to: \u003ccode\u003e apply f x = let g = f x in g x \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003esee also: \u003ccode\u003e\u003ca\u003e$\u003c\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c\u003c\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c\u003c\u003c\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c$\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "applyA",
          "package": "hxt",
          "signature": "a b (a b c) -\u003e a b c",
          "source": "src/Control-Arrow-ArrowList.html#applyA",
          "type": "method"
        },
        "index": {
          "description": "compute an arrow from the input and apply the arrow to this input definition this app in point free style there is no way to use an argument in places this is combinator for simulating this first the argument is used to compute an arrow then this new arrow is applied to the input applyA coresponds to apply let in see also",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "applyA",
          "normalized": "a b(a b c)-\u003ea b c",
          "package": "hxt",
          "signature": "a b(a b c)-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:applyA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of a 2 argument arrow from a binary function\n |\n | example: \u003ccode\u003e a1 &&& a2 \u003e\u003e\u003e arr2 f \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "arr2",
          "package": "hxt",
          "signature": "(b1 -\u003e b2 -\u003e c) -\u003e a (b1, b2) c",
          "source": "src/Control-Arrow-ArrowList.html#arr2",
          "type": "method"
        },
        "index": {
          "description": "construction of argument arrow from binary function example a1 a2 arr2",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "arr2",
          "normalized": "(a-\u003ea-\u003eb)-\u003ec(a,a)b",
          "package": "hxt",
          "signature": "(b-\u003eb-\u003ec)-\u003ea(b,b)c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:arr2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of a 2 argument arrow from a singe argument arrow\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "arr2A",
          "package": "hxt",
          "signature": "(b -\u003e a c d) -\u003e a (b, c) d",
          "source": "src/Control-Arrow-ArrowList.html#arr2A",
          "type": "method"
        },
        "index": {
          "description": "construction of argument arrow from singe argument arrow",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "arr2A",
          "normalized": "(a-\u003eb c d)-\u003eb(a,c)d",
          "package": "hxt",
          "signature": "(b-\u003ea c d)-\u003ea(b,c)d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:arr2A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor for a list arrow with 2 arguments\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "arr2L",
          "package": "hxt",
          "signature": "(b -\u003e c -\u003e [d]) -\u003e a (b, c) d",
          "source": "src/Control-Arrow-ArrowList.html#arr2L",
          "type": "method"
        },
        "index": {
          "description": "constructor for list arrow with arguments",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "arr2L",
          "normalized": "(a-\u003eb-\u003e[c])-\u003ed(a,b)c",
          "package": "hxt",
          "signature": "(b-\u003ec-\u003e[d])-\u003ea(b,c)d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:arr2L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of a 3 argument arrow from a 3-ary function\n |\n | example: \u003ccode\u003e a1 &&& a2 &&& a3 \u003e\u003e\u003e arr3 f \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "arr3",
          "package": "hxt",
          "signature": "(b1 -\u003e b2 -\u003e b3 -\u003e c) -\u003e a (b1, (b2, b3)) c",
          "source": "src/Control-Arrow-ArrowList.html#arr3",
          "type": "method"
        },
        "index": {
          "description": "construction of argument arrow from ary function example a1 a2 a3 arr3",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "arr3",
          "normalized": "(a-\u003ea-\u003ea-\u003eb)-\u003ec(a,(a,a))b",
          "package": "hxt",
          "signature": "(b-\u003eb-\u003eb-\u003ec)-\u003ea(b,(b,b))c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:arr3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of a 4 argument arrow from a 4-ary function\n |\n | example: \u003ccode\u003e a1 &&& a2 &&& a3 &&& a4 \u003e\u003e\u003e arr4 f \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "arr4",
          "package": "hxt",
          "signature": "(b1 -\u003e b2 -\u003e b3 -\u003e b4 -\u003e c) -\u003e a (b1, (b2, (b3, b4))) c",
          "source": "src/Control-Arrow-ArrowList.html#arr4",
          "type": "method"
        },
        "index": {
          "description": "construction of argument arrow from ary function example a1 a2 a3 a4 arr4",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "arr4",
          "normalized": "(a-\u003ea-\u003ea-\u003ea-\u003eb)-\u003ec(a,(a,(a,a)))b",
          "package": "hxt",
          "signature": "(b-\u003eb-\u003eb-\u003eb-\u003ec)-\u003ea(b,(b,(b,b)))c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:arr4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor for a list arrow from a function with a list as result\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "arrL",
          "package": "hxt",
          "signature": "(b -\u003e [c]) -\u003e a b c",
          "source": "src/Control-Arrow-ArrowList.html#arrL",
          "type": "method"
        },
        "index": {
          "description": "constructor for list arrow from function with list as result",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "arrL",
          "normalized": "(a-\u003e[b])-\u003ec a b",
          "package": "hxt",
          "signature": "(b-\u003e[c])-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:arrL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralization of arrow combinator \u003ccode\u003e\u003ca\u003e\u003c+\u003e\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e catA = foldl (\u003c+\u003e) none \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "catA",
          "package": "hxt",
          "signature": "[a b c] -\u003e a b c",
          "source": "src/Control-Arrow-ArrowList.html#catA",
          "type": "method"
        },
        "index": {
          "description": "generalization of arrow combinator definition catA foldl none",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "catA",
          "normalized": "[a b c]-\u003ea b c",
          "package": "hxt",
          "signature": "[a b c]-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:catA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor for a const arrow: \u003ccode\u003e constA = arr . const \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "constA",
          "package": "hxt",
          "signature": "c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowList.html#constA",
          "type": "method"
        },
        "index": {
          "description": "constructor for const arrow constA arr const",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "constA",
          "normalized": "a-\u003eb c a",
          "package": "hxt",
          "signature": "c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:constA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor for a const arrow: \u003ccode\u003e constL = arrL . const \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "constL",
          "package": "hxt",
          "signature": "[c] -\u003e a b c",
          "source": "src/Control-Arrow-ArrowList.html#constL",
          "type": "method"
        },
        "index": {
          "description": "constructor for const arrow constL arrL const",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "constL",
          "normalized": "[a]-\u003eb c a",
          "package": "hxt",
          "signature": "[c]-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:constL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilds an arrow from a predicate.\n If the predicate holds, the single list containing the input is returned, else the empty list\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "isA",
          "package": "hxt",
          "signature": "(b -\u003e Bool) -\u003e a b b",
          "source": "src/Control-Arrow-ArrowList.html#isA",
          "type": "method"
        },
        "index": {
          "description": "builds an arrow from predicate If the predicate holds the single list containing the input is returned else the empty list",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "isA",
          "normalized": "(a-\u003eBool)-\u003eb a a",
          "package": "hxt",
          "signature": "(b-\u003eBool)-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:isA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecombinator for converting an arrow into a determinstic version with all results collected in a single element list\n\u003c/p\u003e\u003cpre\u003e listA af = af \u003e\u003e. (:[])\u003c/pre\u003e\u003cp\u003ethis is useful when the list of results computed by an arrow must be manipulated (e.g. sorted)\n\u003c/p\u003e\u003cp\u003eexample for sorting the results of a filter\n\u003c/p\u003e\u003cpre\u003e collectAndSort         :: a b c -\u003e a b c\n\n collectAndSort collect = listA collect \u003e\u003e\u003e arrL sort\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "listA",
          "package": "hxt",
          "signature": "a b c -\u003e a b [c]",
          "source": "src/Control-Arrow-ArrowList.html#listA",
          "type": "method"
        },
        "index": {
          "description": "combinator for converting an arrow into determinstic version with all results collected in single element list listA af af this is useful when the list of results computed by an arrow must be manipulated e.g sorted example for sorting the results of filter collectAndSort collectAndSort collect listA collect arrL sort",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "listA",
          "normalized": "a b c-\u003ea b[c]",
          "package": "hxt",
          "signature": "a b c-\u003ea b[c]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:listA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emerge the result pairs of an arrow with type \u003ccode\u003ea a1 (b1, b2)\u003c/code\u003e\n by combining the tuple components with the \u003ccode\u003eop\u003c/code\u003e arrow\n\u003c/p\u003e\u003cp\u003eexamples with simple list arrows working on strings and XmlTrees\n\u003c/p\u003e\u003cpre\u003e     a1 :: a String (XmlTree, XmlTree)\n     a1 = selem \"foo\" [this \u003e\u003e\u003e mkText]\n          &&&\n          selem \"bar\" [arr (++\"0\") \u003e\u003e\u003e mkText]\n\n     runLA (a1 \u003e\u003e\u003e mergeA (\u003c+\u003e) \u003e\u003e\u003e xshow this) \"42\" == [\"\u003cfoo\u003e42\u003c/foo\u003e\",\"\u003cbar\u003e420\u003c/bar\u003e\"]\n     runLA (a1 \u003e\u003e\u003e mergeA (+=)  \u003e\u003e\u003e xshow this) \"42\" == [\"\u003cfoo\u003e42\u003cbar\u003e420\u003c/bar\u003e\u003c/foo\u003e\"]\n\u003c/pre\u003e\u003cp\u003esee also: \u003ccode\u003e\u003ca\u003eapplyA\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e$\u003c\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e+=\u003c/code\u003e in class \u003ccode\u003e\u003ca\u003eArrowXml\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "mergeA",
          "package": "hxt",
          "signature": "(a (a1, b1) a1 -\u003e a (a1, b1) b1 -\u003e a (a1, b1) c) -\u003e a (a1, b1) c",
          "source": "src/Control-Arrow-ArrowList.html#mergeA",
          "type": "method"
        },
        "index": {
          "description": "merge the result pairs of an arrow with type a1 b1 b2 by combining the tuple components with the op arrow examples with simple list arrows working on strings and XmlTrees a1 String XmlTree XmlTree a1 selem foo this mkText selem bar arr mkText runLA a1 mergeA xshow this foo foo bar bar runLA a1 mergeA xshow this foo bar bar foo see also applyA and in class ArrowXml",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "mergeA",
          "normalized": "(a(a,b)a-\u003ea(a,b)b-\u003ea(a,b)c)-\u003ea(a,b)c",
          "package": "hxt",
          "signature": "(a(a,b)a-\u003ea(a,b)b-\u003ea(a,b)c)-\u003ea(a,b)c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:mergeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe zero arrow, alias for zeroArrow\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "none",
          "package": "hxt",
          "signature": "a b c",
          "source": "src/Control-Arrow-ArrowList.html#none",
          "type": "method"
        },
        "index": {
          "description": "the zero arrow alias for zeroArrow",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "none",
          "package": "hxt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:none"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euseful only for arrows with side effects: perform applies an arrow to the input\n ignores the result and returns the input\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e ... \u003e\u003e\u003e perform someTraceArrow \u003e\u003e\u003e ... \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "perform",
          "package": "hxt",
          "signature": "a b c -\u003e a b b",
          "source": "src/Control-Arrow-ArrowList.html#perform",
          "type": "method"
        },
        "index": {
          "description": "useful only for arrows with side effects perform applies an arrow to the input ignores the result and returns the input example perform someTraceArrow",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "perform",
          "normalized": "a b c-\u003ea b b",
          "package": "hxt",
          "signature": "a b c-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:perform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralization of arrow combinator \u003ccode\u003e\u003ca\u003e\u003e\u003e\u003e\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e seqA = foldl (\u003e\u003e\u003e) this \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "seqA",
          "package": "hxt",
          "signature": "[a b b] -\u003e a b b",
          "source": "src/Control-Arrow-ArrowList.html#seqA",
          "type": "method"
        },
        "index": {
          "description": "generalization of arrow combinator definition seqA foldl this",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "seqA",
          "normalized": "[a b b]-\u003ea b b",
          "package": "hxt",
          "signature": "[a b b]-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:seqA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emakes a list arrow deterministic, the number of results is at most 1\n\u003c/p\u003e\u003cp\u003edefinition\n\u003c/p\u003e\u003cpre\u003e single f = f \u003e\u003e. take 1\n\u003c/pre\u003e\u003cp\u003eexamples with strings:\n\u003c/p\u003e\u003cpre\u003e runLA ( single none ) \"x\" == []\n runLA ( single this ) \"x\" == [\"x\"]\n runLA ( single\n         (constA \"y\"\n          \u003c+\u003e this ) ) \"x\" == [\"y\"]\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "single",
          "package": "hxt",
          "signature": "a b c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowList.html#single",
          "type": "method"
        },
        "index": {
          "description": "makes list arrow deterministic the number of results is at most definition single take examples with strings runLA single none runLA single this runLA single constA this",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "single",
          "normalized": "a b c-\u003ea b c",
          "package": "hxt",
          "signature": "a b c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:single"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe identity arrow, alias for returnA\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "this",
          "package": "hxt",
          "signature": "a b b",
          "source": "src/Control-Arrow-ArrowList.html#this",
          "type": "method"
        },
        "index": {
          "description": "the identity arrow alias for returnA",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "this",
          "package": "hxt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:this"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe inverse of \u003ccode\u003e\u003ca\u003elistA\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e listA af \u003e\u003e\u003e unlistA = af\u003c/pre\u003e\u003cp\u003eunlistA is defined as \u003ccode\u003e arrL id \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "unlistA",
          "package": "hxt",
          "signature": "a [b] b",
          "source": "src/Control-Arrow-ArrowList.html#unlistA",
          "type": "method"
        },
        "index": {
          "description": "the inverse of listA listA af unlistA af unlistA is defined as arrL id",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "unlistA",
          "normalized": "a[b]b",
          "package": "hxt",
          "signature": "a[b]b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:unlistA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econverts an arrow, that may fail, into an arrow that always succeeds\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e withDefault none \"abc\" \u003c/code\u003e is equivalent to \u003ccode\u003e constA \"abc\" \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowList",
          "name": "withDefault",
          "package": "hxt",
          "signature": "a b c -\u003e c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowList.html#withDefault",
          "type": "method"
        },
        "index": {
          "description": "converts an arrow that may fail into an arrow that always succeeds example withDefault none abc is equivalent to constA abc",
          "hierarchy": "Control Arrow ArrowList",
          "module": "Control.Arrow.ArrowList",
          "name": "withDefault",
          "normalized": "a b c-\u003ec-\u003ea b c",
          "package": "hxt",
          "partial": "Default",
          "signature": "a b c-\u003ec-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowList.html#v:withDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArrows for evaluation of normal form results\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowNF",
          "name": "ArrowNF",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowNF.html",
          "type": "module"
        },
        "index": {
          "description": "Arrows for evaluation of normal form results",
          "hierarchy": "Control Arrow ArrowNF",
          "module": "Control.Arrow.ArrowNF",
          "name": "ArrowNF",
          "package": "hxt",
          "partial": "Arrow NF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNF",
          "name": "ArrowNF",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowNF.html#ArrowNF",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNF",
          "module": "Control.Arrow.ArrowNF",
          "name": "ArrowNF",
          "package": "hxt",
          "partial": "Arrow NF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNF.html#t:ArrowNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epartial evaluation of an arrow result using \u003ccode\u003e\u003ca\u003eFlatSeq\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThere are tow arrows with force the partial evaluation. By convention\n the 2. should be less lazy than the 1.\n\u003c/p\u003e\u003cp\u003eThese arrows are sometimes useful for preventing space leaks, especially when parsing\n complex data structures. In many cases the evaluated AST is more space efficient\n than the unevaluaded with a lot of closures.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNF",
          "name": "ArrowWNF",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowNF.html#ArrowWNF",
          "type": "class"
        },
        "index": {
          "description": "partial evaluation of an arrow result using FlatSeq There are tow arrows with force the partial evaluation By convention the should be less lazy than the These arrows are sometimes useful for preventing space leaks especially when parsing complex data structures In many cases the evaluated AST is more space efficient than the unevaluaded with lot of closures",
          "hierarchy": "Control Arrow ArrowNF",
          "module": "Control.Arrow.ArrowNF",
          "name": "ArrowWNF",
          "package": "hxt",
          "partial": "Arrow WNF",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNF.html#t:ArrowWNF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNF",
          "name": "rnfA",
          "package": "hxt",
          "signature": "a b c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowNF.html#rnfA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNF",
          "module": "Control.Arrow.ArrowNF",
          "name": "rnfA",
          "normalized": "a b c-\u003ea b c",
          "package": "hxt",
          "signature": "a b c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNF.html#v:rnfA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNF",
          "name": "rwnf2A",
          "package": "hxt",
          "signature": "a b c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowNF.html#rwnf2A",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNF",
          "module": "Control.Arrow.ArrowNF",
          "name": "rwnf2A",
          "normalized": "a b c-\u003ea b c",
          "package": "hxt",
          "signature": "a b c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNF.html#v:rwnf2A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNF",
          "name": "rwnfA",
          "package": "hxt",
          "signature": "a b c -\u003e a b c",
          "source": "src/Control-Arrow-ArrowNF.html#rwnfA",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNF",
          "module": "Control.Arrow.ArrowNF",
          "name": "rwnfA",
          "normalized": "a b c-\u003ea b c",
          "package": "hxt",
          "signature": "a b c-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNF.html#v:rwnfA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecomplete evaluation of an arrow result using \u003ccode\u003e\u003ca\u003eDeepSeq\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003ethis is sometimes useful for preventing space leaks, especially after reading\n and validation of a document, all DTD stuff is not longer in use and can be\n recycled by the GC.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNF",
          "name": "strictA",
          "package": "hxt",
          "signature": "a b b",
          "source": "src/Control-Arrow-ArrowNF.html#strictA",
          "type": "function"
        },
        "index": {
          "description": "complete evaluation of an arrow result using DeepSeq this is sometimes useful for preventing space leaks especially after reading and validation of document all DTD stuff is not longer in use and can be recycled by the GC",
          "hierarchy": "Control Arrow ArrowNF",
          "module": "Control.Arrow.ArrowNF",
          "name": "strictA",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNF.html#v:strictA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eList arrows for navigatable trees\n\u003c/p\u003e\u003cp\u003eTrees that implement the \u003ca\u003eData.Tree.NavigatableTree.Class\u003c/a\u003e interface, can be processed\n   with these arrows.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ArrowNavigatableTree",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html",
          "type": "module"
        },
        "index": {
          "description": "List arrows for navigatable trees Trees that implement the Data.Tree.NavigatableTree.Class interface can be processed with these arrows",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ArrowNavigatableTree",
          "package": "hxt",
          "partial": "Arrow Navigatable Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for navigatable tree arrows\n\u003c/p\u003e\u003cp\u003eall functions have default implementations\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ArrowNavigatableTree",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#ArrowNavigatableTree",
          "type": "class"
        },
        "index": {
          "description": "The interface for navigatable tree arrows all functions have default implementations",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ArrowNavigatableTree",
          "package": "hxt",
          "partial": "Arrow Navigatable Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#t:ArrowNavigatableTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from a tree into a navigatable tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addNav",
          "package": "hxt",
          "signature": "a (t b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#addNav",
          "type": "function"
        },
        "index": {
          "description": "Conversion from tree into navigatable tree",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addNav",
          "package": "hxt",
          "partial": "Nav",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:addNav"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eaddToOneSide does the real work for \u003ccode\u003e\u003ca\u003eaddToTheLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eaddToTheRight\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addToOneSide",
          "package": "hxt",
          "signature": "(Maybe (nt b) -\u003e [t b] -\u003e Maybe (nt b)) -\u003e a (t b) (t b) -\u003e a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#addToOneSide",
          "type": "function"
        },
        "index": {
          "description": "addToOneSide does the real work for addToTheLeft and addToTheRight",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addToOneSide",
          "normalized": "(Maybe(a b)-\u003e[c b]-\u003eMaybe(a b))-\u003ed(c b)(c b)-\u003ed(a b)(a b)",
          "package": "hxt",
          "partial": "To One Side",
          "signature": "(Maybe(nt b)-\u003e[t b]-\u003eMaybe(nt b))-\u003ea(t b)(t b)-\u003ea(nt b)(nt b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:addToOneSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an ordinary arrow to the current subtree of a navigatabe tree and add the result trees in front of the current tree.\n\u003c/p\u003e\u003cp\u003eIf this arrow is applied to the root, it will fail, because we want a tree as result, not a forest.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addToTheLeft",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#addToTheLeft",
          "type": "function"
        },
        "index": {
          "description": "apply an ordinary arrow to the current subtree of navigatabe tree and add the result trees in front of the current tree If this arrow is applied to the root it will fail because we want tree as result not forest",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addToTheLeft",
          "normalized": "a(b c)(b c)-\u003ea(d c)(d c)",
          "package": "hxt",
          "partial": "To The Left",
          "signature": "a(t b)(t b)-\u003ea(nt b)(nt b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:addToTheLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an ordinary arrow to the current subtree of a navigatabe tree and add the result trees behind the current tree.\n\u003c/p\u003e\u003cp\u003eIf this arrow is applied to the root, it will fail, because we want a tree as result, not a forest.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addToTheRight",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#addToTheRight",
          "type": "function"
        },
        "index": {
          "description": "apply an ordinary arrow to the current subtree of navigatabe tree and add the result trees behind the current tree If this arrow is applied to the root it will fail because we want tree as result not forest",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "addToTheRight",
          "normalized": "a(b c)(b c)-\u003ea(d c)(d c)",
          "package": "hxt",
          "partial": "To The Right",
          "signature": "a(t b)(t b)-\u003ea(nt b)(nt b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:addToTheRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: ancestor\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ancestorAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#ancestorAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis ancestor",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ancestorAxis",
          "package": "hxt",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:ancestorAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: ancestor or self\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ancestorOrSelfAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#ancestorOrSelfAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis ancestor or self",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "ancestorOrSelfAxis",
          "package": "hxt",
          "partial": "Or Self Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:ancestorOrSelfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the current subtree of a navigatable tree.\n\u003c/p\u003e\u003cp\u003eThe arrow for computing the changes should be deterministic. If it fails\n nothing is changed.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "changeThisTree",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#changeThisTree",
          "type": "function"
        },
        "index": {
          "description": "Change the current subtree of navigatable tree The arrow for computing the changes should be deterministic If it fails nothing is changed",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "changeThisTree",
          "normalized": "a(b c)(b c)-\u003ea(d c)(d c)",
          "package": "hxt",
          "partial": "This Tree",
          "signature": "a(t b)(t b)-\u003ea(nt b)(nt b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:changeThisTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: child\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "childAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#childAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis child",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "childAxis",
          "package": "hxt",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:childAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: descendant\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "descendantAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#descendantAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis descendant",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "descendantAxis",
          "package": "hxt",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:descendantAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enot an XPath axis but useful: descendant or following\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "descendantOrFollowingAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#descendantOrFollowingAxis",
          "type": "function"
        },
        "index": {
          "description": "not an XPath axis but useful descendant or following",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "descendantOrFollowingAxis",
          "package": "hxt",
          "partial": "Or Following Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:descendantOrFollowingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: descendant or self\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "descendantOrSelfAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#descendantOrSelfAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis descendant or self",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "descendantOrSelfAxis",
          "package": "hxt",
          "partial": "Or Self Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:descendantOrSelfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edrop the direct left sibling tree of the given navigatable tree\n\u003c/p\u003e\u003cp\u003eIf this arrow is applied to the root or a leftmost tree, it will fail, because there is nothing to remove\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "dropFromTheLeft",
          "package": "hxt",
          "signature": "a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#dropFromTheLeft",
          "type": "function"
        },
        "index": {
          "description": "drop the direct left sibling tree of the given navigatable tree If this arrow is applied to the root or leftmost tree it will fail because there is nothing to remove",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "dropFromTheLeft",
          "package": "hxt",
          "partial": "From The Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:dropFromTheLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edrop the direct left sibling tree of the given navigatable tree\n\u003c/p\u003e\u003cp\u003eIf this arrow is applied to the root or a rightmost tree, it will fail, because there is nothing to remove\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "dropFromTheRight",
          "package": "hxt",
          "signature": "a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#dropFromTheRight",
          "type": "function"
        },
        "index": {
          "description": "drop the direct left sibling tree of the given navigatable tree If this arrow is applied to the root or rightmost tree it will fail because there is nothing to remove",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "dropFromTheRight",
          "package": "hxt",
          "partial": "From The Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:dropFromTheRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter an axis with an ordinary tree predicate\n\u003c/p\u003e\u003cp\u003eExample: In a tree of Ints find all nodes in the subtrees (in preorder) that have label 42\n\u003c/p\u003e\u003cpre\u003e descendantAxis \u003e\u003e\u003e filterAxis (hasNode (== 42))\n\u003c/pre\u003e\u003cp\u003eExample: In an XML Tree find the following nodes of a node with attribute id and value 42\n\u003c/p\u003e\u003cpre\u003e descendantAxis \u003e\u003e\u003e filterAxis (hasAttrValue \"id\" (==\"42\")) \u003e\u003e\u003e followingAxis\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "filterAxis",
          "package": "hxt",
          "signature": "a (t b) c -\u003e a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#filterAxis",
          "type": "function"
        },
        "index": {
          "description": "Filter an axis with an ordinary tree predicate Example In tree of Ints find all nodes in the subtrees in preorder that have label descendantAxis filterAxis hasNode Example In an XML Tree find the following nodes of node with attribute id and value descendantAxis filterAxis hasAttrValue id followingAxis",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "filterAxis",
          "normalized": "a(b c)d-\u003ea(e c)(e c)",
          "package": "hxt",
          "partial": "Axis",
          "signature": "a(t b)c-\u003ea(nt b)(nt b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:filterAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: following\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "followingAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#followingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis following",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "followingAxis",
          "package": "hxt",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:followingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: following sibling\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "followingSiblingAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#followingSiblingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis following sibling",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "followingSiblingAxis",
          "package": "hxt",
          "partial": "Sibling Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:followingSiblingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "isAtRoot",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#isAtRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "isAtRoot",
          "package": "hxt",
          "partial": "At Root",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:isAtRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveDown",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#moveDown",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveDown",
          "package": "hxt",
          "partial": "Down",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:moveDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveLeft",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#moveLeft",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveLeft",
          "package": "hxt",
          "partial": "Left",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:moveLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to the next tree on a given axis. Deterministic arrow\n\u003c/p\u003e\u003cp\u003eExample: Move to the next node in a preorder visit: next child or else next following\n\u003c/p\u003e\u003cpre\u003e moveOn descendantOrFollowingAxis\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveOn",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#moveOn",
          "type": "function"
        },
        "index": {
          "description": "Move to the next tree on given axis Deterministic arrow Example Move to the next node in preorder visit next child or else next following moveOn descendantOrFollowingAxis",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveOn",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "On",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:moveOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveRight",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#moveRight",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveRight",
          "package": "hxt",
          "partial": "Right",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:moveRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emove to the root\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveToRoot",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#moveToRoot",
          "type": "function"
        },
        "index": {
          "description": "move to the root",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveToRoot",
          "package": "hxt",
          "partial": "To Root",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:moveToRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveUp",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#moveUp",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "moveUp",
          "package": "hxt",
          "partial": "Up",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:moveUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "parentAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#parentAxis",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "parentAxis",
          "package": "hxt",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:parentAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: preceding\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "precedingAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#precedingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis preceding",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "precedingAxis",
          "package": "hxt",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:precedingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: preceeding sibling\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "precedingSiblingAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#precedingSiblingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis preceeding sibling",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "precedingSiblingAxis",
          "package": "hxt",
          "partial": "Sibling Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:precedingSiblingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from a navigatable tree into an ordinary tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "remNav",
          "package": "hxt",
          "signature": "a (nt b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#remNav",
          "type": "function"
        },
        "index": {
          "description": "Conversion from navigatable tree into an ordinary tree",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "remNav",
          "package": "hxt",
          "partial": "Nav",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:remNav"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enot an official XPath axis but useful: reverse descendant or self, used in preceding axis\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "revDescendantOrSelfAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#revDescendantOrSelfAxis",
          "type": "function"
        },
        "index": {
          "description": "not an official XPath axis but useful reverse descendant or self used in preceding axis",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "revDescendantOrSelfAxis",
          "package": "hxt",
          "partial": "Descendant Or Self Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:revDescendantOrSelfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: self\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "selfAxis",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#selfAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis self",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "selfAxis",
          "package": "hxt",
          "partial": "Axis",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:selfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute the current subtree of a navigatable tree by a given tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "substThisTree",
          "package": "hxt",
          "signature": "t b -\u003e a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#substThisTree",
          "type": "function"
        },
        "index": {
          "description": "Substitute the current subtree of navigatable tree by given tree",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "substThisTree",
          "normalized": "a b-\u003ec(d b)(d b)",
          "package": "hxt",
          "partial": "This Tree",
          "signature": "t b-\u003ea(nt b)(nt b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:substThisTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an operation using navigation to an ordinary tree\n\u003c/p\u003e\u003cp\u003eThis root and all children may be visited in arbitrary order\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "withNav",
          "package": "hxt",
          "signature": "a (nt b) (nt c) -\u003e a (t b) (t c)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#withNav",
          "type": "function"
        },
        "index": {
          "description": "apply an operation using navigation to an ordinary tree This root and all children may be visited in arbitrary order",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "withNav",
          "normalized": "a(b c)(b d)-\u003ea(e c)(e d)",
          "package": "hxt",
          "partial": "Nav",
          "signature": "a(nt b)(nt c)-\u003ea(t b)(t c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:withNav"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply a simple operation without use of navigation to a navigatable tree\n\u003c/p\u003e\u003cp\u003eThis enables to apply arbitrary tree operations to navigatable trees\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "withoutNav",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (nt b) (nt b)",
          "source": "src/Control-Arrow-ArrowNavigatableTree.html#withoutNav",
          "type": "function"
        },
        "index": {
          "description": "apply simple operation without use of navigation to navigatable tree This enables to apply arbitrary tree operations to navigatable trees",
          "hierarchy": "Control Arrow ArrowNavigatableTree",
          "module": "Control.Arrow.ArrowNavigatableTree",
          "name": "withoutNav",
          "normalized": "a(b c)(b c)-\u003ea(d c)(d c)",
          "package": "hxt",
          "partial": "Nav",
          "signature": "a(t b)(t b)-\u003ea(nt b)(nt b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowNavigatableTree.html#v:withoutNav"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eArrows for managing an explicit state\n\u003c/p\u003e\u003cp\u003eState arrows work similar to state monads.\n   A state value is threaded through the application of arrows.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowState",
          "name": "ArrowState",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowState.html",
          "type": "module"
        },
        "index": {
          "description": "Arrows for managing an explicit state State arrows work similar to state monads state value is threaded through the application of arrows",
          "hierarchy": "Control Arrow ArrowState",
          "module": "Control.Arrow.ArrowState",
          "name": "ArrowState",
          "package": "hxt",
          "partial": "Arrow State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowState.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for accessing and changing the state component.\n\u003c/p\u003e\u003cp\u003eMulti parameter classes and functional dependencies are required.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowState",
          "name": "ArrowState",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowState.html#ArrowState",
          "type": "class"
        },
        "index": {
          "description": "The interface for accessing and changing the state component Multi parameter classes and functional dependencies are required",
          "hierarchy": "Control Arrow ArrowState",
          "module": "Control.Arrow.ArrowState",
          "name": "ArrowState",
          "package": "hxt",
          "partial": "Arrow State",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowState.html#t:ArrowState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eaccess the state with a function using the arrow input\n as data for selecting state components.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowState",
          "name": "accessState",
          "package": "hxt",
          "signature": "(s -\u003e b -\u003e c) -\u003e a b c",
          "source": "src/Control-Arrow-ArrowState.html#accessState",
          "type": "method"
        },
        "index": {
          "description": "access the state with function using the arrow input as data for selecting state components",
          "hierarchy": "Control Arrow ArrowState",
          "module": "Control.Arrow.ArrowState",
          "name": "accessState",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed b c",
          "package": "hxt",
          "partial": "State",
          "signature": "(s-\u003eb-\u003ec)-\u003ea b c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowState.html#v:accessState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echange the state of a state arrow by applying a function\n for computing a new state from the old and the arrow input.\n Result is the arrow input\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowState",
          "name": "changeState",
          "package": "hxt",
          "signature": "(s -\u003e b -\u003e s) -\u003e a b b",
          "source": "src/Control-Arrow-ArrowState.html#changeState",
          "type": "method"
        },
        "index": {
          "description": "change the state of state arrow by applying function for computing new state from the old and the arrow input Result is the arrow input",
          "hierarchy": "Control Arrow ArrowState",
          "module": "Control.Arrow.ArrowState",
          "name": "changeState",
          "normalized": "(a-\u003eb-\u003ea)-\u003ec b b",
          "package": "hxt",
          "partial": "State",
          "signature": "(s-\u003eb-\u003es)-\u003ea b b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowState.html#v:changeState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread the complete state, ignore arrow input\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e getState = accessState (\\ s x -\u003e s) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowState",
          "name": "getState",
          "package": "hxt",
          "signature": "a b s",
          "source": "src/Control-Arrow-ArrowState.html#getState",
          "type": "method"
        },
        "index": {
          "description": "read the complete state ignore arrow input definition getState accessState",
          "hierarchy": "Control Arrow ArrowState",
          "module": "Control.Arrow.ArrowState",
          "name": "getState",
          "package": "hxt",
          "partial": "State",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowState.html#v:getState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echange state (and ignore input) and return new state\n\u003c/p\u003e\u003cp\u003econvenience function,\n usefull for generating e.g. unique identifiers:\n\u003c/p\u003e\u003cp\u003eexample with SLA state list arrows\n\u003c/p\u003e\u003cpre\u003e newId :: SLA Int b String\n newId = nextState (+1)\n         \u003e\u003e\u003e\n         arr (('#':) . show)\n\n runSLA 0 (newId \u003c+\u003e newId \u003c+\u003e newId) undefined\n   = [\"#1\", \"#2\", \"#3\"]\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowState",
          "name": "nextState",
          "package": "hxt",
          "signature": "(s -\u003e s) -\u003e a b s",
          "source": "src/Control-Arrow-ArrowState.html#nextState",
          "type": "method"
        },
        "index": {
          "description": "change state and ignore input and return new state convenience function usefull for generating e.g unique identifiers example with SLA state list arrows newId SLA Int String newId nextState arr show runSLA newId newId newId undefined",
          "hierarchy": "Control Arrow ArrowState",
          "module": "Control.Arrow.ArrowState",
          "name": "nextState",
          "normalized": "(a-\u003ea)-\u003eb c a",
          "package": "hxt",
          "partial": "State",
          "signature": "(s-\u003es)-\u003ea b s",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowState.html#v:nextState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoverwrite the old state\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e setState = changeState (\\ s x -\u003e x) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowState",
          "name": "setState",
          "package": "hxt",
          "signature": "a s s",
          "source": "src/Control-Arrow-ArrowState.html#setState",
          "type": "method"
        },
        "index": {
          "description": "overwrite the old state definition setState changeState",
          "hierarchy": "Control Arrow ArrowState",
          "module": "Control.Arrow.ArrowState",
          "name": "setState",
          "package": "hxt",
          "partial": "State",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowState.html#v:setState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eList arrows for tree processing.\n\u003c/p\u003e\u003cp\u003eTrees that implement the \u003ca\u003eData.Tree.Class\u003c/a\u003e interface, can be processed\n   with these arrows.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "ArrowTree",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowTree.html",
          "type": "module"
        },
        "index": {
          "description": "List arrows for tree processing Trees that implement the Data.Tree.Class interface can be processed with these arrows",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "ArrowTree",
          "package": "hxt",
          "partial": "Arrow Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for tree arrows\n\u003c/p\u003e\u003cp\u003eall functions have default implementations\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "ArrowTree",
          "package": "hxt",
          "source": "src/Control-Arrow-ArrowTree.html#ArrowTree",
          "type": "class"
        },
        "index": {
          "description": "The interface for tree arrows all functions have default implementations",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "ArrowTree",
          "package": "hxt",
          "partial": "Arrow Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#t:ArrowTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for trees\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "Tree",
          "package": "hxt",
          "source": "src/Data-Tree-Class.html#Tree",
          "type": "class"
        },
        "index": {
          "description": "The interface for trees",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "Tree",
          "package": "hxt",
          "partial": "Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epronounced \"double slash\", meaning g arbitrarily deep inside f\n\u003c/p\u003e\u003cp\u003edefined as \u003ccode\u003e f //\u003e g = f \u003e\u003e\u003e getChildren \u003e\u003e\u003e deep g \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e hasName \"html\" //\u003e hasName \"table\" \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis expression selects\n all top level \"table\" elements within an \"html\" element, an expression.\n Attantion: This does not correspond\n to the XPath selection path \"html//table\". The latter on matches all table elements\n even nested ones, but \u003ccode\u003e//\u003e\u003c/code\u003e gives in many cases the appropriate functionality.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "(//\u003e)",
          "package": "hxt",
          "signature": "a b (t c) -\u003e a (t c) d -\u003e a b d",
          "source": "src/Control-Arrow-ArrowTree.html#%2F%2F%3E",
          "type": "method"
        },
        "index": {
          "description": "pronounced double slash meaning arbitrarily deep inside defined as getChildren deep example hasName html hasName table This expression selects all top level table elements within an html element an expression Attantion This does not correspond to the XPath selection path html table The latter on matches all table elements even nested ones but gives in many cases the appropriate functionality",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "(//\u003e) //\u003e",
          "normalized": "a b(c d)-\u003ea(c d)e-\u003ea b e",
          "package": "hxt",
          "signature": "a b(t c)-\u003ea(t c)d-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:-47--47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epronounced \"slash\", meaning g inside f\n\u003c/p\u003e\u003cp\u003edefined as \u003ccode\u003e f /\u003e g = f \u003e\u003e\u003e getChildren \u003e\u003e\u003e g \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e hasName \"html\" /\u003e hasName \"body\" /\u003e hasName \"h1\" \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis expression selects\n all \"h1\" elements in the \"body\" element of an \"html\" element, an expression, that\n corresponds 1-1 to the XPath selection path \"html/body/h1\"\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "(/\u003e)",
          "package": "hxt",
          "signature": "a b (t c) -\u003e a (t c) d -\u003e a b d",
          "source": "src/Control-Arrow-ArrowTree.html#%2F%3E",
          "type": "method"
        },
        "index": {
          "description": "pronounced slash meaning inside defined as getChildren example hasName html hasName body hasName h1 This expression selects all h1 elements in the body element of an html element an expression that corresponds to the XPath selection path html body h1",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "(/\u003e) /\u003e",
          "normalized": "a b(c d)-\u003ea(c d)e-\u003ea b e",
          "package": "hxt",
          "signature": "a b(t c)-\u003ea(t c)d-\u003ea b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:-47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epronounced \"outside\" meaning f containing g\n\u003c/p\u003e\u003cp\u003edefined as \u003ccode\u003e f \u003c/ g = f `containing` (getChildren \u003e\u003e\u003e g) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "(\u003c/)",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#%3C%2F",
          "type": "method"
        },
        "index": {
          "description": "pronounced outside meaning containing defined as containing getChildren",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "(\u003c/) \u003c/",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:-60--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit the children of the root of a tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "changeChildren",
          "package": "hxt",
          "signature": "([t b] -\u003e [t b]) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#changeChildren",
          "type": "method"
        },
        "index": {
          "description": "edit the children of the root of tree",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "changeChildren",
          "normalized": "([a b]-\u003e[a b])-\u003ec(a b)(a b)",
          "package": "hxt",
          "partial": "Children",
          "signature": "([t b]-\u003e[t b])-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:changeChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit the attribute of the root of a tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "changeNode",
          "package": "hxt",
          "signature": "(b -\u003e b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#changeNode",
          "type": "method"
        },
        "index": {
          "description": "edit the attribute of the root of tree",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "changeNode",
          "normalized": "(a-\u003ea)-\u003eb(c a)(c a)",
          "package": "hxt",
          "partial": "Node",
          "signature": "(b-\u003eb)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:changeNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecursively searches a whole tree for subtrees, for which a predicate holds.\n The search is performed top down. When a tree is found, this becomes an element of the result\n list. The tree found is not further examined for any subtress, for which the predicate also could hold.\n See \u003ccode\u003e\u003ca\u003emulti\u003c/a\u003e\u003c/code\u003e for this kind of search.\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e deep isHtmlTable \u003c/code\u003e selects all top level table elements in a document\n (with an appropriate definition for isHtmlTable) but no tables occuring within a table cell.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "deep",
          "package": "hxt",
          "signature": "a (t b) c -\u003e a (t b) c",
          "source": "src/Control-Arrow-ArrowTree.html#deep",
          "type": "method"
        },
        "index": {
          "description": "recursively searches whole tree for subtrees for which predicate holds The search is performed top down When tree is found this becomes an element of the result list The tree found is not further examined for any subtress for which the predicate also could hold See multi for this kind of search example deep isHtmlTable selects all top level table elements in document with an appropriate definition for isHtmlTable but no tables occuring within table cell",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "deep",
          "normalized": "a(b c)d-\u003ea(b c)d",
          "package": "hxt",
          "signature": "a(t b)c-\u003ea(t b)c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:deep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecursively searches a whole tree for subrees, for which a predicate holds.\n The search is performed bottom up.\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e deepest isHtmlTable \u003c/code\u003e selects all innermost table elements in a document\n but no table elements containing tables. See \u003ccode\u003e\u003ca\u003edeep\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emulti\u003c/a\u003e\u003c/code\u003e for other search strategies.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "deepest",
          "package": "hxt",
          "signature": "a (t b) c -\u003e a (t b) c",
          "source": "src/Control-Arrow-ArrowTree.html#deepest",
          "type": "method"
        },
        "index": {
          "description": "recursively searches whole tree for subrees for which predicate holds The search is performed bottom up example deepest isHtmlTable selects all innermost table elements in document but no table elements containing tables See deep and multi for other search strategies",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "deepest",
          "normalized": "a(b c)d-\u003ea(b c)d",
          "package": "hxt",
          "signature": "a(t b)c-\u003ea(t b)c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:deepest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the children of the root of a tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "getChildren",
          "package": "hxt",
          "signature": "a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#getChildren",
          "type": "method"
        },
        "index": {
          "description": "select the children of the root of tree",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "getChildren",
          "package": "hxt",
          "partial": "Children",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:getChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the node info of the root of a tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "getNode",
          "package": "hxt",
          "signature": "a (t b) b",
          "source": "src/Control-Arrow-ArrowTree.html#getNode",
          "type": "method"
        },
        "index": {
          "description": "select the node info of the root of tree",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "getNode",
          "package": "hxt",
          "partial": "Node",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:getNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the attribute of the root of a tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "hasNode",
          "package": "hxt",
          "signature": "(b -\u003e Bool) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#hasNode",
          "type": "method"
        },
        "index": {
          "description": "select the attribute of the root of tree",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "hasNode",
          "normalized": "(a-\u003eBool)-\u003eb(c a)(c a)",
          "package": "hxt",
          "partial": "Node",
          "signature": "(b-\u003eBool)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:hasNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimilar to \u003ccode\u003e\u003ca\u003einsertChildrenAt\u003c/a\u003e\u003c/code\u003e, but the insertion position is searched with a predicate\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "insertChildrenAfter",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#insertChildrenAfter",
          "type": "method"
        },
        "index": {
          "description": "similar to insertChildrenAt but the insertion position is searched with predicate",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "insertChildrenAfter",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Children After",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:insertChildrenAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecomputes a list of trees by applying an arrow to the input\n and inserts this list in front of index i in the list of children\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e insertChildrenAt 0 (deep isCmt) \u003c/code\u003e selects all subtrees for which isCmt holds\n and copies theses in front of the existing children\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "insertChildrenAt",
          "package": "hxt",
          "signature": "Int -\u003e a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#insertChildrenAt",
          "type": "method"
        },
        "index": {
          "description": "computes list of trees by applying an arrow to the input and inserts this list in front of index in the list of children example insertChildrenAt deep isCmt selects all subtrees for which isCmt holds and copies theses in front of the existing children",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "insertChildrenAt",
          "normalized": "Int-\u003ea(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Children At",
          "signature": "Int-\u003ea(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:insertChildrenAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean arrow for inserting a whole subtree with some holes in it (a template)\n into a document. The holes can be filled with contents from the input.\n\u003c/p\u003e\u003cp\u003eExample\n\u003c/p\u003e\u003cpre\u003e insertTreeTemplateTest :: ArrowXml a =\u003e a b XmlTree\n insertTreeTemplateTest\n     = doc\n       \u003e\u003e\u003e\n       insertTreeTemplate template pattern\n     where\n     doc                                                                -- the input data\n        = constA \"\u003cx\u003e\u003cy\u003eThe Title\u003c/y\u003e\u003cz\u003eThe content\u003c/z\u003e\u003c/x\u003e\"\n          \u003e\u003e\u003e xread\n     template                                                           -- the output template with 2 holes: xxx and yyy\n        = constA \"\u003chtml\u003e\u003chead\u003e\u003ctitle\u003exxx\u003c/title\u003e\u003c/head\u003e\u003cbody\u003e\u003ch1\u003eyyy\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\"\n          \u003e\u003e\u003e xread\n     pattern\n        = [ hasText (== \"xxx\")                                          -- fill the xxx hole with the input contents from element \"x/y\"\n            :-\u003e ( getChildren \u003e\u003e\u003e hasName \"y\" \u003e\u003e\u003e deep isText )\n\n          , hasText (== \"yyy\")                                          -- fill the yyy hole with the input contents from element \"x/z\"\n            :-\u003e ( getChildren \u003e\u003e\u003e hasName \"z\" \u003e\u003e\u003e getChildren )\n          ]\n\u003c/pre\u003e\u003cp\u003ecomputes the XML tree for the following document\n\u003c/p\u003e\u003cpre\u003e \"\u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Title\u003c/title\u003e\u003c/head\u003e\u003cbody\u003e\u003ch1\u003eThe content\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\"\n\u003c/pre\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "insertTreeTemplate",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e [IfThen (a (t b) c) (a (t b) (t b))] -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#insertTreeTemplate",
          "type": "method"
        },
        "index": {
          "description": "an arrow for inserting whole subtree with some holes in it template into document The holes can be filled with contents from the input Example insertTreeTemplateTest ArrowXml XmlTree insertTreeTemplateTest doc insertTreeTemplate template pattern where doc the input data constA The Title The content xread template the output template with holes xxx and yyy constA html head title xxx title head body h1 yyy h1 body html xread pattern hasText xxx fill the xxx hole with the input contents from element getChildren hasName deep isText hasText yyy fill the yyy hole with the input contents from element getChildren hasName getChildren computes the XML tree for the following document html head title The Title title head body h1 The content h1 body html",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "insertTreeTemplate",
          "normalized": "a(b c)(b c)-\u003e[IfThen(a(b c)d)(a(b c)(b c))]-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Tree Template",
          "signature": "a(t b)(t b)-\u003e[IfThen(a(t b)c)(a(t b)(t b))]-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:insertTreeTemplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct a leaf\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "mkLeaf",
          "package": "hxt",
          "signature": "b -\u003e a c (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#mkLeaf",
          "type": "method"
        },
        "index": {
          "description": "construct leaf",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "mkLeaf",
          "normalized": "a-\u003eb c(d a)",
          "package": "hxt",
          "partial": "Leaf",
          "signature": "b-\u003ea c(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:mkLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct an inner node\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "mkTree",
          "package": "hxt",
          "signature": "b -\u003e [t b] -\u003e a c (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#mkTree",
          "type": "method"
        },
        "index": {
          "description": "construct an inner node",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "mkTree",
          "normalized": "a-\u003e[b a]-\u003ec d(b a)",
          "package": "hxt",
          "partial": "Tree",
          "signature": "b-\u003e[t b]-\u003ea c(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:mkTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecursively searches a whole tree for subtrees, for which a predicate holds.\n The search is performed top down. All nodes of the tree are searched, even within the\n subtrees of trees for which the predicate holds.\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e multi isHtmlTable \u003c/code\u003e selects all table elements, even nested ones.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "multi",
          "package": "hxt",
          "signature": "a (t b) c -\u003e a (t b) c",
          "source": "src/Control-Arrow-ArrowTree.html#multi",
          "type": "method"
        },
        "index": {
          "description": "recursively searches whole tree for subtrees for which predicate holds The search is performed top down All nodes of the tree are searched even within the subtrees of trees for which the predicate holds example multi isHtmlTable selects all table elements even nested ones",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "multi",
          "normalized": "a(b c)d-\u003ea(b c)d",
          "package": "hxt",
          "signature": "a(t b)c-\u003ea(t b)c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:multi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecursively transforms a whole tree by applying an arrow to all subtrees,\n this is done bottom up depth first, leaves first, root as last tree\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e processBottomUp (getChildren `when` isHtmlFont) \u003c/code\u003e removes all font tags in a HTML document, even nested ones\n (with an appropriate definition of isHtmlFont)\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "processBottomUp",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#processBottomUp",
          "type": "method"
        },
        "index": {
          "description": "recursively transforms whole tree by applying an arrow to all subtrees this is done bottom up depth first leaves first root as last tree example processBottomUp getChildren when isHtmlFont removes all font tags in HTML document even nested ones with an appropriate definition of isHtmlFont",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "processBottomUp",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Bottom Up",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:processBottomUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecursively transforms a whole tree by applying an arrow to all subtrees,\n but transformation stops when a predicte does not hold for a subtree,\n leaves are transformed first\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "processBottomUpWhenNot",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#processBottomUpWhenNot",
          "type": "method"
        },
        "index": {
          "description": "recursively transforms whole tree by applying an arrow to all subtrees but transformation stops when predicte does not hold for subtree leaves are transformed first",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "processBottomUpWhenNot",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Bottom Up When Not",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:processBottomUpWhenNot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an arrow element wise to all children of the root of a tree\n collect these results and substitute the children with this result\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e processChildren isText \u003c/code\u003e deletes all subtrees, for which isText does not hold\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e processChildren (none `when` isCmt) \u003c/code\u003e removes all children, for which isCmt holds\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "processChildren",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#processChildren",
          "type": "method"
        },
        "index": {
          "description": "apply an arrow element wise to all children of the root of tree collect these results and substitute the children with this result example processChildren isText deletes all subtrees for which isText does not hold example processChildren none when isCmt removes all children for which isCmt holds",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "processChildren",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Children",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:processChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimilar to \u003ccode\u003e\u003ca\u003eprocessBottomUp\u003c/a\u003e\u003c/code\u003e, but recursively transforms a whole tree by applying an arrow to all subtrees\n with a top down depth first traversal strategie. In many cases \u003ccode\u003e\u003ca\u003eprocessBottomUp\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eprocessTopDown\u003c/a\u003e\u003c/code\u003e\n give same results.\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "processTopDown",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#processTopDown",
          "type": "method"
        },
        "index": {
          "description": "similar to processBottomUp but recursively transforms whole tree by applying an arrow to all subtrees with top down depth first traversal strategie In many cases processBottomUp and processTopDown give same results",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "processTopDown",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Top Down",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:processTopDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecursively transforms a whole tree by applying an arrow to all subtrees,\n but transformation stops when a tree is successfully transformed.\n the transformation is done top down\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e processTopDownUntil (isHtmlTable `guards` tranformTable) \u003c/code\u003e\n transforms all top level table elements into something else, but inner tables remain unchanged\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "processTopDownUntil",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#processTopDownUntil",
          "type": "method"
        },
        "index": {
          "description": "recursively transforms whole tree by applying an arrow to all subtrees but transformation stops when tree is successfully transformed the transformation is done top down example processTopDownUntil isHtmlTable guards tranformTable transforms all top level table elements into something else but inner tables remain unchanged",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "processTopDownUntil",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Top Down Until",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:processTopDownUntil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimilar to processChildren, but the new children are computed by processing\n the whole input tree\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003e replaceChildren (deep isText) \u003c/code\u003e selects all subtrees for which isText holds\n and substitutes the children component of the root node with this list\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "replaceChildren",
          "package": "hxt",
          "signature": "a (t b) (t b) -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#replaceChildren",
          "type": "method"
        },
        "index": {
          "description": "similar to processChildren but the new children are computed by processing the whole input tree example replaceChildren deep isText selects all subtrees for which isText holds and substitutes the children component of the root node with this list",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "replaceChildren",
          "normalized": "a(b c)(b c)-\u003ea(b c)(b c)",
          "package": "hxt",
          "partial": "Children",
          "signature": "a(t b)(t b)-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:replaceChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esubstitute the children of the root of a tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "setChildren",
          "package": "hxt",
          "signature": "[t b] -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#setChildren",
          "type": "method"
        },
        "index": {
          "description": "substitute the children of the root of tree",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "setChildren",
          "normalized": "[a b]-\u003ec(a b)(a b)",
          "package": "hxt",
          "partial": "Children",
          "signature": "[t b]-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:setChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esubstitute the attribute of the root of a tree\n\u003c/p\u003e",
          "module": "Control.Arrow.ArrowTree",
          "name": "setNode",
          "package": "hxt",
          "signature": "b -\u003e a (t b) (t b)",
          "source": "src/Control-Arrow-ArrowTree.html#setNode",
          "type": "method"
        },
        "index": {
          "description": "substitute the attribute of the root of tree",
          "hierarchy": "Control Arrow ArrowTree",
          "module": "Control.Arrow.ArrowTree",
          "name": "setNode",
          "normalized": "a-\u003eb(c a)(c a)",
          "package": "hxt",
          "partial": "Node",
          "signature": "b-\u003ea(t b)(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ArrowTree.html#v:setNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of pure list arrows with IO\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.IOListArrow",
          "name": "IOListArrow",
          "package": "hxt",
          "source": "src/Control-Arrow-IOListArrow.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of pure list arrows with IO",
          "hierarchy": "Control Arrow IOListArrow",
          "module": "Control.Arrow.IOListArrow",
          "name": "IOListArrow",
          "package": "hxt",
          "partial": "IOList Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOListArrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist arrow combined with IO monad\n\u003c/p\u003e",
          "module": "Control.Arrow.IOListArrow",
          "name": "IOLA",
          "package": "hxt",
          "source": "src/Control-Arrow-IOListArrow.html#IOLA",
          "type": "newtype"
        },
        "index": {
          "description": "list arrow combined with IO monad",
          "hierarchy": "Control Arrow IOListArrow",
          "module": "Control.Arrow.IOListArrow",
          "name": "IOLA",
          "package": "hxt",
          "partial": "IOLA",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOListArrow.html#t:IOLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.IOListArrow",
          "name": "IOLA",
          "package": "hxt",
          "signature": "IOLA",
          "source": "src/Control-Arrow-IOListArrow.html#IOLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow IOListArrow",
          "module": "Control.Arrow.IOListArrow",
          "name": "IOLA",
          "package": "hxt",
          "partial": "IOLA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOListArrow.html#v:IOLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.IOListArrow",
          "name": "runIOLA",
          "package": "hxt",
          "signature": "a -\u003e IO [b]",
          "source": "src/Control-Arrow-IOListArrow.html#IOLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow IOListArrow",
          "module": "Control.Arrow.IOListArrow",
          "name": "runIOLA",
          "normalized": "a-\u003eIO[b]",
          "package": "hxt",
          "partial": "IOLA",
          "signature": "a-\u003eIO[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOListArrow.html#v:runIOLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of arrows with IO and a state\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "IOStateListArrow",
          "package": "hxt",
          "source": "src/Control-Arrow-IOStateListArrow.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of arrows with IO and state",
          "hierarchy": "Control Arrow IOStateListArrow",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "IOStateListArrow",
          "package": "hxt",
          "partial": "IOState List Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOStateListArrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist arrow combined with a state and the IO monad\n\u003c/p\u003e",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "IOSLA",
          "package": "hxt",
          "source": "src/Control-Arrow-IOStateListArrow.html#IOSLA",
          "type": "newtype"
        },
        "index": {
          "description": "list arrow combined with state and the IO monad",
          "hierarchy": "Control Arrow IOStateListArrow",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "IOSLA",
          "package": "hxt",
          "partial": "IOSLA",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOStateListArrow.html#t:IOSLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.IOStateListArrow",
          "name": "IOSLA",
          "package": "hxt",
          "signature": "IOSLA",
          "source": "src/Control-Arrow-IOStateListArrow.html#IOSLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow IOStateListArrow",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "IOSLA",
          "package": "hxt",
          "partial": "IOSLA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOStateListArrow.html#v:IOSLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elift the state of an IOSLA arrow to a state with an additional component.\n\u003c/p\u003e\u003cp\u003eThis is uesful, when running predefined IO arrows, e.g. for document input,\n in a context with a more complex state component.\n\u003c/p\u003e",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "liftSt",
          "package": "hxt",
          "signature": "IOSLA s1 b c -\u003e IOSLA (s1, s2) b c",
          "source": "src/Control-Arrow-IOStateListArrow.html#liftSt",
          "type": "function"
        },
        "index": {
          "description": "lift the state of an IOSLA arrow to state with an additional component This is uesful when running predefined IO arrows e.g for document input in context with more complex state component",
          "hierarchy": "Control Arrow IOStateListArrow",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "liftSt",
          "normalized": "IOSLA a b c-\u003eIOSLA(a,a)b c",
          "package": "hxt",
          "partial": "St",
          "signature": "IOSLA s b c-\u003eIOSLA(s,s)b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOStateListArrow.html#v:liftSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.IOStateListArrow",
          "name": "runIOSLA",
          "package": "hxt",
          "signature": "s -\u003e a -\u003e IO (s, [b])",
          "source": "src/Control-Arrow-IOStateListArrow.html#IOSLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow IOStateListArrow",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "runIOSLA",
          "normalized": "a-\u003eb-\u003eIO(a,[c])",
          "package": "hxt",
          "partial": "IOSLA",
          "signature": "s-\u003ea-\u003eIO(s,[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOStateListArrow.html#v:runIOSLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erun an arrow with augmented state in the context of a simple state arrow.\n An initial value for the new state component is needed.\n\u003c/p\u003e\u003cp\u003eThis is useful, when running an arrow with an extra environment component, e.g.\n for namespace handling in XML.\n\u003c/p\u003e",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "runSt",
          "package": "hxt",
          "signature": "s2 -\u003e IOSLA (s1, s2) b c -\u003e IOSLA s1 b c",
          "source": "src/Control-Arrow-IOStateListArrow.html#runSt",
          "type": "function"
        },
        "index": {
          "description": "run an arrow with augmented state in the context of simple state arrow An initial value for the new state component is needed This is useful when running an arrow with an extra environment component e.g for namespace handling in XML",
          "hierarchy": "Control Arrow IOStateListArrow",
          "module": "Control.Arrow.IOStateListArrow",
          "name": "runSt",
          "normalized": "a-\u003eIOSLA(a,a)b c-\u003eIOSLA a b c",
          "package": "hxt",
          "partial": "St",
          "signature": "s-\u003eIOSLA(s,s)b c-\u003eIOSLA s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-IOStateListArrow.html#v:runSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of pure list arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ListArrow",
          "name": "ListArrow",
          "package": "hxt",
          "source": "src/Control-Arrow-ListArrow.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of pure list arrows",
          "hierarchy": "Control Arrow ListArrow",
          "module": "Control.Arrow.ListArrow",
          "name": "ListArrow",
          "package": "hxt",
          "partial": "List Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ListArrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epure list arrow data type\n\u003c/p\u003e",
          "module": "Control.Arrow.ListArrow",
          "name": "LA",
          "package": "hxt",
          "source": "src/Control-Arrow-ListArrow.html#LA",
          "type": "newtype"
        },
        "index": {
          "description": "pure list arrow data type",
          "hierarchy": "Control Arrow ListArrow",
          "module": "Control.Arrow.ListArrow",
          "name": "LA",
          "package": "hxt",
          "partial": "LA",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ListArrow.html#t:LA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ListArrow",
          "name": "LA",
          "package": "hxt",
          "signature": "LA",
          "source": "src/Control-Arrow-ListArrow.html#LA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow ListArrow",
          "module": "Control.Arrow.ListArrow",
          "name": "LA",
          "package": "hxt",
          "partial": "LA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ListArrow.html#v:LA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econversion of pure list arrows into other possibly more complex\n list arrows\n\u003c/p\u003e",
          "module": "Control.Arrow.ListArrow",
          "name": "fromLA",
          "package": "hxt",
          "signature": "LA b c -\u003e a b c",
          "source": "src/Control-Arrow-ListArrow.html#fromLA",
          "type": "function"
        },
        "index": {
          "description": "conversion of pure list arrows into other possibly more complex list arrows",
          "hierarchy": "Control Arrow ListArrow",
          "module": "Control.Arrow.ListArrow",
          "name": "fromLA",
          "normalized": "LA a b-\u003ec a b",
          "package": "hxt",
          "partial": "LA",
          "signature": "LA b c-\u003ea b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ListArrow.html#v:fromLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.ListArrow",
          "name": "runLA",
          "package": "hxt",
          "signature": "a -\u003e [b]",
          "source": "src/Control-Arrow-ListArrow.html#LA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow ListArrow",
          "module": "Control.Arrow.ListArrow",
          "name": "runLA",
          "normalized": "a-\u003e[b]",
          "package": "hxt",
          "partial": "LA",
          "signature": "a-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ListArrow.html#v:runLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eModule for importing all list arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.ListArrows",
          "name": "ListArrows",
          "package": "hxt",
          "source": "src/Control-Arrow-ListArrows.html",
          "type": "module"
        },
        "index": {
          "description": "Module for importing all list arrows",
          "hierarchy": "Control Arrow ListArrows",
          "module": "Control.Arrow.ListArrows",
          "name": "ListArrows",
          "package": "hxt",
          "partial": "List Arrows",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-ListArrows.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003earrows for efficient editing of rose trees\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.NTreeEdit",
          "name": "NTreeEdit",
          "package": "hxt",
          "source": "src/Control-Arrow-NTreeEdit.html",
          "type": "module"
        },
        "index": {
          "description": "arrows for efficient editing of rose trees",
          "hierarchy": "Control Arrow NTreeEdit",
          "module": "Control.Arrow.NTreeEdit",
          "name": "NTreeEdit",
          "package": "hxt",
          "partial": "NTree Edit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-NTreeEdit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdit parts of a rose tree\n\u003c/p\u003e\u003cp\u003eThe subtrees to be modified are selected by the first part of the IfThen pairs\n The modification by the second part\n\u003c/p\u003e",
          "module": "Control.Arrow.NTreeEdit",
          "name": "editNTreeA",
          "package": "hxt",
          "signature": "[IfThen (LA (NTree b) c) (LA (NTree b) (NTree b))] -\u003e LA (NTree b) (NTree b)",
          "source": "src/Control-Arrow-NTreeEdit.html#editNTreeA",
          "type": "function"
        },
        "index": {
          "description": "Edit parts of rose tree The subtrees to be modified are selected by the first part of the IfThen pairs The modification by the second part",
          "hierarchy": "Control Arrow NTreeEdit",
          "module": "Control.Arrow.NTreeEdit",
          "name": "editNTreeA",
          "normalized": "[IfThen(LA(NTree a)b)(LA(NTree a)(NTree a))]-\u003eLA(NTree a)(NTree a)",
          "package": "hxt",
          "partial": "NTree",
          "signature": "[IfThen(LA(NTree b)c)(LA(NTree b)(NTree b))]-\u003eLA(NTree b)(NTree b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-NTreeEdit.html#v:editNTreeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.NTreeEdit",
          "name": "fmapNTreeA",
          "package": "hxt",
          "signature": "(b -\u003e Maybe b) -\u003e LA (NTree b) (NTree b)",
          "source": "src/Control-Arrow-NTreeEdit.html#fmapNTreeA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow NTreeEdit",
          "module": "Control.Arrow.NTreeEdit",
          "name": "fmapNTreeA",
          "normalized": "(a-\u003eMaybe a)-\u003eLA(NTree a)(NTree a)",
          "package": "hxt",
          "partial": "NTree",
          "signature": "(b-\u003eMaybe b)-\u003eLA(NTree b)(NTree b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-NTreeEdit.html#v:fmapNTreeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of list arrows with a state\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Arrow.StateListArrow",
          "name": "StateListArrow",
          "package": "hxt",
          "source": "src/Control-Arrow-StateListArrow.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of list arrows with state",
          "hierarchy": "Control Arrow StateListArrow",
          "module": "Control.Arrow.StateListArrow",
          "name": "StateListArrow",
          "package": "hxt",
          "partial": "State List Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-StateListArrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist arrow combined with a state\n\u003c/p\u003e",
          "module": "Control.Arrow.StateListArrow",
          "name": "SLA",
          "package": "hxt",
          "source": "src/Control-Arrow-StateListArrow.html#SLA",
          "type": "newtype"
        },
        "index": {
          "description": "list arrow combined with state",
          "hierarchy": "Control Arrow StateListArrow",
          "module": "Control.Arrow.StateListArrow",
          "name": "SLA",
          "package": "hxt",
          "partial": "SLA",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-StateListArrow.html#t:SLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.StateListArrow",
          "name": "SLA",
          "package": "hxt",
          "signature": "SLA",
          "source": "src/Control-Arrow-StateListArrow.html#SLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow StateListArrow",
          "module": "Control.Arrow.StateListArrow",
          "name": "SLA",
          "package": "hxt",
          "partial": "SLA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-StateListArrow.html#v:SLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econversion of state list arrows into arbitray other\n list arrows.\n\u003c/p\u003e\u003cp\u003eallows running a state list arrow within another arrow:\n\u003c/p\u003e\u003cp\u003eexample:\n\u003c/p\u003e\u003cpre\u003e ... \u003e\u003e\u003e fromSLA 0 (... setState ... getState ... ) \u003e\u003e\u003e ...\n\u003c/pre\u003e\u003cp\u003eruns a state arrow with initial state 0 (e..g. an Int) within\n another arrow sequence\n\u003c/p\u003e",
          "module": "Control.Arrow.StateListArrow",
          "name": "fromSLA",
          "package": "hxt",
          "signature": "s -\u003e SLA s b c -\u003e a b c",
          "source": "src/Control-Arrow-StateListArrow.html#fromSLA",
          "type": "function"
        },
        "index": {
          "description": "conversion of state list arrows into arbitray other list arrows allows running state list arrow within another arrow example fromSLA setState getState runs state arrow with initial state e..g an Int within another arrow sequence",
          "hierarchy": "Control Arrow StateListArrow",
          "module": "Control.Arrow.StateListArrow",
          "name": "fromSLA",
          "normalized": "a-\u003eSLA a b c-\u003ed b c",
          "package": "hxt",
          "partial": "SLA",
          "signature": "s-\u003eSLA s b c-\u003ea b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-StateListArrow.html#v:fromSLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Arrow.StateListArrow",
          "name": "runSLA",
          "package": "hxt",
          "signature": "s -\u003e a -\u003e (s, [b])",
          "source": "src/Control-Arrow-StateListArrow.html#SLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Arrow StateListArrow",
          "module": "Control.Arrow.StateListArrow",
          "name": "runSLA",
          "normalized": "a-\u003eb-\u003e(a,[c])",
          "package": "hxt",
          "partial": "SLA",
          "signature": "s-\u003ea-\u003e(s,[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-Arrow-StateListArrow.html#v:runSLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eForce evaluation like deepseq in Control.DeepSeq,\n   but control the depth of evaluation.\n   flatseq may evaluate more than seq but less than deepseq\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.FlatSeq",
          "name": "FlatSeq",
          "package": "hxt",
          "source": "src/Control-FlatSeq.html",
          "type": "module"
        },
        "index": {
          "description": "Force evaluation like deepseq in Control.DeepSeq but control the depth of evaluation flatseq may evaluate more than seq but less than deepseq",
          "hierarchy": "Control FlatSeq",
          "module": "Control.FlatSeq",
          "name": "FlatSeq",
          "package": "hxt",
          "partial": "Flat Seq",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-FlatSeq.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class of types that can be partially evaluated, but evaluation can be propagated deeper than WHNF\n\u003c/p\u003e",
          "module": "Control.FlatSeq",
          "name": "WNFData",
          "package": "hxt",
          "source": "src/Control-FlatSeq.html#WNFData",
          "type": "class"
        },
        "index": {
          "description": "class of types that can be partially evaluated but evaluation can be propagated deeper than WHNF",
          "hierarchy": "Control FlatSeq",
          "module": "Control.FlatSeq",
          "name": "WNFData",
          "package": "hxt",
          "partial": "WNFData",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-FlatSeq.html#t:WNFData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.FlatSeq",
          "name": "($!!)",
          "package": "hxt",
          "signature": "(a -\u003e b) -\u003e a -\u003e b",
          "source": "src/Control-FlatSeq.html#%24%21%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control FlatSeq",
          "module": "Control.FlatSeq",
          "name": "($!!) $!!",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "hxt",
          "signature": "(a-\u003eb)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-FlatSeq.html#v:-36--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.FlatSeq",
          "name": "flatseq",
          "package": "hxt",
          "signature": "a -\u003e b -\u003e b",
          "source": "src/Control-FlatSeq.html#flatseq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control FlatSeq",
          "module": "Control.FlatSeq",
          "name": "flatseq",
          "normalized": "a-\u003eb-\u003eb",
          "package": "hxt",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-FlatSeq.html#v:flatseq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.FlatSeq",
          "name": "rlnf",
          "package": "hxt",
          "signature": "(a -\u003e ()) -\u003e [a] -\u003e ()",
          "source": "src/Control-FlatSeq.html#rlnf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control FlatSeq",
          "module": "Control.FlatSeq",
          "name": "rlnf",
          "normalized": "(a-\u003e())-\u003e[a]-\u003e()",
          "package": "hxt",
          "signature": "(a-\u003e())-\u003e[a]-\u003e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-FlatSeq.html#v:rlnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault for rwnf is reduction to WHNF\n\u003c/p\u003e",
          "module": "Control.FlatSeq",
          "name": "rwnf",
          "package": "hxt",
          "signature": "a -\u003e ()",
          "source": "src/Control-FlatSeq.html#rwnf",
          "type": "method"
        },
        "index": {
          "description": "Default for rwnf is reduction to WHNF",
          "hierarchy": "Control FlatSeq",
          "module": "Control.FlatSeq",
          "name": "rwnf",
          "normalized": "a-\u003e()",
          "package": "hxt",
          "signature": "a-\u003e()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-FlatSeq.html#v:rwnf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault for rwnf2 is rwnf\n\u003c/p\u003e",
          "module": "Control.FlatSeq",
          "name": "rwnf2",
          "package": "hxt",
          "signature": "a -\u003e ()",
          "source": "src/Control-FlatSeq.html#rwnf2",
          "type": "method"
        },
        "index": {
          "description": "Default for rwnf2 is rwnf",
          "hierarchy": "Control FlatSeq",
          "module": "Control.FlatSeq",
          "name": "rwnf2",
          "normalized": "a-\u003e()",
          "package": "hxt",
          "signature": "a-\u003e()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Control-FlatSeq.html#v:rwnf2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple key value assocciation list\n   implemented as unordered list of pairs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.AssocList",
          "name": "AssocList",
          "package": "hxt",
          "source": "src/Data-AssocList.html",
          "type": "module"
        },
        "index": {
          "description": "Simple key value assocciation list implemented as unordered list of pairs",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "AssocList",
          "package": "hxt",
          "partial": "Assoc List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.AssocList",
          "name": "AssocList",
          "package": "hxt",
          "source": "src/Data-AssocList.html#AssocList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "AssocList",
          "package": "hxt",
          "partial": "Assoc List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#t:AssocList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd a whole list of entries with \u003ccode\u003e\u003ca\u003eaddEntry\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.AssocList",
          "name": "addEntries",
          "package": "hxt",
          "signature": "AssocList k v -\u003e AssocList k v -\u003e AssocList k v",
          "source": "src/Data-AssocList.html#addEntries",
          "type": "function"
        },
        "index": {
          "description": "add whole list of entries with addEntry",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "addEntries",
          "normalized": "AssocList a b-\u003eAssocList a b-\u003eAssocList a b",
          "package": "hxt",
          "partial": "Entries",
          "signature": "AssocList k v-\u003eAssocList k v-\u003eAssocList k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#v:addEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an entry, remove an existing entry before adding the new one at the top of the list, addEntry is strict\n\u003c/p\u003e",
          "module": "Data.AssocList",
          "name": "addEntry",
          "package": "hxt",
          "signature": "k -\u003e v -\u003e AssocList k v -\u003e AssocList k v",
          "source": "src/Data-AssocList.html#addEntry",
          "type": "function"
        },
        "index": {
          "description": "add an entry remove an existing entry before adding the new one at the top of the list addEntry is strict",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "addEntry",
          "normalized": "a-\u003eb-\u003eAssocList a b-\u003eAssocList a b",
          "package": "hxt",
          "partial": "Entry",
          "signature": "k-\u003ev-\u003eAssocList k v-\u003eAssocList k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#v:addEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edelete a list of entries with \u003ccode\u003e\u003ca\u003edelEntry\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.AssocList",
          "name": "delEntries",
          "package": "hxt",
          "signature": "[k] -\u003e AssocList k v -\u003e AssocList k v",
          "source": "src/Data-AssocList.html#delEntries",
          "type": "function"
        },
        "index": {
          "description": "delete list of entries with delEntry",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "delEntries",
          "normalized": "[a]-\u003eAssocList a b-\u003eAssocList a b",
          "package": "hxt",
          "partial": "Entries",
          "signature": "[k]-\u003eAssocList k v-\u003eAssocList k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#v:delEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edelete an entry, delEntry is strict\n\u003c/p\u003e",
          "module": "Data.AssocList",
          "name": "delEntry",
          "package": "hxt",
          "signature": "k -\u003e AssocList k v -\u003e AssocList k v",
          "source": "src/Data-AssocList.html#delEntry",
          "type": "function"
        },
        "index": {
          "description": "delete an entry delEntry is strict",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "delEntry",
          "normalized": "a-\u003eAssocList a b-\u003eAssocList a b",
          "package": "hxt",
          "partial": "Entry",
          "signature": "k-\u003eAssocList k v-\u003eAssocList k v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#v:delEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for existence of a key\n\u003c/p\u003e",
          "module": "Data.AssocList",
          "name": "hasEntry",
          "package": "hxt",
          "signature": "k -\u003e AssocList k v -\u003e Bool",
          "source": "src/Data-AssocList.html#hasEntry",
          "type": "function"
        },
        "index": {
          "description": "test for existence of key",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "hasEntry",
          "normalized": "a-\u003eAssocList a b-\u003eBool",
          "package": "hxt",
          "partial": "Entry",
          "signature": "k-\u003eAssocList k v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#v:hasEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elookup with empty list (empty string) as default value\n\u003c/p\u003e",
          "module": "Data.AssocList",
          "name": "lookup1",
          "package": "hxt",
          "signature": "k -\u003e AssocList k [e] -\u003e [e]",
          "source": "src/Data-AssocList.html#lookup1",
          "type": "function"
        },
        "index": {
          "description": "lookup with empty list empty string as default value",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "lookup1",
          "normalized": "a-\u003eAssocList a[b]-\u003e[b]",
          "package": "hxt",
          "signature": "k-\u003eAssocList k[e]-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#v:lookup1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elookup with default value\n\u003c/p\u003e",
          "module": "Data.AssocList",
          "name": "lookupDef",
          "package": "hxt",
          "signature": "v -\u003e k -\u003e AssocList k v -\u003e v",
          "source": "src/Data-AssocList.html#lookupDef",
          "type": "function"
        },
        "index": {
          "description": "lookup with default value",
          "hierarchy": "Data AssocList",
          "module": "Data.AssocList",
          "name": "lookupDef",
          "normalized": "a-\u003eb-\u003eAssocList b a-\u003ea",
          "package": "hxt",
          "partial": "Def",
          "signature": "v-\u003ek-\u003eAssocList k v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-AssocList.html#v:lookupDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnique Atoms generated from Strings and\n   managed as flyweights\n\u003c/p\u003e\u003cp\u003eData.Atom can be used for caching and storage optimisation\n   of frequently used strings. An \u003ccode\u003eAtom\u003c/code\u003e is constructed from a \u003ccode\u003eString\u003c/code\u003e.\n   For two equal strings the identical atom is returned.\n\u003c/p\u003e\u003cp\u003eThis module can be used for optimizing memory usage when working with\n   strings or names. Many applications use data types like\n   \u003ccode\u003eMap String SomeAttribute\u003c/code\u003e where a rather fixed set of keys is used.\n   Especially XML applications often work with a limited set of element and attribute names.\n   For these applications it becomes more memory efficient when working with types like\n   \u003ccode\u003eMap Atom SomeAttribute\u003c/code\u003e and convert the keys into atoms before operating\n   on such a map.\n\u003c/p\u003e\u003cp\u003eInternally this module manages a map of atoms. The atoms are internally represented\n   by \u003ccode\u003eByteString\u003c/code\u003es. When creating a new atom from a string, the string is first converted\n   into an UTF8 \u003ccode\u003eWord8\u003c/code\u003e sequence, which is packed into a \u003ccode\u003eByteString\u003c/code\u003e. This \u003ccode\u003eByteString\u003c/code\u003e is looked\n   up in the table of atoms. If it is already there, the value in the map is used as atom, else\n   the new \u003ccode\u003eByteString\u003c/code\u003e is inserted into the map.\n\u003c/p\u003e\u003cp\u003eOf course the implementation of this name cache uses \u003ccode\u003eunsavePerformIO\u003c/code\u003e.\n   The global cache is managed by ue of an \u003ccode\u003eIORef\u003c/code\u003e and atomicModifyIORef.\n\u003c/p\u003e\u003cp\u003eThe following laws hold for atoms\n\u003c/p\u003e\u003cpre\u003e\n s  ==       t =\u003e newAtom s  ==       newAtom t\n s `compare` t =\u003e newAtom s `compare` newAtom t\n show . newAtom == id\n\u003c/pre\u003e\u003cp\u003eEquality test for \u003ccode\u003eAtom\u003c/code\u003es runs in \u003cem\u003eO(1)\u003c/em\u003e, it is just a pointer comarison.\n   The \u003ccode\u003eOrd\u003c/code\u003e comparisons have the same runtime like the \u003ccode\u003eByteString\u003c/code\u003e comparisons.\n   Internally there is an UTF8 comparison, but UTF8 encoding preserves the total order.\n\u003c/p\u003e\u003cp\u003eWarning: The internal cache never shrinks during execution. So using it in a\n   undisciplined way can lead to memory leaks.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Atom",
          "name": "Atom",
          "package": "hxt",
          "source": "src/Data-Atom.html",
          "type": "module"
        },
        "index": {
          "description": "Unique Atoms generated from Strings and managed as flyweights Data.Atom can be used for caching and storage optimisation of frequently used strings An Atom is constructed from String For two equal strings the identical atom is returned This module can be used for optimizing memory usage when working with strings or names Many applications use data types like Map String SomeAttribute where rather fixed set of keys is used Especially XML applications often work with limited set of element and attribute names For these applications it becomes more memory efficient when working with types like Map Atom SomeAttribute and convert the keys into atoms before operating on such map Internally this module manages map of atoms The atoms are internally represented by ByteString When creating new atom from string the string is first converted into an UTF8 Word8 sequence which is packed into ByteString This ByteString is looked up in the table of atoms If it is already there the value in the map is used as atom else the new ByteString is inserted into the map Of course the implementation of this name cache uses unsavePerformIO The global cache is managed by ue of an IORef and atomicModifyIORef The following laws hold for atoms newAtom newAtom compare newAtom compare newAtom show newAtom id Equality test for Atom runs in it is just pointer comarison The Ord comparisons have the same runtime like the ByteString comparisons Internally there is an UTF8 comparison but UTF8 encoding preserves the total order Warning The internal cache never shrinks during execution So using it in undisciplined way can lead to memory leaks",
          "hierarchy": "Data Atom",
          "module": "Data.Atom",
          "name": "Atom",
          "package": "hxt",
          "partial": "Atom",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Atom.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Atom",
          "name": "Atom",
          "package": "hxt",
          "source": "src/Data-Atom.html#Atom",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Atom",
          "module": "Data.Atom",
          "name": "Atom",
          "package": "hxt",
          "partial": "Atom",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Atom.html#t:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreation of an \u003ccode\u003eAtom\u003c/code\u003e from a \u003ccode\u003eString\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Atom",
          "name": "newAtom",
          "package": "hxt",
          "signature": "String -\u003e Atom",
          "source": "src/Data-Atom.html#newAtom",
          "type": "function"
        },
        "index": {
          "description": "creation of an Atom from String",
          "hierarchy": "Data Atom",
          "module": "Data.Atom",
          "name": "newAtom",
          "normalized": "String-\u003eAtom",
          "package": "hxt",
          "partial": "Atom",
          "signature": "String-\u003eAtom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Atom.html#v:newAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert a \u003ccode\u003eString\u003c/code\u003e into the atom cache and convert the atom back into a \u003ccode\u003eString\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003elocically \u003ccode\u003eshare == id\u003c/code\u003e holds, but internally equal strings share the same memory.\n\u003c/p\u003e",
          "module": "Data.Atom",
          "name": "share",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Data-Atom.html#share",
          "type": "function"
        },
        "index": {
          "description": "Insert String into the atom cache and convert the atom back into String locically share id holds but internally equal strings share the same memory",
          "hierarchy": "Data Atom",
          "module": "Data.Atom",
          "name": "share",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Atom.html#v:share"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.Selector",
          "name": "Selector",
          "package": "hxt",
          "source": "src/Data-Function-Selector.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "Selector",
          "package": "hxt",
          "partial": "Selector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelectors for pairs and 3-tuples: comp1, comp2, comp3,\n this can be extended to n-tuples\n\u003c/p\u003e",
          "module": "Data.Function.Selector",
          "name": "Comp1",
          "package": "hxt",
          "source": "src/Data-Function-Selector.html#Comp1",
          "type": "class"
        },
        "index": {
          "description": "Selectors for pairs and tuples comp1 comp2 comp3 this can be extended to n-tuples",
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "Comp1",
          "package": "hxt",
          "partial": "Comp",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#t:Comp1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.Selector",
          "name": "Comp2",
          "package": "hxt",
          "source": "src/Data-Function-Selector.html#Comp2",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "Comp2",
          "package": "hxt",
          "partial": "Comp",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#t:Comp2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.Selector",
          "name": "Comp3",
          "package": "hxt",
          "source": "src/Data-Function-Selector.html#Comp3",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "Comp3",
          "package": "hxt",
          "partial": "Comp",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#t:Comp3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Selector is a pair of an access function and a modifying function\n for reading and updating parts of a composite type\n\u003c/p\u003e",
          "module": "Data.Function.Selector",
          "name": "Selector",
          "package": "hxt",
          "source": "src/Data-Function-Selector.html#Selector",
          "type": "data"
        },
        "index": {
          "description": "Selector is pair of an access function and modifying function for reading and updating parts of composite type",
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "Selector",
          "package": "hxt",
          "partial": "Selector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#t:Selector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Function.Selector\",\"Text.XML.HXT.Arrow.XmlState.TypeDefs\"]",
          "name": "(.&&&.)",
          "package": "hxt",
          "signature": "Selector s a -\u003e Selector s b -\u003e Selector s (a, b)",
          "source": "src/Data-Function-Selector.html#.%26%26%26.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:.-38--38--38-.\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:.-38--38--38-.\"]"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "(.&&&.) .&&&.",
          "normalized": "Selector a b-\u003eSelector a c-\u003eSelector a(b,c)",
          "package": "hxt",
          "signature": "Selector s a-\u003eSelector s b-\u003eSelector s(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:.-38--38--38-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Function.Selector\",\"Text.XML.HXT.Arrow.XmlState.TypeDefs\"]",
          "name": "S",
          "package": "hxt",
          "signature": "S",
          "source": "src/Data-Function-Selector.html#Selector",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:S\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:S\"]"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "S",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.Selector",
          "name": "chgM",
          "package": "hxt",
          "signature": "Selector s a -\u003e (a -\u003e m a) -\u003e s -\u003e m s",
          "source": "src/Data-Function-Selector.html#chgM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "chgM",
          "normalized": "Selector a b-\u003e(b-\u003ec b)-\u003ea-\u003ec a",
          "package": "hxt",
          "signature": "Selector s a-\u003e(a-\u003em a)-\u003es-\u003em s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:chgM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Function.Selector\",\"Text.XML.HXT.Arrow.XmlState.TypeDefs\"]",
          "name": "chgS",
          "package": "hxt",
          "signature": "Selector s a -\u003e (a -\u003e a) -\u003e s -\u003e s",
          "source": "src/Data-Function-Selector.html#chgS",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:chgS\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:chgS\"]"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "chgS",
          "normalized": "Selector a b-\u003e(b-\u003eb)-\u003ea-\u003ea",
          "package": "hxt",
          "signature": "Selector s a-\u003e(a-\u003ea)-\u003es-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:chgS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.Selector",
          "name": "comp1",
          "package": "hxt",
          "signature": "Selector s a",
          "source": "src/Data-Function-Selector.html#comp1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "comp1",
          "package": "hxt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:comp1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.Selector",
          "name": "comp2",
          "package": "hxt",
          "signature": "Selector s a",
          "source": "src/Data-Function-Selector.html#comp2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "comp2",
          "package": "hxt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:comp2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.Selector",
          "name": "comp3",
          "package": "hxt",
          "signature": "Selector s a",
          "source": "src/Data-Function-Selector.html#comp3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "comp3",
          "package": "hxt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:comp3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Function.Selector\",\"Text.XML.HXT.Arrow.XmlState.TypeDefs\"]",
          "name": "getS",
          "package": "hxt",
          "signature": "s -\u003e a",
          "source": "src/Data-Function-Selector.html#Selector",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:getS\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getS\"]"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "getS",
          "normalized": "a-\u003eb",
          "package": "hxt",
          "signature": "s-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:getS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Function.Selector\",\"Text.XML.HXT.Arrow.XmlState.TypeDefs\"]",
          "name": "idS",
          "package": "hxt",
          "signature": "Selector s s",
          "source": "src/Data-Function-Selector.html#idS",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:idS\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:idS\"]"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "idS",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:idS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlias for constructor S\n\u003c/p\u003e",
          "module": "Data.Function.Selector",
          "name": "mkSelector",
          "package": "hxt",
          "signature": "(s -\u003e a) -\u003e (a -\u003e s -\u003e s) -\u003e Selector s a",
          "source": "src/Data-Function-Selector.html#mkSelector",
          "type": "function"
        },
        "index": {
          "description": "Alias for constructor",
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "mkSelector",
          "normalized": "(a-\u003eb)-\u003e(b-\u003ea-\u003ea)-\u003eSelector a b",
          "package": "hxt",
          "partial": "Selector",
          "signature": "(s-\u003ea)-\u003e(a-\u003es-\u003es)-\u003eSelector s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:mkSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Data.Function.Selector\",\"Text.XML.HXT.Arrow.XmlState.TypeDefs\"]",
          "name": "setS",
          "package": "hxt",
          "signature": "a -\u003e s -\u003e s",
          "source": "src/Data-Function-Selector.html#Selector",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:setS\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setS\"]"
        },
        "index": {
          "hierarchy": "Data Function Selector",
          "module": "Data.Function.Selector",
          "name": "setS",
          "normalized": "a-\u003eb-\u003eb",
          "package": "hxt",
          "signature": "a-\u003es-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Function-Selector.html#v:setS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterface definition for trees\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.Class",
          "name": "Class",
          "package": "hxt",
          "source": "src/Data-Tree-Class.html",
          "type": "module"
        },
        "index": {
          "description": "Interface definition for trees",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "Class",
          "package": "hxt",
          "partial": "Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for trees\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "Tree",
          "package": "hxt",
          "source": "src/Data-Tree-Class.html#Tree",
          "type": "class"
        },
        "index": {
          "description": "The interface for trees",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "Tree",
          "package": "hxt",
          "partial": "Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumber of nodes in a tree\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "cardTree",
          "package": "hxt",
          "signature": "t a -\u003e Int",
          "source": "src/Data-Tree-Class.html#cardTree",
          "type": "method"
        },
        "index": {
          "description": "number of nodes in tree",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "cardTree",
          "normalized": "a b-\u003eInt",
          "package": "hxt",
          "partial": "Tree",
          "signature": "t a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:cardTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit children\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "changeChildren",
          "package": "hxt",
          "signature": "([t a] -\u003e [t a]) -\u003e t a -\u003e t a",
          "source": "src/Data-Tree-Class.html#changeChildren",
          "type": "method"
        },
        "index": {
          "description": "edit children",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "changeChildren",
          "normalized": "([a b]-\u003e[a b])-\u003ea b-\u003ea b",
          "package": "hxt",
          "partial": "Children",
          "signature": "([t a]-\u003e[t a])-\u003et a-\u003et a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:changeChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit node attribute\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "changeNode",
          "package": "hxt",
          "signature": "(a -\u003e a) -\u003e t a -\u003e t a",
          "source": "src/Data-Tree-Class.html#changeNode",
          "type": "method"
        },
        "index": {
          "description": "edit node attribute",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "changeNode",
          "normalized": "(a-\u003ea)-\u003eb a-\u003eb a",
          "package": "hxt",
          "partial": "Node",
          "signature": "(a-\u003ea)-\u003et a-\u003et a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:changeNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edepth of a tree\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "depthTree",
          "package": "hxt",
          "signature": "t a -\u003e Int",
          "source": "src/Data-Tree-Class.html#depthTree",
          "type": "method"
        },
        "index": {
          "description": "depth of tree",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "depthTree",
          "normalized": "a b-\u003eInt",
          "package": "hxt",
          "partial": "Tree",
          "signature": "t a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:depthTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efold for trees\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "foldTree",
          "package": "hxt",
          "signature": "(a -\u003e [b] -\u003e b) -\u003e t a -\u003e b",
          "source": "src/Data-Tree-Class.html#foldTree",
          "type": "method"
        },
        "index": {
          "description": "fold for trees",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "foldTree",
          "normalized": "(a-\u003e[b]-\u003eb)-\u003ec a-\u003eb",
          "package": "hxt",
          "partial": "Tree",
          "signature": "(a-\u003e[b]-\u003eb)-\u003et a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:foldTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a tree into a pseudo graphical string representation\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "formatNTree'",
          "package": "hxt",
          "signature": "(a -\u003e String) -\u003e (String -\u003e String) -\u003e (String -\u003e String) -\u003e t a -\u003e String -\u003e String",
          "source": "src/Data-Tree-Class.html#formatNTree%27",
          "type": "function"
        },
        "index": {
          "description": "convert tree into pseudo graphical string representation",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "formatNTree'",
          "normalized": "(a-\u003eString)-\u003e(String-\u003eString)-\u003e(String-\u003eString)-\u003eb a-\u003eString-\u003eString",
          "package": "hxt",
          "partial": "NTree'",
          "signature": "(a-\u003eString)-\u003e(String-\u003eString)-\u003e(String-\u003eString)-\u003et a-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:formatNTree-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eformat tree for readable trace output\n\u003c/p\u003e\u003cp\u003ea \u003cem\u003egraphical\u003c/em\u003e representation of the tree in text format\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "formatTree",
          "package": "hxt",
          "signature": "(a -\u003e String) -\u003e t a -\u003e String",
          "source": "src/Data-Tree-Class.html#formatTree",
          "type": "method"
        },
        "index": {
          "description": "format tree for readable trace output graphical representation of the tree in text format",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "formatTree",
          "normalized": "(a-\u003eString)-\u003eb a-\u003eString",
          "package": "hxt",
          "partial": "Tree",
          "signature": "(a-\u003eString)-\u003et a-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:formatTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect children\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "getChildren",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-Class.html#getChildren",
          "type": "method"
        },
        "index": {
          "description": "select children",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "getChildren",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Children",
          "signature": "t a-\u003e[t a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:getChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect node attribute\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "getNode",
          "package": "hxt",
          "signature": "t a -\u003e a",
          "source": "src/Data-Tree-Class.html#getNode",
          "type": "method"
        },
        "index": {
          "description": "select node attribute",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "getNode",
          "normalized": "a b-\u003eb",
          "package": "hxt",
          "partial": "Node",
          "signature": "t a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:getNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einnner node test: \u003ccode\u003e not . isLeaf \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "isInner",
          "package": "hxt",
          "signature": "t a -\u003e Bool",
          "source": "src/Data-Tree-Class.html#isInner",
          "type": "method"
        },
        "index": {
          "description": "innner node test not isLeaf",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "isInner",
          "normalized": "a b-\u003eBool",
          "package": "hxt",
          "partial": "Inner",
          "signature": "t a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:isInner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleaf test: list of children empty?\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "isLeaf",
          "package": "hxt",
          "signature": "t a -\u003e Bool",
          "source": "src/Data-Tree-Class.html#isLeaf",
          "type": "method"
        },
        "index": {
          "description": "leaf test list of children empty",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "isLeaf",
          "normalized": "a b-\u003eBool",
          "package": "hxt",
          "partial": "Leaf",
          "signature": "t a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:isLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleaf construction: leafs don't have any children\n\u003c/p\u003e\u003cp\u003edefinition: \u003ccode\u003e mkLeaf n = mkTree n [] \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "mkLeaf",
          "package": "hxt",
          "signature": "a -\u003e t a",
          "source": "src/Data-Tree-Class.html#mkLeaf",
          "type": "method"
        },
        "index": {
          "description": "leaf construction leafs don have any children definition mkLeaf mkTree",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "mkLeaf",
          "normalized": "a-\u003eb a",
          "package": "hxt",
          "partial": "Leaf",
          "signature": "a-\u003et a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:mkLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etree construction: a new tree is constructed by a node attribute and a list of children\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "mkTree",
          "package": "hxt",
          "signature": "a -\u003e [t a] -\u003e t a",
          "source": "src/Data-Tree-Class.html#mkTree",
          "type": "method"
        },
        "index": {
          "description": "tree construction new tree is constructed by node attribute and list of children",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "mkTree",
          "normalized": "a-\u003e[b a]-\u003eb a",
          "package": "hxt",
          "partial": "Tree",
          "signature": "a-\u003e[t a]-\u003et a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:mkTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eall nodes of a tree\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "nodesTree",
          "package": "hxt",
          "signature": "t a -\u003e [a]",
          "source": "src/Data-Tree-Class.html#nodesTree",
          "type": "method"
        },
        "index": {
          "description": "all nodes of tree",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "nodesTree",
          "normalized": "a b-\u003e[b]",
          "package": "hxt",
          "partial": "Tree",
          "signature": "t a-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:nodesTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esubstitute children: \u003ccode\u003e setChildren cl = changeChildren (const cl) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "setChildren",
          "package": "hxt",
          "signature": "[t a] -\u003e t a -\u003e t a",
          "source": "src/Data-Tree-Class.html#setChildren",
          "type": "method"
        },
        "index": {
          "description": "substitute children setChildren cl changeChildren const cl",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "setChildren",
          "normalized": "[a b]-\u003ea b-\u003ea b",
          "package": "hxt",
          "partial": "Children",
          "signature": "[t a]-\u003et a-\u003et a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:setChildren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esubstitute node: \u003ccode\u003e setNode n = changeNode (const n) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Tree.Class",
          "name": "setNode",
          "package": "hxt",
          "signature": "a -\u003e t a -\u003e t a",
          "source": "src/Data-Tree-Class.html#setNode",
          "type": "method"
        },
        "index": {
          "description": "substitute node setNode changeNode const",
          "hierarchy": "Data Tree Class",
          "module": "Data.Tree.Class",
          "name": "setNode",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "hxt",
          "partial": "Node",
          "signature": "a-\u003et a-\u003et a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-Class.html#v:setNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpace and time efficient editing of rose trees\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.NTree.Edit",
          "name": "Edit",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-Edit.html",
          "type": "module"
        },
        "index": {
          "description": "Space and time efficient editing of rose trees",
          "hierarchy": "Data Tree NTree Edit",
          "module": "Data.Tree.NTree.Edit",
          "name": "Edit",
          "package": "hxt",
          "partial": "Edit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Edit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeditNTreeBottomUp is a space optimized tree edit function\n\u003c/p\u003e\u003cp\u003eThe nodes in a tree are visited bottom up. An edit function is applied to\n all nodes. A Nothing result of the editing function indicates no changes.\n This is used to share the input tree within the resulting tree.\n\u003c/p\u003e\u003cp\u003eThe following law holds:\n\u003c/p\u003e\u003cpre\u003e editNTreeBottomUp (const Nothing) t == [t]\n\u003c/pre\u003e\u003cp\u003eIn this case the resulting tree does not only represent the same value\n but it is the same machine value (relative to some evaluations of closures\n during the tree walk\n\u003c/p\u003e\u003cp\u003eWith a simple fold like editing function the whole tree would be reconstructed\n in memory\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.Edit",
          "name": "editNTreeBottomUp",
          "package": "hxt",
          "signature": "(NTree a -\u003e Maybe [NTree a]) -\u003e NTree a -\u003e [NTree a]",
          "source": "src/Data-Tree-NTree-Edit.html#editNTreeBottomUp",
          "type": "function"
        },
        "index": {
          "description": "editNTreeBottomUp is space optimized tree edit function The nodes in tree are visited bottom up An edit function is applied to all nodes Nothing result of the editing function indicates no changes This is used to share the input tree within the resulting tree The following law holds editNTreeBottomUp const Nothing In this case the resulting tree does not only represent the same value but it is the same machine value relative to some evaluations of closures during the tree walk With simple fold like editing function the whole tree would be reconstructed in memory",
          "hierarchy": "Data Tree NTree Edit",
          "module": "Data.Tree.NTree.Edit",
          "name": "editNTreeBottomUp",
          "normalized": "(NTree a-\u003eMaybe[NTree a])-\u003eNTree a-\u003e[NTree a]",
          "package": "hxt",
          "partial": "NTree Bottom Up",
          "signature": "(NTree a-\u003eMaybe[NTree a])-\u003eNTree a-\u003e[NTree a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Edit.html#v:editNTreeBottomUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA space optimized map for NTrees\n\u003c/p\u003e\u003cp\u003eSubtrees, that are not changed are reused in the resulting tree\n See also: editNTreeBottomUp\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.Edit",
          "name": "mapNTree'",
          "package": "hxt",
          "signature": "(a -\u003e Maybe a) -\u003e NTree a -\u003e NTree a",
          "source": "src/Data-Tree-NTree-Edit.html#mapNTree%27",
          "type": "function"
        },
        "index": {
          "description": "space optimized map for NTrees Subtrees that are not changed are reused in the resulting tree See also editNTreeBottomUp",
          "hierarchy": "Data Tree NTree Edit",
          "module": "Data.Tree.NTree.Edit",
          "name": "mapNTree'",
          "normalized": "(a-\u003eMaybe a)-\u003eNTree a-\u003eNTree a",
          "package": "hxt",
          "partial": "NTree'",
          "signature": "(a-\u003eMaybe a)-\u003eNTree a-\u003eNTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Edit.html#v:mapNTree-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterface definition for trees\n\u003c/p\u003e\u003cp\u003en-ary tree structure (rose trees)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-TypeDefs.html",
          "type": "module"
        },
        "index": {
          "description": "Interface definition for trees n-ary tree structure rose trees",
          "hierarchy": "Data Tree NTree TypeDefs",
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "partial": "Type Defs",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-TypeDefs.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003en-ary ordered tree (rose trees)\n\u003c/p\u003e\u003cp\u003ea tree consists of a node and a possible empty list of children.\n If the list of children is empty, the node is a leaf, else it's\n an inner node.\n\u003c/p\u003e\u003cp\u003eNTree implements Eq, Ord, Show and Read\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "NTree",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-TypeDefs.html#NTree",
          "type": "data"
        },
        "index": {
          "description": "n-ary ordered tree rose trees tree consists of node and possible empty list of children If the list of children is empty the node is leaf else it an inner node NTree implements Eq Ord Show and Read",
          "hierarchy": "Data Tree NTree TypeDefs",
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "NTree",
          "package": "hxt",
          "partial": "NTree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-TypeDefs.html#t:NTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshortcut for a sequence of n-ary trees\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "NTrees",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-TypeDefs.html#NTrees",
          "type": "type"
        },
        "index": {
          "description": "shortcut for sequence of n-ary trees",
          "hierarchy": "Data Tree NTree TypeDefs",
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "NTrees",
          "package": "hxt",
          "partial": "NTrees",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-TypeDefs.html#t:NTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "NTree",
          "package": "hxt",
          "signature": "NTree a (NTrees a)",
          "source": "src/Data-Tree-NTree-TypeDefs.html#NTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree TypeDefs",
          "module": "Data.Tree.NTree.TypeDefs",
          "name": "NTree",
          "package": "hxt",
          "partial": "NTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-TypeDefs.html#v:NTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementation of navigateble trees for\n   rose trees. The implementation is done with zippers.\n   A description and introductory tutorial about zippers\n   can be found in \u003ca\u003ehttp://learnyouahaskell.com/zippers\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html",
          "type": "module"
        },
        "index": {
          "description": "Implementation of navigateble trees for rose trees The implementation is done with zippers description and introductory tutorial about zippers can be found in http learnyouahaskell.com zippers",
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "partial": "Type Defs",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of unzipped nodes from a current tree back to the root\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTBreadCrumbs",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#NTBreadCrumbs",
          "type": "type"
        },
        "index": {
          "description": "The list of unzipped nodes from current tree back to the root",
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTBreadCrumbs",
          "package": "hxt",
          "partial": "NTBread Crumbs",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#t:NTBreadCrumbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOne unzipped step consists of the left siblings, the node info and the right siblings\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTCrumb",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#NTCrumb",
          "type": "data"
        },
        "index": {
          "description": "One unzipped step consists of the left siblings the node info and the right siblings",
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTCrumb",
          "package": "hxt",
          "partial": "NTCrumb",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#t:NTCrumb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZipper for rose trees\n\u003c/p\u003e\u003cp\u003eA zipper consist of the current tree and the branches on the way back to the root\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTZipper",
          "package": "hxt",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#NTZipper",
          "type": "data"
        },
        "index": {
          "description": "Zipper for rose trees zipper consist of the current tree and the branches on the way back to the root",
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTZipper",
          "package": "hxt",
          "partial": "NTZipper",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#t:NTZipper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTC",
          "package": "hxt",
          "signature": "NTC (NTrees a) a (NTrees a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#NTCrumb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTC",
          "package": "hxt",
          "partial": "NTC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:NTC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTZ",
          "package": "hxt",
          "signature": "NTZ",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#NTZipper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "NTZ",
          "package": "hxt",
          "partial": "NTZ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:NTZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "addToTheLeft",
          "package": "hxt",
          "signature": "NTree a -\u003e NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#addToTheLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "addToTheLeft",
          "normalized": "NTree a-\u003eNTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "partial": "To The Left",
          "signature": "NTree a-\u003eNTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:addToTheLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "addToTheRight",
          "package": "hxt",
          "signature": "NTree a -\u003e NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#addToTheRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "addToTheRight",
          "normalized": "NTree a-\u003eNTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "partial": "To The Right",
          "signature": "NTree a-\u003eNTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:addToTheRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "context",
          "package": "hxt",
          "signature": "NTBreadCrumbs a",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#NTZipper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "context",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "down",
          "package": "hxt",
          "signature": "NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#down",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "down",
          "normalized": "NTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "signature": "NTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:down"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "dropFromTheLeft",
          "package": "hxt",
          "signature": "NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#dropFromTheLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "dropFromTheLeft",
          "normalized": "NTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "partial": "From The Left",
          "signature": "NTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:dropFromTheLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "dropFromTheRight",
          "package": "hxt",
          "signature": "NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#dropFromTheRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "dropFromTheRight",
          "normalized": "NTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "partial": "From The Right",
          "signature": "NTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:dropFromTheRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion of a navigatable rose tree into an ordinary rose tree.\n\u003c/p\u003e\u003cp\u003eThe context, the parts for moving up to the root are just removed from the tree.\n So when transforming a navigatable tree by moving around and by changing some nodes,\n one has to navigate back\n to the root, else that parts are removed from the result\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "fromNTZipper",
          "package": "hxt",
          "signature": "NTZipper a -\u003e NTree a",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#fromNTZipper",
          "type": "function"
        },
        "index": {
          "description": "Conversion of navigatable rose tree into an ordinary rose tree The context the parts for moving up to the root are just removed from the tree So when transforming navigatable tree by moving around and by changing some nodes one has to navigate back to the root else that parts are removed from the result",
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "fromNTZipper",
          "normalized": "NTZipper a-\u003eNTree a",
          "package": "hxt",
          "partial": "NTZipper",
          "signature": "NTZipper a-\u003eNTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:fromNTZipper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "isTop",
          "package": "hxt",
          "signature": "NTZipper a -\u003e Bool",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#isTop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "isTop",
          "normalized": "NTZipper a-\u003eBool",
          "package": "hxt",
          "partial": "Top",
          "signature": "NTZipper a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:isTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "ntree",
          "package": "hxt",
          "signature": "NTree a",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#NTZipper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "ntree",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:ntree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion of a rose tree into a navigatable rose tree\n\u003c/p\u003e",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "toNTZipper",
          "package": "hxt",
          "signature": "NTree a -\u003e NTZipper a",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#toNTZipper",
          "type": "function"
        },
        "index": {
          "description": "Conversion of rose tree into navigatable rose tree",
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "toNTZipper",
          "normalized": "NTree a-\u003eNTZipper a",
          "package": "hxt",
          "partial": "NTZipper",
          "signature": "NTree a-\u003eNTZipper a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:toNTZipper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "toTheLeft",
          "package": "hxt",
          "signature": "NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#toTheLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "toTheLeft",
          "normalized": "NTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "partial": "The Left",
          "signature": "NTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:toTheLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "toTheRight",
          "package": "hxt",
          "signature": "NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#toTheRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "toTheRight",
          "normalized": "NTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "partial": "The Right",
          "signature": "NTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:toTheRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "up",
          "package": "hxt",
          "signature": "NTZipper a -\u003e Maybe (NTZipper a)",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#up",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "up",
          "normalized": "NTZipper a-\u003eMaybe(NTZipper a)",
          "package": "hxt",
          "signature": "NTZipper a-\u003eMaybe(NTZipper a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:up"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "up1",
          "package": "hxt",
          "signature": "NTree a -\u003e NTCrumb a -\u003e NTree a",
          "source": "src/Data-Tree-NTree-Zipper-TypeDefs.html#up1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NTree Zipper TypeDefs",
          "module": "Data.Tree.NTree.Zipper.TypeDefs",
          "name": "up1",
          "normalized": "NTree a-\u003eNTCrumb a-\u003eNTree a",
          "package": "hxt",
          "signature": "NTree a-\u003eNTCrumb a-\u003eNTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NTree-Zipper-TypeDefs.html#v:up1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterface definition for navigatable trees.\n   Navigatable trees need to have operations to move up, down, left and right.\n   With these elementary operations, most of the XPath axises can be defined.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "Class",
          "package": "hxt",
          "source": "src/Data-Tree-NavigatableTree-Class.html",
          "type": "module"
        },
        "index": {
          "description": "Interface definition for navigatable trees Navigatable trees need to have operations to move up down left and right With these elementary operations most of the XPath axises can be defined",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "Class",
          "package": "hxt",
          "partial": "Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe interface for navigatable trees\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "NavigatableTree",
          "package": "hxt",
          "source": "src/Data-Tree-NavigatableTree-Class.html#NavigatableTree",
          "type": "class"
        },
        "index": {
          "description": "The interface for navigatable trees",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "NavigatableTree",
          "package": "hxt",
          "partial": "Navigatable Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#t:NavigatableTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEdit operation on navigatable trees\n\u003c/p\u003e\u003cp\u003eThere is only a single navigatable tree implementation for a given tree allowed\n (see the functional dependencies)\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "NavigatableTreeModify",
          "package": "hxt",
          "source": "src/Data-Tree-NavigatableTree-Class.html#NavigatableTreeModify",
          "type": "class"
        },
        "index": {
          "description": "Edit operation on navigatable trees There is only single navigatable tree implementation for given tree allowed see the functional dependencies",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "NavigatableTreeModify",
          "package": "hxt",
          "partial": "Navigatable Tree Modify",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#t:NavigatableTreeModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion between trees and navigatable trees,\n\u003c/p\u003e\u003cp\u003eThere is only a single navigatable tree implementation for a given tree allowed\n (see the functional dependencies)\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "NavigatableTreeToTree",
          "package": "hxt",
          "source": "src/Data-Tree-NavigatableTree-Class.html#NavigatableTreeToTree",
          "type": "class"
        },
        "index": {
          "description": "Conversion between trees and navigatable trees There is only single navigatable tree implementation for given tree allowed see the functional dependencies",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "NavigatableTreeToTree",
          "package": "hxt",
          "partial": "Navigatable Tree To Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#t:NavigatableTreeToTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an ordinary tree in front of the given navigatable tree\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "addTreeLeft",
          "package": "hxt",
          "signature": "t a -\u003e nt a -\u003e Maybe (nt a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#addTreeLeft",
          "type": "method"
        },
        "index": {
          "description": "add an ordinary tree in front of the given navigatable tree",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "addTreeLeft",
          "normalized": "a b-\u003ec b-\u003eMaybe(c b)",
          "package": "hxt",
          "partial": "Tree Left",
          "signature": "t a-\u003ent a-\u003eMaybe(nt a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:addTreeLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an ordinary tree behind of the given navigatable tree\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "addTreeRight",
          "package": "hxt",
          "signature": "t a -\u003e nt a -\u003e Maybe (nt a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#addTreeRight",
          "type": "method"
        },
        "index": {
          "description": "add an ordinary tree behind of the given navigatable tree",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "addTreeRight",
          "normalized": "a b-\u003ec b-\u003eMaybe(c b)",
          "package": "hxt",
          "partial": "Tree Right",
          "signature": "t a-\u003ent a-\u003eMaybe(nt a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:addTreeRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edrop the direct left sibling tree of the given navigatable tree\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "dropTreeLeft",
          "package": "hxt",
          "signature": "nt a -\u003e Maybe (nt a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#dropTreeLeft",
          "type": "method"
        },
        "index": {
          "description": "drop the direct left sibling tree of the given navigatable tree",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "dropTreeLeft",
          "normalized": "a b-\u003eMaybe(a b)",
          "package": "hxt",
          "partial": "Tree Left",
          "signature": "nt a-\u003eMaybe(nt a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:dropTreeLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edrop the direct right sibling tree of the given navigatable tree\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "dropTreeRight",
          "package": "hxt",
          "signature": "nt a -\u003e Maybe (nt a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#dropTreeRight",
          "type": "method"
        },
        "index": {
          "description": "drop the direct right sibling tree of the given navigatable tree",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "dropTreeRight",
          "normalized": "a b-\u003eMaybe(a b)",
          "package": "hxt",
          "partial": "Tree Right",
          "signature": "nt a-\u003eMaybe(nt a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:dropTreeRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruct a navigatable tree\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "fromTree",
          "package": "hxt",
          "signature": "t a -\u003e nt a",
          "source": "src/Data-Tree-NavigatableTree-Class.html#fromTree",
          "type": "method"
        },
        "index": {
          "description": "construct navigatable tree",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "fromTree",
          "normalized": "a b-\u003ec b",
          "package": "hxt",
          "partial": "Tree",
          "signature": "t a-\u003ent a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:fromTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edescend one step to the leftmost child\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvDown",
          "package": "hxt",
          "signature": "t a -\u003e Maybe (t a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#mvDown",
          "type": "method"
        },
        "index": {
          "description": "descend one step to the leftmost child",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvDown",
          "normalized": "a b-\u003eMaybe(a b)",
          "package": "hxt",
          "partial": "Down",
          "signature": "t a-\u003eMaybe(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:mvDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emove to the left neighbour\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvLeft",
          "package": "hxt",
          "signature": "t a -\u003e Maybe (t a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#mvLeft",
          "type": "method"
        },
        "index": {
          "description": "move to the left neighbour",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvLeft",
          "normalized": "a b-\u003eMaybe(a b)",
          "package": "hxt",
          "partial": "Left",
          "signature": "t a-\u003eMaybe(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:mvLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emove to the right neighbour\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvRight",
          "package": "hxt",
          "signature": "t a -\u003e Maybe (t a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#mvRight",
          "type": "method"
        },
        "index": {
          "description": "move to the right neighbour",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvRight",
          "normalized": "a b-\u003eMaybe(a b)",
          "package": "hxt",
          "partial": "Right",
          "signature": "t a-\u003eMaybe(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:mvRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emove one step towards the root\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvUp",
          "package": "hxt",
          "signature": "t a -\u003e Maybe (t a)",
          "source": "src/Data-Tree-NavigatableTree-Class.html#mvUp",
          "type": "method"
        },
        "index": {
          "description": "move one step towards the root",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "mvUp",
          "normalized": "a b-\u003eMaybe(a b)",
          "package": "hxt",
          "partial": "Up",
          "signature": "t a-\u003eMaybe(t a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:mvUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echange the tree but remain the navigation\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "substThisTree",
          "package": "hxt",
          "signature": "t a -\u003e nt a -\u003e nt a",
          "source": "src/Data-Tree-NavigatableTree-Class.html#substThisTree",
          "type": "method"
        },
        "index": {
          "description": "change the tree but remain the navigation",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "substThisTree",
          "normalized": "a b-\u003ec b-\u003ec b",
          "package": "hxt",
          "partial": "This Tree",
          "signature": "t a-\u003ent a-\u003ent a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:substThisTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove navigation\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "toTree",
          "package": "hxt",
          "signature": "nt a -\u003e t a",
          "source": "src/Data-Tree-NavigatableTree-Class.html#toTree",
          "type": "method"
        },
        "index": {
          "description": "remove navigation",
          "hierarchy": "Data Tree NavigatableTree Class",
          "module": "Data.Tree.NavigatableTree.Class",
          "name": "toTree",
          "normalized": "a b-\u003ec b",
          "package": "hxt",
          "partial": "Tree",
          "signature": "nt a-\u003et a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-Class.html#v:toTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNavigatable trees need to have operations to move up, down, left and right.\n   With these elementary operations, the XPath axises can be defined.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "XPathAxis",
          "package": "hxt",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html",
          "type": "module"
        },
        "index": {
          "description": "Navigatable trees need to have operations to move up down left and right With these elementary operations the XPath axises can be defined",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "XPathAxis",
          "package": "hxt",
          "partial": "XPath Axis",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: ancestor\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "ancestorAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#ancestorAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis ancestor",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "ancestorAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:ancestorAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: ancestor or self\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "ancestorOrSelfAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#ancestorOrSelfAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis ancestor or self",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "ancestorOrSelfAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Or Self Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:ancestorOrSelfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: child\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "childAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#childAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis child",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "childAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:childAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: descendant\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "descendantAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#descendantAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis descendant",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "descendantAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:descendantAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: descendant or self\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "descendantOrSelfAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#descendantOrSelfAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis descendant or self",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "descendantOrSelfAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Or Self Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:descendantOrSelfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: following\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "followingAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#followingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis following",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "followingAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:followingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: following sibling\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "followingSiblingAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#followingSiblingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis following sibling",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "followingSiblingAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Sibling Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:followingSiblingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "isAtRoot",
          "package": "hxt",
          "signature": "t a -\u003e Bool",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#isAtRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "isAtRoot",
          "normalized": "a b-\u003eBool",
          "package": "hxt",
          "partial": "At Root",
          "signature": "t a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:isAtRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecollect all trees by moving into one direction, starting tree is not included\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "maybePlus",
          "package": "hxt",
          "signature": "(a -\u003e Maybe a) -\u003e a -\u003e [a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#maybePlus",
          "type": "function"
        },
        "index": {
          "description": "collect all trees by moving into one direction starting tree is not included",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "maybePlus",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003e[a]",
          "package": "hxt",
          "partial": "Plus",
          "signature": "(a-\u003eMaybe a)-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:maybePlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecollect all trees by moving into one direction, starting tree is included\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "maybeStar",
          "package": "hxt",
          "signature": "(a -\u003e Maybe a) -\u003e a -\u003e [a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#maybeStar",
          "type": "function"
        },
        "index": {
          "description": "collect all trees by moving into one direction starting tree is included",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "maybeStar",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003e[a]",
          "package": "hxt",
          "partial": "Star",
          "signature": "(a-\u003eMaybe a)-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:maybeStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emove to the root\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "mvToRoot",
          "package": "hxt",
          "signature": "t a -\u003e t a",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#mvToRoot",
          "type": "function"
        },
        "index": {
          "description": "move to the root",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "mvToRoot",
          "normalized": "a b-\u003ea b",
          "package": "hxt",
          "partial": "To Root",
          "signature": "t a-\u003et a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:mvToRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: parent\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "parentAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#parentAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis parent",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "parentAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:parentAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: preceding\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "precedingAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#precedingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis preceding",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "precedingAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:precedingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: preceeding sibling\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "precedingSiblingAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#precedingSiblingAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis preceeding sibling",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "precedingSiblingAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Sibling Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:precedingSiblingAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enot an official XPath axis but useful: reverse descendant or self, used in preceding axis\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "revDescendantOrSelfAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#revDescendantOrSelfAxis",
          "type": "function"
        },
        "index": {
          "description": "not an official XPath axis but useful reverse descendant or self used in preceding axis",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "revDescendantOrSelfAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Descendant Or Self Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:revDescendantOrSelfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXPath axis: self\n\u003c/p\u003e",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "selfAxis",
          "package": "hxt",
          "signature": "t a -\u003e [t a]",
          "source": "src/Data-Tree-NavigatableTree-XPathAxis.html#selfAxis",
          "type": "function"
        },
        "index": {
          "description": "XPath axis self",
          "hierarchy": "Data Tree NavigatableTree XPathAxis",
          "module": "Data.Tree.NavigatableTree.XPathAxis",
          "name": "selfAxis",
          "normalized": "a b-\u003e[a b]",
          "package": "hxt",
          "partial": "Axis",
          "signature": "t a-\u003e[t a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Data-Tree-NavigatableTree-XPathAxis.html#v:selfAxis"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDe-/Serialisation arrows for XmlTrees and other arbitrary values with a Binary instance\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.Binary",
          "name": "Binary",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Binary.html",
          "type": "module"
        },
        "index": {
          "description": "De Serialisation arrows for XmlTrees and other arbitrary values with Binary instance",
          "hierarchy": "Text XML HXT Arrow Binary",
          "module": "Text.XML.HXT.Arrow.Binary",
          "name": "Binary",
          "package": "hxt",
          "partial": "Binary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Binary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Binary",
          "name": "readBinaryValue",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b a",
          "source": "src/Text-XML-HXT-Arrow-Binary.html#readBinaryValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Binary",
          "module": "Text.XML.HXT.Arrow.Binary",
          "name": "readBinaryValue",
          "normalized": "String-\u003eIOStateArrow a b c",
          "package": "hxt",
          "partial": "Binary Value",
          "signature": "String-\u003eIOStateArrow s b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Binary.html#v:readBinaryValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSerialize a value, optionally compress it, and write it to a file.\n In case of an error, the error message is issued and the arrow fails\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Binary",
          "name": "writeBinaryValue",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s a ()",
          "source": "src/Text-XML-HXT-Arrow-Binary.html#writeBinaryValue",
          "type": "function"
        },
        "index": {
          "description": "Serialize value optionally compress it and write it to file In case of an error the error message is issued and the arrow fails",
          "hierarchy": "Text XML HXT Arrow Binary",
          "module": "Text.XML.HXT.Arrow.Binary",
          "name": "writeBinaryValue",
          "normalized": "String-\u003eIOStateArrow a b()",
          "package": "hxt",
          "partial": "Binary Value",
          "signature": "String-\u003eIOStateArrow s a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Binary.html#v:writeBinaryValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eDTD processing function for\n   including external parts of a DTD\n   parameter entity substitution and general entity substitution\n\u003c/p\u003e\u003cp\u003eImplemtation completely done with arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.DTDProcessing",
          "name": "DTDProcessing",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-DTDProcessing.html",
          "type": "module"
        },
        "index": {
          "description": "DTD processing function for including external parts of DTD parameter entity substitution and general entity substitution Implemtation completely done with arrows",
          "hierarchy": "Text XML HXT Arrow DTDProcessing",
          "module": "Text.XML.HXT.Arrow.DTDProcessing",
          "name": "DTDProcessing",
          "package": "hxt",
          "partial": "DTDProcessing",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DTDProcessing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea filter for DTD processing\n\u003c/p\u003e\u003cp\u003einclusion of external parts of DTD,\n parameter entity substitution\n conditional section evaluation\n\u003c/p\u003e\u003cp\u003einput tree must represent a complete document including root node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.DTDProcessing",
          "name": "processDTD",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DTDProcessing.html#processDTD",
          "type": "function"
        },
        "index": {
          "description": "filter for DTD processing inclusion of external parts of DTD parameter entity substitution conditional section evaluation input tree must represent complete document including root node",
          "hierarchy": "Text XML HXT Arrow DTDProcessing",
          "module": "Text.XML.HXT.Arrow.DTDProcessing",
          "name": "processDTD",
          "package": "hxt",
          "partial": "DTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DTDProcessing.html#v:processDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eState arrows for document input\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "DocumentInput",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-DocumentInput.html",
          "type": "module"
        },
        "index": {
          "description": "State arrows for document input",
          "hierarchy": "Text XML HXT Arrow DocumentInput",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "DocumentInput",
          "package": "hxt",
          "partial": "Document Input",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentInput.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "addInputError",
          "package": "hxt",
          "signature": "Attributes -\u003e String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentInput.html#addInputError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow DocumentInput",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "addInputError",
          "normalized": "Attributes-\u003eString-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Input Error",
          "signature": "Attributes-\u003eString-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentInput.html#v:addInputError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "decodeDocument",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentInput.html#decodeDocument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow DocumentInput",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "decodeDocument",
          "package": "hxt",
          "partial": "Document",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentInput.html#v:decodeDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getEncoding",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-DocumentInput.html#getEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow DocumentInput",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getEncoding",
          "package": "hxt",
          "partial": "Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentInput.html#v:getEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getTextEncoding",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-DocumentInput.html#getTextEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow DocumentInput",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getTextEncoding",
          "package": "hxt",
          "partial": "Text Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentInput.html#v:getTextEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the content of a document.\n\u003c/p\u003e\u003cp\u003eThis routine is usually called from \u003ccode\u003e\u003ca\u003egetDocumentContents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe input must be a root node (constructed with \u003ccode\u003e\u003ca\u003eroot\u003c/a\u003e\u003c/code\u003e), usually without children.\n   The attribute list contains all input parameters, e.g. URI or source file name, encoding preferences, ...\n   If the source name is empty, the input is read from standard input.\n\u003c/p\u003e\u003cp\u003eThe source is transformed into an absolute URI. If the source is a relative URI, or a file name,\n   it is expanded into an absolut URI with respect to the current base URI.\n   The default base URI is of protocol \"file\" and points to the current working directory.\n\u003c/p\u003e\u003cp\u003eThe currently supported protocols are \"http\", \"file\", \"stdin\" and \"string\".\n\u003c/p\u003e\u003cp\u003eThe latter two are internal protocols. An uri of the form \"stdin:\" stands for the content of\n   the standard input stream.\n\u003c/p\u003e\u003cp\u003e\"string:some text\" means, that \"some text\" is taken as input.\n   This internal protocol is used for reading from normal \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getXmlContents",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentInput.html#getXmlContents",
          "type": "function"
        },
        "index": {
          "description": "Read the content of document This routine is usually called from getDocumentContents The input must be root node constructed with root usually without children The attribute list contains all input parameters e.g URI or source file name encoding preferences If the source name is empty the input is read from standard input The source is transformed into an absolute URI If the source is relative URI or file name it is expanded into an absolut URI with respect to the current base URI The default base URI is of protocol file and points to the current working directory The currently supported protocols are http file stdin and string The latter two are internal protocols An uri of the form stdin stands for the content of the standard input stream string some text means that some text is taken as input This internal protocol is used for reading from normal String values",
          "hierarchy": "Text XML HXT Arrow DocumentInput",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getXmlContents",
          "package": "hxt",
          "partial": "Xml Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentInput.html#v:getXmlContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getXmlEntityContents",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentInput.html#getXmlEntityContents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow DocumentInput",
          "module": "Text.XML.HXT.Arrow.DocumentInput",
          "name": "getXmlEntityContents",
          "package": "hxt",
          "partial": "Xml Entity Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentInput.html#v:getXmlEntityContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eState arrows for document output\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "DocumentOutput",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-DocumentOutput.html",
          "type": "module"
        },
        "index": {
          "description": "State arrows for document output",
          "hierarchy": "Text XML HXT Arrow DocumentOutput",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "DocumentOutput",
          "package": "hxt",
          "partial": "Document Output",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentOutput.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "encodeDocument",
          "package": "hxt",
          "signature": "Bool -\u003e Bool -\u003e String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentOutput.html#encodeDocument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow DocumentOutput",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "encodeDocument",
          "normalized": "Bool-\u003eBool-\u003eString-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Document",
          "signature": "Bool-\u003eBool-\u003eString-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentOutput.html#v:encodeDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "encodeDocument'",
          "package": "hxt",
          "signature": "Bool -\u003e Bool -\u003e String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentOutput.html#encodeDocument%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow DocumentOutput",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "encodeDocument'",
          "normalized": "Bool-\u003eBool-\u003eString-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Document'",
          "signature": "Bool-\u003eBool-\u003eString-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentOutput.html#v:encodeDocument-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the contents of a document tree into an output stream (file or stdout).\n\u003c/p\u003e\u003cp\u003eIf textMode is set, writing is done with Haskell string output, else (default)\n writing is done with lazy ByteString output\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "putXmlDocument",
          "package": "hxt",
          "signature": "Bool -\u003e String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentOutput.html#putXmlDocument",
          "type": "function"
        },
        "index": {
          "description": "Write the contents of document tree into an output stream file or stdout If textMode is set writing is done with Haskell string output else default writing is done with lazy ByteString output",
          "hierarchy": "Text XML HXT Arrow DocumentOutput",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "putXmlDocument",
          "normalized": "Bool-\u003eString-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Xml Document",
          "signature": "Bool-\u003eString-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentOutput.html#v:putXmlDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrite a document with indentaion and line numers\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "putXmlSource",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentOutput.html#putXmlSource",
          "type": "function"
        },
        "index": {
          "description": "write document with indentaion and line numers",
          "hierarchy": "Text XML HXT Arrow DocumentOutput",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "putXmlSource",
          "normalized": "String-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Xml Source",
          "signature": "String-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentOutput.html#v:putXmlSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrite the tree representation of a document to a file\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "putXmlTree",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-DocumentOutput.html#putXmlTree",
          "type": "function"
        },
        "index": {
          "description": "write the tree representation of document to file",
          "hierarchy": "Text XML HXT Arrow DocumentOutput",
          "module": "Text.XML.HXT.Arrow.DocumentOutput",
          "name": "putXmlTree",
          "normalized": "String-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Xml Tree",
          "signature": "String-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-DocumentOutput.html#v:putXmlTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ecommon edit arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "Edit",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Edit.html",
          "type": "module"
        },
        "index": {
          "description": "common edit arrows",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "Edit",
          "package": "hxt",
          "partial": "Edit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addDefaultDTDecl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addDefaultDTDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addDefaultDTDecl",
          "package": "hxt",
          "partial": "Default DTDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addDefaultDTDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd a doctype declaration to a document\n\u003c/p\u003e\u003cp\u003eThe arguments are the root element name, the PUBLIC id and the SYSTEM id\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addDoctypeDecl",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addDoctypeDecl",
          "type": "function"
        },
        "index": {
          "description": "add doctype declaration to document The arguments are the root element name the PUBLIC id and the SYSTEM id",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addDoctypeDecl",
          "normalized": "String-\u003eString-\u003eString-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Doctype Decl",
          "signature": "String-\u003eString-\u003eString-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addDoctypeDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addHeadlineToXmlDoc",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addHeadlineToXmlDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addHeadlineToXmlDoc",
          "package": "hxt",
          "partial": "Headline To Xml Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addHeadlineToXmlDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an XHTML frameset doctype declaration to a document\n\u003c/p\u003e\u003cp\u003eadd an XHTML strict doctype declaration to a document\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXHtmlDoctypeFrameset",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addXHtmlDoctypeFrameset",
          "type": "function"
        },
        "index": {
          "description": "add an XHTML frameset doctype declaration to document add an XHTML strict doctype declaration to document",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXHtmlDoctypeFrameset",
          "package": "hxt",
          "partial": "XHtml Doctype Frameset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addXHtmlDoctypeFrameset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an XHTML strict doctype declaration to a document\n\u003c/p\u003e\u003cp\u003eadd an XHTML strict doctype declaration to a document\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXHtmlDoctypeStrict",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addXHtmlDoctypeStrict",
          "type": "function"
        },
        "index": {
          "description": "add an XHTML strict doctype declaration to document add an XHTML strict doctype declaration to document",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXHtmlDoctypeStrict",
          "package": "hxt",
          "partial": "XHtml Doctype Strict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addXHtmlDoctypeStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an XHTML transitional doctype declaration to a document\n\u003c/p\u003e\u003cp\u003eadd an XHTML strict doctype declaration to a document\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXHtmlDoctypeTransitional",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addXHtmlDoctypeTransitional",
          "type": "function"
        },
        "index": {
          "description": "add an XHTML transitional doctype declaration to document add an XHTML strict doctype declaration to document",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXHtmlDoctypeTransitional",
          "package": "hxt",
          "partial": "XHtml Doctype Transitional",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addXHtmlDoctypeTransitional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an \u003c?xml version=\"1.0\"?\u003e processing instruction\n if it's not already there\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXmlPi",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addXmlPi",
          "type": "function"
        },
        "index": {
          "description": "add an xml version processing instruction if it not already there",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXmlPi",
          "package": "hxt",
          "partial": "Xml Pi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addXmlPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd an encoding spec to the \u003c?xml version=\"1.0\"?\u003e processing instruction\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXmlPiEncoding",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#addXmlPiEncoding",
          "type": "function"
        },
        "index": {
          "description": "add an encoding spec to the xml version processing instruction",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "addXmlPiEncoding",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Xml Pi Encoding",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:addXmlPiEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies some \u003ca\u003eCanonical XML\u003c/a\u003e rules to a document tree.\n\u003c/p\u003e\u003cp\u003eThe rule differ slightly for canonical XML and XPath in handling of comments\n\u003c/p\u003e\u003cp\u003eNote: This is not the whole canonicalization as it is specified by the W3C\n Recommendation. Adding attribute defaults or sorting attributes in lexicographic\n order is done by the \u003ccode\u003etransform\u003c/code\u003e function of module \u003ccode\u003eText.XML.HXT.Validator.Validation\u003c/code\u003e.\n Replacing entities or line feed normalization is done by the parser.\n\u003c/p\u003e\u003cp\u003eRules: remove DTD parts, processing instructions, comments and substitute char refs in attribute\n values and text\n\u003c/p\u003e\u003cp\u003eNot implemented yet:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Whitespace within start and end tags is normalized\n\u003c/li\u003e\u003cli\u003e Special characters in attribute values and character content are replaced by character references\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "canonicalizeAllNodes",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#canonicalizeAllNodes",
          "type": "function"
        },
        "index": {
          "description": "Applies some Canonical XML rules to document tree The rule differ slightly for canonical XML and XPath in handling of comments Note This is not the whole canonicalization as it is specified by the W3C Recommendation Adding attribute defaults or sorting attributes in lexicographic order is done by the transform function of module Text.XML.HXT.Validator.Validation Replacing entities or line feed normalization is done by the parser Rules remove DTD parts processing instructions comments and substitute char refs in attribute values and text Not implemented yet Whitespace within start and end tags is normalized Special characters in attribute values and character content are replaced by character references",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "canonicalizeAllNodes",
          "package": "hxt",
          "partial": "All Nodes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:canonicalizeAllNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCanonicalize the contents of a document\n\u003c/p\u003e\u003cp\u003esubstitutes all char refs in text and attribute values,\n removes CDATA section and combines all sequences of resulting text\n nodes into a single text node\n\u003c/p\u003e\u003cp\u003esee \u003ccode\u003e\u003ca\u003ecanonicalizeAllNodes\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "canonicalizeContents",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#canonicalizeContents",
          "type": "function"
        },
        "index": {
          "description": "Canonicalize the contents of document substitutes all char refs in text and attribute values removes CDATA section and combines all sequences of resulting text nodes into single text node see canonicalizeAllNodes",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "canonicalizeContents",
          "package": "hxt",
          "partial": "Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:canonicalizeContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCanonicalize a tree for XPath\n Like \u003ccode\u003e\u003ca\u003ecanonicalizeAllNodes\u003c/a\u003e\u003c/code\u003e but comment nodes are not removed\n\u003c/p\u003e\u003cp\u003esee \u003ccode\u003e\u003ca\u003ecanonicalizeAllNodes\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "canonicalizeForXPath",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#canonicalizeForXPath",
          "type": "function"
        },
        "index": {
          "description": "Canonicalize tree for XPath Like canonicalizeAllNodes but comment nodes are not removed see canonicalizeAllNodes",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "canonicalizeForXPath",
          "package": "hxt",
          "partial": "For XPath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:canonicalizeForXPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies collapseXText recursively.\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003ecollapseXText\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "collapseAllXText",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#collapseAllXText",
          "type": "function"
        },
        "index": {
          "description": "Applies collapseXText recursively see also collapseXText",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "collapseAllXText",
          "package": "hxt",
          "partial": "All XText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:collapseAllXText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollects sequences of text nodes in the list of children of a node into one single text node.\n This is useful, e.g. after char and entity reference substitution\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "collapseXText",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#collapseXText",
          "type": "function"
        },
        "index": {
          "description": "Collects sequences of text nodes in the list of children of node into one single text node This is useful e.g after char and entity reference substitution",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "collapseXText",
          "package": "hxt",
          "partial": "XText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:collapseXText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "escapeHtmlRefs",
          "package": "hxt",
          "signature": "(Char -\u003e String -\u003e String, Char -\u003e String -\u003e String)",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#escapeHtmlRefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "escapeHtmlRefs",
          "normalized": "(Char-\u003eString-\u003eString,Char-\u003eString-\u003eString)",
          "package": "hxt",
          "partial": "Html Refs",
          "signature": "(Char-\u003eString-\u003eString,Char-\u003eString-\u003eString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:escapeHtmlRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "escapeXmlRefs",
          "package": "hxt",
          "signature": "(Char -\u003e String -\u003e String, Char -\u003e String -\u003e String)",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#escapeXmlRefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "escapeXmlRefs",
          "normalized": "(Char-\u003eString-\u003eString,Char-\u003eString-\u003eString)",
          "package": "hxt",
          "partial": "Xml Refs",
          "signature": "(Char-\u003eString-\u003eString,Char-\u003eString-\u003eString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:escapeXmlRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "hasXmlPi",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#hasXmlPi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "hasXmlPi",
          "package": "hxt",
          "partial": "Xml Pi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:hasXmlPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a document into a Haskell representation (with show).\n\u003c/p\u003e\u003cp\u003eUseful for debugging and trace output.\n see also : \u003ccode\u003e\u003ca\u003etreeRepOfXmlDoc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enumberLinesInXmlDoc\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "haskellRepOfXmlDoc",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#haskellRepOfXmlDoc",
          "type": "function"
        },
        "index": {
          "description": "convert document into Haskell representation with show Useful for debugging and trace output see also treeRepOfXmlDoc numberLinesInXmlDoc",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "haskellRepOfXmlDoc",
          "package": "hxt",
          "partial": "Rep Of Xml Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:haskellRepOfXmlDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efilter for indenting a document tree for pretty printing.\n\u003c/p\u003e\u003cp\u003ethe tree is traversed for inserting whitespace for tag indentation.\n\u003c/p\u003e\u003cp\u003ewhitespace is only inserted or changed at places, where it isn't significant,\n is's not inserted between tags and text containing non whitespace chars.\n\u003c/p\u003e\u003cp\u003ewhitespace is only inserted or changed at places, where it's not significant.\n preserving whitespace may be controlled in a document tree\n by a tag attribute \u003ccode\u003exml:space\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eallowed values for this attribute are \u003ccode\u003edefault | preserve\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003einput is a complete document tree or a document fragment\n result is the semantically equivalent formatted tree.\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eremoveDocWhiteSpace\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "indentDoc",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#indentDoc",
          "type": "function"
        },
        "index": {
          "description": "filter for indenting document tree for pretty printing the tree is traversed for inserting whitespace for tag indentation whitespace is only inserted or changed at places where it isn significant is not inserted between tags and text containing non whitespace chars whitespace is only inserted or changed at places where it not significant preserving whitespace may be controlled in document tree by tag attribute xml space allowed values for this attribute are default preserve input is complete document tree or document fragment result is the semantically equivalent formatted tree see also removeDocWhiteSpace",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "indentDoc",
          "package": "hxt",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:indentDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a document into a text and add line numbers to the text representation.\n\u003c/p\u003e\u003cp\u003eResult is a root node with a single text node as child.\n Useful for debugging and trace output.\n see also : \u003ccode\u003e\u003ca\u003ehaskellRepOfXmlDoc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etreeRepOfXmlDoc\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "numberLinesInXmlDoc",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#numberLinesInXmlDoc",
          "type": "function"
        },
        "index": {
          "description": "convert document into text and add line numbers to the text representation Result is root node with single text node as child Useful for debugging and trace output see also haskellRepOfXmlDoc treeRepOfXmlDoc",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "numberLinesInXmlDoc",
          "package": "hxt",
          "partial": "Lines In Xml Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:numberLinesInXmlDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "preventEmptyElements",
          "package": "hxt",
          "signature": "[String] -\u003e Bool -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#preventEmptyElements",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "preventEmptyElements",
          "normalized": "[String]-\u003eBool-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Empty Elements",
          "signature": "[String]-\u003eBool-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:preventEmptyElements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "rememberDTDAttrl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#rememberDTDAttrl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "rememberDTDAttrl",
          "package": "hxt",
          "partial": "DTDAttrl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:rememberDTDAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove all comments in a tree recursively\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeAllComment",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#removeAllComment",
          "type": "function"
        },
        "index": {
          "description": "remove all comments in tree recursively",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeAllComment",
          "package": "hxt",
          "partial": "All Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:removeAllComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimple recursive filter for removing all whitespace.\n\u003c/p\u003e\u003cp\u003eremoves all text nodes in a tree that consist only of whitespace.\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eremoveWhiteSpace\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eremoveDocWhiteSpace\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeAllWhiteSpace",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#removeAllWhiteSpace",
          "type": "function"
        },
        "index": {
          "description": "simple recursive filter for removing all whitespace removes all text nodes in tree that consist only of whitespace see also removeWhiteSpace removeDocWhiteSpace",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeAllWhiteSpace",
          "package": "hxt",
          "partial": "All White Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:removeAllWhiteSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove a Comment node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeComment",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#removeComment",
          "type": "function"
        },
        "index": {
          "description": "remove Comment node",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeComment",
          "package": "hxt",
          "partial": "Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:removeComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efilter for removing all not significant whitespace.\n\u003c/p\u003e\u003cp\u003ethe tree traversed for removing whitespace between elements,\n that was inserted for indentation and readability.\n whitespace is only removed at places, where it's not significat\n preserving whitespace may be controlled in a document tree\n by a tag attribute \u003ccode\u003exml:space\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eallowed values for this attribute are \u003ccode\u003edefault | preserve\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003einput is root node of the document to be cleaned up,\n output the semantically equivalent simplified tree\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eindentDoc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eremoveAllWhiteSpace\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeDocWhiteSpace",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#removeDocWhiteSpace",
          "type": "function"
        },
        "index": {
          "description": "filter for removing all not significant whitespace the tree traversed for removing whitespace between elements that was inserted for indentation and readability whitespace is only removed at places where it not significat preserving whitespace may be controlled in document tree by tag attribute xml space allowed values for this attribute are default preserve input is root node of the document to be cleaned up output the semantically equivalent simplified tree see also indentDoc removeAllWhiteSpace",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeDocWhiteSpace",
          "package": "hxt",
          "partial": "Doc White Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:removeDocWhiteSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimple filter for removing whitespace.\n\u003c/p\u003e\u003cp\u003eno check on sigificant whitespace, e.g. in HTML \u003cpre\u003e-elements, is done.\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eremoveAllWhiteSpace\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eremoveDocWhiteSpace\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeWhiteSpace",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#removeWhiteSpace",
          "type": "function"
        },
        "index": {
          "description": "simple filter for removing whitespace no check on sigificant whitespace e.g in HTML pre elements is done see also removeAllWhiteSpace removeDocWhiteSpace",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "removeWhiteSpace",
          "package": "hxt",
          "partial": "White Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:removeWhiteSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "substAllXHTMLEntityRefs",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#substAllXHTMLEntityRefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "substAllXHTMLEntityRefs",
          "package": "hxt",
          "partial": "All XHTMLEntity Refs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:substAllXHTMLEntityRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "substXHTMLEntityRef",
          "package": "hxt",
          "signature": "LA XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#substXHTMLEntityRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "substXHTMLEntityRef",
          "package": "hxt",
          "partial": "XHTMLEntity Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:substXHTMLEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econverts CDATA sections in whole document tree into normal text nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfAllCdata",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#transfAllCdata",
          "type": "function"
        },
        "index": {
          "description": "converts CDATA sections in whole document tree into normal text nodes",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfAllCdata",
          "package": "hxt",
          "partial": "All Cdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:transfAllCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecursively converts all character references to normal text\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfAllCharRef",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#transfAllCharRef",
          "type": "function"
        },
        "index": {
          "description": "recursively converts all character references to normal text",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfAllCharRef",
          "package": "hxt",
          "partial": "All Char Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:transfAllCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econverts a CDATA section into normal text nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfCdata",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#transfCdata",
          "type": "function"
        },
        "index": {
          "description": "converts CDATA section into normal text nodes",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfCdata",
          "package": "hxt",
          "partial": "Cdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:transfCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econverts a character reference to normal text\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfCharRef",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#transfCharRef",
          "type": "function"
        },
        "index": {
          "description": "converts character reference to normal text",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "transfCharRef",
          "package": "hxt",
          "partial": "Char Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:transfCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a document into a text representation in tree form.\n\u003c/p\u003e\u003cp\u003eUseful for debugging and trace output.\n see also : \u003ccode\u003e\u003ca\u003ehaskellRepOfXmlDoc\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003enumberLinesInXmlDoc\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "treeRepOfXmlDoc",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#treeRepOfXmlDoc",
          "type": "function"
        },
        "index": {
          "description": "convert document into text representation in tree form Useful for debugging and trace output see also haskellRepOfXmlDoc numberLinesInXmlDoc",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "treeRepOfXmlDoc",
          "package": "hxt",
          "partial": "Rep Of Xml Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:treeRepOfXmlDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an arrow to the input and convert the resulting XML trees into an XML escaped string\n\u003c/p\u003e\u003cp\u003eThis is a save variant for converting a tree into an XML string representation\n that is parsable with \u003ccode\u003e\u003ca\u003eReadDocument\u003c/a\u003e\u003c/code\u003e.\n It is implemented with \u003ccode\u003e\u003ca\u003exshow\u003c/a\u003e\u003c/code\u003e,\n but xshow does no XML escaping. The XML escaping is done with\n \u003ccode\u003e\u003ca\u003eescapeXmlDoc\u003c/a\u003e\u003c/code\u003e before xshow is applied.\n\u003c/p\u003e\u003cp\u003eSo the following law holds\n\u003c/p\u003e\u003cpre\u003e xshowEscapeXml f \u003e\u003e\u003e xread == f\n\u003c/pre\u003e",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "xshowEscapeXml",
          "package": "hxt",
          "signature": "a n XmlTree -\u003e a n String",
          "source": "src/Text-XML-HXT-Arrow-Edit.html#xshowEscapeXml",
          "type": "function"
        },
        "index": {
          "description": "apply an arrow to the input and convert the resulting XML trees into an XML escaped string This is save variant for converting tree into an XML string representation that is parsable with ReadDocument It is implemented with xshow but xshow does no XML escaping The XML escaping is done with escapeXmlDoc before xshow is applied So the following law holds xshowEscapeXml xread",
          "hierarchy": "Text XML HXT Arrow Edit",
          "module": "Text.XML.HXT.Arrow.Edit",
          "name": "xshowEscapeXml",
          "normalized": "a b XmlTree-\u003ea b String",
          "package": "hxt",
          "partial": "Escape Xml",
          "signature": "a n XmlTree-\u003ea n String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Edit.html#v:xshowEscapeXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003egeneral entity substitution\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.GeneralEntitySubstitution",
          "name": "GeneralEntitySubstitution",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-GeneralEntitySubstitution.html",
          "type": "module"
        },
        "index": {
          "description": "general entity substitution",
          "hierarchy": "Text XML HXT Arrow GeneralEntitySubstitution",
          "module": "Text.XML.HXT.Arrow.GeneralEntitySubstitution",
          "name": "GeneralEntitySubstitution",
          "package": "hxt",
          "partial": "General Entity Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-GeneralEntitySubstitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esubstitution of general entities\n\u003c/p\u003e\u003cp\u003einput: a complete document tree including root node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.GeneralEntitySubstitution",
          "name": "processGeneralEntities",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-GeneralEntitySubstitution.html#processGeneralEntities",
          "type": "function"
        },
        "index": {
          "description": "substitution of general entities input complete document tree including root node",
          "hierarchy": "Text XML HXT Arrow GeneralEntitySubstitution",
          "module": "Text.XML.HXT.Arrow.GeneralEntitySubstitution",
          "name": "processGeneralEntities",
          "package": "hxt",
          "partial": "General Entities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-GeneralEntitySubstitution.html#v:processGeneralEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003enamespace specific arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "Namespace",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html",
          "type": "module"
        },
        "index": {
          "description": "namespace specific arrows",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "Namespace",
          "package": "hxt",
          "partial": "Namespace",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattach all valid namespace declarations to the attribute list of element nodes.\n\u003c/p\u003e\u003cp\u003eThis arrow is useful for document processing, that requires access to all namespace\n declarations at any element node, but which cannot be done with a simple \u003ccode\u003e\u003ca\u003eprocessWithNsEnv\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "attachNsEnv",
          "package": "hxt",
          "signature": "NsEnv -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#attachNsEnv",
          "type": "function"
        },
        "index": {
          "description": "attach all valid namespace declarations to the attribute list of element nodes This arrow is useful for document processing that requires access to all namespace declarations at any element node but which cannot be done with simple processWithNsEnv",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "attachNsEnv",
          "normalized": "NsEnv-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Ns Env",
          "signature": "NsEnv-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:attachNsEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edoes the real work for namespace cleanup.\n\u003c/p\u003e\u003cp\u003eThe parameter is used for collecting namespace uris and prefixes from the input tree\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "cleanupNamespaces",
          "package": "hxt",
          "signature": "LA XmlTree (String, String) -\u003e LA XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#cleanupNamespaces",
          "type": "function"
        },
        "index": {
          "description": "does the real work for namespace cleanup The parameter is used for collecting namespace uris and prefixes from the input tree",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "cleanupNamespaces",
          "normalized": "LA XmlTree(String,String)-\u003eLA XmlTree XmlTree",
          "package": "hxt",
          "partial": "Namespaces",
          "signature": "LA XmlTree(String,String)-\u003eLA XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:cleanupNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecollect all namespace declarations contained in a document\n\u003c/p\u003e\u003cp\u003eapply \u003ccode\u003e\u003ca\u003egetNamespaceDecl\u003c/a\u003e\u003c/code\u003e to a whole XmlTree\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "collectNamespaceDecl",
          "package": "hxt",
          "signature": "LA XmlTree (String, String)",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#collectNamespaceDecl",
          "type": "function"
        },
        "index": {
          "description": "collect all namespace declarations contained in document apply getNamespaceDecl to whole XmlTree",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "collectNamespaceDecl",
          "normalized": "LA XmlTree(String,String)",
          "package": "hxt",
          "partial": "Namespace Decl",
          "signature": "LA XmlTree(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:collectNamespaceDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecollect all (namePrefix, namespaceUri) pairs from a tree\n\u003c/p\u003e\u003cp\u003eall qualified names are inspected, whether a namespace uri is defined,\n for these uris the prefix and uri is returned. This arrow is useful for\n namespace cleanup, e.g. for documents generated with XSLT. It can be used\n together with \u003ccode\u003e\u003ca\u003ecollectNamespaceDecl\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ecleanupNamespaces\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "collectPrefixUriPairs",
          "package": "hxt",
          "signature": "LA XmlTree (String, String)",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#collectPrefixUriPairs",
          "type": "function"
        },
        "index": {
          "description": "collect all namePrefix namespaceUri pairs from tree all qualified names are inspected whether namespace uri is defined for these uris the prefix and uri is returned This arrow is useful for namespace cleanup e.g for documents generated with XSLT It can be used together with collectNamespaceDecl to cleanupNamespaces",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "collectPrefixUriPairs",
          "normalized": "LA XmlTree(String,String)",
          "package": "hxt",
          "partial": "Prefix Uri Pairs",
          "signature": "LA XmlTree(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:collectPrefixUriPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eget the namespace prefix and the namespace URI out of\n an attribute tree with a namespace declaration (see \u003ccode\u003e\u003ca\u003eisNamespaceDeclAttr\u003c/a\u003e\u003c/code\u003e)\n for all other nodes this arrow fails\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "getNamespaceDecl",
          "package": "hxt",
          "signature": "a XmlTree (String, String)",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#getNamespaceDecl",
          "type": "function"
        },
        "index": {
          "description": "get the namespace prefix and the namespace URI out of an attribute tree with namespace declaration see isNamespaceDeclAttr for all other nodes this arrow fails",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "getNamespaceDecl",
          "normalized": "a XmlTree(String,String)",
          "package": "hxt",
          "partial": "Namespace Decl",
          "signature": "a XmlTree(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:getNamespaceDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether an attribute node contains an XML Namespace declaration\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "isNamespaceDeclAttr",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#isNamespaceDeclAttr",
          "type": "function"
        },
        "index": {
          "description": "test whether an attribute node contains an XML Namespace declaration",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "isNamespaceDeclAttr",
          "package": "hxt",
          "partial": "Namespace Decl Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:isNamespaceDeclAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprocess a document tree with an arrow, containing always the\n valid namespace environment as extra parameter.\n\u003c/p\u003e\u003cp\u003eThe namespace environment is implemented as a \u003ccode\u003e\u003ca\u003eAssocList\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "processWithNsEnv",
          "package": "hxt",
          "signature": "(NsEnv -\u003e a XmlTree XmlTree) -\u003e NsEnv -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#processWithNsEnv",
          "type": "function"
        },
        "index": {
          "description": "process document tree with an arrow containing always the valid namespace environment as extra parameter The namespace environment is implemented as AssocList",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "processWithNsEnv",
          "normalized": "(NsEnv-\u003ea XmlTree XmlTree)-\u003eNsEnv-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "With Ns Env",
          "signature": "(NsEnv-\u003ea XmlTree XmlTree)-\u003eNsEnv-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:processWithNsEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprocess all element nodes of a document tree with an arrow, containing always the\n valid namespace environment as extra parameter. Attribute lists are not processed.\n\u003c/p\u003e\u003cp\u003eSee also: \u003ccode\u003e\u003ca\u003eprocessWithNsEnv\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "processWithNsEnvWithoutAttrl",
          "package": "hxt",
          "signature": "(NsEnv -\u003e a XmlTree XmlTree) -\u003e NsEnv -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#processWithNsEnvWithoutAttrl",
          "type": "function"
        },
        "index": {
          "description": "process all element nodes of document tree with an arrow containing always the valid namespace environment as extra parameter Attribute lists are not processed See also processWithNsEnv",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "processWithNsEnvWithoutAttrl",
          "normalized": "(NsEnv-\u003ea XmlTree XmlTree)-\u003eNsEnv-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "With Ns Env Without Attrl",
          "signature": "(NsEnv-\u003ea XmlTree XmlTree)-\u003eNsEnv-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:processWithNsEnvWithoutAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epropagate all namespace declarations \"xmlns:ns=...\" to all element and attribute nodes of a document.\n\u003c/p\u003e\u003cp\u003eThis arrow does not check for illegal use of namespaces.\n The real work is done by \u003ccode\u003epropagateNamespaceEnv\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe arrow may be applied repeatedly if neccessary.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "propagateNamespaces",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#propagateNamespaces",
          "type": "function"
        },
        "index": {
          "description": "propagate all namespace declarations xmlns ns to all element and attribute nodes of document This arrow does not check for illegal use of namespaces The real work is done by propagateNamespaceEnv The arrow may be applied repeatedly if neccessary",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "propagateNamespaces",
          "package": "hxt",
          "partial": "Namespaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:propagateNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egenerate unique namespaces and add all namespace declarations to all top nodes containing a namespace declaration\n Usually the top node containing namespace declarations is the root node, but this isn't mandatory.\n\u003c/p\u003e\u003cp\u003eCalls \u003ccode\u003e\u003ca\u003ecleanupNamespaces\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003ecollectNamespaceDecl\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "uniqueNamespaces",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#uniqueNamespaces",
          "type": "function"
        },
        "index": {
          "description": "generate unique namespaces and add all namespace declarations to all top nodes containing namespace declaration Usually the top node containing namespace declarations is the root node but this isn mandatory Calls cleanupNamespaces with collectNamespaceDecl",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "uniqueNamespaces",
          "package": "hxt",
          "partial": "Namespaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:uniqueNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egenerate unique namespaces and add all namespace declarations for all prefix-uri pairs in all qualified names\n\u003c/p\u003e\u003cp\u003euseful for cleanup of namespaces in generated documents.\n Calls \u003ccode\u003e\u003ca\u003ecleanupNamespaces\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e collectNamespaceDecl \u003c+\u003e collectPrefixUriPairs \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "uniqueNamespacesFromDeclAndQNames",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#uniqueNamespacesFromDeclAndQNames",
          "type": "function"
        },
        "index": {
          "description": "generate unique namespaces and add all namespace declarations for all prefix-uri pairs in all qualified names useful for cleanup of namespaces in generated documents Calls cleanupNamespaces with collectNamespaceDecl collectPrefixUriPairs",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "uniqueNamespacesFromDeclAndQNames",
          "package": "hxt",
          "partial": "Namespaces From Decl And QNames",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:uniqueNamespacesFromDeclAndQNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evalidate the namespace constraints in a whole tree.\n\u003c/p\u003e\u003cp\u003eResult is the list of errors concerning namespaces.\n Predicates \u003ccode\u003e\u003ca\u003eisWellformedQName\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisWellformedQualifiedName\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisDeclaredNamespace\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003eisWellformedNSDecl\u003c/a\u003e\u003c/code\u003e are applied to the appropriate elements and attributes.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "validateNamespaces",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Namespace.html#validateNamespaces",
          "type": "function"
        },
        "index": {
          "description": "validate the namespace constraints in whole tree Result is the list of errors concerning namespaces Predicates isWellformedQName isWellformedQualifiedName isDeclaredNamespace and isWellformedNSDecl are applied to the appropriate elements and attributes",
          "hierarchy": "Text XML HXT Arrow Namespace",
          "module": "Text.XML.HXT.Arrow.Namespace",
          "name": "validateNamespaces",
          "package": "hxt",
          "partial": "Namespaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Namespace.html#v:validateNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003einterface to the HXT XML and DTD parsers\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "ParserInterface",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html",
          "type": "module"
        },
        "index": {
          "description": "interface to the HXT XML and DTD parsers",
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "ParserInterface",
          "package": "hxt",
          "partial": "Parser Interface",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "hread",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#hread",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "hread",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:hread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "hreadDoc",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#hreadDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "hreadDoc",
          "package": "hxt",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:hreadDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseHtmlDoc",
          "package": "hxt",
          "signature": "a (String, String) XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseHtmlDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseHtmlDoc",
          "normalized": "a(String,String)XmlTree",
          "package": "hxt",
          "partial": "Html Doc",
          "signature": "a(String,String)XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseHtmlDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDEntityValue",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlDTDEntityValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDEntityValue",
          "package": "hxt",
          "partial": "Xml DTDEntity Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlDTDEntityValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDPart",
          "package": "hxt",
          "signature": "a (String, XmlTree) XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlDTDPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDPart",
          "normalized": "a(String,XmlTree)XmlTree",
          "package": "hxt",
          "partial": "Xml DTDPart",
          "signature": "a(String,XmlTree)XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlDTDPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDdecl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlDTDdecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDdecl",
          "package": "hxt",
          "partial": "Xml DTDdecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlDTDdecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDdeclPart",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlDTDdeclPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDTDdeclPart",
          "package": "hxt",
          "partial": "Xml DTDdecl Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlDTDdeclPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDoc",
          "package": "hxt",
          "signature": "a (String, String) XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDoc",
          "normalized": "a(String,String)XmlTree",
          "package": "hxt",
          "partial": "Xml Doc",
          "signature": "a(String,String)XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDocEncodingSpec",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlDocEncodingSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlDocEncodingSpec",
          "package": "hxt",
          "partial": "Xml Doc Encoding Spec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlDocEncodingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlEntityEncodingSpec",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlEntityEncodingSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlEntityEncodingSpec",
          "package": "hxt",
          "partial": "Xml Entity Encoding Spec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlEntityEncodingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlEntityValueAsAttrValue",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlEntityValueAsAttrValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlEntityValueAsAttrValue",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Xml Entity Value As Attr Value",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlEntityValueAsAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlEntityValueAsContent",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#parseXmlEntityValueAsContent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "parseXmlEntityValueAsContent",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Xml Entity Value As Content",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:parseXmlEntityValueAsContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "removeEncodingSpec",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#removeEncodingSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "removeEncodingSpec",
          "package": "hxt",
          "partial": "Encoding Spec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:removeEncodingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "xreadCont",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#xreadCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "xreadCont",
          "package": "hxt",
          "partial": "Cont",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:xreadCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "xreadDoc",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ParserInterface.html#xreadDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ParserInterface",
          "module": "Text.XML.HXT.Arrow.ParserInterface",
          "name": "xreadDoc",
          "package": "hxt",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ParserInterface.html#v:xreadDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVersion    : $Id$\n\u003c/p\u003e\u003cp\u003eFunctions for converting a pickler schema\ninto a DTD\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "DTD",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html",
          "type": "module"
        },
        "index": {
          "description": "Version Id Functions for converting pickler schema into DTD",
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "DTD",
          "package": "hxt",
          "partial": "DTD",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "DTDdescr",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#DTDdescr",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "DTDdescr",
          "package": "hxt",
          "partial": "DTDdescr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#t:DTDdescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "DTDdescr",
          "package": "hxt",
          "signature": "DTDdescr Name Schemas [(Name, Schemas)]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#DTDdescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "DTDdescr",
          "normalized": "DTDdescr Name Schemas[(Name,Schemas)]",
          "package": "hxt",
          "partial": "DTDdescr",
          "signature": "DTDdescr Name Schemas[(Name,Schemas)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:DTDdescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "attrDec",
          "package": "hxt",
          "signature": "Schema -\u003e [(Name, Schemas)]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#attrDec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "attrDec",
          "normalized": "Schema-\u003e[(Name,Schemas)]",
          "package": "hxt",
          "partial": "Dec",
          "signature": "Schema-\u003e[(Name,Schemas)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:attrDec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkAM",
          "package": "hxt",
          "signature": "Name -\u003e Schema -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#checkAM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkAM",
          "normalized": "Name-\u003eSchema-\u003eXmlTrees",
          "package": "hxt",
          "partial": "AM",
          "signature": "Name-\u003eSchema-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:checkAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkAMC",
          "package": "hxt",
          "signature": "Name -\u003e Name -\u003e Schema -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#checkAMC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkAMC",
          "normalized": "Name-\u003eName-\u003eSchema-\u003eXmlTrees",
          "package": "hxt",
          "partial": "AMC",
          "signature": "Name-\u003eName-\u003eSchema-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:checkAMC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkAttrModell",
          "package": "hxt",
          "signature": "Name -\u003e Schemas -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#checkAttrModell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkAttrModell",
          "normalized": "Name-\u003eSchemas-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Attr Modell",
          "signature": "Name-\u003eSchemas-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:checkAttrModell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkContentModell",
          "package": "hxt",
          "signature": "Name -\u003e Schema -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#checkContentModell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkContentModell",
          "normalized": "Name-\u003eSchema-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Content Modell",
          "signature": "Name-\u003eSchema-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:checkContentModell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkErr",
          "package": "hxt",
          "signature": "Bool -\u003e String -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#checkErr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "checkErr",
          "normalized": "Bool-\u003eString-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Err",
          "signature": "Bool-\u003eString-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:checkErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a pickler schema into a DTD descr\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "dtdDescr",
          "package": "hxt",
          "signature": "Schema -\u003e DTDdescr",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#dtdDescr",
          "type": "function"
        },
        "index": {
          "description": "convert pickler schema into DTD descr",
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "dtdDescr",
          "normalized": "Schema-\u003eDTDdescr",
          "package": "hxt",
          "partial": "Descr",
          "signature": "Schema-\u003eDTDdescr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:dtdDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a DTD descr into XmlTrees\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "dtdDescrToXml",
          "package": "hxt",
          "signature": "DTDdescr -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#dtdDescrToXml",
          "type": "function"
        },
        "index": {
          "description": "convert DTD descr into XmlTrees",
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "dtdDescrToXml",
          "normalized": "DTDdescr-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Descr To Xml",
          "signature": "DTDdescr-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:dtdDescrToXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elemName",
          "package": "hxt",
          "signature": "Schema -\u003e Maybe Name",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#elemName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elemName",
          "normalized": "Schema-\u003eMaybe Name",
          "package": "hxt",
          "partial": "Name",
          "signature": "Schema-\u003eMaybe Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:elemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elemNames",
          "package": "hxt",
          "signature": "Schemas -\u003e [Name]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#elemNames",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elemNames",
          "normalized": "Schemas-\u003e[Name]",
          "package": "hxt",
          "partial": "Names",
          "signature": "Schemas-\u003e[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:elemNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elemRefs",
          "package": "hxt",
          "signature": "Schemas -\u003e Schemas",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#elemRefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elemRefs",
          "normalized": "Schemas-\u003eSchemas",
          "package": "hxt",
          "partial": "Refs",
          "signature": "Schemas-\u003eSchemas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:elemRefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elementDeclarations",
          "package": "hxt",
          "signature": "Schema -\u003e Schemas",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#elementDeclarations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elementDeclarations",
          "normalized": "Schema-\u003eSchemas",
          "package": "hxt",
          "partial": "Declarations",
          "signature": "Schema-\u003eSchemas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:elementDeclarations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elementDecs",
          "package": "hxt",
          "signature": "Schemas -\u003e Schemas -\u003e Schemas",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#elementDecs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "elementDecs",
          "normalized": "Schemas-\u003eSchemas-\u003eSchemas",
          "package": "hxt",
          "partial": "Decs",
          "signature": "Schemas-\u003eSchemas-\u003eSchemas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:elementDecs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "foundErr",
          "package": "hxt",
          "signature": "String -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#foundErr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "foundErr",
          "normalized": "String-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Err",
          "signature": "String-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:foundErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "remAttrDec",
          "package": "hxt",
          "signature": "Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#remAttrDec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "remAttrDec",
          "normalized": "Schema-\u003eSchema",
          "package": "hxt",
          "partial": "Attr Dec",
          "signature": "Schema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:remAttrDec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scAttrToXml",
          "package": "hxt",
          "signature": "Schema -\u003e (Attributes, XmlTrees)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#scAttrToXml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scAttrToXml",
          "normalized": "Schema-\u003e(Attributes,XmlTrees)",
          "package": "hxt",
          "partial": "Attr To Xml",
          "signature": "Schema-\u003e(Attributes,XmlTrees)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:scAttrToXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scCont",
          "package": "hxt",
          "signature": "Attributes -\u003e Schema -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#scCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scCont",
          "normalized": "Attributes-\u003eSchema-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Cont",
          "signature": "Attributes-\u003eSchema-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:scCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scContToXml",
          "package": "hxt",
          "signature": "Schema -\u003e (Attributes, XmlTrees)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#scContToXml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scContToXml",
          "normalized": "Schema-\u003e(Attributes,XmlTrees)",
          "package": "hxt",
          "partial": "Cont To Xml",
          "signature": "Schema-\u003e(Attributes,XmlTrees)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:scContToXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scConts",
          "package": "hxt",
          "signature": "Attributes -\u003e Schemas -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#scConts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scConts",
          "normalized": "Attributes-\u003eSchemas-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Conts",
          "signature": "Attributes-\u003eSchemas-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:scConts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scWrap",
          "package": "hxt",
          "signature": "Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-DTD.html#scWrap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle DTD",
          "module": "Text.XML.HXT.Arrow.Pickle.DTD",
          "name": "scWrap",
          "normalized": "Schema-\u003eSchema",
          "package": "hxt",
          "partial": "Wrap",
          "signature": "Schema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-DTD.html#v:scWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVersion    : $Id$\n\u003c/p\u003e\u003cp\u003eDatatypes and functions for building a content model\nfor XML picklers. A schema is part of every pickler\nand can be used to derive a corrensponding DTD (or Relax NG schema).\nThis schema further enables checking the picklers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Schema",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html",
          "type": "module"
        },
        "index": {
          "description": "Version Id Datatypes and functions for building content model for XML picklers schema is part of every pickler and can be used to derive corrensponding DTD or Relax NG schema This schema further enables checking the picklers",
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Schema",
          "package": "hxt",
          "partial": "Schema",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "DataTypeDescr",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#DataTypeDescr",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "DataTypeDescr",
          "package": "hxt",
          "partial": "Data Type Descr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#t:DataTypeDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Name",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Name",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Name",
          "package": "hxt",
          "partial": "Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe datatype for modelling the structure of an\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Schema",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "data"
        },
        "index": {
          "description": "The datatype for modelling the structure of an",
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Schema",
          "package": "hxt",
          "partial": "Schema",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#t:Schema"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Schemas",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schemas",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Schemas",
          "package": "hxt",
          "partial": "Schemas",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#t:Schemas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Alt",
          "package": "hxt",
          "signature": "Alt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Alt",
          "package": "hxt",
          "partial": "Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:Alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Any",
          "package": "hxt",
          "signature": "Any",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Any",
          "package": "hxt",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:Any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Attribute",
          "package": "hxt",
          "signature": "Attribute",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Attribute",
          "package": "hxt",
          "partial": "Attribute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:Attribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "CharData",
          "package": "hxt",
          "signature": "CharData",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "CharData",
          "package": "hxt",
          "partial": "Char Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:CharData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "DTDescr",
          "package": "hxt",
          "signature": "DTDescr",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#DataTypeDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "DTDescr",
          "package": "hxt",
          "partial": "DTDescr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:DTDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "ElemRef",
          "package": "hxt",
          "signature": "ElemRef",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "ElemRef",
          "package": "hxt",
          "partial": "Elem Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:ElemRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Element",
          "package": "hxt",
          "signature": "Element",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Element",
          "package": "hxt",
          "partial": "Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Rep",
          "package": "hxt",
          "signature": "Rep",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Rep",
          "package": "hxt",
          "partial": "Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:Rep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Seq",
          "package": "hxt",
          "signature": "Seq",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "Seq",
          "package": "hxt",
          "partial": "Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "dtLib",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#DataTypeDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "dtLib",
          "package": "hxt",
          "partial": "Lib",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:dtLib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "dtName",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#DataTypeDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "dtName",
          "package": "hxt",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:dtName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "dtParams",
          "package": "hxt",
          "signature": "Attributes",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#DataTypeDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "dtParams",
          "package": "hxt",
          "partial": "Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:dtParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScAttr",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScAttr",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Attr",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScCharData",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScCharData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScCharData",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Char Data",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScCharData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScElem",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScElem",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Elem",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScElemRef",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScElemRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScElemRef",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Elem Ref",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScElemRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScEnum",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScEnum",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Enum",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest: is type a fixed value attribute type\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScFixed",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScFixed",
          "type": "function"
        },
        "index": {
          "description": "test is type fixed value attribute type",
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScFixed",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Fixed",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScFixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScList",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScList",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc List",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScOpt",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScOpt",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Opt",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScSARE",
          "package": "hxt",
          "signature": "Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScSARE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScSARE",
          "normalized": "Schema-\u003eBool",
          "package": "hxt",
          "partial": "Sc SARE",
          "signature": "Schema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScSARE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest: is schema a simple XML Schema datatype\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScXsd",
          "package": "hxt",
          "signature": "(String -\u003e Bool) -\u003e Schema -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#isScXsd",
          "type": "function"
        },
        "index": {
          "description": "test is schema simple XML Schema datatype",
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "isScXsd",
          "normalized": "(String-\u003eBool)-\u003eSchema-\u003eBool",
          "package": "hxt",
          "partial": "Sc Xsd",
          "signature": "(String-\u003eBool)-\u003eSchema-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:isScXsd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scAlt",
          "package": "hxt",
          "signature": "Schema -\u003e Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scAlt",
          "normalized": "Schema-\u003eSchema-\u003eSchema",
          "package": "hxt",
          "partial": "Alt",
          "signature": "Schema-\u003eSchema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scAlts",
          "package": "hxt",
          "signature": "[Schema] -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scAlts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scAlts",
          "normalized": "[Schema]-\u003eSchema",
          "package": "hxt",
          "partial": "Alts",
          "signature": "[Schema]-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scAttr",
          "package": "hxt",
          "signature": "String -\u003e Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scAttr",
          "normalized": "String-\u003eSchema-\u003eSchema",
          "package": "hxt",
          "partial": "Attr",
          "signature": "String-\u003eSchema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scDT",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e Attributes -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scDT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scDT",
          "normalized": "String-\u003eString-\u003eAttributes-\u003eSchema",
          "package": "hxt",
          "partial": "DT",
          "signature": "String-\u003eString-\u003eAttributes-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scDT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scDTxsd",
          "package": "hxt",
          "signature": "String -\u003e Attributes -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scDTxsd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scDTxsd",
          "normalized": "String-\u003eAttributes-\u003eSchema",
          "package": "hxt",
          "partial": "DTxsd",
          "signature": "String-\u003eAttributes-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scDTxsd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scElem",
          "package": "hxt",
          "signature": "String -\u003e Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scElem",
          "normalized": "String-\u003eSchema-\u003eSchema",
          "package": "hxt",
          "partial": "Elem",
          "signature": "String-\u003eSchema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scEmpty",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scEmpty",
          "package": "hxt",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scEnum",
          "package": "hxt",
          "signature": "[String] -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scEnum",
          "normalized": "[String]-\u003eSchema",
          "package": "hxt",
          "partial": "Enum",
          "signature": "[String]-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scFixed",
          "package": "hxt",
          "signature": "String -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scFixed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scFixed",
          "normalized": "String-\u003eSchema",
          "package": "hxt",
          "partial": "Fixed",
          "signature": "String-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scFixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scList",
          "package": "hxt",
          "signature": "Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scList",
          "normalized": "Schema-\u003eSchema",
          "package": "hxt",
          "partial": "List",
          "signature": "Schema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scList1",
          "package": "hxt",
          "signature": "Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scList1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scList1",
          "normalized": "Schema-\u003eSchema",
          "package": "hxt",
          "partial": "List",
          "signature": "Schema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scList1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scNmtoken",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scNmtoken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scNmtoken",
          "package": "hxt",
          "partial": "Nmtoken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scNmtoken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scNmtokens",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scNmtokens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scNmtokens",
          "package": "hxt",
          "partial": "Nmtokens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scNmtokens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scNull",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scNull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scNull",
          "package": "hxt",
          "partial": "Null",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scOpt",
          "package": "hxt",
          "signature": "Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scOpt",
          "normalized": "Schema-\u003eSchema",
          "package": "hxt",
          "partial": "Opt",
          "signature": "Schema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scOption",
          "package": "hxt",
          "signature": "Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scOption",
          "normalized": "Schema-\u003eSchema",
          "package": "hxt",
          "partial": "Option",
          "signature": "Schema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scRep",
          "package": "hxt",
          "signature": "Int -\u003e Int -\u003e Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scRep",
          "normalized": "Int-\u003eInt-\u003eSchema-\u003eSchema",
          "package": "hxt",
          "partial": "Rep",
          "signature": "Int-\u003eInt-\u003eSchema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scSeq",
          "package": "hxt",
          "signature": "Schema -\u003e Schema -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scSeq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scSeq",
          "normalized": "Schema-\u003eSchema-\u003eSchema",
          "package": "hxt",
          "partial": "Seq",
          "signature": "Schema-\u003eSchema-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scSeqs",
          "package": "hxt",
          "signature": "[Schema] -\u003e Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scSeqs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scSeqs",
          "normalized": "[Schema]-\u003eSchema",
          "package": "hxt",
          "partial": "Seqs",
          "signature": "[Schema]-\u003eSchema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scSeqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scString",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scString",
          "package": "hxt",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scString1",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#scString1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "scString1",
          "package": "hxt",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:scString1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_1",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_1",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:sc_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_dt",
          "package": "hxt",
          "signature": "DataTypeDescr",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_dt",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:sc_dt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_l",
          "package": "hxt",
          "signature": "[Schema]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_l",
          "normalized": "[Schema]",
          "package": "hxt",
          "signature": "[Schema]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:sc_l"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_lb",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_lb",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:sc_lb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_n",
          "package": "hxt",
          "signature": "Name",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_n",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:sc_n"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_ub",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "sc_ub",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:sc_ub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eaccess an attribute of a descr of an atomic type\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "xsdParam",
          "package": "hxt",
          "signature": "String -\u003e Schema -\u003e String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#xsdParam",
          "type": "function"
        },
        "index": {
          "description": "access an attribute of descr of an atomic type",
          "hierarchy": "Text XML HXT Arrow Pickle Schema",
          "module": "Text.XML.HXT.Arrow.Pickle.Schema",
          "name": "xsdParam",
          "normalized": "String-\u003eSchema-\u003eString",
          "package": "hxt",
          "partial": "Param",
          "signature": "String-\u003eSchema-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Schema.html#v:xsdParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePickler functions for converting between user defined data types\n   and XmlTree data. Usefull for persistent storage and retreival\n   of arbitray data as XML documents.\n\u003c/p\u003e\u003cp\u003eThis module is an adaptation of the pickler combinators\n   developed by Andrew Kennedy\n   ( http://research.microsoft.com/~akenn/fun/picklercombinators.pdf ).\n\u003c/p\u003e\u003cp\u003eThe difference to Kennedys approach is that the target is not\n   a list of Chars but a list of XmlTrees. The basic picklers will\n   convert data into XML text nodes. New are the picklers for\n   creating elements and attributes.\n\u003c/p\u003e\u003cp\u003eOne extension was neccessary: The unpickling may fail.\n\u003c/p\u003e\u003cp\u003eOld: Therefore the unpickler has a Maybe result type.\n   Failure is used to unpickle optional elements\n   (Maybe data) and lists of arbitray length.\n\u003c/p\u003e\u003cp\u003eSince hxt-9.2.0: The unpicklers are implemented as\n   a parser monad with an Either err val result type.\n   This enables appropriate error messages , when unpickling\n   XML stuff, that is not generated with the picklers and which contains\n   some elements and/or attributes that are not handled when unpickling.\n\u003c/p\u003e\u003cp\u003eThere is an example program demonstrating the use\n   of the picklers for a none trivial data structure.\n   (see \"examples/arrows/pickle\" directory in the hxt distribution)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "Xml",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html",
          "type": "module"
        },
        "index": {
          "description": "Pickler functions for converting between user defined data types and XmlTree data Usefull for persistent storage and retreival of arbitray data as XML documents This module is an adaptation of the pickler combinators developed by Andrew Kennedy http research.microsoft.com akenn fun picklercombinators.pdf The difference to Kennedys approach is that the target is not list of Chars but list of XmlTrees The basic picklers will convert data into XML text nodes New are the picklers for creating elements and attributes One extension was neccessary The unpickling may fail Old Therefore the unpickler has Maybe result type Failure is used to unpickle optional elements Maybe data and lists of arbitray length Since hxt-9.2.0 The unpicklers are implemented as parser monad with an Either err val result type This enables appropriate error messages when unpickling XML stuff that is not generated with the picklers and which contains some elements and or attributes that are not handled when unpickling There is an example program demonstrating the use of the picklers for none trivial data structure see examples arrows pickle directory in the hxt distribution",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "Xml",
          "package": "hxt",
          "partial": "Xml",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "PU",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#PU",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "PU",
          "package": "hxt",
          "partial": "PU",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#t:PU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "Pickler",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#Pickler",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "Pickler",
          "package": "hxt",
          "partial": "Pickler",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#t:Pickler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "St",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#St",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "St",
          "package": "hxt",
          "partial": "St",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#t:St"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "UnpickleErr",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#UnpickleErr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "UnpickleErr",
          "package": "hxt",
          "partial": "Unpickle Err",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#t:UnpickleErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "UnpickleVal",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#UnpickleVal",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "UnpickleVal",
          "package": "hxt",
          "partial": "Unpickle Val",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#t:UnpickleVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "Unpickler",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#Unpickler",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "Unpickler",
          "package": "hxt",
          "partial": "Unpickler",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#t:Unpickler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class for overloading \u003ccode\u003e\u003ca\u003expickle\u003c/a\u003e\u003c/code\u003e, the default pickler\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "XmlPickler",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#XmlPickler",
          "type": "class"
        },
        "index": {
          "description": "The class for overloading xpickle the default pickler",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "XmlPickler",
          "package": "hxt",
          "partial": "Xml Pickler",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#t:XmlPickler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "PU",
          "package": "hxt",
          "signature": "PU",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#PU",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:PU\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:PU\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "PU",
          "package": "hxt",
          "partial": "PU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:PU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "St",
          "package": "hxt",
          "signature": "St",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#St",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "St",
          "package": "hxt",
          "partial": "St",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:St"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "UP",
          "package": "hxt",
          "signature": "UP",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#Unpickler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "UP",
          "package": "hxt",
          "partial": "UP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:UP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "appPickle",
          "package": "hxt",
          "signature": "Pickler a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#PU",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:appPickle\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:appPickle\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "appPickle",
          "package": "hxt",
          "partial": "Pickle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:appPickle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "appUnPickle",
          "package": "hxt",
          "signature": "Unpickler a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#PU",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:appUnPickle\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:appUnPickle\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "appUnPickle",
          "package": "hxt",
          "partial": "Un Pickle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:appUnPickle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "attributes",
          "package": "hxt",
          "signature": "[XmlTree]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#St",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "attributes",
          "normalized": "[XmlTree]",
          "package": "hxt",
          "signature": "[XmlTree]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "contents",
          "package": "hxt",
          "signature": "[XmlTree]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#St",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "contents",
          "normalized": "[XmlTree]",
          "package": "hxt",
          "signature": "[XmlTree]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:contents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "emptySt",
          "package": "hxt",
          "signature": "St",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#emptySt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "emptySt",
          "package": "hxt",
          "partial": "St",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:emptySt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "findElem",
          "package": "hxt",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe (a, [a])",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#findElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "findElem",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe(a,[a])",
          "package": "hxt",
          "partial": "Elem",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:findElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormat the context of an error message.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "formatSt",
          "package": "hxt",
          "signature": "St -\u003e String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#formatSt",
          "type": "function"
        },
        "index": {
          "description": "Format the context of an error message",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "formatSt",
          "normalized": "St-\u003eString",
          "package": "hxt",
          "partial": "St",
          "signature": "St-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:formatSt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "getAtt",
          "package": "hxt",
          "signature": "QName -\u003e Unpickler XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#getAtt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "getAtt",
          "normalized": "QName-\u003eUnpickler XmlTree",
          "package": "hxt",
          "partial": "Att",
          "signature": "QName-\u003eUnpickler XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:getAtt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "getCont",
          "package": "hxt",
          "signature": "Unpickler XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#getCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "getCont",
          "package": "hxt",
          "partial": "Cont",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:getCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "getNSAtt",
          "package": "hxt",
          "signature": "String -\u003e Unpickler ()",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#getNSAtt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "getNSAtt",
          "normalized": "String-\u003eUnpickler()",
          "package": "hxt",
          "partial": "NSAtt",
          "signature": "String-\u003eUnpickler()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:getNSAtt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a Maybe value into the Unpickler monad.\n\u003c/p\u003e\u003cp\u003eThe 1. arg is the attached error message\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "liftMaybe",
          "package": "hxt",
          "signature": "String -\u003e Maybe a -\u003e Unpickler a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#liftMaybe",
          "type": "function"
        },
        "index": {
          "description": "Lift Maybe value into the Unpickler monad The arg is the attached error message",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "liftMaybe",
          "normalized": "String-\u003eMaybe a-\u003eUnpickler a",
          "package": "hxt",
          "partial": "Maybe",
          "signature": "String-\u003eMaybe a-\u003eUnpickler a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:liftMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift an Either value into the Unpickler monad\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "liftUnpickleVal",
          "package": "hxt",
          "signature": "UnpickleVal a -\u003e Unpickler a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#liftUnpickleVal",
          "type": "function"
        },
        "index": {
          "description": "Lift an Either value into the Unpickler monad",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "liftUnpickleVal",
          "normalized": "UnpickleVal a-\u003eUnpickler a",
          "package": "hxt",
          "partial": "Unpickle Val",
          "signature": "UnpickleVal a-\u003eUnpickler a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:liftUnpickleVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChoice combinator for unpickling\n\u003c/p\u003e\u003cp\u003efirst 2 arguments are applied sequentially, but if the 1. one fails the\n 3. arg is applied\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "mchoice",
          "package": "hxt",
          "signature": "Unpickler a -\u003e (a -\u003e Unpickler b) -\u003e Unpickler b -\u003e Unpickler b",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#mchoice",
          "type": "function"
        },
        "index": {
          "description": "Choice combinator for unpickling first arguments are applied sequentially but if the one fails the arg is applied",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "mchoice",
          "normalized": "Unpickler a-\u003e(a-\u003eUnpickler b)-\u003eUnpickler b-\u003eUnpickler b",
          "package": "hxt",
          "signature": "Unpickler a-\u003e(a-\u003eUnpickler b)-\u003eUnpickler b-\u003eUnpickler b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:mchoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "nesting",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#St",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "nesting",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:nesting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "pelem",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#St",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "pelem",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:pelem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econversion of an arbitrary value into an XML document tree.\n\u003c/p\u003e\u003cp\u003eThe pickler, first parameter, controls the conversion process.\n Result is a complete document tree including a root node\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "pickleDoc",
          "package": "hxt",
          "signature": "PU a -\u003e a -\u003e XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#pickleDoc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:pickleDoc\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:pickleDoc\"]"
        },
        "index": {
          "description": "conversion of an arbitrary value into an XML document tree The pickler first parameter controls the conversion process Result is complete document tree including root node",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "pickleDoc",
          "normalized": "PU a-\u003ea-\u003eXmlTree",
          "package": "hxt",
          "partial": "Doc",
          "signature": "PU a-\u003ea-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:pickleDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "pname",
          "package": "hxt",
          "signature": "QName",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#St",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "pname",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:pname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "putAtt",
          "package": "hxt",
          "signature": "QName -\u003e [XmlTree] -\u003e St -\u003e St",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#putAtt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "putAtt",
          "normalized": "QName-\u003e[XmlTree]-\u003eSt-\u003eSt",
          "package": "hxt",
          "partial": "Att",
          "signature": "QName-\u003e[XmlTree]-\u003eSt-\u003eSt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:putAtt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "putCont",
          "package": "hxt",
          "signature": "XmlTree -\u003e St -\u003e St",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#putCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "putCont",
          "normalized": "XmlTree-\u003eSt-\u003eSt",
          "package": "hxt",
          "partial": "Cont",
          "signature": "XmlTree-\u003eSt-\u003eSt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:putCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "runUP",
          "package": "hxt",
          "signature": "St -\u003e (UnpickleVal a, St)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#Unpickler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "runUP",
          "normalized": "St-\u003e(UnpickleVal a,St)",
          "package": "hxt",
          "partial": "UP",
          "signature": "St-\u003e(UnpickleVal a,St)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:runUP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickles a value, then writes the document to a string.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "showPickled",
          "package": "hxt",
          "signature": "SysConfigList -\u003e a -\u003e String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#showPickled",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:showPickled\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:showPickled\"]"
        },
        "index": {
          "description": "Pickles value then writes the document to string",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "showPickled",
          "normalized": "SysConfigList-\u003ea-\u003eString",
          "package": "hxt",
          "partial": "Pickled",
          "signature": "SysConfigList-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:showPickled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "theSchema",
          "package": "hxt",
          "signature": "Schema",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#PU",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:theSchema\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:theSchema\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "theSchema",
          "package": "hxt",
          "partial": "Schema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:theSchema"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "throwMsg",
          "package": "hxt",
          "signature": "String -\u003e Unpickler a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#throwMsg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "throwMsg",
          "normalized": "String-\u003eUnpickler a",
          "package": "hxt",
          "partial": "Msg",
          "signature": "String-\u003eUnpickler a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:throwMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion of an XML document tree into an arbitrary data type\n\u003c/p\u003e\u003cp\u003eThe inverse of \u003ccode\u003e\u003ca\u003epickleDoc\u003c/a\u003e\u003c/code\u003e.\n This law should hold for all picklers: \u003ccode\u003e unpickle px . pickle px $ v == Just v \u003c/code\u003e.\n Not every possible combination of picklers does make sense.\n For reconverting a value from an XML tree, is becomes neccessary,\n to introduce \"enough\" markup for unpickling the value\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "unpickleDoc",
          "package": "hxt",
          "signature": "PU a -\u003e XmlTree -\u003e Maybe a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#unpickleDoc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:unpickleDoc\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:unpickleDoc\"]"
        },
        "index": {
          "description": "Conversion of an XML document tree into an arbitrary data type The inverse of pickleDoc This law should hold for all picklers unpickle px pickle px Just Not every possible combination of picklers does make sense For reconverting value from an XML tree is becomes neccessary to introduce enough markup for unpickling the value",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "unpickleDoc",
          "normalized": "PU a-\u003eXmlTree-\u003eMaybe a",
          "package": "hxt",
          "partial": "Doc",
          "signature": "PU a-\u003eXmlTree-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:unpickleDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike unpickleDoc but with a (sometimes) useful error message, when unpickling failed.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "unpickleDoc'",
          "package": "hxt",
          "signature": "PU a -\u003e XmlTree -\u003e Either String a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#unpickleDoc%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:unpickleDoc-39-\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:unpickleDoc-39-\"]"
        },
        "index": {
          "description": "Like unpickleDoc but with sometimes useful error message when unpickling failed",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "unpickleDoc'",
          "normalized": "PU a-\u003eXmlTree-\u003eEither String a",
          "package": "hxt",
          "partial": "Doc'",
          "signature": "PU a-\u003eXmlTree-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:unpickleDoc-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main entry for unpickling, called by unpickleDoc\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "unpickleElem'",
          "package": "hxt",
          "signature": "PU a -\u003e Int -\u003e XmlTree -\u003e UnpickleVal a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#unpickleElem%27",
          "type": "function"
        },
        "index": {
          "description": "The main entry for unpickling called by unpickleDoc",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "unpickleElem'",
          "normalized": "PU a-\u003eInt-\u003eXmlTree-\u003eUnpickleVal a",
          "package": "hxt",
          "partial": "Elem'",
          "signature": "PU a-\u003eInt-\u003eXmlTree-\u003eUnpickleVal a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:unpickleElem-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp10Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU (a, b, c, d, e, f, g, h, i, j)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp10Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp10Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp10Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp10Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU(a,b,c,d,e,f,g,h,i,j)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU(a,b,c,d,e,f,g,h,i,j)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp10Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp11Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU (a, b, c, d, e, f, g, h, i, j, k)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp11Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp11Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp11Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp11Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU(a,b,c,d,e,f,g,h,i,j,k)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU(a,b,c,d,e,f,g,h,i,j,k)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp11Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp12Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp12Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp12Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp12Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp12Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp12Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp13Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp13Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp13Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp13Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp13Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp13Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp14Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp14Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp14Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp14Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp14Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp14Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp15Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp15Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp15Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp15Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp15Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp15Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp16Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp16Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp16Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp16Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp16Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp16Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp17Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp17Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp17Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp17Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp17Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp17Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp18Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU r -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp18Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp18Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp18Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp18Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp18Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp19Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU r -\u003e PU s -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp19Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp19Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp19Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp19Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp19Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp20Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU r -\u003e PU s -\u003e PU t -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp20Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp20Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp20Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp20Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp20Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp21Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU r -\u003e PU s -\u003e PU t -\u003e PU u -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp21Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp21Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp21Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp21Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp21Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp22Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU r -\u003e PU s -\u003e PU t -\u003e PU u -\u003e PU v -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp22Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp22Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp22Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp22Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU v-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU v-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp22Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp23Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU r -\u003e PU s -\u003e PU t -\u003e PU u -\u003e PU v -\u003e PU w -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp23Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp23Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp23Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp23Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU v-\u003ePU w-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU v-\u003ePU w-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp23Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHopefully no one needs a xp25Tuple\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp24Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU j -\u003e PU k -\u003e PU l -\u003e PU m -\u003e PU n -\u003e PU o -\u003e PU p -\u003e PU q -\u003e PU r -\u003e PU s -\u003e PU t -\u003e PU u -\u003e PU v -\u003e PU w -\u003e PU x -\u003e PU (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp24Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp24Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp24Tuple\"]"
        },
        "index": {
          "description": "Hopefully no one needs xp25Tuple",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp24Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU v-\u003ePU w-\u003ePU x-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU j-\u003ePU k-\u003ePU l-\u003ePU m-\u003ePU n-\u003ePU o-\u003ePU p-\u003ePU q-\u003ePU r-\u003ePU s-\u003ePU t-\u003ePU u-\u003ePU v-\u003ePU w-\u003ePU x-\u003ePU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp24Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003expPair\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003expTriple\u003c/a\u003e\u003c/code\u003e but for 4-tuples\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp4Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU (a, b, c, d)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp4Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp4Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp4Tuple\"]"
        },
        "index": {
          "description": "Like xpPair and xpTriple but for tuples",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp4Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU(a,b,c,d)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU(a,b,c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp4Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003expPair\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003expTriple\u003c/a\u003e\u003c/code\u003e but for 5-tuples\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp5Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU (a, b, c, d, e)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp5Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp5Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp5Tuple\"]"
        },
        "index": {
          "description": "Like xpPair and xpTriple but for tuples",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp5Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU(a,b,c,d,e)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU(a,b,c,d,e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp5Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003expPair\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003expTriple\u003c/a\u003e\u003c/code\u003e but for 6-tuples\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp6Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU (a, b, c, d, e, f)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp6Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp6Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp6Tuple\"]"
        },
        "index": {
          "description": "Like xpPair and xpTriple but for tuples",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp6Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU(a,b,c,d,e,f)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU(a,b,c,d,e,f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp6Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003expPair\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003expTriple\u003c/a\u003e\u003c/code\u003e but for 7-tuples\n\u003c/p\u003e\u003cp\u003eThanks to Tony Morris for doing xp7Tuple, ..., xp24Tuple.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp7Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU (a, b, c, d, e, f, g)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp7Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp7Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp7Tuple\"]"
        },
        "index": {
          "description": "Like xpPair and xpTriple but for tuples Thanks to Tony Morris for doing xp7Tuple xp24Tuple",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp7Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU(a,b,c,d,e,f,g)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU(a,b,c,d,e,f,g)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp7Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp8Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU (a, b, c, d, e, f, g, h)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp8Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp8Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp8Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp8Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU(a,b,c,d,e,f,g,h)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU(a,b,c,d,e,f,g,h)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp8Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xp9Tuple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU d -\u003e PU e -\u003e PU f -\u003e PU g -\u003e PU h -\u003e PU i -\u003e PU (a, b, c, d, e, f, g, h, i)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xp9Tuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp9Tuple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xp9Tuple\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xp9Tuple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU(a,b,c,d,e,f,g,h,i)",
          "package": "hxt",
          "partial": "Tuple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU d-\u003ePU e-\u003ePU f-\u003ePU g-\u003ePU h-\u003ePU i-\u003ePU(a,b,c,d,e,f,g,h,i)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xp9Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd/Check an attribute with a fixed value.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpAddFixedAttr",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAddFixedAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAddFixedAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpAddFixedAttr\"]"
        },
        "index": {
          "description": "Add Check an attribute with fixed value",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAddFixedAttr",
          "normalized": "String-\u003eString-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Add Fixed Attr",
          "signature": "String-\u003eString-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAddFixedAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a namespace declaration.\n\u003c/p\u003e\u003cp\u003eWhen generating XML the namespace decl is added,\n when reading a document, the unpickler checks\n whether there is a namespace declaration for the given\n namespace URI (2. arg)\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpAddNSDecl",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAddNSDecl",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAddNSDecl\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpAddNSDecl\"]"
        },
        "index": {
          "description": "Add namespace declaration When generating XML the namespace decl is added when reading document the unpickler checks whether there is namespace declaration for the given namespace URI arg",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAddNSDecl",
          "normalized": "String-\u003eString-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Add NSDecl",
          "signature": "String-\u003eString-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAddNSDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickler for sum data types.\n\u003c/p\u003e\u003cp\u003eEvery constructor is mapped to an index into the list of picklers.\n The index is used only during pickling, not during unpickling, there the 1. match is taken\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpAlt",
          "package": "hxt",
          "signature": "(a -\u003e Int) -\u003e [PU a] -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAlt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAlt\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpAlt\"]"
        },
        "index": {
          "description": "Pickler for sum data types Every constructor is mapped to an index into the list of picklers The index is used only during pickling not during unpickling there the match is taken",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAlt",
          "normalized": "(a-\u003eInt)-\u003e[PU a]-\u003ePU a",
          "package": "hxt",
          "partial": "Alt",
          "signature": "(a-\u003eInt)-\u003e[PU a]-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient Pickler for xpAttrQN\n\u003c/p\u003e\u003cpre\u003e xpAttr n = xpAttrQN (mkName n)\n\u003c/pre\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpAttr",
          "package": "hxt",
          "signature": "String -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpAttr\"]"
        },
        "index": {
          "description": "convenient Pickler for xpAttrQN xpAttr xpAttrQN mkName",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttr",
          "normalized": "String-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Attr",
          "signature": "String-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpAttrFixed",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e PU ()",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAttrFixed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrFixed\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpAttrFixed\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttrFixed",
          "normalized": "String-\u003eString-\u003ePU()",
          "package": "hxt",
          "partial": "Attr Fixed",
          "signature": "String-\u003eString-\u003ePU()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrFixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an optional attribute for an optional value (Maybe a).\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpAttrImplied",
          "package": "hxt",
          "signature": "String -\u003e PU a -\u003e PU (Maybe a)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAttrImplied",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrImplied\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpAttrImplied\"]"
        },
        "index": {
          "description": "Add an optional attribute for an optional value Maybe",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttrImplied",
          "normalized": "String-\u003ePU a-\u003ePU(Maybe a)",
          "package": "hxt",
          "partial": "Attr Implied",
          "signature": "String-\u003ePU a-\u003ePU(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrImplied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient Pickler for xpAttrQN\n\u003c/p\u003e\u003cpre\u003e xpAttr ns px lp = xpAttrQN (mkQName px lp ns)\n\u003c/pre\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpAttrNS",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e String -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAttrNS",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrNS\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpAttrNS\"]"
        },
        "index": {
          "description": "convenient Pickler for xpAttrQN xpAttr ns px lp xpAttrQN mkQName px lp ns",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttrNS",
          "normalized": "String-\u003eString-\u003eString-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Attr NS",
          "signature": "String-\u003eString-\u003eString-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrNS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttrNSDecl",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e PU ()",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAttrNSDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttrNSDecl",
          "normalized": "String-\u003eString-\u003ePU()",
          "package": "hxt",
          "partial": "Attr NSDecl",
          "signature": "String-\u003eString-\u003ePU()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrNSDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickler for storing/retreiving data into/from an attribute value\n\u003c/p\u003e\u003cp\u003eThe attribute is inserted in the surrounding element constructed by the \u003ccode\u003e\u003ca\u003expElem\u003c/a\u003e\u003c/code\u003e pickler\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttrQN",
          "package": "hxt",
          "signature": "QName -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpAttrQN",
          "type": "function"
        },
        "index": {
          "description": "Pickler for storing retreiving data into from an attribute value The attribute is inserted in the surrounding element constructed by the xpElem pickler",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpAttrQN",
          "normalized": "QName-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Attr QN",
          "signature": "QName-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpAttrQN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of xpCheckEmptyContents and xpCheckAttributes\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpCheckEmpty",
          "package": "hxt",
          "signature": "PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpCheckEmpty",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpCheckEmpty\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpCheckEmpty\"]"
        },
        "index": {
          "description": "Composition of xpCheckEmptyContents and xpCheckAttributes",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpCheckEmpty",
          "normalized": "PU a-\u003ePU a",
          "package": "hxt",
          "partial": "Check Empty",
          "signature": "PU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpCheckEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike xpCheckEmptyContents, but checks the attribute list\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpCheckEmptyAttributes",
          "package": "hxt",
          "signature": "PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpCheckEmptyAttributes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpCheckEmptyAttributes\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpCheckEmptyAttributes\"]"
        },
        "index": {
          "description": "Like xpCheckEmptyContents but checks the attribute list",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpCheckEmptyAttributes",
          "normalized": "PU a-\u003ePU a",
          "package": "hxt",
          "partial": "Check Empty Attributes",
          "signature": "PU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpCheckEmptyAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck EOF pickler.\n\u003c/p\u003e\u003cp\u003eWhen pickling, this behaves like the unit pickler.\n The unpickler fails, when there is some unprocessed XML contents left.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpCheckEmptyContents",
          "package": "hxt",
          "signature": "PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpCheckEmptyContents",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpCheckEmptyContents\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpCheckEmptyContents\"]"
        },
        "index": {
          "description": "Check EOF pickler When pickling this behaves like the unit pickler The unpickler fails when there is some unprocessed XML contents left",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpCheckEmptyContents",
          "normalized": "PU a-\u003ePU a",
          "package": "hxt",
          "partial": "Check Empty Contents",
          "signature": "PU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpCheckEmptyContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecombine tow picklers with a choice\n\u003c/p\u003e\u003cp\u003eRun two picklers in sequence like with xpSeq.\n When during unpickling the first one fails,\n an alternative pickler (first argument) is applied.\n This pickler is only used as combinator for unpickling.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpChoice",
          "package": "hxt",
          "signature": "PU b -\u003e PU a -\u003e (a -\u003e PU b) -\u003e Unpickler b",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpChoice",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpChoice\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpChoice\"]"
        },
        "index": {
          "description": "combine tow picklers with choice Run two picklers in sequence like with xpSeq When during unpickling the first one fails an alternative pickler first argument is applied This pickler is only used as combinator for unpickling",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpChoice",
          "normalized": "PU a-\u003ePU b-\u003e(b-\u003ePU a)-\u003eUnpickler a",
          "package": "hxt",
          "partial": "Choice",
          "signature": "PU b-\u003ePU a-\u003e(a-\u003ePU b)-\u003eUnpickler b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpChoice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptional conversion with default value\n\u003c/p\u003e\u003cp\u003eThe default value is not encoded in the XML document,\n during unpickling the default value is inserted if the pickler fails\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpDefault",
          "package": "hxt",
          "signature": "a -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpDefault",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpDefault\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpDefault\"]"
        },
        "index": {
          "description": "Optional conversion with default value The default value is not encoded in the XML document during unpickling the default value is inserted if the pickler fails",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpDefault",
          "normalized": "a-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Default",
          "signature": "a-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient Pickler for xpElemQN\n\u003c/p\u003e\u003cpre\u003e xpElem n = xpElemQN (mkName n)\n\u003c/pre\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpElem",
          "package": "hxt",
          "signature": "String -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpElem",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpElem\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpElem\"]"
        },
        "index": {
          "description": "convenient Pickler for xpElemQN xpElem xpElemQN mkName",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpElem",
          "normalized": "String-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Elem",
          "signature": "String-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient Pickler for xpElemQN\n   for pickling elements with respect to namespaces\n\u003c/p\u003e\u003cpre\u003e xpElemNS ns px lp = xpElemQN (mkQName px lp ns)\n\u003c/pre\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpElemNS",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e String -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpElemNS",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpElemNS\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpElemNS\"]"
        },
        "index": {
          "description": "convenient Pickler for xpElemQN for pickling elements with respect to namespaces xpElemNS ns px lp xpElemQN mkQName px lp ns",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpElemNS",
          "normalized": "String-\u003eString-\u003eString-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Elem NS",
          "signature": "String-\u003eString-\u003eString-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpElemNS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickler for wrapping/unwrapping data into an XML element\n\u003c/p\u003e\u003cp\u003eExtra parameter is the element name given as a QName. THE pickler for constructing\n nested structures\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e xpElemQN (mkName \"number\") $ xpickle\n\u003c/pre\u003e\u003cp\u003ewill map an (42::Int) onto\n\u003c/p\u003e\u003cpre\u003e \u003cnumber\u003e42\u003c/number\u003e\n\u003c/pre\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpElemQN",
          "package": "hxt",
          "signature": "QName -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpElemQN",
          "type": "function"
        },
        "index": {
          "description": "Pickler for wrapping unwrapping data into an XML element Extra parameter is the element name given as QName THE pickler for constructing nested structures Example xpElemQN mkName number xpickle will map an Int onto number number",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpElemQN",
          "normalized": "QName-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Elem QN",
          "signature": "QName-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpElemQN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickler for wrapping/unwrapping data into an XML element with an attribute with given value\n\u003c/p\u003e\u003cp\u003eTo make XML structures flexible but limit the number of different elements, it's sometimes\n useful to use a kind of generic element with a key value structure\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e \u003cattr name=\"key1\"\u003evalue1\u003c/attr\u003e\n \u003cattr name=\"key2\"\u003evalue2\u003c/attr\u003e\n \u003cattr name=\"key3\"\u003evalue3\u003c/attr\u003e\n\u003c/pre\u003e\u003cp\u003ethe Haskell datatype may look like this\n\u003c/p\u003e\u003cpre\u003e type T = T { key1 :: Int ; key2 :: String ; key3 :: Double }\n\u003c/pre\u003e\u003cp\u003eThen the picker for that type looks like this\n\u003c/p\u003e\u003cpre\u003e xpT :: PU T\n xpT = xpWrap ( uncurry3 T, \\ t -\u003e (key1 t, key2 t, key3 t) ) $\n       xpTriple (xpElemWithAttrValue \"attr\" \"name\" \"key1\" $ xpickle)\n                (xpElemWithAttrValue \"attr\" \"name\" \"key2\" $ xpText0)\n                (xpElemWithAttrValue \"attr\" \"name\" \"key3\" $ xpickle)\n\u003c/pre\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpElemWithAttrValue",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e String -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpElemWithAttrValue",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpElemWithAttrValue\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpElemWithAttrValue\"]"
        },
        "index": {
          "description": "Pickler for wrapping unwrapping data into an XML element with an attribute with given value To make XML structures flexible but limit the number of different elements it sometimes useful to use kind of generic element with key value structure Example attr name key1 value1 attr attr name key2 value2 attr attr name key3 value3 attr the Haskell datatype may look like this type key1 Int key2 String key3 Double Then the picker for that type looks like this xpT PU xpT xpWrap uncurry3 key1 key2 key3 xpTriple xpElemWithAttrValue attr name key1 xpickle xpElemWithAttrValue attr name key2 xpText0 xpElemWithAttrValue attr name key3 xpickle",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpElemWithAttrValue",
          "normalized": "String-\u003eString-\u003eString-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Elem With Attr Value",
          "signature": "String-\u003eString-\u003eString-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpElemWithAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003expFilterCont\u003c/a\u003e\u003c/code\u003e but for the  attribute list of the element currently processed.\n\u003c/p\u003e\u003cp\u003eMaybe useful to ignore some stuff in the input, e.g. class attributes, or to do some cleanup before unpickling.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpFilterAttr",
          "package": "hxt",
          "signature": "LA XmlTree XmlTree -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpFilterAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpFilterAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpFilterAttr\"]"
        },
        "index": {
          "description": "Same as xpFilterCont but for the attribute list of the element currently processed Maybe useful to ignore some stuff in the input e.g class attributes or to do some cleanup before unpickling",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpFilterAttr",
          "normalized": "LA XmlTree XmlTree-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Filter Attr",
          "signature": "LA XmlTree XmlTree-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpFilterAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen unpickling, filter the contents of the element currently processed,\n before applying the pickler argument\n\u003c/p\u003e\u003cp\u003eMaybe useful to ignore some stuff in the input, or to do some cleanup before unpickling.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpFilterCont",
          "package": "hxt",
          "signature": "LA XmlTree XmlTree -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpFilterCont",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpFilterCont\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpFilterCont\"]"
        },
        "index": {
          "description": "When unpickling filter the contents of the element currently processed before applying the pickler argument Maybe useful to ignore some stuff in the input or to do some cleanup before unpickling",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpFilterCont",
          "normalized": "LA XmlTree XmlTree-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Filter Cont",
          "signature": "LA XmlTree XmlTree-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpFilterCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpIgnoreAttr",
          "package": "hxt",
          "signature": "LA XmlTree XmlTree -\u003e PU ()",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpIgnoreAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpIgnoreAttr",
          "normalized": "LA XmlTree XmlTree-\u003ePU()",
          "package": "hxt",
          "partial": "Ignore Attr",
          "signature": "LA XmlTree XmlTree-\u003ePU()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpIgnoreAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpIgnoreCont",
          "package": "hxt",
          "signature": "LA XmlTree XmlTree -\u003e PU ()",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpIgnoreCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpIgnoreCont",
          "normalized": "LA XmlTree XmlTree-\u003ePU()",
          "package": "hxt",
          "partial": "Ignore Cont",
          "signature": "LA XmlTree XmlTree-\u003ePU()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpIgnoreCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpIgnoreInput",
          "package": "hxt",
          "signature": "(([XmlTree] -\u003e [XmlTree]) -\u003e St -\u003e St) -\u003e LA XmlTree XmlTree -\u003e PU ()",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpIgnoreInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpIgnoreInput",
          "normalized": "(([XmlTree]-\u003e[XmlTree])-\u003eSt-\u003eSt)-\u003eLA XmlTree XmlTree-\u003ePU()",
          "package": "hxt",
          "partial": "Ignore Input",
          "signature": "(([XmlTree]-\u003e[XmlTree])-\u003eSt-\u003eSt)-\u003eLA XmlTree XmlTree-\u003ePU()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpIgnoreInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle an Int\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpInt",
          "package": "hxt",
          "signature": "PU Int",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpInt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpInt\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpInt\"]"
        },
        "index": {
          "description": "Pickle an Int",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpInt",
          "package": "hxt",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpLift",
          "package": "hxt",
          "signature": "a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpLift",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpLift\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpLift\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpLift",
          "normalized": "a-\u003ePU a",
          "package": "hxt",
          "partial": "Lift",
          "signature": "a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpLift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpLiftEither",
          "package": "hxt",
          "signature": "Either String a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpLiftEither",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpLiftEither\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpLiftEither\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpLiftEither",
          "normalized": "Either String a-\u003ePU a",
          "package": "hxt",
          "partial": "Lift Either",
          "signature": "Either String a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpLiftEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a Maybe value to a pickler.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eNothing\u003c/code\u003e is mapped to the zero pickler, \u003ccode\u003eJust x\u003c/code\u003e is pickled with \u003ccode\u003expLift x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpLiftMaybe",
          "package": "hxt",
          "signature": "Maybe a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpLiftMaybe",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpLiftMaybe\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpLiftMaybe\"]"
        },
        "index": {
          "description": "Lift Maybe value to pickler Nothing is mapped to the zero pickler Just is pickled with xpLift",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpLiftMaybe",
          "normalized": "Maybe a-\u003ePU a",
          "package": "hxt",
          "partial": "Lift Maybe",
          "signature": "Maybe a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpLiftMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoding of list values by pickling all list elements sequentially.\n\u003c/p\u003e\u003cp\u003eUnpickler relies on failure for detecting the end of the list.\n The standard pickler for lists. Can also be used in combination with \u003ccode\u003e\u003ca\u003expWrap\u003c/a\u003e\u003c/code\u003e\n for constructing set and map picklers\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpList",
          "package": "hxt",
          "signature": "PU a -\u003e PU [a]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpList\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpList\"]"
        },
        "index": {
          "description": "Encoding of list values by pickling all list elements sequentially Unpickler relies on failure for detecting the end of the list The standard pickler for lists Can also be used in combination with xpWrap for constructing set and map picklers",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpList",
          "normalized": "PU a-\u003ePU[a]",
          "package": "hxt",
          "partial": "List",
          "signature": "PU a-\u003ePU[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoding of a none empty list of values\n\u003c/p\u003e\u003cp\u003eAttention: when calling this pickler with an empty list,\n an internal error \"head of empty list is raised\".\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpList1",
          "package": "hxt",
          "signature": "PU a -\u003e PU [a]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpList1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpList1\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpList1\"]"
        },
        "index": {
          "description": "Encoding of none empty list of values Attention when calling this pickler with an empty list an internal error head of empty list is raised",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpList1",
          "normalized": "PU a-\u003ePU[a]",
          "package": "hxt",
          "partial": "List",
          "signature": "PU a-\u003ePU[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpList1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStandard pickler for maps\n\u003c/p\u003e\u003cp\u003eThis pickler converts a map into a list of pairs.\n All key value pairs are mapped to an element with name (1.arg),\n the key is encoded as an attribute named by the 2. argument,\n the 3. arg is the pickler for the keys, the last one for the values\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpMap",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e PU k -\u003e PU v -\u003e PU (Map k v)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpMap",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpMap\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpMap\"]"
        },
        "index": {
          "description": "Standard pickler for maps This pickler converts map into list of pairs All key value pairs are mapped to an element with name arg the key is encoded as an attribute named by the argument the arg is the pickler for the keys the last one for the values",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpMap",
          "normalized": "String-\u003eString-\u003ePU a-\u003ePU b-\u003ePU(Map a b)",
          "package": "hxt",
          "partial": "Map",
          "signature": "String-\u003eString-\u003ePU k-\u003ePU v-\u003ePU(Map k v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncoding of optional data by ignoring the Nothing case during pickling\n and relying on failure during unpickling to recompute the Nothing case\n\u003c/p\u003e\u003cp\u003eThe default pickler for Maybe types\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpOption",
          "package": "hxt",
          "signature": "PU a -\u003e PU (Maybe a)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpOption\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpOption\"]"
        },
        "index": {
          "description": "Encoding of optional data by ignoring the Nothing case during pickling and relying on failure during unpickling to recompute the Nothing case The default pickler for Maybe types",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpOption",
          "normalized": "PU a-\u003ePU(Maybe a)",
          "package": "hxt",
          "partial": "Option",
          "signature": "PU a-\u003ePU(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epickle a pair of values sequentially\n\u003c/p\u003e\u003cp\u003eUsed for pairs or together with wrap for pickling\n algebraic data types with two components\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpPair",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU (a, b)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpPair",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpPair\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpPair\"]"
        },
        "index": {
          "description": "pickle pair of values sequentially Used for pairs or together with wrap for pickling algebraic data types with two components",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpPair",
          "normalized": "PU a-\u003ePU b-\u003ePU(a,b)",
          "package": "hxt",
          "partial": "Pair",
          "signature": "PU a-\u003ePU b-\u003ePU(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle an arbitrary value by applyling show during pickling\n and read during unpickling.\n\u003c/p\u003e\u003cp\u003eReal pickling is then done with \u003ccode\u003e\u003ca\u003expText\u003c/a\u003e\u003c/code\u003e.\n One of the most often used pimitive picklers. Applicable for all\n types which are instances of \u003ccode\u003eRead\u003c/code\u003e and \u003ccode\u003eShow\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpPrim",
          "package": "hxt",
          "signature": "PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpPrim",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpPrim\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpPrim\"]"
        },
        "index": {
          "description": "Pickle an arbitrary value by applyling show during pickling and read during unpickling Real pickling is then done with xpText One of the most often used pimitive picklers Applicable for all types which are instances of Read and Show",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpPrim",
          "package": "hxt",
          "partial": "Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two picklers sequentially.\n\u003c/p\u003e\u003cp\u003eIf the first fails during\n unpickling, the whole unpickler fails\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpSeq",
          "package": "hxt",
          "signature": "(b -\u003e a) -\u003e PU a -\u003e (a -\u003e PU b) -\u003e PU b",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpSeq",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpSeq\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpSeq\"]"
        },
        "index": {
          "description": "Combine two picklers sequentially If the first fails during unpickling the whole unpickler fails",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpSeq",
          "normalized": "(a-\u003eb)-\u003ePU b-\u003e(b-\u003ePU a)-\u003ePU a",
          "package": "hxt",
          "partial": "Seq",
          "signature": "(b-\u003ea)-\u003ePU a-\u003e(a-\u003ePU b)-\u003ePU b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst apply a fixed pickler/unpickler, then a 2. one\n\u003c/p\u003e\u003cp\u003eIf the first fails during unpickling, the whole pickler fails.\n This can be used to check some properties of the input, e.g. whether\n a given fixed attribute or a namespace declaration exists (\u003ccode\u003e\u003ca\u003expAddFixedAttr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003expAddNSDecl\u003c/a\u003e\u003c/code\u003e)\n or to filter the input, e.g. to ignore some elements or attributes (\u003ccode\u003e\u003ca\u003expFilterCont\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003expFilterAttr\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eWhen pickling, this can be used to insert some fixed XML pieces, e.g. namespace declarations,\n class attributes or other stuff.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpSeq'",
          "package": "hxt",
          "signature": "PU () -\u003e PU a -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpSeq%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpSeq-39-\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpSeq-39-\"]"
        },
        "index": {
          "description": "First apply fixed pickler unpickler then one If the first fails during unpickling the whole pickler fails This can be used to check some properties of the input e.g whether given fixed attribute or namespace declaration exists xpAddFixedAttr xpAddNSDecl or to filter the input e.g to ignore some elements or attributes xpFilterCont xpFilterAttr When pickling this can be used to insert some fixed XML pieces e.g namespace declarations class attributes or other stuff",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpSeq'",
          "normalized": "PU()-\u003ePU a-\u003ePU a",
          "package": "hxt",
          "partial": "Seq'",
          "signature": "PU()-\u003ePU a-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpSeq-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle a string into an XML text node\n\u003c/p\u003e\u003cp\u003eOne of the most often used primitive picklers. Attention:\n For pickling empty strings use \u003ccode\u003e\u003ca\u003expText0\u003c/a\u003e\u003c/code\u003e. If the text has a more\n specific datatype than xsd:string, use \u003ccode\u003e\u003ca\u003expTextDT\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpText",
          "package": "hxt",
          "signature": "PU String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpText",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpText\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpText\"]"
        },
        "index": {
          "description": "Pickle string into an XML text node One of the most often used primitive picklers Attention For pickling empty strings use xpText0 If the text has more specific datatype than xsd string use xpTextDT",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpText",
          "package": "hxt",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle a possibly empty string into an XML node.\n\u003c/p\u003e\u003cp\u003eMust be used in all places, where empty strings are legal values.\n If the content of an element can be an empty string, this string disapears\n during storing the DOM into a document and reparse the document.\n So the empty text node becomes nothing, and the pickler must deliver an empty string,\n if there is no text node in the document.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpText0",
          "package": "hxt",
          "signature": "PU String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpText0",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpText0\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpText0\"]"
        },
        "index": {
          "description": "Pickle possibly empty string into an XML node Must be used in all places where empty strings are legal values If the content of an element can be an empty string this string disapears during storing the DOM into document and reparse the document So the empty text node becomes nothing and the pickler must deliver an empty string if there is no text node in the document",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpText0",
          "package": "hxt",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpText0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle a possibly empty string with a datatype description into an XML node.\n\u003c/p\u003e\u003cp\u003eLike \u003ccode\u003e\u003ca\u003expText0\u003c/a\u003e\u003c/code\u003e but with extra Parameter for datatype description as in \u003ccode\u003e\u003ca\u003expTextDT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpText0DT",
          "package": "hxt",
          "signature": "Schema -\u003e PU String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpText0DT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpText0DT\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpText0DT\"]"
        },
        "index": {
          "description": "Pickle possibly empty string with datatype description into an XML node Like xpText0 but with extra Parameter for datatype description as in xpTextDT",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpText0DT",
          "normalized": "Schema-\u003ePU String",
          "package": "hxt",
          "partial": "Text DT",
          "signature": "Schema-\u003ePU String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpText0DT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA text attribute.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpTextAttr",
          "package": "hxt",
          "signature": "String -\u003e PU String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpTextAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTextAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpTextAttr\"]"
        },
        "index": {
          "description": "text attribute",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpTextAttr",
          "normalized": "String-\u003ePU String",
          "package": "hxt",
          "partial": "Text Attr",
          "signature": "String-\u003ePU String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTextAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle a string into an XML text node\n\u003c/p\u003e\u003cp\u003eText pickler with a description of the structure of the text\n by a schema. A schema for a data type can be defined by \u003ccode\u003e\u003ca\u003escDT\u003c/a\u003e\u003c/code\u003e.\n In \u003ccode\u003e\u003ca\u003eSchema\u003c/a\u003e\u003c/code\u003e there are some more functions for creating\n simple datatype descriptions.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpTextDT",
          "package": "hxt",
          "signature": "Schema -\u003e PU String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpTextDT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTextDT\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpTextDT\"]"
        },
        "index": {
          "description": "Pickle string into an XML text node Text pickler with description of the structure of the text by schema schema for data type can be defined by scDT In Schema there are some more functions for creating simple datatype descriptions",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpTextDT",
          "normalized": "Schema-\u003ePU String",
          "package": "hxt",
          "partial": "Text DT",
          "signature": "Schema-\u003ePU String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTextDT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle an XmlTree by just adding it\n\u003c/p\u003e\u003cp\u003eUsefull for components of type XmlTree in other data structures\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpTree",
          "package": "hxt",
          "signature": "PU XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTree\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpTree\"]"
        },
        "index": {
          "description": "Pickle an XmlTree by just adding it Usefull for components of type XmlTree in other data structures",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpTree",
          "package": "hxt",
          "partial": "Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle a whole list of XmlTrees by just adding the list, unpickle is done by taking all element contents.\n\u003c/p\u003e\u003cp\u003eThis pickler should always be combined with \u003ccode\u003e\u003ca\u003expElem\u003c/a\u003e\u003c/code\u003e for taking the whole contents of an element.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpTrees",
          "package": "hxt",
          "signature": "PU [XmlTree]",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpTrees",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTrees\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpTrees\"]"
        },
        "index": {
          "description": "Pickle whole list of XmlTrees by just adding the list unpickle is done by taking all element contents This pickler should always be combined with xpElem for taking the whole contents of an element",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpTrees",
          "normalized": "PU[XmlTree]",
          "package": "hxt",
          "partial": "Trees",
          "signature": "PU[XmlTree]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003expPair\u003c/a\u003e\u003c/code\u003e but for triples\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpTriple",
          "package": "hxt",
          "signature": "PU a -\u003e PU b -\u003e PU c -\u003e PU (a, b, c)",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpTriple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTriple\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpTriple\"]"
        },
        "index": {
          "description": "Like xpPair but for triples",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpTriple",
          "normalized": "PU a-\u003ePU b-\u003ePU c-\u003ePU(a,b,c)",
          "package": "hxt",
          "partial": "Triple",
          "signature": "PU a-\u003ePU b-\u003ePU c-\u003ePU(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunit pickler\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpUnit",
          "package": "hxt",
          "signature": "PU ()",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpUnit\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpUnit\"]"
        },
        "index": {
          "description": "unit pickler",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpUnit",
          "normalized": "PU()",
          "package": "hxt",
          "partial": "Unit",
          "signature": "PU()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap value into another domain and apply pickler there\n\u003c/p\u003e\u003cp\u003eOne of the most often used picklers.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpWrap",
          "package": "hxt",
          "signature": "(a -\u003e b, b -\u003e a) -\u003e PU a -\u003e PU b",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpWrap",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpWrap\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpWrap\"]"
        },
        "index": {
          "description": "map value into another domain and apply pickler there One of the most often used picklers",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpWrap",
          "normalized": "(a-\u003eb,b-\u003ea)-\u003ePU a-\u003ePU b",
          "package": "hxt",
          "partial": "Wrap",
          "signature": "(a-\u003eb,b-\u003ea)-\u003ePU a-\u003ePU b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003expWrap\u003c/a\u003e\u003c/code\u003e, but if the inverse mapping is undefined, the unpickler fails\n\u003c/p\u003e\u003cp\u003eMap a value into another domain. If the inverse mapping is\n undefined, the unpickler fails with an error message in the Left component\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpWrapEither",
          "package": "hxt",
          "signature": "(a -\u003e Either String b, b -\u003e a) -\u003e PU a -\u003e PU b",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpWrapEither",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpWrapEither\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpWrapEither\"]"
        },
        "index": {
          "description": "like xpWrap but if the inverse mapping is undefined the unpickler fails Map value into another domain If the inverse mapping is undefined the unpickler fails with an error message in the Left component",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpWrapEither",
          "normalized": "(a-\u003eEither String b,b-\u003ea)-\u003ePU a-\u003ePU b",
          "package": "hxt",
          "partial": "Wrap Either",
          "signature": "(a-\u003eEither String b,b-\u003ea)-\u003ePU a-\u003ePU b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpWrapEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003expWrap\u003c/a\u003e\u003c/code\u003e, but if the inverse mapping is undefined, the unpickler fails\n\u003c/p\u003e\u003cp\u003eMap a value into another domain. If the inverse mapping is\n undefined (Nothing), the unpickler fails\n\u003c/p\u003e\u003cp\u003eDeprecated: Use xpWrapEither, this gives better error messages\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpWrapMaybe",
          "package": "hxt",
          "signature": "(a -\u003e Maybe b, b -\u003e a) -\u003e PU a -\u003e PU b",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpWrapMaybe",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpWrapMaybe\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpWrapMaybe\"]"
        },
        "index": {
          "description": "like xpWrap but if the inverse mapping is undefined the unpickler fails Map value into another domain If the inverse mapping is undefined Nothing the unpickler fails Deprecated Use xpWrapEither this gives better error messages",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpWrapMaybe",
          "normalized": "(a-\u003eMaybe b,b-\u003ea)-\u003ePU a-\u003ePU b",
          "package": "hxt",
          "partial": "Wrap Maybe",
          "signature": "(a-\u003eMaybe b,b-\u003ea)-\u003ePU a-\u003ePU b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpWrapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePickle a string representing XML contents by inserting the tree representation into the XML document.\n\u003c/p\u003e\u003cp\u003eUnpickling is done by converting the contents with\n \u003ccode\u003e\u003ca\u003exshowEscapeXml\u003c/a\u003e\u003c/code\u003e into a string,\n this function will escape all XML special chars, such that pickling the value back becomes save.\n Pickling is done with \u003ccode\u003e\u003ca\u003exread\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpXmlText",
          "package": "hxt",
          "signature": "PU String",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpXmlText",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpXmlText\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpXmlText\"]"
        },
        "index": {
          "description": "Pickle string representing XML contents by inserting the tree representation into the XML document Unpickling is done by converting the contents with xshowEscapeXml into string this function will escape all XML special chars such that pickling the value back becomes save Pickling is done with xread",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpXmlText",
          "package": "hxt",
          "partial": "Xml Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpXmlText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe zero pickler\n\u003c/p\u003e\u003cp\u003eEncodes nothing, fails always during unpickling\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.Pickle.Xml\",\"Text.XML.HXT.Arrow.Pickle\"]",
          "name": "xpZero",
          "package": "hxt",
          "signature": "String -\u003e PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpZero",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpZero\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpZero\"]"
        },
        "index": {
          "description": "The zero pickler Encodes nothing fails always during unpickling",
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpZero",
          "normalized": "String-\u003ePU a",
          "package": "hxt",
          "partial": "Zero",
          "signature": "String-\u003ePU a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpickle",
          "package": "hxt",
          "signature": "PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpickle",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle Xml",
          "module": "Text.XML.HXT.Arrow.Pickle.Xml",
          "name": "xpickle",
          "package": "hxt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle-Xml.html#v:xpickle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePickler functions for converting between user defined data types\nand XmlTree data. Usefull for persistent storage and retreival\nof arbitray data as XML documents\n\u003c/p\u003e\u003cp\u003eThis module is an adaptation of the pickler combinators\ndeveloped by Andrew Kennedy\n( http://research.microsoft.com/~akenn/fun/picklercombinators.pdf )\n\u003c/p\u003e\u003cp\u003eThe difference to Kennedys approach is that the target is not\na list of Chars but a list of XmlTrees. The basic picklers will\nconvert data into XML text nodes. New are the picklers for\ncreating elements and attributes.\n\u003c/p\u003e\u003cp\u003eOne extension was neccessary: The unpickling may fail.\nTherefore the unpickler has a Maybe result type.\nFailure is used to unpickle optional elements\n(Maybe data) and lists of arbitray length\n\u003c/p\u003e\u003cp\u003eThere is an example program demonstrating the use\nof the picklers for a none trivial data structure.\n(see \"examples/arrows/pickle\" directory)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "Pickle",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html",
          "type": "module"
        },
        "index": {
          "description": "Pickler functions for converting between user defined data types and XmlTree data Usefull for persistent storage and retreival of arbitray data as XML documents This module is an adaptation of the pickler combinators developed by Andrew Kennedy http research.microsoft.com akenn fun picklercombinators.pdf The difference to Kennedys approach is that the target is not list of Chars but list of XmlTrees The basic picklers will convert data into XML text nodes New are the picklers for creating elements and attributes One extension was neccessary The unpickling may fail Therefore the unpickler has Maybe result type Failure is used to unpickle optional elements Maybe data and lists of arbitray length There is an example program demonstrating the use of the picklers for none trivial data structure see examples arrows pickle directory",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "Pickle",
          "package": "hxt",
          "partial": "Pickle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "DataTypeDescr",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#DataTypeDescr",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "DataTypeDescr",
          "package": "hxt",
          "partial": "Data Type Descr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#t:DataTypeDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "PU",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#PU",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "PU",
          "package": "hxt",
          "partial": "PU",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#t:PU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe datatype for modelling the structure of an\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "Schema",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schema",
          "type": "data"
        },
        "index": {
          "description": "The datatype for modelling the structure of an",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "Schema",
          "package": "hxt",
          "partial": "Schema",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#t:Schema"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "Schemas",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Schema.html#Schemas",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "Schemas",
          "package": "hxt",
          "partial": "Schemas",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#t:Schemas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class for overloading \u003ccode\u003e\u003ca\u003expickle\u003c/a\u003e\u003c/code\u003e, the default pickler\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "XmlPickler",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#XmlPickler",
          "type": "class"
        },
        "index": {
          "description": "The class for overloading xpickle the default pickler",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "XmlPickler",
          "package": "hxt",
          "partial": "Xml Pickler",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#t:XmlPickler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOption for generating and adding DTD when document is pickled\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "a_addDTD",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#a_addDTD",
          "type": "function"
        },
        "index": {
          "description": "Option for generating and adding DTD when document is pickled",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "a_addDTD",
          "package": "hxt",
          "partial": "DTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:a_addDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn arrow for checking picklers\n\u003c/p\u003e\u003cp\u003eA value is transformed into an XML document by a given pickler,\n the associated DTD is extracted from the pickler and checked,\n the document including the DTD is tranlated into a string,\n this string is read and validated against the included DTD,\n and unpickled.\n The last step is the equality with the input.\n\u003c/p\u003e\u003cp\u003eIf the check succeeds, the arrow works like this, else it fails.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "checkPickler",
          "package": "hxt",
          "signature": "PU a -\u003e IOStateArrow s a a",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#checkPickler",
          "type": "function"
        },
        "index": {
          "description": "An arrow for checking picklers value is transformed into an XML document by given pickler the associated DTD is extracted from the pickler and checked the document including the DTD is tranlated into string this string is read and validated against the included DTD and unpickled The last step is the equality with the input If the check succeeds the arrow works like this else it fails",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "checkPickler",
          "normalized": "PU a-\u003eIOStateArrow b a a",
          "package": "hxt",
          "partial": "Pickler",
          "signature": "PU a-\u003eIOStateArrow s a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:checkPickler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the associated DTD of a pickler\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "thePicklerDTD",
          "package": "hxt",
          "signature": "PU b -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#thePicklerDTD",
          "type": "function"
        },
        "index": {
          "description": "Compute the associated DTD of pickler",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "thePicklerDTD",
          "normalized": "PU a-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Pickler DTD",
          "signature": "PU b-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:thePicklerDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickle",
          "package": "hxt",
          "signature": "PU a",
          "source": "src/Text-XML-HXT-Arrow-Pickle-Xml.html#xpickle",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickle",
          "package": "hxt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpickle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arrow for generating the DTD out of a pickler\n\u003c/p\u003e\u003cp\u003eA DTD is generated from a pickler and check for consistency.\n Errors concerning the DTD are issued.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleDTD",
          "package": "hxt",
          "signature": "PU b -\u003e IOStateArrow s b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#xpickleDTD",
          "type": "function"
        },
        "index": {
          "description": "The arrow for generating the DTD out of pickler DTD is generated from pickler and check for consistency Errors concerning the DTD are issued",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleDTD",
          "normalized": "PU a-\u003eIOStateArrow b a XmlTree",
          "package": "hxt",
          "partial": "DTD",
          "signature": "PU b-\u003eIOStateArrow s b XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpickleDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estore an arbitray value in a persistent XML document\n\u003c/p\u003e\u003cp\u003eThe pickler converts a value into an XML tree, this is written out with\n \u003ccode\u003e\u003ca\u003ewriteDocument\u003c/a\u003e\u003c/code\u003e. The option list is passed to \u003ccode\u003e\u003ca\u003ewriteDocument\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eAn option evaluated by this arrow is \u003ccode\u003e\u003ca\u003ea_addDTD\u003c/a\u003e\u003c/code\u003e.\n If \u003ccode\u003e\u003ca\u003ea_addDTD\u003c/a\u003e\u003c/code\u003e is set (\u003ccode\u003e\u003ca\u003ev_1\u003c/a\u003e\u003c/code\u003e), the pickler DTD is added as an inline DTD into the document.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleDocument",
          "package": "hxt",
          "signature": "PU a -\u003e SysConfigList -\u003e String -\u003e IOStateArrow s a XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#xpickleDocument",
          "type": "function"
        },
        "index": {
          "description": "store an arbitray value in persistent XML document The pickler converts value into an XML tree this is written out with writeDocument The option list is passed to writeDocument An option evaluated by this arrow is addDTD If addDTD is set the pickler DTD is added as an inline DTD into the document",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleDocument",
          "normalized": "PU a-\u003eSysConfigList-\u003eString-\u003eIOStateArrow b a XmlTree",
          "package": "hxt",
          "partial": "Document",
          "signature": "PU a-\u003eSysConfigList-\u003eString-\u003eIOStateArrow s a XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpickleDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arrow version of the pickler function\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleVal",
          "package": "hxt",
          "signature": "PU b -\u003e a b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#xpickleVal",
          "type": "function"
        },
        "index": {
          "description": "The arrow version of the pickler function",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleVal",
          "normalized": "PU a-\u003eb a XmlTree",
          "package": "hxt",
          "partial": "Val",
          "signature": "PU b-\u003ea b XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpickleVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite out the DTD generated out of a pickler. Calls \u003ccode\u003expicklerDTD\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleWriteDTD",
          "package": "hxt",
          "signature": "PU b -\u003e SysConfigList -\u003e String -\u003e IOStateArrow s b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#xpickleWriteDTD",
          "type": "function"
        },
        "index": {
          "description": "Write out the DTD generated out of pickler Calls xpicklerDTD",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xpickleWriteDTD",
          "normalized": "PU a-\u003eSysConfigList-\u003eString-\u003eIOStateArrow b a XmlTree",
          "package": "hxt",
          "partial": "Write DTD",
          "signature": "PU b-\u003eSysConfigList-\u003eString-\u003eIOStateArrow s b XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xpickleWriteDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread an arbitray value from an XML document\n\u003c/p\u003e\u003cp\u003eThe document is read with \u003ccode\u003e\u003ca\u003ereadDocument\u003c/a\u003e\u003c/code\u003e. Options are passed\n to \u003ccode\u003e\u003ca\u003ereadDocument\u003c/a\u003e\u003c/code\u003e. The conversion from XmlTree is done with the\n pickler.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e xpickleDocument xp al dest \u003e\u003e\u003e xunpickleDocument xp al' dest \u003c/code\u003e is the identity arrow\n when applied with the appropriate options. When during pickling indentation is switched on,\n the whitespace must be removed during unpickling.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xunpickleDocument",
          "package": "hxt",
          "signature": "PU a -\u003e SysConfigList -\u003e String -\u003e IOStateArrow s b a",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#xunpickleDocument",
          "type": "function"
        },
        "index": {
          "description": "read an arbitray value from an XML document The document is read with readDocument Options are passed to readDocument The conversion from XmlTree is done with the pickler xpickleDocument xp al dest xunpickleDocument xp al dest is the identity arrow when applied with the appropriate options When during pickling indentation is switched on the whitespace must be removed during unpickling",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xunpickleDocument",
          "normalized": "PU a-\u003eSysConfigList-\u003eString-\u003eIOStateArrow b c a",
          "package": "hxt",
          "partial": "Document",
          "signature": "PU a-\u003eSysConfigList-\u003eString-\u003eIOStateArrow s b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xunpickleDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arrow version of the unpickler function\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xunpickleVal",
          "package": "hxt",
          "signature": "PU b -\u003e IOStateArrow s XmlTree b",
          "source": "src/Text-XML-HXT-Arrow-Pickle.html#xunpickleVal",
          "type": "function"
        },
        "index": {
          "description": "The arrow version of the unpickler function",
          "hierarchy": "Text XML HXT Arrow Pickle",
          "module": "Text.XML.HXT.Arrow.Pickle",
          "name": "xunpickleVal",
          "normalized": "PU a-\u003eIOStateArrow b XmlTree a",
          "package": "hxt",
          "partial": "Val",
          "signature": "PU b-\u003eIOStateArrow s XmlTree b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-Pickle.html#v:xunpickleVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompound arrows for reading, parsing, validating and writing XML documents\n\u003c/p\u003e\u003cp\u003eAll arrows use IO and a global state for options, errorhandling, ...\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "ProcessDocument",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html",
          "type": "module"
        },
        "index": {
          "description": "Compound arrows for reading parsing validating and writing XML documents All arrows use IO and global state for options errorhandling",
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "ProcessDocument",
          "package": "hxt",
          "partial": "Process Document",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "andValidateNamespaces",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html#andValidateNamespaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "andValidateNamespaces",
          "package": "hxt",
          "partial": "Validate Namespaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#v:andValidateNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a new document root, adds all options\n   as attributes to the document root and calls \u003ccode\u003e\u003ca\u003egetXmlContents\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the document name is the empty string, the document will be read\n   from standard input.\n\u003c/p\u003e\u003cp\u003eFor supported protocols see \u003ccode\u003e\u003ca\u003egetXmlContents\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "getDocumentContents",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html#getDocumentContents",
          "type": "function"
        },
        "index": {
          "description": "creates new document root adds all options as attributes to the document root and calls getXmlContents If the document name is the empty string the document will be read from standard input For supported protocols see getXmlContents",
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "getDocumentContents",
          "normalized": "String-\u003eIOStateArrow a b XmlTree",
          "package": "hxt",
          "partial": "Document Contents",
          "signature": "String-\u003eIOStateArrow s b XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#v:getDocumentContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHTML parser\n\u003c/p\u003e\u003cp\u003eInput tree must be a root tree with a text tree as child containing the document to be parsed.\nThe parser tries to parse everything as HTML, if the HTML document is not wellformed XML or if\nerrors occur, warnings are generated. The warnings can be issued, or suppressed.\n\u003c/p\u003e\u003cp\u003eExample: \u003ccode\u003e parseHtmlDocument True \u003c/code\u003e : parse document and issue warnings\n\u003c/p\u003e\u003cp\u003eThis parser is useful for applications like web crawlers, where the pages may contain\narbitray errors, but the application is only interested in parts of the document, e.g. the plain text.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "parseHtmlDocument",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html#parseHtmlDocument",
          "type": "function"
        },
        "index": {
          "description": "HTML parser Input tree must be root tree with text tree as child containing the document to be parsed The parser tries to parse everything as HTML if the HTML document is not wellformed XML or if errors occur warnings are generated The warnings can be issued or suppressed Example parseHtmlDocument True parse document and issue warnings This parser is useful for applications like web crawlers where the pages may contain arbitray errors but the application is only interested in parts of the document e.g the plain text",
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "parseHtmlDocument",
          "package": "hxt",
          "partial": "Html Document",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#v:parseHtmlDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML parser\n\u003c/p\u003e\u003cp\u003eInput tree must be a root tree with a text tree as child containing the document to be parsed.\nThe parser generates from the input string a tree of a wellformed XML document,\nprocesses the DTD (parameter substitution, conditional DTD parts, ...) and\nsubstitutes all general entity references. Next step is character reference substitution.\nLast step is the document validation.\nValidation can be controlled by an extra parameter.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e parseXmlDocument True    -- parse and validate document\n\n parseXmlDocument False   -- only parse document, don't validate\n\u003c/pre\u003e\u003cp\u003eThis parser is useful for applications processing correct XML documents.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "parseXmlDocument",
          "package": "hxt",
          "signature": "Bool -\u003e Bool -\u003e Bool -\u003e Bool -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html#parseXmlDocument",
          "type": "function"
        },
        "index": {
          "description": "XML parser Input tree must be root tree with text tree as child containing the document to be parsed The parser generates from the input string tree of wellformed XML document processes the DTD parameter substitution conditional DTD parts and substitutes all general entity references Next step is character reference substitution Last step is the document validation Validation can be controlled by an extra parameter Example parseXmlDocument True parse and validate document parseXmlDocument False only parse document don validate This parser is useful for applications processing correct XML documents",
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "parseXmlDocument",
          "normalized": "Bool-\u003eBool-\u003eBool-\u003eBool-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Xml Document",
          "signature": "Bool-\u003eBool-\u003eBool-\u003eBool-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#v:parseXmlDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "parseXmlDocumentWithExpat",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html#parseXmlDocumentWithExpat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "parseXmlDocumentWithExpat",
          "package": "hxt",
          "partial": "Xml Document With Expat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#v:parseXmlDocumentWithExpat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace propagation\n\u003c/p\u003e\u003cp\u003eInput must be a complete document tree. The namespace declarations\nare evaluated and all element and attribute names are processed by\nsplitting the name into prefix, local part and namespace URI.\n\u003c/p\u003e\u003cp\u003eNaames are checked with respect to the XML namespace definition\n\u003c/p\u003e\u003cp\u003eIf no error was found, result is the unchanged input tree,\nelse the error status is set in the list of attributes\nof the root node \"/\" and the document content is removed from the tree.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "propagateAndValidateNamespaces",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html#propagateAndValidateNamespaces",
          "type": "function"
        },
        "index": {
          "description": "Namespace propagation Input must be complete document tree The namespace declarations are evaluated and all element and attribute names are processed by splitting the name into prefix local part and namespace URI Naames are checked with respect to the XML namespace definition If no error was found result is the unchanged input tree else the error status is set in the list of attributes of the root node and the document content is removed from the tree",
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "propagateAndValidateNamespaces",
          "package": "hxt",
          "partial": "And Validate Namespaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#v:propagateAndValidateNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDocument validation\n\u003c/p\u003e\u003cp\u003eInput must be a complete document tree. The document\nis validated with respect to the DTD spec.\nOnly useful for XML documents containing a DTD.\n\u003c/p\u003e\u003cp\u003eIf the document is valid, it is transformed with respect to the DTD,\nnormalization of attribute values, adding default values, sorting attributes by name,...\n\u003c/p\u003e\u003cp\u003eIf no error was found, result is the normalized tree,\nelse the error status is set in the list of attributes\nof the root node \"/\" and the document content is removed from the tree.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "validateDocument",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ProcessDocument.html#validateDocument",
          "type": "function"
        },
        "index": {
          "description": "Document validation Input must be complete document tree The document is validated with respect to the DTD spec Only useful for XML documents containing DTD If the document is valid it is transformed with respect to the DTD normalization of attribute values adding default values sorting attributes by name If no error was found result is the normalized tree else the error status is set in the list of attributes of the root node and the document content is removed from the tree",
          "hierarchy": "Text XML HXT Arrow ProcessDocument",
          "module": "Text.XML.HXT.Arrow.ProcessDocument",
          "name": "validateDocument",
          "package": "hxt",
          "partial": "Document",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ProcessDocument.html#v:validateDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompound arrows for reading an XML/HTML document or an XML/HTML string\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "ReadDocument",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html",
          "type": "module"
        },
        "index": {
          "description": "Compound arrows for reading an XML HTML document or an XML HTML string",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "ReadDocument",
          "package": "hxt",
          "partial": "Read Document",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a string as HTML content, substitute all HTML entity refs and canonicalize tree.\n (substitute char refs, ...). Errors are ignored.\n\u003c/p\u003e\u003cp\u003eThis arrow delegates all work to the parseHtmlContent parser in module HtmlParser.\n\u003c/p\u003e\u003cp\u003eThis is a simpler version of \u003ccode\u003e\u003ca\u003ereadFromString\u003c/a\u003e\u003c/code\u003e without any options,\n but it does not run in the IO monad.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "hread",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#hread",
          "type": "function"
        },
        "index": {
          "description": "parse string as HTML content substitute all HTML entity refs and canonicalize tree substitute char refs Errors are ignored This arrow delegates all work to the parseHtmlContent parser in module HtmlParser This is simpler version of readFromString without any options but it does not run in the IO monad",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "hread",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:hread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike hread, but accepts a whole document, not a HTML content\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "hreadDoc",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#hreadDoc",
          "type": "function"
        },
        "index": {
          "description": "like hread but accepts whole document not HTML content",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "hreadDoc",
          "package": "hxt",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:hreadDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe main document input filter\n\u003c/p\u003e\u003cp\u003ethis filter can be configured by a list of configuration options,\na value of type \u003ccode\u003e\u003ca\u003eSysConfig\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003efor all available options see module \u003ccode\u003e\u003ca\u003eSystemConfig\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ewithValidate yes/no\u003c/code\u003e :\n  switch on/off DTD validation. Only for XML parsed documents, not for HTML parsing.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithSubstDTDEntities yes/no\u003c/code\u003e :\n  switch on/off entity substitution for general entities defined in DTD validation.\n  Default is \u003ccode\u003eyes\u003c/code\u003e.\n  Switching this option and the validation off can lead to faster parsing, in that case\n  reading the DTD documents is not longer necessary.\n  Only used with XML parsed documents, not with HTML parsing.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithSubstHTMLEntities yes/no\u003c/code\u003e :\n  switch on/off entity substitution for general entities defined in HTML validation.\n  Default is \u003ccode\u003eno\u003c/code\u003e.\n  Switching this option on and the validation and substDTDEntities off can lead to faster parsing,\n  in that case\n  reading the DTD documents is not longer necessary, HTML general entities are still substituted.\n  Only used with XML parsed documents, not with HTML parsing.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithParseHTML yes/no\u003c/code\u003e :\n  switch on HTML parsing.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithParseByMimeType yes/no\u003c/code\u003e :\n  select XML/HTML parser by document mime type.\n  text/xml and text/xhtml are parsed as XML, text/html as HTML.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithCheckNamespaces yes/no\u003c/code\u003e :\n  Switch on/off namespace propagation and checking\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithInputEncoding \u003cencoding-spec\u003e\u003c/code\u003e :\n  Set default encoding.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithTagSoup\u003c/code\u003e :\n  use light weight and lazy parser based on tagsoup lib.\n  This is only available when package hxt-tagsoup is installed and\n  the source contains an \u003ccode\u003eimport Text.XML.HXT.TagSoup\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithRelaxNG \u003cschema.rng\u003e\u003c/code\u003e :\n  validate document with Relax NG, the parameter is for the schema URI.\n  This implies using XML parser, no validation against DTD, and canonicalisation.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithCurl [\u003ccurl-option\u003e...]\u003c/code\u003e :\n  Use the libCurl binding for HTTP access.\n  This is only available when package hxt-curl is installed and\n  the source contains an \u003ccode\u003eimport Text.XML.HXT.Curl\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithHTTP [\u003chttp-option\u003e...]\u003c/code\u003e :\n  Use the Haskell HTTP package for HTTP access.\n  This is only available when package hxt-http is installed and\n  the source contains an \u003ccode\u003eimport Text.XML.HXT.HTTP\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e readDocument [] \"test.xml\"\n\u003c/pre\u003e\u003cp\u003ereads and validates a document \"test.xml\", no namespace propagation, only canonicalization is performed\n\u003c/p\u003e\u003cpre\u003e ...\n import Text.XML.HXT.Curl\n ...\n\n readDocument [ withValidate        no\n              , withInputEncoding   isoLatin1\n              , withParseByMimeType yes\n              , withCurl []\n              ] \"http://localhost/test.php\"\n\u003c/pre\u003e\u003cp\u003ereads document \"test.php\", parses it as HTML or XML depending on the mimetype given from the server, but without validation, default encoding \u003ccode\u003e\u003ca\u003eisoLatin1\u003c/a\u003e\u003c/code\u003e.\nHTTP access is done via libCurl.\n\u003c/p\u003e\u003cpre\u003e readDocument [ withParseHTML       yes\n              , withInputEncoding   isoLatin1\n              ] \"\"\n\u003c/pre\u003e\u003cp\u003ereads a HTML document from standard input, no validation is done when parsing HTML, default encoding is \u003ccode\u003e\u003ca\u003eisoLatin1\u003c/a\u003e\u003c/code\u003e,\n\u003c/p\u003e\u003cpre\u003e readDocument [ withInputEncoding  isoLatin1\n              , withValidate       no\n              , withMimeTypeFile   \"/etc/mime.types\"\n              , withStrictInput    yes\n              ] \"test.svg\"\n\u003c/pre\u003e\u003cp\u003ereads an SVG document from \"test.svg\", sets the mime type by looking in the system mimetype config file,\ndefault encoding is \u003ccode\u003e\u003ca\u003eisoLatin1\u003c/a\u003e\u003c/code\u003e,\n\u003c/p\u003e\u003cpre\u003e ...\n import Text.XML.HXT.Curl\n import Text.XML.HXT.TagSoup\n ...\n\n readDocument [ withParseHTML      yes\n              , withTagSoup\n              , withProxy          \"www-cache:3128\"\n              , withCurl           []\n              , withWarnings       no\n              ] \"http://www.haskell.org/\"\n\u003c/pre\u003e\u003cp\u003ereads Haskell homepage with HTML parser, ignoring any warnings\n(at the time of writing, there were some HTML errors),\nwith http access via libCurl interface\nand proxy \"www-cache\" at port 3128,\nparsing is done with tagsoup HTML parser.\nThis requires packages \"hxt-curl\" and \"hxt-tagsoup\" to be installed\n\u003c/p\u003e\u003cpre\u003e readDocument [ withValidate          yes\n              , withCheckNamespaces   yes\n              , withRemoveWS          yes\n              , withTrace             2\n              , withHTTP              []\n              ] \"http://www.w3c.org/\"\n\u003c/pre\u003e\u003cp\u003eread w3c home page (xhtml), validate and check namespaces, remove whitespace between tags,\ntrace activities with level 2.\nHTTP access is done with Haskell HTTP package\n\u003c/p\u003e\u003cpre\u003e readDocument [ withValidate          no\n              , withSubstDTDEntities  no\n              ...\n              ] \"http://www.w3c.org/\"\n\u003c/pre\u003e\u003cp\u003eread w3c home page (xhtml), but without accessing the DTD given in that document.\nOnly the predefined XML general entity refs are substituted.\n\u003c/p\u003e\u003cpre\u003e readDocument [ withValidate          no\n              , withSubstDTDEntities  no\n              , withSubstHTMLEntities yes\n              ...\n              ] \"http://www.w3c.org/\"\n\u003c/pre\u003e\u003cp\u003esame as above, but with substituion of all general entity refs defined in XHTML.\n\u003c/p\u003e\u003cp\u003efor minimal complete examples see \u003ccode\u003e\u003ca\u003ewriteDocument\u003c/a\u003e\u003c/code\u003e\nand \u003ccode\u003e\u003ca\u003erunX\u003c/a\u003e\u003c/code\u003e, the main starting point for running an XML arrow.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readDocument",
          "package": "hxt",
          "signature": "SysConfigList -\u003e String -\u003e IOStateArrow s b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#readDocument",
          "type": "function"
        },
        "index": {
          "description": "the main document input filter this filter can be configured by list of configuration options value of type SysConfig for all available options see module SystemConfig withValidate yes no switch on off DTD validation Only for XML parsed documents not for HTML parsing withSubstDTDEntities yes no switch on off entity substitution for general entities defined in DTD validation Default is yes Switching this option and the validation off can lead to faster parsing in that case reading the DTD documents is not longer necessary Only used with XML parsed documents not with HTML parsing withSubstHTMLEntities yes no switch on off entity substitution for general entities defined in HTML validation Default is no Switching this option on and the validation and substDTDEntities off can lead to faster parsing in that case reading the DTD documents is not longer necessary HTML general entities are still substituted Only used with XML parsed documents not with HTML parsing withParseHTML yes no switch on HTML parsing withParseByMimeType yes no select XML HTML parser by document mime type text xml and text xhtml are parsed as XML text html as HTML withCheckNamespaces yes no Switch on off namespace propagation and checking withInputEncoding encoding-spec Set default encoding withTagSoup use light weight and lazy parser based on tagsoup lib This is only available when package hxt-tagsoup is installed and the source contains an import Text.XML.HXT.TagSoup withRelaxNG schema.rng validate document with Relax NG the parameter is for the schema URI This implies using XML parser no validation against DTD and canonicalisation withCurl curl-option Use the libCurl binding for HTTP access This is only available when package hxt-curl is installed and the source contains an import Text.XML.HXT.Curl withHTTP http-option Use the Haskell HTTP package for HTTP access This is only available when package hxt-http is installed and the source contains an import Text.XML.HXT.HTTP examples readDocument test.xml reads and validates document test.xml no namespace propagation only canonicalization is performed import Text.XML.HXT.Curl readDocument withValidate no withInputEncoding isoLatin1 withParseByMimeType yes withCurl http localhost test.php reads document test.php parses it as HTML or XML depending on the mimetype given from the server but without validation default encoding isoLatin1 HTTP access is done via libCurl readDocument withParseHTML yes withInputEncoding isoLatin1 reads HTML document from standard input no validation is done when parsing HTML default encoding is isoLatin1 readDocument withInputEncoding isoLatin1 withValidate no withMimeTypeFile etc mime.types withStrictInput yes test.svg reads an SVG document from test.svg sets the mime type by looking in the system mimetype config file default encoding is isoLatin1 import Text.XML.HXT.Curl import Text.XML.HXT.TagSoup readDocument withParseHTML yes withTagSoup withProxy www-cache withCurl withWarnings no http www.haskell.org reads Haskell homepage with HTML parser ignoring any warnings at the time of writing there were some HTML errors with http access via libCurl interface and proxy www-cache at port parsing is done with tagsoup HTML parser This requires packages hxt-curl and hxt-tagsoup to be installed readDocument withValidate yes withCheckNamespaces yes withRemoveWS yes withTrace withHTTP http www.w3c.org read w3c home page xhtml validate and check namespaces remove whitespace between tags trace activities with level HTTP access is done with Haskell HTTP package readDocument withValidate no withSubstDTDEntities no http www.w3c.org read w3c home page xhtml but without accessing the DTD given in that document Only the predefined XML general entity refs are substituted readDocument withValidate no withSubstDTDEntities no withSubstHTMLEntities yes http www.w3c.org same as above but with substituion of all general entity refs defined in XHTML for minimal complete examples see writeDocument and runX the main starting point for running an XML arrow",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readDocument",
          "normalized": "SysConfigList-\u003eString-\u003eIOStateArrow a b XmlTree",
          "package": "hxt",
          "partial": "Document",
          "signature": "SysConfigList-\u003eString-\u003eIOStateArrow s b XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:readDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe arrow version of \u003ccode\u003e\u003ca\u003ereadDocument\u003c/a\u003e\u003c/code\u003e, the arrow input is the source URI\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readFromDocument",
          "package": "hxt",
          "signature": "SysConfigList -\u003e IOStateArrow s String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#readFromDocument",
          "type": "function"
        },
        "index": {
          "description": "the arrow version of readDocument the arrow input is the source URI",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readFromDocument",
          "normalized": "SysConfigList-\u003eIOStateArrow a String XmlTree",
          "package": "hxt",
          "partial": "From Document",
          "signature": "SysConfigList-\u003eIOStateArrow s String XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:readFromDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe arrow version of \u003ccode\u003e\u003ca\u003ereadString\u003c/a\u003e\u003c/code\u003e, the arrow input is the source URI\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readFromString",
          "package": "hxt",
          "signature": "SysConfigList -\u003e IOStateArrow s String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#readFromString",
          "type": "function"
        },
        "index": {
          "description": "the arrow version of readString the arrow input is the source URI",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readFromString",
          "normalized": "SysConfigList-\u003eIOStateArrow a String XmlTree",
          "package": "hxt",
          "partial": "From String",
          "signature": "SysConfigList-\u003eIOStateArrow s String XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:readFromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread a document that is stored in a normal Haskell String\n\u003c/p\u003e\u003cp\u003ethe same function as readDocument, but the parameter forms the input.\n All options available for \u003ccode\u003e\u003ca\u003ereadDocument\u003c/a\u003e\u003c/code\u003e are applicable for readString,\n except input encoding options.\n\u003c/p\u003e\u003cp\u003eEncoding: No decoding is done, the String argument is taken as Unicode string\n All decoding must be done before calling readString, even if the\n XML document contains an encoding spec.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readString",
          "package": "hxt",
          "signature": "SysConfigList -\u003e String -\u003e IOStateArrow s b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#readString",
          "type": "function"
        },
        "index": {
          "description": "read document that is stored in normal Haskell String the same function as readDocument but the parameter forms the input All options available for readDocument are applicable for readString except input encoding options Encoding No decoding is done the String argument is taken as Unicode string All decoding must be done before calling readString even if the XML document contains an encoding spec",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "readString",
          "normalized": "SysConfigList-\u003eString-\u003eIOStateArrow a b XmlTree",
          "package": "hxt",
          "partial": "String",
          "signature": "SysConfigList-\u003eString-\u003eIOStateArrow s b XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:readString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a string as XML CONTENT, (no xml decl or doctype decls are allowed),\n substitute all predefined XML entity refs and canonicalize tree\n This xread arrow delegates all work to the xread parser function in module XmlParsec\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "xread",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#xread",
          "type": "function"
        },
        "index": {
          "description": "parse string as XML CONTENT no xml decl or doctype decls are allowed substitute all predefined XML entity refs and canonicalize tree This xread arrow delegates all work to the xread parser function in module XmlParsec",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "xread",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:xread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea more general version of xread which\n parses a whole document including a prolog\n (xml decl, doctype decl) and processing\n instructions. Doctype decls remain uninterpreted,\n but are in the list of results trees.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "xreadDoc",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-ReadDocument.html#xreadDoc",
          "type": "function"
        },
        "index": {
          "description": "more general version of xread which parses whole document including prolog xml decl doctype decl and processing instructions Doctype decls remain uninterpreted but are in the list of results trees",
          "hierarchy": "Text XML HXT Arrow ReadDocument",
          "module": "Text.XML.HXT.Arrow.ReadDocument",
          "name": "xreadDoc",
          "package": "hxt",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html#v:xreadDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompound arrow for writing XML documents\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "WriteDocument",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-WriteDocument.html",
          "type": "module"
        },
        "index": {
          "description": "Compound arrow for writing XML documents",
          "hierarchy": "Text XML HXT Arrow WriteDocument",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "WriteDocument",
          "package": "hxt",
          "partial": "Write Document",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-WriteDocument.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindent and format output\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "prepareContents",
          "package": "hxt",
          "signature": "XIOSysState -\u003e (Bool -\u003e Bool -\u003e String -\u003e a XmlTree XmlTree) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-WriteDocument.html#prepareContents",
          "type": "function"
        },
        "index": {
          "description": "indent and format output",
          "hierarchy": "Text XML HXT Arrow WriteDocument",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "prepareContents",
          "normalized": "XIOSysState-\u003e(Bool-\u003eBool-\u003eString-\u003ea XmlTree XmlTree)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Contents",
          "signature": "XIOSysState-\u003e(Bool-\u003eBool-\u003eString-\u003ea XmlTree XmlTree)-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-WriteDocument.html#v:prepareContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe main filter for writing documents\n\u003c/p\u003e\u003cp\u003ethis filter can be configured by an option list like \u003ccode\u003e\u003ca\u003ereadDocument\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eusage: \u003ccode\u003e writeDocument optionList destination \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eif \u003ccode\u003e destination \u003c/code\u003e is the empty string or \"-\", stdout is used as output device\n\u003c/p\u003e\u003cp\u003efor available options see \u003ccode\u003e\u003ca\u003eSystemConfig\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003ewithOutputXML\u003c/code\u003e :\n (default) issue XML: quote special XML chars \u003e,\u003c,\",',& where neccessary\n                   add XML processing instruction\n                   and encode document with respect to output encoding,\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithOutputHTML\u003c/code\u003e :\n issue HTML: translate all special XML chars and all HTML chars with a corresponding entity reference\n into entity references. Do not generate empty elements, e.g. \u003ccode\u003e\u003ca\u003e.../\u003c/a\u003e\u003c/code\u003e for HTML elements, that are allowed\n to contain a none empty body. Result is for the example is \u003ccode\u003e\u003ca\u003e...\u003c/a\u003e\u003ca\u003e/script\u003c/a\u003e\u003c/code\u003e.\n The short form introduces trouble in various browsers.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithOutputXHTML\u003c/code\u003e :\n same as \u003ccode\u003ewithOutputHTML\u003c/code\u003e, but all none ASCII chars are substituted by char references.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithOutputPLAIN\u003c/code\u003e :\n Do not substitute any chars. This is useful when generating something else than XML/HTML, e.g. Haskell source code.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithXmlPi yes/no\u003c/code\u003e :\n Add a \u003ccode\u003e\u003ca\u003eversion=... encoding=... ?\u003c/a\u003e\u003c/code\u003e processing instruction to the beginning of the document.\n Default is yes.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithAddDefaultDTD\u003c/code\u003e :\n  if the document to be written was build by reading another document containing a Document Type Declaration,\n  this DTD is inserted into the output document (default: no insert)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithShowTree yes/no\u003c/code\u003e :\n  show DOM tree representation of document (for debugging)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ewithShowHaskell yes/no\u003c/code\u003e :\n  show Haskell representaion of document (for debugging)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ea minimal main program for copying a document\n has the following structure:\n\u003c/p\u003e\u003cpre\u003e module Main\n where\n\n import Text.XML.HXT.Core\n\n main        :: IO ()\n main\n     = do\n       runX ( readDocument  [] \"hello.xml\"\n              \u003e\u003e\u003e\n              writeDocument [] \"bye.xml\"\n            )\n       return ()\n\u003c/pre\u003e\u003cp\u003ean example for copying a document from the web to standard output with global trace level 1, input trace level 2,\noutput encoding isoLatin1,\nand evaluation of\nerror code is:\n\u003c/p\u003e\u003cpre\u003e module Main\n where\n\n import Text.XML.HXT.Core\n import Text.XML.HXT.Curl\n -- or\n -- import Text.XML.HXT.HTTP\n import System.Exit\n\n main        :: IO ()\n main\n     = do\n       [rc] \u003c- runX\n               ( configSysVars [ withTrace 1          -- set the defaults for all read-,\n                               , withCurl []          -- write- and other operations\n                                 -- or withHTTP []\n                               ]\n                 \u003e\u003e\u003e\n                 readDocument  [ withTrace     2      -- use these additional\n                               , withParseHTML yes    -- options only for this read\n                               ]\n                               \"http://www.haskell.org/\"\n                 \u003e\u003e\u003e\n                 writeDocument [ withOutputEncoding isoLatin1\n                               ]\n                               \"\"                     -- output to stdout\n                 \u003e\u003e\u003e\n                 getErrStatus\n               )\n       exitWith ( if rc \u003e= c_err\n                  then ExitFailure 1\n                  else ExitSuccess\n                )\n\u003c/pre\u003e",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "writeDocument",
          "package": "hxt",
          "signature": "SysConfigList -\u003e String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-WriteDocument.html#writeDocument",
          "type": "function"
        },
        "index": {
          "description": "the main filter for writing documents this filter can be configured by an option list like readDocument usage writeDocument optionList destination if destination is the empty string or stdout is used as output device for available options see SystemConfig withOutputXML default issue XML quote special XML chars where neccessary add XML processing instruction and encode document with respect to output encoding withOutputHTML issue HTML translate all special XML chars and all HTML chars with corresponding entity reference into entity references Do not generate empty elements e.g for HTML elements that are allowed to contain none empty body Result is for the example is script The short form introduces trouble in various browsers withOutputXHTML same as withOutputHTML but all none ASCII chars are substituted by char references withOutputPLAIN Do not substitute any chars This is useful when generating something else than XML HTML e.g Haskell source code withXmlPi yes no Add version encoding processing instruction to the beginning of the document Default is yes withAddDefaultDTD if the document to be written was build by reading another document containing Document Type Declaration this DTD is inserted into the output document default no insert withShowTree yes no show DOM tree representation of document for debugging withShowHaskell yes no show Haskell representaion of document for debugging minimal main program for copying document has the following structure module Main where import Text.XML.HXT.Core main IO main do runX readDocument hello.xml writeDocument bye.xml return an example for copying document from the web to standard output with global trace level input trace level output encoding isoLatin1 and evaluation of error code is module Main where import Text.XML.HXT.Core import Text.XML.HXT.Curl or import Text.XML.HXT.HTTP import System.Exit main IO main do rc runX configSysVars withTrace set the defaults for all read withCurl write and other operations or withHTTP readDocument withTrace use these additional withParseHTML yes options only for this read http www.haskell.org writeDocument withOutputEncoding isoLatin1 output to stdout getErrStatus exitWith if rc err then ExitFailure else ExitSuccess",
          "hierarchy": "Text XML HXT Arrow WriteDocument",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "writeDocument",
          "normalized": "SysConfigList-\u003eString-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Document",
          "signature": "SysConfigList-\u003eString-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-WriteDocument.html#v:writeDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "writeDocument'",
          "package": "hxt",
          "signature": "Bool -\u003e String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-WriteDocument.html#writeDocument%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow WriteDocument",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "writeDocument'",
          "normalized": "Bool-\u003eString-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Document'",
          "signature": "Bool-\u003eString-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-WriteDocument.html#v:writeDocument-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a document into a string. Formating is done the same way\n and with the same options as in \u003ccode\u003e\u003ca\u003ewriteDocument\u003c/a\u003e\u003c/code\u003e. Default output encoding is\n no encoding, that means the result is a normal unicode encode haskell string.\n The default may be overwritten with the \u003ccode\u003e\u003ca\u003ewithOutputEncoding\u003c/a\u003e\u003c/code\u003e option.\n The XML PI can be suppressed by the \u003ccode\u003e\u003ca\u003ea_no_xml_pi\u003c/a\u003e\u003c/code\u003e option.\n\u003c/p\u003e\u003cp\u003eThis arrow fails, when the encoding scheme is not supported.\n The arrow is pure, it does not run in the IO monad.\n The XML PI is suppressed, if not explicitly turned on with an\n option \u003ccode\u003e (a_no_xml_pi, v_0) \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "writeDocumentToString",
          "package": "hxt",
          "signature": "SysConfigList -\u003e a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-WriteDocument.html#writeDocumentToString",
          "type": "function"
        },
        "index": {
          "description": "Convert document into string Formating is done the same way and with the same options as in writeDocument Default output encoding is no encoding that means the result is normal unicode encode haskell string The default may be overwritten with the withOutputEncoding option The XML PI can be suppressed by the no xml pi option This arrow fails when the encoding scheme is not supported The arrow is pure it does not run in the IO monad The XML PI is suppressed if not explicitly turned on with an option no xml pi",
          "hierarchy": "Text XML HXT Arrow WriteDocument",
          "module": "Text.XML.HXT.Arrow.WriteDocument",
          "name": "writeDocumentToString",
          "normalized": "SysConfigList-\u003ea XmlTree String",
          "package": "hxt",
          "partial": "Document To String",
          "signature": "SysConfigList-\u003ea XmlTree String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-WriteDocument.html#v:writeDocumentToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic arrows for processing XML documents\n\u003c/p\u003e\u003cp\u003eAll arrows use IO and a global state for options, errorhandling, ...\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "XmlArrow",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html",
          "type": "module"
        },
        "index": {
          "description": "Basic arrows for processing XML documents All arrows use IO and global state for options errorhandling",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "XmlArrow",
          "package": "hxt",
          "partial": "Xml Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDocument Type Definition arrows\n\u003c/p\u003e\u003cp\u003eThese are separated, because they are not needed for document processing,\nonly when processing the DTD, e.g. for generating access funtions for the toolbox\nfrom a DTD (se example DTDtoHaskell in the examples directory)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "ArrowDTD",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#ArrowDTD",
          "type": "class"
        },
        "index": {
          "description": "Document Type Definition arrows These are separated because they are not needed for document processing only when processing the DTD e.g for generating access funtions for the toolbox from DTD se example DTDtoHaskell in the examples directory",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "ArrowDTD",
          "package": "hxt",
          "partial": "Arrow DTD",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#t:ArrowDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrows for processing \u003ccode\u003e\u003ca\u003eXmlTree\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e\u003cp\u003eThese arrows can be grouped into predicates, selectors, constructors, and transformers.\n\u003c/p\u003e\u003cp\u003eAll predicates (tests) act like \u003ccode\u003e\u003ca\u003enone\u003c/a\u003e\u003c/code\u003e for failure and \u003ccode\u003e\u003ca\u003ethis\u003c/a\u003e\u003c/code\u003e for success.\nA logical and can be formed by \u003ccode\u003e a1 \u003e\u003e\u003e a2 \u003c/code\u003e, a locical or by \u003ccode\u003e a1 \u003c+\u003e a2 \u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSelector arrows will fail, when applied to wrong input, e.g. selecting the text of a node with \u003ccode\u003e\u003ca\u003egetText\u003c/a\u003e\u003c/code\u003e\nwill fail when applied to a none text node.\n\u003c/p\u003e\u003cp\u003eEdit arrows will remain the input unchanged, when applied to wrong argument, e.g. editing the content of a text node\nwith \u003ccode\u003e\u003ca\u003echangeText\u003c/a\u003e\u003c/code\u003e applied to an element node will return the unchanged element node.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "ArrowXml",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#ArrowXml",
          "type": "class"
        },
        "index": {
          "description": "Arrows for processing XmlTree These arrows can be grouped into predicates selectors constructors and transformers All predicates tests act like none for failure and this for success logical and can be formed by a1 a2 locical or by a1 a2 Selector arrows will fail when applied to wrong input e.g selecting the text of node with getText will fail when applied to none text node Edit arrows will remain the input unchanged when applied to wrong argument e.g editing the content of text node with changeText applied to an element node will return the unchanged element node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "ArrowXml",
          "package": "hxt",
          "partial": "Arrow Xml",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#t:ArrowXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient op for adding attributes or children to a node\n\u003c/p\u003e\u003cp\u003eusage: \u003ccode\u003e tf += cf \u003c/code\u003e\n\u003c/p\u003e\u003cp\u003ethe \u003ccode\u003etf\u003c/code\u003e arrow computes an element node, and all trees computed by \u003ccode\u003ecf\u003c/code\u003e are\n added to this node, if a tree is an attribute, it is inserted in the attribute list\n else it is appended to the content list.\n\u003c/p\u003e\u003cp\u003eattention: do not build long content list this way because \u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e is implemented by ++\n\u003c/p\u003e\u003cp\u003eexamples:\n\u003c/p\u003e\u003cpre\u003e eelem \"a\"\n   += sattr \"href\" \"page.html\"\n   += sattr \"name\" \"here\"\n   += txt \"look here\"\n\u003c/pre\u003e\u003cp\u003eis the same as\n\u003c/p\u003e\u003cpre\u003e mkelem [ sattr \"href\" \"page.html\"\n        , sattr \"name\" \"here\"\n        ]\n        [ txt \"look here\" ]\n\u003c/pre\u003e\u003cp\u003eand results in the XML fragment: \u003ca href=\"page.html\" name=\"here\"\u003elook here\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eadvantage of the \u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e operator is, that attributes and content can be added\n any time step by step.\n if \u003ccode\u003etf\u003c/code\u003e computes a whole list of trees, e.g. a list of \"td\" or \"tr\" elements,\n the attributes or content is added to all trees. useful for adding \"class\" or \"style\" attributes\n to table elements.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "(+=)",
          "package": "hxt",
          "signature": "a b XmlTree -\u003e a b XmlTree -\u003e a b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#%2B%3D",
          "type": "method"
        },
        "index": {
          "description": "convenient op for adding attributes or children to node usage tf cf the tf arrow computes an element node and all trees computed by cf are added to this node if tree is an attribute it is inserted in the attribute list else it is appended to the content list attention do not build long content list this way because is implemented by examples eelem sattr href page.html sattr name here txt look here is the same as mkelem sattr href page.html sattr name here txt look here and results in the XML fragment href page.html name here look here advantage of the operator is that attributes and content can be added any time step by step if tf computes whole list of trees e.g list of td or tr elements the attributes or content is added to all trees useful for adding class or style attributes to table elements",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "(+=) +=",
          "normalized": "a b XmlTree-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "a b XmlTree-\u003ea b XmlTree-\u003ea b XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:-43--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd (or replace) an attribute\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "addAttr",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#addAttr",
          "type": "method"
        },
        "index": {
          "description": "add or replace an attribute",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "addAttr",
          "normalized": "String-\u003eString-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attr",
          "signature": "String-\u003eString-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:addAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd a list of attributes to an element\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "addAttrl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#addAttrl",
          "type": "method"
        },
        "index": {
          "description": "add list of attributes to an element",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "addAttrl",
          "normalized": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attrl",
          "signature": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:addAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient arrow for element constrution with attributes but without content, simple variant of \u003ccode\u003e\u003ca\u003emkelem\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emkElement\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "aelem",
          "package": "hxt",
          "signature": "String -\u003e [a n XmlTree] -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#aelem",
          "type": "method"
        },
        "index": {
          "description": "convenient arrow for element constrution with attributes but without content simple variant of mkelem and mkElement",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "aelem",
          "normalized": "String-\u003e[a b XmlTree]-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003e[a n XmlTree]-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:aelem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient arrow for attribute constrution, simple variant of \u003ccode\u003e\u003ca\u003emkAttr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "attr",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#attr",
          "type": "method"
        },
        "index": {
          "description": "convenient arrow for attribute constrution simple variant of mkAttr",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "attr",
          "normalized": "String-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003ea n XmlTree-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:attr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for blob nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "blb",
          "package": "hxt",
          "signature": "Blob -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#blb",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for blob nodes",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "blb",
          "normalized": "Blob-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "Blob-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:blb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit an attribute name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeAttrName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeAttrName",
          "type": "method"
        },
        "index": {
          "description": "edit an attribute name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeAttrName",
          "normalized": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attr Name",
          "signature": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeAttrName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit an attribute value\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeAttrValue",
          "package": "hxt",
          "signature": "(String -\u003e String) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeAttrValue",
          "type": "method"
        },
        "index": {
          "description": "edit an attribute value",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeAttrValue",
          "normalized": "(String-\u003eString)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attr Value",
          "signature": "(String-\u003eString)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit an attribute list of an element node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeAttrl",
          "package": "hxt",
          "signature": "(XmlTrees -\u003e XmlTrees -\u003e XmlTrees) -\u003e a XmlTree XmlTree -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeAttrl",
          "type": "method"
        },
        "index": {
          "description": "edit an attribute list of an element node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeAttrl",
          "normalized": "(XmlTrees-\u003eXmlTrees-\u003eXmlTrees)-\u003ea XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attrl",
          "signature": "(XmlTrees-\u003eXmlTrees-\u003eXmlTrees)-\u003ea XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit the blob of a blob node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeBlob",
          "package": "hxt",
          "signature": "(Blob -\u003e Blob) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeBlob",
          "type": "method"
        },
        "index": {
          "description": "edit the blob of blob node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeBlob",
          "normalized": "(Blob-\u003eBlob)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Blob",
          "signature": "(Blob-\u003eBlob)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit the comment string of a comment node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeCmt",
          "package": "hxt",
          "signature": "(String -\u003e String) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeCmt",
          "type": "method"
        },
        "index": {
          "description": "edit the comment string of comment node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeCmt",
          "normalized": "(String-\u003eString)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Cmt",
          "signature": "(String-\u003eString)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit an element name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeElemName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeElemName",
          "type": "method"
        },
        "index": {
          "description": "edit an element name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeElemName",
          "normalized": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Elem Name",
          "signature": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeElemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit a pi name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changePiName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changePiName",
          "type": "method"
        },
        "index": {
          "description": "edit pi name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changePiName",
          "normalized": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Pi Name",
          "signature": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changePiName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit an element-, attribute- or pi- name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeQName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeQName",
          "type": "method"
        },
        "index": {
          "description": "edit an element attribute or pi name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeQName",
          "normalized": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "QName",
          "signature": "(QName-\u003eQName)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eedit the string of a text node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeText",
          "package": "hxt",
          "signature": "(String -\u003e String) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#changeText",
          "type": "method"
        },
        "index": {
          "description": "edit the string of text node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "changeText",
          "normalized": "(String-\u003eString)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Text",
          "signature": "(String-\u003eString)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:changeText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for char reference nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "charRef",
          "package": "hxt",
          "signature": "Int -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#charRef",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for char reference nodes",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "charRef",
          "normalized": "Int-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "Ref",
          "signature": "Int-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:charRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for comment\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "cmt",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#cmt",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for comment",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "cmt",
          "normalized": "String-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:cmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient arrow for constrution of empty elements without attributes, simple variant of \u003ccode\u003e\u003ca\u003emkelem\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emkElement\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "eelem",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#eelem",
          "type": "method"
        },
        "index": {
          "description": "convenient arrow for constrution of empty elements without attributes simple variant of mkelem and mkElement",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "eelem",
          "normalized": "String-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:eelem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for entity reference nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "entityRef",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#entityRef",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for entity reference nodes",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "entityRef",
          "normalized": "String-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "Ref",
          "signature": "String-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:entityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for errors\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "err",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#err",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for errors",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "err",
          "normalized": "String-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for fatal errors\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "fatal",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#fatal",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for fatal errors",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "fatal",
          "normalized": "String-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:fatal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the name of an attribute\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrName",
          "package": "hxt",
          "signature": "a XmlTree QName",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getAttrName",
          "type": "method"
        },
        "index": {
          "description": "select the name of an attribute",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrName",
          "package": "hxt",
          "partial": "Attr Name",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getAttrName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the value of an attribute of an element node,\n always succeeds with empty string as default value \"\"\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrValue",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getAttrValue",
          "type": "method"
        },
        "index": {
          "description": "select the value of an attribute of an element node always succeeds with empty string as default value",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrValue",
          "normalized": "String-\u003ea XmlTree String",
          "package": "hxt",
          "partial": "Attr Value",
          "signature": "String-\u003ea XmlTree String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003egetAttrValue\u003c/a\u003e\u003c/code\u003e, but fails if the attribute does not exist\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrValue0",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getAttrValue0",
          "type": "method"
        },
        "index": {
          "description": "like getAttrValue but fails if the attribute does not exist",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrValue0",
          "normalized": "String-\u003ea XmlTree String",
          "package": "hxt",
          "partial": "Attr Value",
          "signature": "String-\u003ea XmlTree String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getAttrValue0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the attribute list of an element node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getAttrl",
          "type": "method"
        },
        "index": {
          "description": "select the attribute list of an element node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getAttrl",
          "package": "hxt",
          "partial": "Attrl",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the content of a CDATA node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getCdata",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getCdata",
          "type": "method"
        },
        "index": {
          "description": "select the content of CDATA node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getCdata",
          "package": "hxt",
          "partial": "Cdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the value of a char reference\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getCharRef",
          "package": "hxt",
          "signature": "a XmlTree Int",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getCharRef",
          "type": "method"
        },
        "index": {
          "description": "select the value of char reference",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getCharRef",
          "package": "hxt",
          "partial": "Char Ref",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the comment of a comment node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getCmt",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getCmt",
          "type": "method"
        },
        "index": {
          "description": "select the comment of comment node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getCmt",
          "package": "hxt",
          "partial": "Cmt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getDTDAttrValue",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getDTDAttrValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getDTDAttrValue",
          "normalized": "String-\u003ea XmlTree String",
          "package": "hxt",
          "partial": "DTDAttr Value",
          "signature": "String-\u003ea XmlTree String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getDTDAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the DTD attributes of a DTD node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getDTDAttrl",
          "package": "hxt",
          "signature": "a XmlTree Attributes",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getDTDAttrl",
          "type": "method"
        },
        "index": {
          "description": "select the DTD attributes of DTD node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getDTDAttrl",
          "package": "hxt",
          "partial": "DTDAttrl",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getDTDAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the DTD type of a DTD node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getDTDPart",
          "package": "hxt",
          "signature": "a XmlTree DTDElem",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getDTDPart",
          "type": "method"
        },
        "index": {
          "description": "select the DTD type of DTD node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getDTDPart",
          "package": "hxt",
          "partial": "DTDPart",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getDTDPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the name of an element node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getElemName",
          "package": "hxt",
          "signature": "a XmlTree QName",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getElemName",
          "type": "method"
        },
        "index": {
          "description": "select the name of an element node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getElemName",
          "package": "hxt",
          "partial": "Elem Name",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getElemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the name of a entity reference node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getEntityRef",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getEntityRef",
          "type": "method"
        },
        "index": {
          "description": "select the name of entity reference node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getEntityRef",
          "package": "hxt",
          "partial": "Entity Ref",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the error level (c_warn, c_err, c_fatal) from an error node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getErrorLevel",
          "package": "hxt",
          "signature": "a XmlTree Int",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getErrorLevel",
          "type": "method"
        },
        "index": {
          "description": "select the error level warn err fatal from an error node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getErrorLevel",
          "package": "hxt",
          "partial": "Error Level",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getErrorLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the error message from an error node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getErrorMsg",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getErrorMsg",
          "type": "method"
        },
        "index": {
          "description": "select the error message from an error node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getErrorMsg",
          "package": "hxt",
          "partial": "Error Msg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getErrorMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the local part\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getLocalPart",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getLocalPart",
          "type": "method"
        },
        "index": {
          "description": "select the local part",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getLocalPart",
          "package": "hxt",
          "partial": "Local Part",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getLocalPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the prefix:localPart or localPart from an element, attribute or pi\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getName",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getName",
          "type": "method"
        },
        "index": {
          "description": "select the prefix localPart or localPart from an element attribute or pi",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getName",
          "package": "hxt",
          "partial": "Name",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the name prefix\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getNamePrefix",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getNamePrefix",
          "type": "method"
        },
        "index": {
          "description": "select the name prefix",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getNamePrefix",
          "package": "hxt",
          "partial": "Name Prefix",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getNamePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the namespace URI\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getNamespaceUri",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getNamespaceUri",
          "type": "method"
        },
        "index": {
          "description": "select the namespace URI",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getNamespaceUri",
          "package": "hxt",
          "partial": "Namespace Uri",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getNamespaceUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the content of a processing instruction\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getPiContent",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getPiContent",
          "type": "method"
        },
        "index": {
          "description": "select the content of processing instruction",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getPiContent",
          "package": "hxt",
          "partial": "Pi Content",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getPiContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the name of a processing instruction\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getPiName",
          "package": "hxt",
          "signature": "a XmlTree QName",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getPiName",
          "type": "method"
        },
        "index": {
          "description": "select the name of processing instruction",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getPiName",
          "package": "hxt",
          "partial": "Pi Name",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getPiName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003egetAttrValue\u003c/a\u003e\u003c/code\u003e, but select the value of an attribute given by a qualified name,\n always succeeds with empty string as default value \"\"\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getQAttrValue",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getQAttrValue",
          "type": "method"
        },
        "index": {
          "description": "like getAttrValue but select the value of an attribute given by qualified name always succeeds with empty string as default value",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getQAttrValue",
          "normalized": "QName-\u003ea XmlTree String",
          "package": "hxt",
          "partial": "QAttr Value",
          "signature": "QName-\u003ea XmlTree String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getQAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike \u003ccode\u003e\u003ca\u003egetQAttrValue\u003c/a\u003e\u003c/code\u003e, but fails if attribute does not exist\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getQAttrValue0",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getQAttrValue0",
          "type": "method"
        },
        "index": {
          "description": "like getQAttrValue but fails if attribute does not exist",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getQAttrValue0",
          "normalized": "QName-\u003ea XmlTree String",
          "package": "hxt",
          "partial": "QAttr Value",
          "signature": "QName-\u003ea XmlTree String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getQAttrValue0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the qualified name from an element, attribute or pi\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getQName",
          "package": "hxt",
          "signature": "a XmlTree QName",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getQName",
          "type": "method"
        },
        "index": {
          "description": "select the qualified name from an element attribute or pi",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getQName",
          "package": "hxt",
          "partial": "QName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the text of a text node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getText",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getText",
          "type": "method"
        },
        "index": {
          "description": "select the text of text node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getText",
          "package": "hxt",
          "partial": "Text",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the univeral name ({namespace URI} ++ localPart)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getUniversalName",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getUniversalName",
          "type": "method"
        },
        "index": {
          "description": "select the univeral name namespace URI localPart",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getUniversalName",
          "package": "hxt",
          "partial": "Universal Name",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getUniversalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect the univeral name (namespace URI ++ localPart)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getUniversalUri",
          "package": "hxt",
          "signature": "a XmlTree String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#getUniversalUri",
          "type": "method"
        },
        "index": {
          "description": "select the univeral name namespace URI localPart",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "getUniversalUri",
          "package": "hxt",
          "partial": "Universal Uri",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:getUniversalUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether an element node has an attribute node with a specific name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasAttr",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasAttr",
          "type": "method"
        },
        "index": {
          "description": "test whether an element node has an attribute node with specific name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasAttr",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attr",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether an element node has an attribute with a specific value\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasAttrValue",
          "package": "hxt",
          "signature": "String -\u003e (String -\u003e Bool) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasAttrValue",
          "type": "method"
        },
        "index": {
          "description": "test whether an element node has an attribute with specific value",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasAttrValue",
          "normalized": "String-\u003e(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attr Value",
          "signature": "String-\u003e(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasDTDAttr",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasDTDAttr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasDTDAttr",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "DTDAttr",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasDTDAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether a node has a specific name as local part,\n useful only after namespace propagation\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasLocalPart",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasLocalPart",
          "type": "method"
        },
        "index": {
          "description": "test whether node has specific name as local part useful only after namespace propagation",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasLocalPart",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Local Part",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasLocalPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether a node has a specific name (prefix:localPart ore localPart),\n generally useful, even without namespace handling\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasName",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasName",
          "type": "method"
        },
        "index": {
          "description": "test whether node has specific name prefix localPart ore localPart generally useful even without namespace handling",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasName",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Name",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether a node has a specific name prefix,\n useful only after namespace propagation\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasNamePrefix",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasNamePrefix",
          "type": "method"
        },
        "index": {
          "description": "test whether node has specific name prefix useful only after namespace propagation",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasNamePrefix",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Name Prefix",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasNamePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether a node (element, attribute, pi) has a name with a special property\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasNameWith",
          "package": "hxt",
          "signature": "(QName -\u003e Bool) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasNameWith",
          "type": "method"
        },
        "index": {
          "description": "test whether node element attribute pi has name with special property",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasNameWith",
          "normalized": "(QName-\u003eBool)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Name With",
          "signature": "(QName-\u003eBool)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasNameWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether a node has a specific namespace URI\n useful only after namespace propagation\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasNamespaceUri",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasNamespaceUri",
          "type": "method"
        },
        "index": {
          "description": "test whether node has specific namespace URI useful only after namespace propagation",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasNamespaceUri",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Namespace Uri",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasNamespaceUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether an element node has an attribute node with a specific qualified name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasQAttr",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasQAttr",
          "type": "method"
        },
        "index": {
          "description": "test whether an element node has an attribute node with specific qualified name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasQAttr",
          "normalized": "QName-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "QAttr",
          "signature": "QName-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasQAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether an element node has an attribute with a qualified name and a specific value\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasQAttrValue",
          "package": "hxt",
          "signature": "QName -\u003e (String -\u003e Bool) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasQAttrValue",
          "type": "method"
        },
        "index": {
          "description": "test whether an element node has an attribute with qualified name and specific value",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasQAttrValue",
          "normalized": "QName-\u003e(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "QAttr Value",
          "signature": "QName-\u003e(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasQAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether a node (element, attribute, pi) has a specific qualified name\n useful only after namespace propagation\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasQName",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasQName",
          "type": "method"
        },
        "index": {
          "description": "test whether node element attribute pi has specific qualified name useful only after namespace propagation",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasQName",
          "normalized": "QName-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "QName",
          "signature": "QName-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for text nodes with text, for which a predicate holds\n\u003c/p\u003e\u003cp\u003eexample: \u003ccode\u003ehasText (all (`elem` \" \\t\\n\"))\u003c/code\u003e check for text nodes with only whitespace content\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasText",
          "package": "hxt",
          "signature": "(String -\u003e Bool) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#hasText",
          "type": "method"
        },
        "index": {
          "description": "test for text nodes with text for which predicate holds example hasText all elem check for text nodes with only whitespace content",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "hasText",
          "normalized": "(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Text",
          "signature": "(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:hasText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for attribute tree\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isAttr",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isAttr",
          "type": "method"
        },
        "index": {
          "description": "test for attribute tree",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isAttr",
          "package": "hxt",
          "partial": "Attr",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isBlob",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isBlob",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isBlob",
          "package": "hxt",
          "partial": "Blob",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for CDATA section, used during parsing\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isCdata",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isCdata",
          "type": "method"
        },
        "index": {
          "description": "test for CDATA section used during parsing",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isCdata",
          "package": "hxt",
          "partial": "Cdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for char reference, used during parsing\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isCharRef",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isCharRef",
          "type": "method"
        },
        "index": {
          "description": "test for char reference used during parsing",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isCharRef",
          "package": "hxt",
          "partial": "Char Ref",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for comment\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isCmt",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isCmt",
          "type": "method"
        },
        "index": {
          "description": "test for comment",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isCmt",
          "package": "hxt",
          "partial": "Cmt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for DTD part, used during parsing\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTD",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTD",
          "type": "method"
        },
        "index": {
          "description": "test for DTD part used during parsing",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTD",
          "package": "hxt",
          "partial": "DTD",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDAttlist",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDAttlist",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDAttlist",
          "package": "hxt",
          "partial": "DTDAttlist",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDAttlist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDCondSect",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDCondSect",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDCondSect",
          "package": "hxt",
          "partial": "DTDCond Sect",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDCondSect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDContent",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDContent",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDContent",
          "package": "hxt",
          "partial": "DTDContent",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDDoctype",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDDoctype",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDDoctype",
          "package": "hxt",
          "partial": "DTDDoctype",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDDoctype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDElement",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDElement",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDElement",
          "package": "hxt",
          "partial": "DTDElement",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDEntity",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDEntity",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDEntity",
          "package": "hxt",
          "partial": "DTDEntity",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDName",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDName",
          "package": "hxt",
          "partial": "DTDName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDNotation",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDNotation",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDNotation",
          "package": "hxt",
          "partial": "DTDNotation",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDNotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDPERef",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDPERef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDPERef",
          "package": "hxt",
          "partial": "DTDPERef",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDPERef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDPEntity",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isDTDPEntity",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isDTDPEntity",
          "package": "hxt",
          "partial": "DTDPEntity",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isDTDPEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for element\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isElem",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isElem",
          "type": "method"
        },
        "index": {
          "description": "test for element",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isElem",
          "package": "hxt",
          "partial": "Elem",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for entity reference, used during parsing\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isEntityRef",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isEntityRef",
          "type": "method"
        },
        "index": {
          "description": "test for entity reference used during parsing",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isEntityRef",
          "package": "hxt",
          "partial": "Entity Ref",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for error message\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isError",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isError",
          "type": "method"
        },
        "index": {
          "description": "test for error message",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isError",
          "package": "hxt",
          "partial": "Error",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for processing instruction\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isPi",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isPi",
          "type": "method"
        },
        "index": {
          "description": "test for processing instruction",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isPi",
          "package": "hxt",
          "partial": "Pi",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for root node (element with name \"/\")\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isRoot",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isRoot",
          "type": "method"
        },
        "index": {
          "description": "test for root node element with name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isRoot",
          "package": "hxt",
          "partial": "Root",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for text nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isText",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isText",
          "type": "method"
        },
        "index": {
          "description": "test for text nodes",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isText",
          "package": "hxt",
          "partial": "Text",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for text nodes with only white space\n\u003c/p\u003e\u003cp\u003eimplemented with \u003ccode\u003ehasTest\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isWhiteSpace",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isWhiteSpace",
          "type": "method"
        },
        "index": {
          "description": "test for text nodes with only white space implemented with hasTest",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isWhiteSpace",
          "package": "hxt",
          "partial": "White Space",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isWhiteSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for processing instruction \u003c?xml ...\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isXmlPi",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#isXmlPi",
          "type": "method"
        },
        "index": {
          "description": "test for processing instruction xml",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "isXmlPi",
          "package": "hxt",
          "partial": "Xml Pi",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:isXmlPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattribute node construction:\n | the attribute value is computed by applying an arrow to the input\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkAttr",
          "package": "hxt",
          "signature": "QName -\u003e a n XmlTree -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkAttr",
          "type": "method"
        },
        "index": {
          "description": "attribute node construction the attribute value is computed by applying an arrow to the input",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkAttr",
          "normalized": "QName-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "Attr",
          "signature": "QName-\u003ea n XmlTree-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblob node construction arrow\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkBlob",
          "package": "hxt",
          "signature": "a Blob XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkBlob",
          "type": "method"
        },
        "index": {
          "description": "blob node construction arrow",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkBlob",
          "package": "hxt",
          "partial": "Blob",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCDATA construction, useful for document output\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkCdata",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkCdata",
          "type": "method"
        },
        "index": {
          "description": "CDATA construction useful for document output",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkCdata",
          "package": "hxt",
          "partial": "Cdata",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echar reference construction arrow, useful for document output\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkCharRef",
          "package": "hxt",
          "signature": "a Int XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkCharRef",
          "type": "method"
        },
        "index": {
          "description": "char reference construction arrow useful for document output",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkCharRef",
          "package": "hxt",
          "partial": "Char Ref",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecomment node construction, useful for document output\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkCmt",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkCmt",
          "type": "method"
        },
        "index": {
          "description": "comment node construction useful for document output",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkCmt",
          "package": "hxt",
          "partial": "Cmt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDDoctype",
          "package": "hxt",
          "signature": "Attributes -\u003e a n XmlTree -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkDTDDoctype",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDDoctype",
          "normalized": "Attributes-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "DTDDoctype",
          "signature": "Attributes-\u003ea n XmlTree-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkDTDDoctype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDElem",
          "package": "hxt",
          "signature": "DTDElem -\u003e Attributes -\u003e a n XmlTree -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkDTDElem",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDElem",
          "normalized": "DTDElem-\u003eAttributes-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "DTDElem",
          "signature": "DTDElem-\u003eAttributes-\u003ea n XmlTree-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkDTDElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDElement",
          "package": "hxt",
          "signature": "Attributes -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkDTDElement",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDElement",
          "normalized": "Attributes-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "DTDElement",
          "signature": "Attributes-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkDTDElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDEntity",
          "package": "hxt",
          "signature": "Attributes -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkDTDEntity",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDEntity",
          "normalized": "Attributes-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "DTDEntity",
          "signature": "Attributes-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkDTDEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDPEntity",
          "package": "hxt",
          "signature": "Attributes -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkDTDPEntity",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkDTDPEntity",
          "normalized": "Attributes-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "DTDPEntity",
          "signature": "Attributes-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkDTDPEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eelement construction:\n | the attributes and the content of the element are computed by applying arrows\n to the input\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkElement",
          "package": "hxt",
          "signature": "QName -\u003e a n XmlTree -\u003e a n XmlTree -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkElement",
          "type": "method"
        },
        "index": {
          "description": "element construction the attributes and the content of the element are computed by applying arrows to the input",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkElement",
          "normalized": "QName-\u003ea b XmlTree-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "Element",
          "signature": "QName-\u003ea n XmlTree-\u003ea n XmlTree-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eentity reference construction arrow, useful for document output\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkEntityRef",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkEntityRef",
          "type": "method"
        },
        "index": {
          "description": "entity reference construction arrow useful for document output",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkEntityRef",
          "package": "hxt",
          "partial": "Entity Ref",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror node construction, useful only internally\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkError",
          "package": "hxt",
          "signature": "Int -\u003e a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkError",
          "type": "method"
        },
        "index": {
          "description": "error node construction useful only internally",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkError",
          "normalized": "Int-\u003ea String XmlTree",
          "package": "hxt",
          "partial": "Error",
          "signature": "Int-\u003ea String XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprocessing instruction construction:\n | the content of the processing instruction is computed by applying an arrow to the input\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkPi",
          "package": "hxt",
          "signature": "QName -\u003e a n XmlTree -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkPi",
          "type": "method"
        },
        "index": {
          "description": "processing instruction construction the content of the processing instruction is computed by applying an arrow to the input",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkPi",
          "normalized": "QName-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "partial": "Pi",
          "signature": "QName-\u003ea n XmlTree-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etext node construction arrow\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkText",
          "package": "hxt",
          "signature": "a String XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkText",
          "type": "method"
        },
        "index": {
          "description": "text node construction arrow",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkText",
          "package": "hxt",
          "partial": "Text",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient arrow for element construction with strings instead of qualified names as element names, see also \u003ccode\u003e\u003ca\u003emkElement\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emkelem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkelem",
          "package": "hxt",
          "signature": "String -\u003e [a n XmlTree] -\u003e [a n XmlTree] -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkelem",
          "type": "method"
        },
        "index": {
          "description": "convenient arrow for element construction with strings instead of qualified names as element names see also mkElement and mkelem",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkelem",
          "normalized": "String-\u003e[a b XmlTree]-\u003e[a b XmlTree]-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003e[a n XmlTree]-\u003e[a n XmlTree]-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkelem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient arrow for element construction, more comfortable variant of \u003ccode\u003e\u003ca\u003emkElement\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexample for simplifying \u003ccode\u003e\u003ca\u003emkElement\u003c/a\u003e\u003c/code\u003e :\n\u003c/p\u003e\u003cpre\u003e mkElement qn (a1 \u003c+\u003e ... \u003c+\u003e ai) (c1 \u003c+\u003e ... \u003c+\u003e cj)\n\u003c/pre\u003e\u003cp\u003eequals\n\u003c/p\u003e\u003cpre\u003e mkqelem qn [a1,...,ai] [c1,...,cj]\n\u003c/pre\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkqelem",
          "package": "hxt",
          "signature": "QName -\u003e [a n XmlTree] -\u003e [a n XmlTree] -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#mkqelem",
          "type": "method"
        },
        "index": {
          "description": "convenient arrow for element construction more comfortable variant of mkElement example for simplifying mkElement mkElement qn a1 ai c1 cj equals mkqelem qn a1 ai c1 cj",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "mkqelem",
          "normalized": "QName-\u003e[a b XmlTree]-\u003e[a b XmlTree]-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "QName-\u003e[a n XmlTree]-\u003e[a n XmlTree]-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:mkqelem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprocess the attributes of an element node with an arrow\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "processAttrl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#processAttrl",
          "type": "method"
        },
        "index": {
          "description": "process the attributes of an element node with an arrow",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "processAttrl",
          "normalized": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attrl",
          "signature": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:processAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eprocess a whole tree inclusive attribute list of element nodes\n see also: \u003ccode\u003e\u003ca\u003eprocessTopDown\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "processTopDownWithAttrl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#processTopDownWithAttrl",
          "type": "method"
        },
        "index": {
          "description": "process whole tree inclusive attribute list of element nodes see also processTopDown",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "processTopDownWithAttrl",
          "normalized": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Top Down With Attrl",
          "signature": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:processTopDownWithAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealias for \u003ccode\u003e\u003ca\u003emkAttr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "qattr",
          "package": "hxt",
          "signature": "QName -\u003e a n XmlTree -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#qattr",
          "type": "method"
        },
        "index": {
          "description": "alias for mkAttr",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "qattr",
          "normalized": "QName-\u003ea b XmlTree-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "QName-\u003ea n XmlTree-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:qattr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove an attribute\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "removeAttr",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#removeAttr",
          "type": "method"
        },
        "index": {
          "description": "remove an attribute",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "removeAttr",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attr",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:removeAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove an attribute with a qualified name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "removeQAttr",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#removeQAttr",
          "type": "method"
        },
        "index": {
          "description": "remove an attribute with qualified name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "removeQAttr",
          "normalized": "QName-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "QAttr",
          "signature": "QName-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:removeQAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstruction of an element node with name \"/\" for document roots\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "root",
          "package": "hxt",
          "signature": "[a n XmlTree] -\u003e [a n XmlTree] -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#root",
          "type": "method"
        },
        "index": {
          "description": "construction of an element node with name for document roots",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "root",
          "normalized": "[a b XmlTree]-\u003e[a b XmlTree]-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "[a n XmlTree]-\u003e[a n XmlTree]-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for attribute nodes, attribute name and value are\n | given by parameters, see \u003ccode\u003e\u003ca\u003emkAttr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "sattr",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#sattr",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for attribute nodes attribute name and value are given by parameters see mkAttr",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "sattr",
          "normalized": "String-\u003eString-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003eString-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:sattr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvenient arrow for simple element constrution without attributes, simple variant of \u003ccode\u003e\u003ca\u003emkelem\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emkElement\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "selem",
          "package": "hxt",
          "signature": "String -\u003e [a n XmlTree] -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#selem",
          "type": "method"
        },
        "index": {
          "description": "convenient arrow for simple element constrution without attributes simple variant of mkelem and mkElement",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "selem",
          "normalized": "String-\u003e[a b XmlTree]-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003e[a n XmlTree]-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:selem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplace an attribute name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setAttrName",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#setAttrName",
          "type": "method"
        },
        "index": {
          "description": "replace an attribute name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setAttrName",
          "normalized": "QName-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attr Name",
          "signature": "QName-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:setAttrName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplace an atribute list of an element node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setAttrl",
          "package": "hxt",
          "signature": "a XmlTree XmlTree -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#setAttrl",
          "type": "method"
        },
        "index": {
          "description": "replace an atribute list of an element node",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setAttrl",
          "normalized": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attrl",
          "signature": "a XmlTree XmlTree-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:setAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setDTDAttrValue",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#setDTDAttrValue",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setDTDAttrValue",
          "normalized": "String-\u003eString-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "DTDAttr Value",
          "signature": "String-\u003eString-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:setDTDAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplace an element name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setElemName",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#setElemName",
          "type": "method"
        },
        "index": {
          "description": "replace an element name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setElemName",
          "normalized": "QName-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Elem Name",
          "signature": "QName-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:setElemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplace an element name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setPiName",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#setPiName",
          "type": "method"
        },
        "index": {
          "description": "replace an element name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setPiName",
          "normalized": "QName-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Pi Name",
          "signature": "QName-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:setPiName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplace an element, attribute or pi name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setQName",
          "package": "hxt",
          "signature": "QName -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#setQName",
          "type": "method"
        },
        "index": {
          "description": "replace an element attribute or pi name",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "setQName",
          "normalized": "QName-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "QName",
          "signature": "QName-\u003ea XmlTree XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:setQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for simple processing instructions, see \u003ccode\u003e\u003ca\u003emkPi\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "spi",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#spi",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for simple processing instructions see mkPi",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "spi",
          "normalized": "String-\u003eString-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003eString-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:spi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for attribute nodes, attribute name is a qualified name and value is a text,\n | see also \u003ccode\u003e\u003ca\u003emkAttr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eqattr\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eattr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "sqattr",
          "package": "hxt",
          "signature": "QName -\u003e String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#sqattr",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for attribute nodes attribute name is qualified name and value is text see also mkAttr qattr attr",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "sqattr",
          "normalized": "QName-\u003eString-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "QName-\u003eString-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:sqattr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for text nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "txt",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#txt",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for text nodes",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "txt",
          "normalized": "String-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:txt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant arrow for warning\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "warn",
          "package": "hxt",
          "signature": "String -\u003e a n XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#warn",
          "type": "method"
        },
        "index": {
          "description": "constant arrow for warning",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "warn",
          "normalized": "String-\u003ea b XmlTree",
          "package": "hxt",
          "signature": "String-\u003ea n XmlTree",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:warn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an arrow to the input and convert the resulting XML trees into a string representation\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "xshow",
          "package": "hxt",
          "signature": "a n XmlTree -\u003e a n String",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#xshow",
          "type": "method"
        },
        "index": {
          "description": "apply an arrow to the input and convert the resulting XML trees into string representation",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "xshow",
          "normalized": "a b XmlTree-\u003ea b String",
          "package": "hxt",
          "signature": "a n XmlTree-\u003ea n String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:xshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an arrow to the input and convert the resulting XML trees into a string representation\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "xshowBlob",
          "package": "hxt",
          "signature": "a n XmlTree -\u003e a n Blob",
          "source": "src/Text-XML-HXT-Arrow-XmlArrow.html#xshowBlob",
          "type": "method"
        },
        "index": {
          "description": "apply an arrow to the input and convert the resulting XML trees into string representation",
          "hierarchy": "Text XML HXT Arrow XmlArrow",
          "module": "Text.XML.HXT.Arrow.XmlArrow",
          "name": "xshowBlob",
          "normalized": "a b XmlTree-\u003ea b Blob",
          "package": "hxt",
          "partial": "Blob",
          "signature": "a n XmlTree-\u003ea n Blob",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html#v:xshowBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003esystem configuration and common options options\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "XmlOptions",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html",
          "type": "module"
        },
        "index": {
          "description": "system configuration and common options options",
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "XmlOptions",
          "package": "hxt",
          "partial": "Xml Options",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_accept_mimetypes",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_accept_mimetypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_accept_mimetypes",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_accept_mimetypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_add_default_dtd",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_add_default_dtd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_add_default_dtd",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_add_default_dtd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_canonicalize",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_canonicalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_canonicalize",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_canonicalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_check_namespaces",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_check_namespaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_check_namespaces",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_check_namespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_collect_errors",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_collect_errors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_collect_errors",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_collect_errors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_default_baseuri",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_default_baseuri",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_default_baseuri",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_default_baseuri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_canonicalize",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_canonicalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_canonicalize",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_canonicalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_check_namespaces",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_check_namespaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_check_namespaces",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_check_namespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_issue_errors",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_issue_errors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_issue_errors",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_issue_errors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_issue_warnings",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_issue_warnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_issue_warnings",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_issue_warnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_preserve_comment",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_preserve_comment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_preserve_comment",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_preserve_comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_remove_whitespace",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_remove_whitespace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_remove_whitespace",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_remove_whitespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_subst_dtd_entities",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_subst_dtd_entities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_subst_dtd_entities",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_subst_dtd_entities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_subst_html_entities",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_subst_html_entities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_subst_html_entities",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_subst_html_entities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_validate",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_do_not_validate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_do_not_validate",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_do_not_validate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_error",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_error",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_error",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_error_log",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_error_log",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_error_log",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_error_log"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_help",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_help",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_help",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_help"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_if_modified_since",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_if_modified_since",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_if_modified_since",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_if_modified_since"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_if_unmodified_since",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_if_unmodified_since",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_if_unmodified_since",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_if_unmodified_since"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_ignore_encoding_errors",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_ignore_encoding_errors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_ignore_encoding_errors",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_ignore_encoding_errors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_ignore_none_xml_contents",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_ignore_none_xml_contents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_ignore_none_xml_contents",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_ignore_none_xml_contents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_indent",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_indent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_indent",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_indent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_issue_errors",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_issue_errors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_issue_errors",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_issue_errors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_issue_warnings",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_issue_warnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_issue_warnings",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_issue_warnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_mime_types",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_mime_types",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_mime_types",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_mime_types"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_empty_elem_for",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_no_empty_elem_for",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_empty_elem_for",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_no_empty_elem_for"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_empty_elements",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_no_empty_elements",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_empty_elements",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_no_empty_elements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_redirect",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_no_redirect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_redirect",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_no_redirect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_xml_pi",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_no_xml_pi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_no_xml_pi",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_no_xml_pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_file",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_output_file",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_file",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_output_file"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_html",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_output_html",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_html",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_output_html"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_plain",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_output_plain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_plain",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_output_plain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_xhtml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_output_xhtml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_xhtml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_output_xhtml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_xml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_output_xml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_output_xml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_output_xml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_parse_by_mimetype",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_parse_by_mimetype",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_parse_by_mimetype",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_parse_by_mimetype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_parse_html",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_parse_html",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_parse_html",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_parse_html"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_parse_xml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_parse_xml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_parse_xml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_parse_xml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_preserve_comment",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_preserve_comment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_preserve_comment",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_preserve_comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_proxy",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_proxy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_proxy",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_proxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_redirect",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_redirect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_redirect",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_redirect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_remove_whitespace",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_remove_whitespace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_remove_whitespace",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_remove_whitespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_show_haskell",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_show_haskell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_show_haskell",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_show_haskell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_show_tree",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_show_tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_show_tree",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_show_tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_strict_input",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_strict_input",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_strict_input",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_strict_input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_subst_dtd_entities",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_subst_dtd_entities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_subst_dtd_entities",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_subst_dtd_entities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_subst_html_entities",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_subst_html_entities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_subst_html_entities",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_subst_html_entities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_text_mode",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_text_mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_text_mode",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_text_mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_trace",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_trace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_trace",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_trace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_validate",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_validate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_validate",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_validate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_verbose",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#a_verbose",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "a_verbose",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:a_verbose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecommonly useful options\n\u003c/p\u003e\u003cp\u003edefines options: \u003ccode\u003e\u003ca\u003ea_verbose\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_help\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "generalOptions",
          "package": "hxt",
          "signature": "[OptDescr SysConfig]",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#generalOptions",
          "type": "function"
        },
        "index": {
          "description": "commonly useful options defines options verbose help",
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "generalOptions",
          "normalized": "[OptDescr SysConfig]",
          "package": "hxt",
          "partial": "Options",
          "signature": "[OptDescr SysConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:generalOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecommonly useful options for XML input\n\u003c/p\u003e\u003cp\u003ecan be used for option definition with haskell getopt\n\u003c/p\u003e\u003cp\u003edefines options: \u003ccode\u003e\u003ca\u003ea_trace\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_proxy\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003ea_use_curl\u003c/code\u003e, \u003ccode\u003ea_do_not_use_curl\u003c/code\u003e, \u003ccode\u003ea_options_curl\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_encoding\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003ea_issue_errors\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_do_not_issue_errors\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_parse_html\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_parse_by_mimetype\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_issue_warnings\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_do_not_issue_warnings\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003ea_parse_xml\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_validate\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_do_not_validate\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_canonicalize\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_do_not_canonicalize\u003c/a\u003e\u003c/code\u003e,\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "inputOptions",
          "package": "hxt",
          "signature": "[OptDescr SysConfig]",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#inputOptions",
          "type": "function"
        },
        "index": {
          "description": "commonly useful options for XML input can be used for option definition with haskell getopt defines options trace proxy use curl do not use curl options curl encoding issue errors do not issue errors parse html parse by mimetype issue warnings do not issue warnings parse xml validate do not validate canonicalize do not canonicalize",
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "inputOptions",
          "normalized": "[OptDescr SysConfig]",
          "package": "hxt",
          "partial": "Options",
          "signature": "[OptDescr SysConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:inputOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecommonly useful options for XML output\n\u003c/p\u003e\u003cp\u003edefines options: \u003ccode\u003e\u003ca\u003ea_indent\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_output_encoding\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ea_output_html\u003c/a\u003e\u003c/code\u003e and others\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "outputOptions",
          "package": "hxt",
          "signature": "[OptDescr SysConfig]",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#outputOptions",
          "type": "function"
        },
        "index": {
          "description": "commonly useful options for XML output defines options indent output encoding output html and others",
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "outputOptions",
          "normalized": "[OptDescr SysConfig]",
          "package": "hxt",
          "partial": "Options",
          "signature": "[OptDescr SysConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:outputOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "removeOptions",
          "package": "hxt",
          "signature": "[String] -\u003e [OptDescr a] -\u003e [OptDescr a]",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#removeOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "removeOptions",
          "normalized": "[String]-\u003e[OptDescr a]-\u003e[OptDescr a]",
          "package": "hxt",
          "partial": "Options",
          "signature": "[String]-\u003e[OptDescr a]-\u003e[OptDescr a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:removeOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eselect options from a predefined list of option desciptions\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "selectOptions",
          "package": "hxt",
          "signature": "[String] -\u003e [OptDescr a] -\u003e [OptDescr a]",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#selectOptions",
          "type": "function"
        },
        "index": {
          "description": "select options from predefined list of option desciptions",
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "selectOptions",
          "normalized": "[String]-\u003e[OptDescr a]-\u003e[OptDescr a]",
          "package": "hxt",
          "partial": "Options",
          "signature": "[String]-\u003e[OptDescr a]-\u003e[OptDescr a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:selectOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edebug output options\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "showOptions",
          "package": "hxt",
          "signature": "[OptDescr SysConfig]",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#showOptions",
          "type": "function"
        },
        "index": {
          "description": "debug output options",
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "showOptions",
          "normalized": "[OptDescr SysConfig]",
          "package": "hxt",
          "partial": "Options",
          "signature": "[OptDescr SysConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:showOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefines \u003ccode\u003e\u003ca\u003ea_version\u003c/a\u003e\u003c/code\u003e option\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "versionOptions",
          "package": "hxt",
          "signature": "[OptDescr SysConfig]",
          "source": "src/Text-XML-HXT-Arrow-XmlOptions.html#versionOptions",
          "type": "function"
        },
        "index": {
          "description": "defines version option",
          "hierarchy": "Text XML HXT Arrow XmlOptions",
          "module": "Text.XML.HXT.Arrow.XmlOptions",
          "name": "versionOptions",
          "normalized": "[OptDescr SysConfig]",
          "package": "hxt",
          "partial": "Options",
          "signature": "[OptDescr SysConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlOptions.html#v:versionOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRegular Expression Matcher working on lists of XmlTrees\n\u003c/p\u003e\u003cp\u003eIt's intended to import this module with an explicit\n   import declaration for not spoiling the namespace\n   with these somewhat special arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "XmlRegex",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html",
          "type": "module"
        },
        "index": {
          "description": "Regular Expression Matcher working on lists of XmlTrees It intended to import this module with an explicit import declaration for not spoiling the namespace with these somewhat special arrows",
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "XmlRegex",
          "package": "hxt",
          "partial": "Xml Regex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "XmlRegex",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#XmlRegex",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "XmlRegex",
          "package": "hxt",
          "partial": "Xml Regex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#t:XmlRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "delta",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlTree -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#delta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "delta",
          "normalized": "XmlRegex-\u003eXmlTree-\u003eXmlRegex",
          "package": "hxt",
          "signature": "XmlRegex-\u003eXmlTree-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:delta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echeck whether a sequence of XmlTrees match an Xml regular expression\n\u003c/p\u003e\u003cp\u003eThe arrow for \u003ccode\u003e\u003ca\u003ematchXmlRegex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe expession is build up from simple arrows acting as predicate (\u003ccode\u003e\u003ca\u003emkPrimA\u003c/a\u003e\u003c/code\u003e) for\n an XmlTree and of the usual cobinators for sequence (\u003ccode\u003e\u003ca\u003emkSeq\u003c/a\u003e\u003c/code\u003e), repetition\n (\u003ccode\u003e\u003ca\u003emkStar\u003c/a\u003e\u003c/code\u003e, mkRep', \u003ccode\u003e\u003ca\u003emkRng\u003c/a\u003e\u003c/code\u003e) and choice (\u003ccode\u003e\u003ca\u003emkAlt\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emkOpt\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "matchRegexA",
          "package": "hxt",
          "signature": "XmlRegex -\u003e LA XmlTree XmlTree -\u003e LA XmlTree XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#matchRegexA",
          "type": "function"
        },
        "index": {
          "description": "check whether sequence of XmlTrees match an Xml regular expression The arrow for matchXmlRegex The expession is build up from simple arrows acting as predicate mkPrimA for an XmlTree and of the usual cobinators for sequence mkSeq repetition mkStar mkRep mkRng and choice mkAlt mkOpt",
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "matchRegexA",
          "normalized": "XmlRegex-\u003eLA XmlTree XmlTree-\u003eLA XmlTree XmlTrees",
          "package": "hxt",
          "partial": "Regex",
          "signature": "XmlRegex-\u003eLA XmlTree XmlTree-\u003eLA XmlTree XmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:matchRegexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematch a sequence of XML trees with a regular expression over trees\n\u003c/p\u003e\u003cp\u003eIf the input matches, the result is Nothing, else Just an error message is returned\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "matchXmlRegex",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlTrees -\u003e Maybe String",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#matchXmlRegex",
          "type": "function"
        },
        "index": {
          "description": "match sequence of XML trees with regular expression over trees If the input matches the result is Nothing else Just an error message is returned",
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "matchXmlRegex",
          "normalized": "XmlRegex-\u003eXmlTrees-\u003eMaybe String",
          "package": "hxt",
          "partial": "Xml Regex",
          "signature": "XmlRegex-\u003eXmlTrees-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:matchXmlRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkAlt",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkAlt",
          "normalized": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Alt",
          "signature": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkAlts",
          "package": "hxt",
          "signature": "[XmlRegex] -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkAlts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkAlts",
          "normalized": "[XmlRegex]-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Alts",
          "signature": "[XmlRegex]-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkDot",
          "package": "hxt",
          "signature": "XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkDot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkDot",
          "package": "hxt",
          "partial": "Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkMerge",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkMerge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkMerge",
          "normalized": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Merge",
          "signature": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkMerge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkOpt",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkOpt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkOpt",
          "normalized": "XmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Opt",
          "signature": "XmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPerm",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkPerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPerm",
          "normalized": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Perm",
          "signature": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkPerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPerms",
          "package": "hxt",
          "signature": "[XmlRegex] -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkPerms",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPerms",
          "normalized": "[XmlRegex]-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Perms",
          "signature": "[XmlRegex]-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkPerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPrim",
          "package": "hxt",
          "signature": "(XmlTree -\u003e Bool) -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkPrim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPrim",
          "normalized": "(XmlTree-\u003eBool)-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Prim",
          "signature": "(XmlTree-\u003eBool)-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPrim'",
          "package": "hxt",
          "signature": "(XmlTree -\u003e Bool) -\u003e String -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkPrim%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPrim'",
          "normalized": "(XmlTree-\u003eBool)-\u003eString-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Prim'",
          "signature": "(XmlTree-\u003eBool)-\u003eString-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkPrim-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPrimA",
          "package": "hxt",
          "signature": "LA XmlTree XmlTree -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkPrimA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkPrimA",
          "normalized": "LA XmlTree XmlTree-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Prim",
          "signature": "LA XmlTree XmlTree-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkPrimA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkRep",
          "package": "hxt",
          "signature": "Int -\u003e XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkRep",
          "normalized": "Int-\u003eXmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Rep",
          "signature": "Int-\u003eXmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkRng",
          "package": "hxt",
          "signature": "Int -\u003e Int -\u003e XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkRng",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkRng",
          "normalized": "Int-\u003eInt-\u003eXmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Rng",
          "signature": "Int-\u003eInt-\u003eXmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkRng"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkSeq",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkSeq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkSeq",
          "normalized": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Seq",
          "signature": "XmlRegex-\u003eXmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkSeqs",
          "package": "hxt",
          "signature": "[XmlRegex] -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkSeqs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkSeqs",
          "normalized": "[XmlRegex]-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Seqs",
          "signature": "[XmlRegex]-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkSeqs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkStar",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkStar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkStar",
          "normalized": "XmlRegex-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Star",
          "signature": "XmlRegex-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkUnit",
          "package": "hxt",
          "signature": "XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkUnit",
          "package": "hxt",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkZero",
          "package": "hxt",
          "signature": "String -\u003e XmlRegex",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#mkZero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "mkZero",
          "normalized": "String-\u003eXmlRegex",
          "package": "hxt",
          "partial": "Zero",
          "signature": "String-\u003eXmlRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:mkZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "nullable",
          "package": "hxt",
          "signature": "XmlRegex -\u003e Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#nullable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "nullable",
          "normalized": "XmlRegex-\u003eBool",
          "package": "hxt",
          "signature": "XmlRegex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:nullable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escan the input sequence with a regex and give the result as a list of lists of trees back\n the regex must at least match one input tree, so the empty sequence should not match the regex\n\u003c/p\u003e\u003cp\u003eThe arrow for \u003ccode\u003e\u003ca\u003escanXmlRegex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "scanRegexA",
          "package": "hxt",
          "signature": "XmlRegex -\u003e LA XmlTree XmlTree -\u003e LA XmlTree XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#scanRegexA",
          "type": "function"
        },
        "index": {
          "description": "scan the input sequence with regex and give the result as list of lists of trees back the regex must at least match one input tree so the empty sequence should not match the regex The arrow for scanXmlRegex",
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "scanRegexA",
          "normalized": "XmlRegex-\u003eLA XmlTree XmlTree-\u003eLA XmlTree XmlTrees",
          "package": "hxt",
          "partial": "Regex",
          "signature": "XmlRegex-\u003eLA XmlTree XmlTree-\u003eLA XmlTree XmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:scanRegexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escan a sequence of XML trees and split it into parts matching the given regex\n\u003c/p\u003e\u003cp\u003eIf the parts cannot be split because of a missing match, or because of the\n empty sequence as match, Nothing is returned\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "scanXmlRegex",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlTrees -\u003e Maybe [XmlTrees]",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#scanXmlRegex",
          "type": "function"
        },
        "index": {
          "description": "scan sequence of XML trees and split it into parts matching the given regex If the parts cannot be split because of missing match or because of the empty sequence as match Nothing is returned",
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "scanXmlRegex",
          "normalized": "XmlRegex-\u003eXmlTrees-\u003eMaybe[XmlTrees]",
          "package": "hxt",
          "partial": "Xml Regex",
          "signature": "XmlRegex-\u003eXmlTrees-\u003eMaybe[XmlTrees]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:scanXmlRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit the sequence of trees computed by the filter a into\n\u003c/p\u003e\u003cp\u003eThe arrow for \u003ccode\u003e\u003ca\u003esplitXmlRegex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ea first part matching the regex and a rest,\n if a prefix of the input sequence does not match the regex, the arrow fails\n else the pair containing the result lists is returned\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "splitRegexA",
          "package": "hxt",
          "signature": "XmlRegex -\u003e LA XmlTree XmlTree -\u003e LA XmlTree (XmlTrees, XmlTrees)",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#splitRegexA",
          "type": "function"
        },
        "index": {
          "description": "split the sequence of trees computed by the filter into The arrow for splitXmlRegex first part matching the regex and rest if prefix of the input sequence does not match the regex the arrow fails else the pair containing the result lists is returned",
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "splitRegexA",
          "normalized": "XmlRegex-\u003eLA XmlTree XmlTree-\u003eLA XmlTree(XmlTrees,XmlTrees)",
          "package": "hxt",
          "partial": "Regex",
          "signature": "XmlRegex-\u003eLA XmlTree XmlTree-\u003eLA XmlTree(XmlTrees,XmlTrees)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:splitRegexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esplit a sequence of XML trees into a pair of a a matching prefix and a rest\n\u003c/p\u003e\u003cp\u003eIf there is no matching prefix, Nothing is returned\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "splitXmlRegex",
          "package": "hxt",
          "signature": "XmlRegex -\u003e XmlTrees -\u003e Maybe (XmlTrees, XmlTrees)",
          "source": "src/Text-XML-HXT-Arrow-XmlRegex.html#splitXmlRegex",
          "type": "function"
        },
        "index": {
          "description": "split sequence of XML trees into pair of matching prefix and rest If there is no matching prefix Nothing is returned",
          "hierarchy": "Text XML HXT Arrow XmlRegex",
          "module": "Text.XML.HXT.Arrow.XmlRegex",
          "name": "splitXmlRegex",
          "normalized": "XmlRegex-\u003eXmlTrees-\u003eMaybe(XmlTrees,XmlTrees)",
          "package": "hxt",
          "partial": "Xml Regex",
          "signature": "XmlRegex-\u003eXmlTrees-\u003eMaybe(XmlTrees,XmlTrees)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlRegex.html#v:splitXmlRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethe basic state arrows for XML processing\n\u003c/p\u003e\u003cp\u003eA state is needed for global processing options,\n   like encoding options, document base URI, trace levels\n   and error message handling\n\u003c/p\u003e\u003cp\u003eThe state is separated into a user defined state\n   and a system state. The system state contains variables\n   for error message handling, for tracing, for the document base\n   for accessing XML documents with relative references, e.g. DTDs,\n   and a global key value store. This assoc list has strings as keys\n   and lists of XmlTrees as values. It is used to store arbitrary\n   XML and text values, e.g. user defined global options.\n\u003c/p\u003e\u003cp\u003eThe user defined part of the store is in the default case empty, defined as ().\n   It can be extended with an arbitray data type\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "ErrorHandling",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html",
          "type": "module"
        },
        "index": {
          "description": "the basic state arrows for XML processing state is needed for global processing options like encoding options document base URI trace levels and error message handling The state is separated into user defined state and system state The system state contains variables for error message handling for tracing for the document base for accessing XML documents with relative references e.g DTDs and global key value store This assoc list has strings as keys and lists of XmlTrees as values It is used to store arbitrary XML and text values e.g user defined global options The user defined part of the store is in the default case empty defined as It can be extended with an arbitray data type",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "ErrorHandling",
          "package": "hxt",
          "partial": "Error Handling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "addToErrorMsgList",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#addToErrorMsgList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "addToErrorMsgList",
          "package": "hxt",
          "partial": "To Error Msg List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:addToErrorMsgList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "changeErrorStatus",
          "package": "hxt",
          "signature": "(Int -\u003e Int -\u003e Int) -\u003e IOStateArrow s Int Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#changeErrorStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "changeErrorStatus",
          "normalized": "(Int-\u003eInt-\u003eInt)-\u003eIOStateArrow a Int Int",
          "package": "hxt",
          "partial": "Error Status",
          "signature": "(Int-\u003eInt-\u003eInt)-\u003eIOStateArrow s Int Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:changeErrorStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereset global error variable\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "clearErrStatus",
          "package": "hxt",
          "signature": "IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#clearErrStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:clearErrStatus\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:clearErrStatus\"]"
        },
        "index": {
          "description": "reset global error variable",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "clearErrStatus",
          "package": "hxt",
          "partial": "Err Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:clearErrStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echeck whether tree is a document root and the status attribute has a value less than \u003ccode\u003e\u003ca\u003ec_err\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "documentStatusOk",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#documentStatusOk",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:documentStatusOk\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:documentStatusOk\"]"
        },
        "index": {
          "description": "check whether tree is document root and the status attribute has value less than err",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "documentStatusOk",
          "package": "hxt",
          "partial": "Status Ok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:documentStatusOk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror message handler for collecting errors\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "errorMsgCollect",
          "package": "hxt",
          "signature": "IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#errorMsgCollect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgCollect\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:errorMsgCollect\"]"
        },
        "index": {
          "description": "error message handler for collecting errors",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "errorMsgCollect",
          "package": "hxt",
          "partial": "Msg Collect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgCollect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror message handler for ignoring errors\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "errorMsgIgnore",
          "package": "hxt",
          "signature": "IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#errorMsgIgnore",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgIgnore\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:errorMsgIgnore\"]"
        },
        "index": {
          "description": "error message handler for ignoring errors",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "errorMsgIgnore",
          "package": "hxt",
          "partial": "Msg Ignore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgIgnore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe default error message handler: error output to stderr\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "errorMsgStderr",
          "package": "hxt",
          "signature": "IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#errorMsgStderr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgStderr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:errorMsgStderr\"]"
        },
        "index": {
          "description": "the default error message handler error output to stderr",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "errorMsgStderr",
          "package": "hxt",
          "partial": "Msg Stderr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgStderr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror message handler for output to stderr and collecting\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "errorMsgStderrAndCollect",
          "package": "hxt",
          "signature": "IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#errorMsgStderrAndCollect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgStderrAndCollect\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:errorMsgStderrAndCollect\"]"
        },
        "index": {
          "description": "error message handler for output to stderr and collecting",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "errorMsgStderrAndCollect",
          "package": "hxt",
          "partial": "Msg Stderr And Collect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorMsgStderrAndCollect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "errorOutputToStderr",
          "package": "hxt",
          "signature": "String -\u003e IO ()",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#errorOutputToStderr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "errorOutputToStderr",
          "normalized": "String-\u003eIO()",
          "package": "hxt",
          "partial": "Output To Stderr",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:errorOutputToStderr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efilter error messages from input trees and issue errors\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "filterErrorMsg",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#filterErrorMsg",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:filterErrorMsg\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:filterErrorMsg\"]"
        },
        "index": {
          "description": "filter error messages from input trees and issue errors",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "filterErrorMsg",
          "package": "hxt",
          "partial": "Error Msg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:filterErrorMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread current global error status\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getErrStatus",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#getErrStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:getErrStatus\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getErrStatus\"]"
        },
        "index": {
          "description": "read current global error status",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "getErrStatus",
          "package": "hxt",
          "partial": "Err Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:getErrStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif error messages are collected by the error handler for\n processing these messages by the calling application,\n this arrow reads the stored messages and clears the error message store\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getErrorMessages",
          "package": "hxt",
          "signature": "IOStateArrow s b XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#getErrorMessages",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:getErrorMessages\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getErrorMessages\"]"
        },
        "index": {
          "description": "if error messages are collected by the error handler for processing these messages by the calling application this arrow reads the stored messages and clears the error message store",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "getErrorMessages",
          "package": "hxt",
          "partial": "Error Messages",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:getErrorMessages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egenerate an error message\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "issueErr",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#issueErr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueErr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:issueErr\"]"
        },
        "index": {
          "description": "generate an error message",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "issueErr",
          "normalized": "String-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Err",
          "signature": "String-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault exception handler: issue a fatal error message and fail.\n\u003c/p\u003e\u003cp\u003eThe parameter can be used to specify where the error occured\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "issueExc",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s SomeException b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#issueExc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueExc\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:issueExc\"]"
        },
        "index": {
          "description": "Default exception handler issue fatal error message and fail The parameter can be used to specify where the error occured",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "issueExc",
          "normalized": "String-\u003eIOStateArrow a SomeException b",
          "package": "hxt",
          "partial": "Exc",
          "signature": "String-\u003eIOStateArrow s SomeException b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueExc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egenerate a fatal error message, e.g. document not found\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "issueFatal",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#issueFatal",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueFatal\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:issueFatal\"]"
        },
        "index": {
          "description": "generate fatal error message e.g document not found",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "issueFatal",
          "normalized": "String-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Fatal",
          "signature": "String-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueFatal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egenerate a warnig message\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "issueWarn",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#issueWarn",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueWarn\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:issueWarn\"]"
        },
        "index": {
          "description": "generate warnig message",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "issueWarn",
          "normalized": "String-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Warn",
          "signature": "String-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:issueWarn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd the error level and the module where the error occured\n to the attributes of a document root node and remove the children when level is greater or equal to \u003ccode\u003e\u003ca\u003ec_err\u003c/a\u003e\u003c/code\u003e.\n called by \u003ccode\u003e\u003ca\u003esetDocumentStatusFromSystemState\u003c/a\u003e\u003c/code\u003e when the system state indicates an error\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setDocumentStatus",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#setDocumentStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setDocumentStatus\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setDocumentStatus\"]"
        },
        "index": {
          "description": "add the error level and the module where the error occured to the attributes of document root node and remove the children when level is greater or equal to err called by setDocumentStatusFromSystemState when the system state indicates an error",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "setDocumentStatus",
          "normalized": "Int-\u003eString-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Document Status",
          "signature": "Int-\u003eString-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setDocumentStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echeck whether the error level attribute in the system state\n is set to error, in this case the children of the document root are\n removed and the module name where the error occured and the error level are added as attributes with \u003ccode\u003e\u003ca\u003esetDocumentStatus\u003c/a\u003e\u003c/code\u003e\n else nothing is changed\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setDocumentStatusFromSystemState",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#setDocumentStatusFromSystemState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setDocumentStatusFromSystemState\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setDocumentStatusFromSystemState\"]"
        },
        "index": {
          "description": "check whether the error level attribute in the system state is set to error in this case the children of the document root are removed and the module name where the error occured and the error level are added as attributes with setDocumentStatus else nothing is changed",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "setDocumentStatusFromSystemState",
          "normalized": "String-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Document Status From System State",
          "signature": "String-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setDocumentStatusFromSystemState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eraise the global error status level to that of the input tree\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setErrMsgStatus",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#setErrMsgStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setErrMsgStatus\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setErrMsgStatus\"]"
        },
        "index": {
          "description": "raise the global error status level to that of the input tree",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "setErrMsgStatus",
          "package": "hxt",
          "partial": "Err Msg Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setErrMsgStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset global error variable\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setErrStatus",
          "package": "hxt",
          "signature": "IOStateArrow s Int Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#setErrStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setErrStatus\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setErrStatus\"]"
        },
        "index": {
          "description": "set global error variable",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "setErrStatus",
          "package": "hxt",
          "partial": "Err Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setErrStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the error message handler and the flag for collecting the errors\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.ErrorHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setErrorMsgHandler",
          "package": "hxt",
          "signature": "Bool -\u003e (String -\u003e IO ()) -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#setErrorMsgHandler",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setErrorMsgHandler\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setErrorMsgHandler\"]"
        },
        "index": {
          "description": "set the error message handler and the flag for collecting the errors",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "setErrorMsgHandler",
          "normalized": "Bool-\u003e(String-\u003eIO())-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Error Msg Handler",
          "signature": "Bool-\u003e(String-\u003eIO())-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:setErrorMsgHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror message handler for output to stderr\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "sysErrorMsg",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#sysErrorMsg",
          "type": "function"
        },
        "index": {
          "description": "error message handler for output to stderr",
          "hierarchy": "Text XML HXT Arrow XmlState ErrorHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.ErrorHandling",
          "name": "sysErrorMsg",
          "package": "hxt",
          "partial": "Error Msg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-ErrorHandling.html#v:sysErrorMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethe mime type configuration functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.MimeTypeTable",
          "name": "MimeTypeTable",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html",
          "type": "module"
        },
        "index": {
          "description": "the mime type configuration functions",
          "hierarchy": "Text XML HXT Arrow XmlState MimeTypeTable",
          "module": "Text.XML.HXT.Arrow.XmlState.MimeTypeTable",
          "name": "MimeTypeTable",
          "package": "hxt",
          "partial": "Mime Type Table",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread the system mimetype table\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.MimeTypeTable\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getMimeTypeTable",
          "package": "hxt",
          "signature": "IOStateArrow s b MimeTypeTable",
          "source": "src/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#getMimeTypeTable",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#v:getMimeTypeTable\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getMimeTypeTable\"]"
        },
        "index": {
          "description": "read the system mimetype table",
          "hierarchy": "Text XML HXT Arrow XmlState MimeTypeTable",
          "module": "Text.XML.HXT.Arrow.XmlState.MimeTypeTable",
          "name": "getMimeTypeTable",
          "package": "hxt",
          "partial": "Mime Type Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#v:getMimeTypeTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the table mapping of file extensions to mime types in the system state\n\u003c/p\u003e\u003cp\u003eDefault table is defined in \u003ccode\u003e\u003ca\u003eMimeTypeDefaults\u003c/a\u003e\u003c/code\u003e.\n This table is used when reading loacl files, (file: protocol) to determine the mime type\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.MimeTypeTable\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setMimeTypeTable",
          "package": "hxt",
          "signature": "MimeTypeTable -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#setMimeTypeTable",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#v:setMimeTypeTable\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setMimeTypeTable\"]"
        },
        "index": {
          "description": "set the table mapping of file extensions to mime types in the system state Default table is defined in MimeTypeDefaults This table is used when reading loacl files file protocol to determine the mime type",
          "hierarchy": "Text XML HXT Arrow XmlState MimeTypeTable",
          "module": "Text.XML.HXT.Arrow.XmlState.MimeTypeTable",
          "name": "setMimeTypeTable",
          "normalized": "MimeTypeTable-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Mime Type Table",
          "signature": "MimeTypeTable-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#v:setMimeTypeTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the table mapping of file extensions to mime types by an external config file\n\u003c/p\u003e\u003cp\u003eThe config file must follow the conventions of \u003cem\u003eetc\u003c/em\u003emime.types on a debian linux system,\n that means all empty lines and all lines starting with a # are ignored. The other lines\n must consist of a mime type followed by a possible empty list of extensions.\n The list of extenstions and mime types overwrites the default list in the system state\n of the IOStateArrow\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.MimeTypeTable\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setMimeTypeTableFromFile",
          "package": "hxt",
          "signature": "FilePath -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#setMimeTypeTableFromFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#v:setMimeTypeTableFromFile\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setMimeTypeTableFromFile\"]"
        },
        "index": {
          "description": "set the table mapping of file extensions to mime types by an external config file The config file must follow the conventions of etc mime.types on debian linux system that means all empty lines and all lines starting with are ignored The other lines must consist of mime type followed by possible empty list of extensions The list of extenstions and mime types overwrites the default list in the system state of the IOStateArrow",
          "hierarchy": "Text XML HXT Arrow XmlState MimeTypeTable",
          "module": "Text.XML.HXT.Arrow.XmlState.MimeTypeTable",
          "name": "setMimeTypeTableFromFile",
          "normalized": "FilePath-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Mime Type Table From File",
          "signature": "FilePath-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-MimeTypeTable.html#v:setMimeTypeTableFromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003erun an io state arrow\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "RunIOStateArrow",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html",
          "type": "module"
        },
        "index": {
          "description": "run an io state arrow",
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "RunIOStateArrow",
          "package": "hxt",
          "partial": "Run IOState Arrow",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyCacheRead",
          "package": "hxt",
          "signature": "String -\u003e IOSArrow b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#dummyCacheRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyCacheRead",
          "normalized": "String-\u003eIOSArrow a a",
          "package": "hxt",
          "partial": "Cache Read",
          "signature": "String-\u003eIOSArrow b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:dummyCacheRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyExpatParser",
          "package": "hxt",
          "signature": "IOSArrow b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#dummyExpatParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyExpatParser",
          "package": "hxt",
          "partial": "Expat Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:dummyExpatParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyHTTPHandler",
          "package": "hxt",
          "signature": "IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#dummyHTTPHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyHTTPHandler",
          "package": "hxt",
          "partial": "HTTPHandler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:dummyHTTPHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyRelaxValidator",
          "package": "hxt",
          "signature": "IOSArrow b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#dummyRelaxValidator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyRelaxValidator",
          "package": "hxt",
          "partial": "Relax Validator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:dummyRelaxValidator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyTagSoupParser",
          "package": "hxt",
          "signature": "IOSArrow b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#dummyTagSoupParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyTagSoupParser",
          "package": "hxt",
          "partial": "Tag Soup Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:dummyTagSoupParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyXmlSchemaValidator",
          "package": "hxt",
          "signature": "IOSArrow b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#dummyXmlSchemaValidator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "dummyXmlSchemaValidator",
          "package": "hxt",
          "partial": "Xml Schema Validator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:dummyXmlSchemaValidator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.RunIOStateArrow\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getConfigAttr",
          "package": "hxt",
          "signature": "String -\u003e SysConfigList -\u003e String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#getConfigAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:getConfigAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getConfigAttr\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "getConfigAttr",
          "normalized": "String-\u003eSysConfigList-\u003eString",
          "package": "hxt",
          "partial": "Config Attr",
          "signature": "String-\u003eSysConfigList-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:getConfigAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialCacheConfig",
          "package": "hxt",
          "signature": "XIOCacheConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialCacheConfig",
          "package": "hxt",
          "partial": "Cache Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialCacheConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialInputConfig",
          "package": "hxt",
          "signature": "XIOInputConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialInputConfig",
          "package": "hxt",
          "partial": "Input Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialInputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialOutputConfig",
          "package": "hxt",
          "signature": "XIOOutputConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialOutputConfig",
          "package": "hxt",
          "partial": "Output Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialOutputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialParseConfig",
          "package": "hxt",
          "signature": "XIOParseConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialParseConfig",
          "package": "hxt",
          "partial": "Parse Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialParseConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialRelaxConfig",
          "package": "hxt",
          "signature": "XIORelaxConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialRelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialRelaxConfig",
          "package": "hxt",
          "partial": "Relax Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialRelaxConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe default global state, used as initial state when running an \u003ccode\u003e\u003ca\u003eIOSArrow\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003erunIOSLA\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003erunX\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialState",
          "package": "hxt",
          "signature": "us -\u003e XIOState us",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialState",
          "type": "function"
        },
        "index": {
          "description": "the default global state used as initial state when running an IOSArrow with runIOSLA or runX",
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialState",
          "normalized": "a-\u003eXIOState a",
          "package": "hxt",
          "partial": "State",
          "signature": "us-\u003eXIOState us",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialSysEnv",
          "package": "hxt",
          "signature": "XIOSysEnv",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialSysEnv",
          "package": "hxt",
          "partial": "Sys Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialSysEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialSysState",
          "package": "hxt",
          "signature": "XIOSysState",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialSysState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialSysState",
          "package": "hxt",
          "partial": "Sys State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialSysState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialSysWriter",
          "package": "hxt",
          "signature": "XIOSysWriter",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialSysWriter",
          "package": "hxt",
          "partial": "Sys Writer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialSysWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialXmlSchemaConfig",
          "package": "hxt",
          "signature": "XIOXmlSchemaConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#initialXmlSchemaConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "initialXmlSchemaConfig",
          "package": "hxt",
          "partial": "Xml Schema Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:initialXmlSchemaConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply an \u003ccode\u003e\u003ca\u003eIOSArrow\u003c/a\u003e\u003c/code\u003e to an empty root node with \u003ccode\u003e\u003ca\u003einitialState\u003c/a\u003e\u003c/code\u003e () as initial state\n\u003c/p\u003e\u003cp\u003ethe main entry point for running a state arrow with IO\n\u003c/p\u003e\u003cp\u003ewhen running \u003ccode\u003e runX f\u003c/code\u003e an empty XML root node is applied to \u003ccode\u003ef\u003c/code\u003e.\n usually \u003ccode\u003ef\u003c/code\u003e will start with a constant arrow (ignoring the input), e.g. a \u003ccode\u003e\u003ca\u003ereadDocument\u003c/a\u003e\u003c/code\u003e arrow.\n\u003c/p\u003e\u003cp\u003efor usage see examples with \u003ccode\u003e\u003ca\u003ewriteDocument\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eif input has to be feed into the arrow use \u003ccode\u003e\u003ca\u003erunIOSLA\u003c/a\u003e\u003c/code\u003e like in \u003ccode\u003e runIOSLA f emptyX inputDoc \u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.RunIOStateArrow\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "runX",
          "package": "hxt",
          "signature": "IOSArrow XmlTree c -\u003e IO [c]",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#runX",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:runX\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:runX\"]"
        },
        "index": {
          "description": "apply an IOSArrow to an empty root node with initialState as initial state the main entry point for running state arrow with IO when running runX an empty XML root node is applied to usually will start with constant arrow ignoring the input e.g readDocument arrow for usage see examples with writeDocument if input has to be feed into the arrow use runIOSLA like in runIOSLA emptyX inputDoc",
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "runX",
          "normalized": "IOSArrow XmlTree a-\u003eIO[a]",
          "package": "hxt",
          "signature": "IOSArrow XmlTree c-\u003eIO[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:runX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "runXIOState",
          "package": "hxt",
          "signature": "XIOState s -\u003e IOStateArrow s XmlTree c -\u003e IO [c]",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#runXIOState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "runXIOState",
          "normalized": "XIOState a-\u003eIOStateArrow a XmlTree b-\u003eIO[b]",
          "package": "hxt",
          "partial": "XIOState",
          "signature": "XIOState s-\u003eIOStateArrow s XmlTree c-\u003eIO[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:runXIOState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "theSysConfigComp",
          "package": "hxt",
          "signature": "Selector XIOSysState a -\u003e Selector SysConfig a",
          "source": "src/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#theSysConfigComp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState RunIOStateArrow",
          "module": "Text.XML.HXT.Arrow.XmlState.RunIOStateArrow",
          "name": "theSysConfigComp",
          "normalized": "Selector XIOSysState a-\u003eSelector SysConfig a",
          "package": "hxt",
          "partial": "Sys Config Comp",
          "signature": "Selector XIOSysState a-\u003eSelector SysConfig a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-RunIOStateArrow.html#v:theSysConfigComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003esystem configuration and common options options\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "SystemConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html",
          "type": "module"
        },
        "index": {
          "description": "system configuration and common options options",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "SystemConfig",
          "package": "hxt",
          "partial": "System Config",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "no",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#no",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:no\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:no\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "no",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:no"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify the set of accepted mime types.\n\u003c/p\u003e\u003cp\u003eAll contents of documents for which the mime type is not found in this list\n are discarded.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withAcceptedMimeTypes",
          "package": "hxt",
          "signature": "[String] -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withAcceptedMimeTypes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withAcceptedMimeTypes\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withAcceptedMimeTypes\"]"
        },
        "index": {
          "description": "Specify the set of accepted mime types All contents of documents for which the mime type is not found in this list are discarded",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withAcceptedMimeTypes",
          "normalized": "[String]-\u003eSysConfig",
          "package": "hxt",
          "partial": "Accepted Mime Types",
          "signature": "[String]-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withAcceptedMimeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withAddDefaultDTD",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withAddDefaultDTD",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withAddDefaultDTD\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withAddDefaultDTD\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withAddDefaultDTD",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Add Default DTD",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withAddDefaultDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithCanonicalize yes/no\u003c/code\u003e : read option, canonicalize document, default is \u003ccode\u003e\u003ca\u003eyes\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withCanonicalize",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withCanonicalize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withCanonicalize\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withCanonicalize\"]"
        },
        "index": {
          "description": "withCanonicalize yes no read option canonicalize document default is yes",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withCanonicalize",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Canonicalize",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withCanonicalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithCheckNamespaces yes/no\u003c/code\u003e: read option, check namespaces, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withCheckNamespaces",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withCheckNamespaces",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withCheckNamespaces\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withCheckNamespaces\"]"
        },
        "index": {
          "description": "withCheckNamespaces yes no read option check namespaces default is no",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withCheckNamespaces",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Check Namespaces",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withCheckNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConfigure compression and decompression for binary serialization/deserialization.\n First component is the compression function applied after serialization,\n second the decompression applied before deserialization.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withCompression",
          "package": "hxt",
          "signature": "(CompressionFct, DeCompressionFct) -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withCompression",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withCompression\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withCompression\"]"
        },
        "index": {
          "description": "Configure compression and decompression for binary serialization deserialization First component is the compression function applied after serialization second the decompression applied before deserialization",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withCompression",
          "normalized": "(CompressionFct,DeCompressionFct)-\u003eSysConfig",
          "package": "hxt",
          "partial": "Compression",
          "signature": "(CompressionFct,DeCompressionFct)-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithDefaultBaseURI URI\u003c/code\u003e , input option, set the default base URI\n\u003c/p\u003e\u003cp\u003eThis option can be useful when parsing documents from stdin or contained in a string, and interpreting\n relative URIs within the document\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withDefaultBaseURI",
          "package": "hxt",
          "signature": "String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withDefaultBaseURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withDefaultBaseURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withDefaultBaseURI\"]"
        },
        "index": {
          "description": "withDefaultBaseURI URI input option set the default base URI This option can be useful when parsing documents from stdin or contained in string and interpreting relative URIs within the document",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withDefaultBaseURI",
          "normalized": "String-\u003eSysConfig",
          "package": "hxt",
          "partial": "Default Base URI",
          "signature": "String-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withDefaultBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithEncodingErrors yes/no\u003c/code\u003e : input option, ignore all encoding errors, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withEncodingErrors",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withEncodingErrors",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withEncodingErrors\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withEncodingErrors\"]"
        },
        "index": {
          "description": "withEncodingErrors yes no input option ignore all encoding errors default is no",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withEncodingErrors",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Encoding Errors",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withEncodingErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithErrors yes/no\u003c/code\u003e : system option for suppressing error messages, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withErrors",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withErrors",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withErrors\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withErrors\"]"
        },
        "index": {
          "description": "withErrors yes no system option for suppressing error messages default is no",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withErrors",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Errors",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForce a given mime type for all file contents.\n\u003c/p\u003e\u003cp\u003eThe mime type for file access will then not be computed by looking into a mime.types file\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withFileMimeType",
          "package": "hxt",
          "signature": "String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withFileMimeType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withFileMimeType\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withFileMimeType\"]"
        },
        "index": {
          "description": "Force given mime type for all file contents The mime type for file access will then not be computed by looking into mime.types file",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withFileMimeType",
          "normalized": "String-\u003eSysConfig",
          "package": "hxt",
          "partial": "File Mime Type",
          "signature": "String-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withFileMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithIgnoreNoneXmlContents yes/no\u003c/code\u003e : input option, ignore document contents of none XML/HTML documents.\n\u003c/p\u003e\u003cp\u003eThis option can be useful for implementing crawler like applications, e.g. an URL checker.\n In those cases net traffic can be reduced.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withIgnoreNoneXmlContents",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withIgnoreNoneXmlContents",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withIgnoreNoneXmlContents\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withIgnoreNoneXmlContents\"]"
        },
        "index": {
          "description": "withIgnoreNoneXmlContents yes no input option ignore document contents of none XML HTML documents This option can be useful for implementing crawler like applications e.g an URL checker In those cases net traffic can be reduced",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withIgnoreNoneXmlContents",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Ignore None Xml Contents",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withIgnoreNoneXmlContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithIndent yes/no\u003c/code\u003e : output option, indent document before output, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withIndent",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withIndent",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withIndent\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withIndent\"]"
        },
        "index": {
          "description": "withIndent yes no output option indent document before output default is no",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withIndent",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Indent",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithInputEncoding encodingName\u003c/code\u003e : input option\n\u003c/p\u003e\u003cp\u003eSet default document encoding (\u003ccode\u003e\u003ca\u003eutf8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eisoLatin1\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eusAscii\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eiso8859_2\u003c/a\u003e\u003c/code\u003e, ... , \u003ccode\u003e\u003ca\u003eiso8859_16\u003c/a\u003e\u003c/code\u003e, ...).\n Only XML, HTML and text documents are decoded,\n default decoding for XML/HTML is utf8, for text iso latin1 (no decoding).\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withInputEncoding",
          "package": "hxt",
          "signature": "String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withInputEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withInputEncoding\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withInputEncoding\"]"
        },
        "index": {
          "description": "withInputEncoding encodingName input option Set default document encoding utf8 isoLatin1 usAscii iso8859 iso8859 Only XML HTML and text documents are decoded default decoding for XML HTML is utf8 for text iso latin1 no decoding",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withInputEncoding",
          "normalized": "String-\u003eSysConfig",
          "package": "hxt",
          "partial": "Input Encoding",
          "signature": "String-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withInputEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withInputOption",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withInputOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withInputOption\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withInputOption\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withInputOption",
          "normalized": "String-\u003eString-\u003eSysConfig",
          "package": "hxt",
          "partial": "Input Option",
          "signature": "String-\u003eString-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withInputOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withInputOptions",
          "package": "hxt",
          "signature": "Attributes -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withInputOptions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withInputOptions\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withInputOptions\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withInputOptions",
          "normalized": "Attributes-\u003eSysConfig",
          "package": "hxt",
          "partial": "Input Options",
          "signature": "Attributes-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withInputOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithMimeTypeFile filename\u003c/code\u003e : input option,\n set the mime type table for \u003ccode\u003efile:\u003c/code\u003e documents by given file.\n The format of this config file must be in the syntax of a debian linux \"mime.types\" config file\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withMimeTypeFile",
          "package": "hxt",
          "signature": "String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withMimeTypeFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withMimeTypeFile\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withMimeTypeFile\"]"
        },
        "index": {
          "description": "withMimeTypeFile filename input option set the mime type table for file documents by given file The format of this config file must be in the syntax of debian linux mime.types config file",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withMimeTypeFile",
          "normalized": "String-\u003eSysConfig",
          "package": "hxt",
          "partial": "Mime Type File",
          "signature": "String-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withMimeTypeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify a content handler for documents of a given mime type\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withMimeTypeHandler",
          "package": "hxt",
          "signature": "String -\u003e IOSArrow XmlTree XmlTree -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withMimeTypeHandler",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withMimeTypeHandler\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withMimeTypeHandler\"]"
        },
        "index": {
          "description": "Specify content handler for documents of given mime type",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withMimeTypeHandler",
          "normalized": "String-\u003eIOSArrow XmlTree XmlTree-\u003eSysConfig",
          "package": "hxt",
          "partial": "Mime Type Handler",
          "signature": "String-\u003eIOSArrow XmlTree XmlTree-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withMimeTypeHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withNoEmptyElemFor",
          "package": "hxt",
          "signature": "[String] -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withNoEmptyElemFor",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withNoEmptyElemFor\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withNoEmptyElemFor\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withNoEmptyElemFor",
          "normalized": "[String]-\u003eSysConfig",
          "package": "hxt",
          "partial": "No Empty Elem For",
          "signature": "[String]-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withNoEmptyElemFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithOutputEncoding encoding\u003c/code\u003e , output option,\n default is the default input encoding or utf8, if input encoding is not set\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withOutputEncoding",
          "package": "hxt",
          "signature": "String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withOutputEncoding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputEncoding\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withOutputEncoding\"]"
        },
        "index": {
          "description": "withOutputEncoding encoding output option default is the default input encoding or utf8 if input encoding is not set",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withOutputEncoding",
          "normalized": "String-\u003eSysConfig",
          "package": "hxt",
          "partial": "Output Encoding",
          "signature": "String-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite XHTML: quote all special XML chars, use HTML entity refs or char refs for none ASCII chars\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withOutputHTML",
          "package": "hxt",
          "signature": "SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withOutputHTML",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputHTML\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withOutputHTML\"]"
        },
        "index": {
          "description": "Write XHTML quote all special XML chars use HTML entity refs or char refs for none ASCII chars",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withOutputHTML",
          "package": "hxt",
          "partial": "Output HTML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esuppreses all char and entitiy substitution\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withOutputPLAIN",
          "package": "hxt",
          "signature": "SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withOutputPLAIN",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputPLAIN\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withOutputPLAIN\"]"
        },
        "index": {
          "description": "suppreses all char and entitiy substitution",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withOutputPLAIN",
          "package": "hxt",
          "partial": "Output PLAIN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputPLAIN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite XML: quote only special XML chars, don't substitute chars by HTML entities,\n and don't generate empty elements for HTML elements,\n which may contain any contents, e.g. \u003ccode\u003e\u003ca\u003esrc=...\u003c/a\u003e\u003ca\u003e/script\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003esrc=... /\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withOutputXHTML",
          "package": "hxt",
          "signature": "SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withOutputXHTML",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputXHTML\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withOutputXHTML\"]"
        },
        "index": {
          "description": "Write XML quote only special XML chars don substitute chars by HTML entities and don generate empty elements for HTML elements which may contain any contents e.g src script instead of src",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withOutputXHTML",
          "package": "hxt",
          "partial": "Output XHTML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputXHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithOutputXML\u003c/code\u003e : output option, default writing\n\u003c/p\u003e\u003cp\u003eDefault is writing XML: quote special XML chars \u003e,\u003c,\",',& where neccessary,\n add XML processing instruction\n and encode document with respect to \u003ccode\u003e\u003ca\u003ewithOutputEncoding\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withOutputXML",
          "package": "hxt",
          "signature": "SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withOutputXML",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputXML\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withOutputXML\"]"
        },
        "index": {
          "description": "withOutputXML output option default writing Default is writing XML quote special XML chars where neccessary add XML processing instruction and encode document with respect to withOutputEncoding",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withOutputXML",
          "package": "hxt",
          "partial": "Output XML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withOutputXML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithParseByMimeType yes/no\u003c/code\u003e  : read option, select the parser by the mime type of the document\n (pulled out of the HTTP header).\n\u003c/p\u003e\u003cp\u003eWhen the mime type is set to \"text/html\"\n the configured HTML parser is taken, when it's set to\n \"text/xml\" or \"text/xhtml\" the configured XML parser is taken.\n If the mime type is something else, no further processing is performed,\n the contents is given back to the application in form of a single text node.\n If the default document encoding is set to isoLatin1, this even enables processing\n of arbitray binary data.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withParseByMimeType",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withParseByMimeType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withParseByMimeType\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withParseByMimeType\"]"
        },
        "index": {
          "description": "withParseByMimeType yes no read option select the parser by the mime type of the document pulled out of the HTTP header When the mime type is set to text html the configured HTML parser is taken when it set to text xml or text xhtml the configured XML parser is taken If the mime type is something else no further processing is performed the contents is given back to the application in form of single text node If the default document encoding is set to isoLatin1 this even enables processing of arbitray binary data",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withParseByMimeType",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Parse By Mime Type",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withParseByMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithParseHTML yes/no\u003c/code\u003e: read option, use HTML parser, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e (use XML parser)\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withParseHTML",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withParseHTML",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withParseHTML\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withParseHTML\"]"
        },
        "index": {
          "description": "withParseHTML yes no read option use HTML parser default is no use XML parser",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withParseHTML",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Parse HTML",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withParseHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithPreserveComment yes/no\u003c/code\u003e : read option, preserve comments during canonicalization, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withPreserveComment",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withPreserveComment",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withPreserveComment\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withPreserveComment\"]"
        },
        "index": {
          "description": "withPreserveComment yes no read option preserve comments during canonicalization default is no",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withPreserveComment",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Preserve Comment",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withPreserveComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithProxy \"host:port\"\u003c/code\u003e : input option, configure a proxy for HTTP access, e.g. www-cache:3128\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withProxy",
          "package": "hxt",
          "signature": "String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withProxy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withProxy\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withProxy\"]"
        },
        "index": {
          "description": "withProxy host port input option configure proxy for HTTP access e.g www-cache",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withProxy",
          "normalized": "String-\u003eSysConfig",
          "package": "hxt",
          "partial": "Proxy",
          "signature": "String-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withProxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithRedirect yes/no\u003c/code\u003e : input option, automatically follow redirected URIs, default is \u003ccode\u003e\u003ca\u003eyes\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withRedirect",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withRedirect",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withRedirect\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withRedirect\"]"
        },
        "index": {
          "description": "withRedirect yes no input option automatically follow redirected URIs default is yes",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withRedirect",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Redirect",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withRedirect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithRemoveWS yes/no\u003c/code\u003e : read and write option, remove all whitespace, used for document indentation, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withRemoveWS",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withRemoveWS",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withRemoveWS\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withRemoveWS\"]"
        },
        "index": {
          "description": "withRemoveWS yes no read and write option remove all whitespace used for document indentation default is no",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withRemoveWS",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Remove WS",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withRemoveWS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withShowHaskell",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withShowHaskell",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withShowHaskell\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withShowHaskell\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withShowHaskell",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Show Haskell",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withShowHaskell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withShowTree",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withShowTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withShowTree\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withShowTree\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withShowTree",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Show Tree",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withShowTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrict input for deserialization of binary data\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withStrictDeserialize",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withStrictDeserialize",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withStrictDeserialize\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withStrictDeserialize\"]"
        },
        "index": {
          "description": "Strict input for deserialization of binary data",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withStrictDeserialize",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Strict Deserialize",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withStrictDeserialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithStrictInput yes/no\u003c/code\u003e : input option, input of file and HTTP contents is read eagerly, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withStrictInput",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withStrictInput",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withStrictInput\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withStrictInput\"]"
        },
        "index": {
          "description": "withStrictInput yes no input option input of file and HTTP contents is read eagerly default is no",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withStrictInput",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Strict Input",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withStrictInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithSubstDTDEntities yes/no\u003c/code\u003e: read option, substitute general entities defined in DTD, default is \u003ccode\u003e\u003ca\u003eyes\u003c/a\u003e\u003c/code\u003e.\n switching this option and the validate option off can lead to faster parsing, because then\n there is no need to access the DTD\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withSubstDTDEntities",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withSubstDTDEntities",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withSubstDTDEntities\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withSubstDTDEntities\"]"
        },
        "index": {
          "description": "withSubstDTDEntities yes no read option substitute general entities defined in DTD default is yes switching this option and the validate option off can lead to faster parsing because then there is no need to access the DTD",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withSubstDTDEntities",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Subst DTDEntities",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withSubstDTDEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithSubstHTMLEntities yes/no\u003c/code\u003e: read option, substitute general entities defined in HTML DTD, default is \u003ccode\u003e\u003ca\u003eno\u003c/a\u003e\u003c/code\u003e.\n switching this option on and the substDTDEntities and validate options off can lead to faster parsing\n because there is no need to access a DTD, but still the HTML general entities are substituted\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withSubstHTMLEntities",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withSubstHTMLEntities",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withSubstHTMLEntities\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withSubstHTMLEntities\"]"
        },
        "index": {
          "description": "withSubstHTMLEntities yes no read option substitute general entities defined in HTML DTD default is no switching this option on and the substDTDEntities and validate options off can lead to faster parsing because there is no need to access DTD but still the HTML general entities are substituted",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withSubstHTMLEntities",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Subst HTMLEntities",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withSubstHTMLEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithSysAttr key value\u003c/code\u003e : store an arbitarty key value pair in system state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withSysAttr",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withSysAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withSysAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withSysAttr\"]"
        },
        "index": {
          "description": "withSysAttr key value store an arbitarty key value pair in system state",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withSysAttr",
          "normalized": "String-\u003eString-\u003eSysConfig",
          "package": "hxt",
          "partial": "Sys Attr",
          "signature": "String-\u003eString-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withSysAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withTextMode",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withTextMode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withTextMode\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withTextMode\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withTextMode",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Text Mode",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withTextMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithTace level\u003c/code\u003e : system option, set the trace level, (0..4)\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withTrace",
          "package": "hxt",
          "signature": "Int -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withTrace",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withTrace\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withTrace\"]"
        },
        "index": {
          "description": "withTace level system option set the trace level",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withTrace",
          "normalized": "Int-\u003eSysConfig",
          "package": "hxt",
          "partial": "Trace",
          "signature": "Int-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withTrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithValidate yes/no\u003c/code\u003e: read option, validate document against DTD, default is \u003ccode\u003e\u003ca\u003eyes\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withValidate",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withValidate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withValidate\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withValidate\"]"
        },
        "index": {
          "description": "withValidate yes no read option validate document against DTD default is yes",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withValidate",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Validate",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withValidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithWarnings yes/no\u003c/code\u003e : system option, issue warnings during reading, HTML parsing and processing,\n default is \u003ccode\u003e\u003ca\u003eyes\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withWarnings",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withWarnings",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withWarnings\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withWarnings\"]"
        },
        "index": {
          "description": "withWarnings yes no system option issue warnings during reading HTML parsing and processing default is yes",
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withWarnings",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Warnings",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withXmlPi",
          "package": "hxt",
          "signature": "Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#withXmlPi",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withXmlPi\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withXmlPi\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "withXmlPi",
          "normalized": "Bool-\u003eSysConfig",
          "package": "hxt",
          "partial": "Xml Pi",
          "signature": "Bool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:withXmlPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.SystemConfig\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "yes",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#yes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:yes\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:yes\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState SystemConfig",
          "module": "Text.XML.HXT.Arrow.XmlState.SystemConfig",
          "name": "yes",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-SystemConfig.html#v:yes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethe trace arrows\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "TraceHandling",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html",
          "type": "module"
        },
        "index": {
          "description": "the trace arrows",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "TraceHandling",
          "package": "hxt",
          "partial": "Trace Handling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eacces the command for trace output\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getTraceCmd",
          "package": "hxt",
          "signature": "IOStateArrow a b (Int -\u003e String -\u003e IO ())",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#getTraceCmd",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:getTraceCmd\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getTraceCmd\"]"
        },
        "index": {
          "description": "acces the command for trace output",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "getTraceCmd",
          "normalized": "IOStateArrow a b(Int-\u003eString-\u003eIO())",
          "package": "hxt",
          "partial": "Trace Cmd",
          "signature": "IOStateArrow a b(Int-\u003eString-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:getTraceCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread the global trace level\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getTraceLevel",
          "package": "hxt",
          "signature": "IOStateArrow s b Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#getTraceLevel",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:getTraceLevel\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getTraceLevel\"]"
        },
        "index": {
          "description": "read the global trace level",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "getTraceLevel",
          "package": "hxt",
          "partial": "Trace Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:getTraceLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the global trace command. This command does the trace output\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setTraceCmd",
          "package": "hxt",
          "signature": "(Int -\u003e String -\u003e IO ()) -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#setTraceCmd",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:setTraceCmd\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setTraceCmd\"]"
        },
        "index": {
          "description": "set the global trace command This command does the trace output",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "setTraceCmd",
          "normalized": "(Int-\u003eString-\u003eIO())-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Trace Cmd",
          "signature": "(Int-\u003eString-\u003eIO())-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:setTraceCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the global trace level\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setTraceLevel",
          "package": "hxt",
          "signature": "Int -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#setTraceLevel",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:setTraceLevel\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setTraceLevel\"]"
        },
        "index": {
          "description": "set the global trace level",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "setTraceLevel",
          "normalized": "Int-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Trace Level",
          "signature": "Int-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:setTraceLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapply a trace arrow and issue message to stderr\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "trace",
          "package": "hxt",
          "signature": "Int -\u003e IOStateArrow s b String -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#trace",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:trace\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:trace\"]"
        },
        "index": {
          "description": "apply trace arrow and issue message to stderr",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "trace",
          "normalized": "Int-\u003eIOStateArrow a b String-\u003eIOStateArrow a b b",
          "package": "hxt",
          "signature": "Int-\u003eIOStateArrow s b String-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:trace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etrace a main computation step\n issue a message when trace level \u003e= 1, issue document source if level \u003e= 3, issue tree when level is \u003e= 4\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "traceDoc",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#traceDoc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceDoc\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:traceDoc\"]"
        },
        "index": {
          "description": "trace main computation step issue message when trace level issue document source if level issue tree when level is",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceDoc",
          "normalized": "String-\u003eIOStateArrow a XmlTree XmlTree",
          "package": "hxt",
          "partial": "Doc",
          "signature": "String-\u003eIOStateArrow s XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eissue a string message as trace\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "traceMsg",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#traceMsg",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceMsg\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:traceMsg\"]"
        },
        "index": {
          "description": "issue string message as trace",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceMsg",
          "normalized": "Int-\u003eString-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Msg",
          "signature": "Int-\u003eString-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceOutputToStderr",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e IO ()",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#traceOutputToStderr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceOutputToStderr",
          "normalized": "Int-\u003eString-\u003eIO()",
          "package": "hxt",
          "partial": "Output To Stderr",
          "signature": "Int-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceOutputToStderr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eissue the source representation of a document if trace level \u003e= 3\n\u003c/p\u003e\u003cp\u003efor better readability the source is formated with indentDoc\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "traceSource",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#traceSource",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceSource\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:traceSource\"]"
        },
        "index": {
          "description": "issue the source representation of document if trace level for better readability the source is formated with indentDoc",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceSource",
          "package": "hxt",
          "partial": "Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean old alias for \u003ccode\u003e\u003ca\u003etraceValue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "traceString",
          "package": "hxt",
          "signature": "Int -\u003e (b -\u003e String) -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#traceString",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceString\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:traceString\"]"
        },
        "index": {
          "description": "an old alias for traceValue",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceString",
          "normalized": "Int-\u003e(a-\u003eString)-\u003eIOStateArrow b a a",
          "package": "hxt",
          "partial": "String",
          "signature": "Int-\u003e(b-\u003eString)-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eissue the tree representation of a document if trace level \u003e= 4\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "traceTree",
          "package": "hxt",
          "signature": "IOStateArrow s XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#traceTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceTree\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:traceTree\"]"
        },
        "index": {
          "description": "issue the tree representation of document if trace level",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceTree",
          "package": "hxt",
          "partial": "Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etrace the current value transfered in a sequence of arrows.\n\u003c/p\u003e\u003cp\u003eThe value is formated by a string conversion function. This is a substitute for\n the old and less general traceString function\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "traceValue",
          "package": "hxt",
          "signature": "Int -\u003e (b -\u003e String) -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#traceValue",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceValue\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:traceValue\"]"
        },
        "index": {
          "description": "trace the current value transfered in sequence of arrows The value is formated by string conversion function This is substitute for the old and less general traceString function",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "traceValue",
          "normalized": "Int-\u003e(a-\u003eString)-\u003eIOStateArrow b a a",
          "package": "hxt",
          "partial": "Value",
          "signature": "Int-\u003e(b-\u003eString)-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:traceValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erun an arrow with a given trace level, the old trace level is restored after the arrow execution\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TraceHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withTraceLevel",
          "package": "hxt",
          "signature": "Int -\u003e IOStateArrow s b c -\u003e IOStateArrow s b c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#withTraceLevel",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:withTraceLevel\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withTraceLevel\"]"
        },
        "index": {
          "description": "run an arrow with given trace level the old trace level is restored after the arrow execution",
          "hierarchy": "Text XML HXT Arrow XmlState TraceHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.TraceHandling",
          "name": "withTraceLevel",
          "normalized": "Int-\u003eIOStateArrow a b c-\u003eIOStateArrow a b c",
          "package": "hxt",
          "partial": "Trace Level",
          "signature": "Int-\u003eIOStateArrow s b c-\u003eIOStateArrow s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TraceHandling.html#v:withTraceLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethe basic state arrows for XML processing\n\u003c/p\u003e\u003cp\u003eA state is needed for global processing options,\n   like encoding options, document base URI, trace levels\n   and error message handling\n\u003c/p\u003e\u003cp\u003eThe state is separated into a user defined state\n   and a system state. The system state contains variables\n   for error message handling, for tracing, for the document base\n   for accessing XML documents with relative references, e.g. DTDs,\n   and a global key value store. This assoc list has strings as keys\n   and lists of XmlTrees as values. It is used to store arbitrary\n   XML and text values, e.g. user defined global options.\n\u003c/p\u003e\u003cp\u003eThe user defined part of the store is in the default case empty, defined as ().\n   It can be extended with an arbitray data type\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html",
          "type": "module"
        },
        "index": {
          "description": "the basic state arrows for XML processing state is needed for global processing options like encoding options document base URI trace levels and error message handling The state is separated into user defined state and system state The system state contains variables for error message handling for tracing for the document base for accessing XML documents with relative references e.g DTDs and global key value store This assoc list has strings as keys and lists of XmlTrees as values It is used to store arbitrary XML and text values e.g user defined global options The user defined part of the store is in the default case empty defined as It can be extended with an arbitray data type",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "partial": "Type Defs",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "CompressionFct",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#CompressionFct",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "CompressionFct",
          "package": "hxt",
          "partial": "Compression Fct",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:CompressionFct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "DeCompressionFct",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#DeCompressionFct",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "DeCompressionFct",
          "package": "hxt",
          "partial": "De Compression Fct",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:DeCompressionFct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arrow for stateful arrows with no user defined state\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "IOSArrow",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#IOSArrow",
          "type": "type"
        },
        "index": {
          "description": "The arrow for stateful arrows with no user defined state",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "IOSArrow",
          "package": "hxt",
          "partial": "IOSArrow",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:IOSArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arrow type for stateful arrows\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "IOStateArrow",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#IOStateArrow",
          "type": "type"
        },
        "index": {
          "description": "The arrow type for stateful arrows",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "IOStateArrow",
          "package": "hxt",
          "partial": "IOState Arrow",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:IOStateArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "MimeTypeHandlers",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#MimeTypeHandlers",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "MimeTypeHandlers",
          "package": "hxt",
          "partial": "Mime Type Handlers",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:MimeTypeHandlers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Selector is a pair of an access function and a modifying function\n for reading and updating parts of a composite type\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "Selector",
          "package": "hxt",
          "source": "src/Data-Function-Selector.html#Selector",
          "type": "data"
        },
        "index": {
          "description": "Selector is pair of an access function and modifying function for reading and updating parts of composite type",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "Selector",
          "package": "hxt",
          "partial": "Selector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:Selector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "SysConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#SysConfig",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "SysConfig",
          "package": "hxt",
          "partial": "Sys Config",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:SysConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "SysConfigList",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#SysConfigList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "SysConfigList",
          "package": "hxt",
          "partial": "Sys Config List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:SysConfigList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOCacheConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOCacheConfig",
          "package": "hxt",
          "partial": "XIOCache Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOCacheConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOInputConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOInputConfig",
          "package": "hxt",
          "partial": "XIOInput Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOInputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOOutputConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOOutputConfig",
          "package": "hxt",
          "partial": "XIOOutput Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOOutputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOParseConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOParseConfig",
          "package": "hxt",
          "partial": "XIOParse Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOParseConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIORelaxConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIORelaxConfig",
          "package": "hxt",
          "partial": "XIORelax Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIORelaxConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estate datatype consists of a system state and a user state\n the user state is not fixed\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOState",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOState",
          "type": "data"
        },
        "index": {
          "description": "state datatype consists of system state and user state the user state is not fixed",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOState",
          "package": "hxt",
          "partial": "XIOState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSysEnv",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSysEnv",
          "package": "hxt",
          "partial": "XIOSys Env",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOSysEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epredefined system state data type with all components for the\n system functions, like trace, error handling, ...\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSysState",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysState",
          "type": "data"
        },
        "index": {
          "description": "predefined system state data type with all components for the system functions like trace error handling",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSysState",
          "package": "hxt",
          "partial": "XIOSys State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOSysState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSysWriter",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSysWriter",
          "package": "hxt",
          "partial": "XIOSys Writer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOSysWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOXmlSchemaConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXmlSchemaConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOXmlSchemaConfig",
          "package": "hxt",
          "partial": "XIOXml Schema Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOXmlSchemaConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOXoutConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXoutConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOXoutConfig",
          "package": "hxt",
          "partial": "XIOXout Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#t:XIOXoutConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "HTMLoutput",
          "package": "hxt",
          "signature": "HTMLoutput",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXoutConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "HTMLoutput",
          "package": "hxt",
          "partial": "HTMLoutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:HTMLoutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "PLAINoutput",
          "package": "hxt",
          "signature": "PLAINoutput",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXoutConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "PLAINoutput",
          "package": "hxt",
          "partial": "PLAINoutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:PLAINoutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XHTMLoutput",
          "package": "hxt",
          "signature": "XHTMLoutput",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXoutConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XHTMLoutput",
          "package": "hxt",
          "partial": "XHTMLoutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XHTMLoutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOCch",
          "package": "hxt",
          "signature": "XIOCch",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOCch",
          "package": "hxt",
          "partial": "XIOCch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOCch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOEnv",
          "package": "hxt",
          "signature": "XIOEnv",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOEnv",
          "package": "hxt",
          "partial": "XIOEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOIcgf",
          "package": "hxt",
          "signature": "XIOIcgf",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOIcgf",
          "package": "hxt",
          "partial": "XIOIcgf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOIcgf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOOcfg",
          "package": "hxt",
          "signature": "XIOOcfg",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOOcfg",
          "package": "hxt",
          "partial": "XIOOcfg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOOcfg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOPcfg",
          "package": "hxt",
          "signature": "XIOPcfg",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOPcfg",
          "package": "hxt",
          "partial": "XIOPcfg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOPcfg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIORxc",
          "package": "hxt",
          "signature": "XIORxc",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIORxc",
          "package": "hxt",
          "partial": "XIORxc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIORxc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOScc",
          "package": "hxt",
          "signature": "XIOScc",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXmlSchemaConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOScc",
          "package": "hxt",
          "partial": "XIOScc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOScc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOState",
          "package": "hxt",
          "signature": "XIOState",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOState",
          "package": "hxt",
          "partial": "XIOState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSys",
          "package": "hxt",
          "signature": "XIOSys",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOSys",
          "package": "hxt",
          "partial": "XIOSys",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOSys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOwrt",
          "package": "hxt",
          "signature": "XIOwrt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XIOwrt",
          "package": "hxt",
          "partial": "XIOwrt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XIOwrt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XMLoutput",
          "package": "hxt",
          "signature": "XMLoutput",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXoutConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "XMLoutput",
          "package": "hxt",
          "partial": "XMLoutput",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:XMLoutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echange the user defined part of the state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "changeUserState",
          "package": "hxt",
          "signature": "(b -\u003e s -\u003e s) -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#changeUserState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:changeUserState\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:changeUserState\"]"
        },
        "index": {
          "description": "change the user defined part of the state",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "changeUserState",
          "normalized": "(a-\u003eb-\u003eb)-\u003eIOStateArrow b a a",
          "package": "hxt",
          "partial": "User State",
          "signature": "(b-\u003es-\u003es)-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:changeUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "chgSysVar",
          "package": "hxt",
          "signature": "Selector XIOSysState c -\u003e (b -\u003e c -\u003e c) -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#chgSysVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "chgSysVar",
          "normalized": "Selector XIOSysState a-\u003e(b-\u003ea-\u003ea)-\u003eIOStateArrow c b b",
          "package": "hxt",
          "partial": "Sys Var",
          "signature": "Selector XIOSysState c-\u003e(b-\u003ec-\u003ec)-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:chgSysVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "configSysVar",
          "package": "hxt",
          "signature": "SysConfig -\u003e IOStateArrow s c c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#configSysVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "configSysVar",
          "normalized": "SysConfig-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Sys Var",
          "signature": "SysConfig-\u003eIOStateArrow s c c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:configSysVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "configSysVars",
          "package": "hxt",
          "signature": "SysConfigList -\u003e IOStateArrow s c c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#configSysVars",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:configSysVars\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:configSysVars\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "configSysVars",
          "normalized": "SysConfigList-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Sys Vars",
          "signature": "SysConfigList-\u003eIOStateArrow s c c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:configSysVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread all attributes from global state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getAllSysAttrs",
          "package": "hxt",
          "signature": "IOStateArrow s b Attributes",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#getAllSysAttrs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getAllSysAttrs\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getAllSysAttrs\"]"
        },
        "index": {
          "description": "read all attributes from global state",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "getAllSysAttrs",
          "package": "hxt",
          "partial": "All Sys Attrs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getAllSysAttrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread an attribute value from global state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getSysAttr",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#getSysAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getSysAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getSysAttr\"]"
        },
        "index": {
          "description": "read an attribute value from global state",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "getSysAttr",
          "normalized": "String-\u003eIOStateArrow a b String",
          "package": "hxt",
          "partial": "Sys Attr",
          "signature": "String-\u003eIOStateArrow s b String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getSysAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread an int value from global state\n\u003c/p\u003e\u003cpre\u003e getSysAttrInt 0 myIntAttr\n\u003c/pre\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getSysAttrInt",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e IOStateArrow s b Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#getSysAttrInt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getSysAttrInt\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getSysAttrInt\"]"
        },
        "index": {
          "description": "read an int value from global state getSysAttrInt myIntAttr",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "getSysAttrInt",
          "normalized": "Int-\u003eString-\u003eIOStateArrow a b Int",
          "package": "hxt",
          "partial": "Sys Attr Int",
          "signature": "Int-\u003eString-\u003eIOStateArrow s b Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getSysAttrInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "getSysVar",
          "package": "hxt",
          "signature": "Selector XIOSysState c -\u003e IOStateArrow s b c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#getSysVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "getSysVar",
          "normalized": "Selector XIOSysState a-\u003eIOStateArrow b c a",
          "package": "hxt",
          "partial": "Sys Var",
          "signature": "Selector XIOSysState c-\u003eIOStateArrow s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getSysVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread the user defined part of the state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getUserState",
          "package": "hxt",
          "signature": "IOStateArrow s b s",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#getUserState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getUserState\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getUserState\"]"
        },
        "index": {
          "description": "read the user defined part of the state",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "getUserState",
          "package": "hxt",
          "partial": "User State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:getUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "incrSysVar",
          "package": "hxt",
          "signature": "Selector XIOSysState Int -\u003e IOStateArrow s a Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#incrSysVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "incrSysVar",
          "normalized": "Selector XIOSysState Int-\u003eIOStateArrow a b Int",
          "package": "hxt",
          "partial": "Sys Var",
          "signature": "Selector XIOSysState Int-\u003eIOStateArrow s a Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:incrSysVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "localSysEnv",
          "package": "hxt",
          "signature": "IOStateArrow s a b -\u003e IOStateArrow s a b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#localSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "localSysEnv",
          "normalized": "IOStateArrow a b c-\u003eIOStateArrow a b c",
          "package": "hxt",
          "partial": "Sys Env",
          "signature": "IOStateArrow s a b-\u003eIOStateArrow s a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:localSysEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "localSysVar",
          "package": "hxt",
          "signature": "Selector XIOSysState c -\u003e IOStateArrow s a b -\u003e IOStateArrow s a b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#localSysVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "localSysVar",
          "normalized": "Selector XIOSysState a-\u003eIOStateArrow b c d-\u003eIOStateArrow b c d",
          "package": "hxt",
          "partial": "Sys Var",
          "signature": "Selector XIOSysState c-\u003eIOStateArrow s a b-\u003eIOStateArrow s a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:localSysVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estore a string in global state under a given attribute name\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setSysAttr",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#setSysAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setSysAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setSysAttr\"]"
        },
        "index": {
          "description": "store string in global state under given attribute name",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "setSysAttr",
          "normalized": "String-\u003eIOStateArrow a String String",
          "package": "hxt",
          "partial": "Sys Attr",
          "signature": "String-\u003eIOStateArrow s String String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setSysAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estore an int value in global state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setSysAttrInt",
          "package": "hxt",
          "signature": "String -\u003e Int -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#setSysAttrInt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setSysAttrInt\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setSysAttrInt\"]"
        },
        "index": {
          "description": "store an int value in global state",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "setSysAttrInt",
          "normalized": "String-\u003eInt-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Sys Attr Int",
          "signature": "String-\u003eInt-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setSysAttrInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setSysAttrString",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#setSysAttrString",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setSysAttrString\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setSysAttrString\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "setSysAttrString",
          "normalized": "String-\u003eString-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Sys Attr String",
          "signature": "String-\u003eString-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setSysAttrString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "setSysVar",
          "package": "hxt",
          "signature": "Selector XIOSysState c -\u003e IOStateArrow s c c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#setSysVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "setSysVar",
          "normalized": "Selector XIOSysState a-\u003eIOStateArrow b a a",
          "package": "hxt",
          "partial": "Sys Var",
          "signature": "Selector XIOSysState c-\u003eIOStateArrow s c c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setSysVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the user defined part of the state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setUserState",
          "package": "hxt",
          "signature": "IOStateArrow s s s",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#setUserState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setUserState\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setUserState\"]"
        },
        "index": {
          "description": "set the user defined part of the state",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "setUserState",
          "package": "hxt",
          "partial": "User State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:setUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theAcceptedMimeTypes",
          "package": "hxt",
          "signature": "Selector XIOSysState [String]",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theAcceptedMimeTypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theAcceptedMimeTypes",
          "normalized": "Selector XIOSysState[String]",
          "package": "hxt",
          "partial": "Accepted Mime Types",
          "signature": "Selector XIOSysState[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theAcceptedMimeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theAddDefaultDTD",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theAddDefaultDTD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theAddDefaultDTD",
          "package": "hxt",
          "partial": "Add Default DTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theAddDefaultDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theAttrList",
          "package": "hxt",
          "signature": "Selector XIOSysState Attributes",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theAttrList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theAttrList",
          "package": "hxt",
          "partial": "Attr List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theAttrList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theBaseURI",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theBaseURI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theBaseURI",
          "package": "hxt",
          "partial": "Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theBinaryCompression",
          "package": "hxt",
          "signature": "Selector XIOSysState (ByteString -\u003e ByteString)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theBinaryCompression",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theBinaryCompression",
          "normalized": "Selector XIOSysState(ByteString-\u003eByteString)",
          "package": "hxt",
          "partial": "Binary Compression",
          "signature": "Selector XIOSysState(ByteString-\u003eByteString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theBinaryCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theBinaryDeCompression",
          "package": "hxt",
          "signature": "Selector XIOSysState (ByteString -\u003e ByteString)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theBinaryDeCompression",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theBinaryDeCompression",
          "normalized": "Selector XIOSysState(ByteString-\u003eByteString)",
          "package": "hxt",
          "partial": "Binary De Compression",
          "signature": "Selector XIOSysState(ByteString-\u003eByteString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theBinaryDeCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCache404Err",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theCache404Err",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCache404Err",
          "package": "hxt",
          "partial": "Cache Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theCache404Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCacheConfig",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOCacheConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCacheConfig",
          "package": "hxt",
          "partial": "Cache Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theCacheConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCacheDir",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theCacheDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCacheDir",
          "package": "hxt",
          "partial": "Cache Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theCacheDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCacheRead",
          "package": "hxt",
          "signature": "Selector XIOSysState (String -\u003e IOSArrow XmlTree XmlTree)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theCacheRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCacheRead",
          "normalized": "Selector XIOSysState(String-\u003eIOSArrow XmlTree XmlTree)",
          "package": "hxt",
          "partial": "Cache Read",
          "signature": "Selector XIOSysState(String-\u003eIOSArrow XmlTree XmlTree)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theCacheRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCanonicalize",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theCanonicalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCanonicalize",
          "package": "hxt",
          "partial": "Canonicalize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theCanonicalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCheckNamespaces",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theCheckNamespaces",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theCheckNamespaces",
          "package": "hxt",
          "partial": "Check Namespaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theCheckNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theDefaultBaseURI",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theDefaultBaseURI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theDefaultBaseURI",
          "package": "hxt",
          "partial": "Default Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theDefaultBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theDocumentAge",
          "package": "hxt",
          "signature": "Selector XIOSysState Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theDocumentAge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theDocumentAge",
          "package": "hxt",
          "partial": "Document Age",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theDocumentAge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theEncodingErrors",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theEncodingErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theEncodingErrors",
          "package": "hxt",
          "partial": "Encoding Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theEncodingErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorMsgCollect",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theErrorMsgCollect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorMsgCollect",
          "package": "hxt",
          "partial": "Error Msg Collect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theErrorMsgCollect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorMsgHandler",
          "package": "hxt",
          "signature": "Selector XIOSysState (String -\u003e IO ())",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theErrorMsgHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorMsgHandler",
          "normalized": "Selector XIOSysState(String-\u003eIO())",
          "package": "hxt",
          "partial": "Error Msg Handler",
          "signature": "Selector XIOSysState(String-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theErrorMsgHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorMsgList",
          "package": "hxt",
          "signature": "Selector XIOSysState XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theErrorMsgList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorMsgList",
          "package": "hxt",
          "partial": "Error Msg List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theErrorMsgList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorStatus",
          "package": "hxt",
          "signature": "Selector XIOSysState Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theErrorStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theErrorStatus",
          "package": "hxt",
          "partial": "Error Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theErrorStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theExpat",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theExpat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theExpat",
          "package": "hxt",
          "partial": "Expat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theExpat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theExpatErrors",
          "package": "hxt",
          "signature": "Selector XIOSysState (IOSArrow XmlTree XmlTree)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theExpatErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theExpatErrors",
          "package": "hxt",
          "partial": "Expat Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theExpatErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theExpatParser",
          "package": "hxt",
          "signature": "Selector XIOSysState (IOSArrow XmlTree XmlTree)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theExpatParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theExpatParser",
          "package": "hxt",
          "partial": "Expat Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theExpatParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theFileMimeType",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theFileMimeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theFileMimeType",
          "package": "hxt",
          "partial": "File Mime Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theFileMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theHttpHandler",
          "package": "hxt",
          "signature": "Selector XIOSysState (IOSArrow XmlTree XmlTree)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theHttpHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theHttpHandler",
          "package": "hxt",
          "partial": "Http Handler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theHttpHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theIgnoreNoneXmlContents",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theIgnoreNoneXmlContents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theIgnoreNoneXmlContents",
          "package": "hxt",
          "partial": "Ignore None Xml Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theIgnoreNoneXmlContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theIndent",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theIndent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theIndent",
          "package": "hxt",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theInputConfig",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOInputConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theInputConfig",
          "package": "hxt",
          "partial": "Input Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theInputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theInputEncoding",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theInputEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theInputEncoding",
          "package": "hxt",
          "partial": "Input Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theInputEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theInputOptions",
          "package": "hxt",
          "signature": "Selector XIOSysState Attributes",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theInputOptions",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theInputOptions",
          "package": "hxt",
          "partial": "Input Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theInputOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theLowerCaseNames",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theLowerCaseNames",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theLowerCaseNames",
          "package": "hxt",
          "partial": "Lower Case Names",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theLowerCaseNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theMimeTypeFile",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theMimeTypeFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theMimeTypeFile",
          "package": "hxt",
          "partial": "Mime Type File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theMimeTypeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theMimeTypeHandlers",
          "package": "hxt",
          "signature": "Selector XIOSysState MimeTypeHandlers",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theMimeTypeHandlers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theMimeTypeHandlers",
          "package": "hxt",
          "partial": "Mime Type Handlers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theMimeTypeHandlers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theMimeTypes",
          "package": "hxt",
          "signature": "Selector XIOSysState MimeTypeTable",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theMimeTypes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theMimeTypes",
          "package": "hxt",
          "partial": "Mime Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theMimeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theNoEmptyElemFor",
          "package": "hxt",
          "signature": "Selector XIOSysState [String]",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theNoEmptyElemFor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theNoEmptyElemFor",
          "normalized": "Selector XIOSysState[String]",
          "package": "hxt",
          "partial": "No Empty Elem For",
          "signature": "Selector XIOSysState[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theNoEmptyElemFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theOutputConfig",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOOutputConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theOutputConfig",
          "package": "hxt",
          "partial": "Output Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theOutputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theOutputEncoding",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theOutputEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theOutputEncoding",
          "package": "hxt",
          "partial": "Output Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theOutputEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theOutputFmt",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOXoutConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theOutputFmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theOutputFmt",
          "package": "hxt",
          "partial": "Output Fmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theOutputFmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theParseByMimeType",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theParseByMimeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theParseByMimeType",
          "package": "hxt",
          "partial": "Parse By Mime Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theParseByMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theParseConfig",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOParseConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theParseConfig",
          "package": "hxt",
          "partial": "Parse Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theParseConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theParseHTML",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theParseHTML",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theParseHTML",
          "package": "hxt",
          "partial": "Parse HTML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theParseHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "thePreserveComment",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#thePreserveComment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "thePreserveComment",
          "package": "hxt",
          "partial": "Preserve Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:thePreserveComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theProxy",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theProxy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theProxy",
          "package": "hxt",
          "partial": "Proxy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theProxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRedirect",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRedirect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRedirect",
          "package": "hxt",
          "partial": "Redirect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRedirect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxAttrList",
          "package": "hxt",
          "signature": "Selector XIOSysState (AssocList String XmlTrees)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxAttrList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxAttrList",
          "package": "hxt",
          "partial": "Relax Attr List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxAttrList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxCheckRestr",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxCheckRestr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxCheckRestr",
          "package": "hxt",
          "partial": "Relax Check Restr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxCheckRestr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxCollectErrors",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxCollectErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxCollectErrors",
          "package": "hxt",
          "partial": "Relax Collect Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxCollectErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxConfig",
          "package": "hxt",
          "signature": "Selector XIOSysState XIORelaxConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxConfig",
          "package": "hxt",
          "partial": "Relax Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxDefineId",
          "package": "hxt",
          "signature": "Selector XIOSysState Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxDefineId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxDefineId",
          "package": "hxt",
          "partial": "Relax Define Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxDefineId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxNoOfErrors",
          "package": "hxt",
          "signature": "Selector XIOSysState Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxNoOfErrors",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxNoOfErrors",
          "package": "hxt",
          "partial": "Relax No Of Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxNoOfErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxSchema",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxSchema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxSchema",
          "package": "hxt",
          "partial": "Relax Schema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxSchema"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidate",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxValidate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidate",
          "package": "hxt",
          "partial": "Relax Validate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxValidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidateExtRef",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxValidateExtRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidateExtRef",
          "package": "hxt",
          "partial": "Relax Validate Ext Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxValidateExtRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidateInclude",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxValidateInclude",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidateInclude",
          "package": "hxt",
          "partial": "Relax Validate Include",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxValidateInclude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidator",
          "package": "hxt",
          "signature": "Selector XIOSysState (IOSArrow XmlTree XmlTree)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRelaxValidator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRelaxValidator",
          "package": "hxt",
          "partial": "Relax Validator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRelaxValidator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRemoveWS",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theRemoveWS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theRemoveWS",
          "package": "hxt",
          "partial": "Remove WS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theRemoveWS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theShowHaskell",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theShowHaskell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theShowHaskell",
          "package": "hxt",
          "partial": "Show Haskell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theShowHaskell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theShowTree",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theShowTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theShowTree",
          "package": "hxt",
          "partial": "Show Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theShowTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theStrictDeserialize",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theStrictDeserialize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theStrictDeserialize",
          "package": "hxt",
          "partial": "Strict Deserialize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theStrictDeserialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theStrictInput",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theStrictInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theStrictInput",
          "package": "hxt",
          "partial": "Strict Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theStrictInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSubstDTDEntities",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theSubstDTDEntities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSubstDTDEntities",
          "package": "hxt",
          "partial": "Subst DTDEntities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theSubstDTDEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSubstHTMLEntities",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theSubstHTMLEntities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSubstHTMLEntities",
          "package": "hxt",
          "partial": "Subst HTMLEntities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theSubstHTMLEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSysEnv",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOSysEnv",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSysEnv",
          "package": "hxt",
          "partial": "Sys Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theSysEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSysState",
          "package": "hxt",
          "signature": "Selector (XIOState us) XIOSysState",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theSysState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSysState",
          "package": "hxt",
          "partial": "Sys State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theSysState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSysWriter",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOSysWriter",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theSysWriter",
          "package": "hxt",
          "partial": "Sys Writer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theSysWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTagSoup",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theTagSoup",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTagSoup",
          "package": "hxt",
          "partial": "Tag Soup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theTagSoup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTagSoupParser",
          "package": "hxt",
          "signature": "Selector XIOSysState (IOSArrow XmlTree XmlTree)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theTagSoupParser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTagSoupParser",
          "package": "hxt",
          "partial": "Tag Soup Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theTagSoupParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTextMode",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theTextMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTextMode",
          "package": "hxt",
          "partial": "Text Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theTextMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTrace",
          "package": "hxt",
          "signature": "Selector XIOSysState (Int, Int -\u003e String -\u003e IO ())",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theTrace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTrace",
          "normalized": "Selector XIOSysState(Int,Int-\u003eString-\u003eIO())",
          "package": "hxt",
          "partial": "Trace",
          "signature": "Selector XIOSysState(Int,Int-\u003eString-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theTrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTraceCmd",
          "package": "hxt",
          "signature": "Selector XIOSysState (Int -\u003e String -\u003e IO ())",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theTraceCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTraceCmd",
          "normalized": "Selector XIOSysState(Int-\u003eString-\u003eIO())",
          "package": "hxt",
          "partial": "Trace Cmd",
          "signature": "Selector XIOSysState(Int-\u003eString-\u003eIO())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theTraceCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTraceLevel",
          "package": "hxt",
          "signature": "Selector XIOSysState Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theTraceLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theTraceLevel",
          "package": "hxt",
          "partial": "Trace Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theTraceLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theUserState",
          "package": "hxt",
          "signature": "Selector (XIOState us) us",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theUserState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theUserState",
          "package": "hxt",
          "partial": "User State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theValidate",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theValidate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theValidate",
          "package": "hxt",
          "partial": "Validate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theValidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theWarnings",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theWarnings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theWarnings",
          "package": "hxt",
          "partial": "Warnings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theWithCache",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theWithCache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theWithCache",
          "package": "hxt",
          "partial": "With Cache",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theWithCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlPi",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theXmlPi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlPi",
          "package": "hxt",
          "partial": "Xml Pi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theXmlPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaConfig",
          "package": "hxt",
          "signature": "Selector XIOSysState XIOXmlSchemaConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theXmlSchemaConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaConfig",
          "package": "hxt",
          "partial": "Xml Schema Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theXmlSchemaConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaSchema",
          "package": "hxt",
          "signature": "Selector XIOSysState String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theXmlSchemaSchema",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaSchema",
          "package": "hxt",
          "partial": "Xml Schema Schema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theXmlSchemaSchema"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaValidate",
          "package": "hxt",
          "signature": "Selector XIOSysState Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theXmlSchemaValidate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaValidate",
          "package": "hxt",
          "partial": "Xml Schema Validate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theXmlSchemaValidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaValidator",
          "package": "hxt",
          "signature": "Selector XIOSysState (IOSArrow XmlTree XmlTree)",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#theXmlSchemaValidator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "theXmlSchemaValidator",
          "package": "hxt",
          "partial": "Xml Schema Validator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:theXmlSchemaValidator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "toInt",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#toInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "toInt",
          "normalized": "Int-\u003eString-\u003eInt",
          "package": "hxt",
          "partial": "Int",
          "signature": "Int-\u003eString-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:toInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove an entry in global state, arrow input remains unchanged\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "unsetSysAttr",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b b",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#unsetSysAttr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:unsetSysAttr\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:unsetSysAttr\"]"
        },
        "index": {
          "description": "remove an entry in global state arrow input remains unchanged",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "unsetSysAttr",
          "normalized": "String-\u003eIOStateArrow a b b",
          "package": "hxt",
          "partial": "Sys Attr",
          "signature": "String-\u003eIOStateArrow s b b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:unsetSysAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextend user state\n\u003c/p\u003e\u003cp\u003eRun an arrow with an extended user state component, The old component\n is stored together with a new one in a pair, the arrow is executed with this\n extended state, and the augmented state component is removed form the state\n when the arrow has finished its execution\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withExtendedUserState",
          "package": "hxt",
          "signature": "s1 -\u003e IOStateArrow (s1, s0) b c -\u003e IOStateArrow s0 b c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#withExtendedUserState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:withExtendedUserState\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withExtendedUserState\"]"
        },
        "index": {
          "description": "extend user state Run an arrow with an extended user state component The old component is stored together with new one in pair the arrow is executed with this extended state and the augmented state component is removed form the state when the arrow has finished its execution",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "withExtendedUserState",
          "normalized": "a-\u003eIOStateArrow(a,a)b c-\u003eIOStateArrow a b c",
          "package": "hxt",
          "partial": "Extended User State",
          "signature": "s-\u003eIOStateArrow(s,s)b c-\u003eIOStateArrow s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:withExtendedUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echange the type of user state\n\u003c/p\u003e\u003cp\u003eThis conversion is useful, when running a state arrow with another\n structure of the user state, e.g. with () when executing some IO arrows\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withOtherUserState",
          "package": "hxt",
          "signature": "s1 -\u003e IOStateArrow s1 b c -\u003e IOStateArrow s0 b c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#withOtherUserState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:withOtherUserState\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withOtherUserState\"]"
        },
        "index": {
          "description": "change the type of user state This conversion is useful when running state arrow with another structure of the user state e.g with when executing some IO arrows",
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "withOtherUserState",
          "normalized": "a-\u003eIOStateArrow a b c-\u003eIOStateArrow a b c",
          "package": "hxt",
          "partial": "Other User State",
          "signature": "s-\u003eIOStateArrow s b c-\u003eIOStateArrow s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:withOtherUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Text.XML.HXT.Arrow.XmlState.TypeDefs\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "withoutUserState",
          "package": "hxt",
          "signature": "IOSArrow b c -\u003e IOStateArrow s0 b c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#withoutUserState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:withoutUserState\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:withoutUserState\"]"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "withoutUserState",
          "normalized": "IOSArrow a b-\u003eIOStateArrow c a b",
          "package": "hxt",
          "partial": "User State",
          "signature": "IOSArrow b c-\u003eIOStateArrow s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:withoutUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioAcceptedMimeTypes",
          "package": "hxt",
          "signature": "[String]",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioAcceptedMimeTypes",
          "normalized": "[String]",
          "package": "hxt",
          "partial": "Accepted Mime Types",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioAcceptedMimeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioAddDefaultDTD",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioAddDefaultDTD",
          "package": "hxt",
          "partial": "Add Default DTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioAddDefaultDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioAttrList",
          "package": "hxt",
          "signature": "Attributes",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioAttrList",
          "package": "hxt",
          "partial": "Attr List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioAttrList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioBaseURI",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioBaseURI",
          "package": "hxt",
          "partial": "Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioBinaryCompression",
          "package": "hxt",
          "signature": "CompressionFct",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioBinaryCompression",
          "package": "hxt",
          "partial": "Binary Compression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioBinaryCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioBinaryDeCompression",
          "package": "hxt",
          "signature": "DeCompressionFct",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioBinaryDeCompression",
          "package": "hxt",
          "partial": "Binary De Compression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioBinaryDeCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCache404Err",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCache404Err",
          "package": "hxt",
          "partial": "Cache Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioCache404Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCacheConfig",
          "package": "hxt",
          "signature": "XIOCacheConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCacheConfig",
          "package": "hxt",
          "partial": "Cache Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioCacheConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCacheDir",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCacheDir",
          "package": "hxt",
          "partial": "Cache Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioCacheDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCacheRead",
          "package": "hxt",
          "signature": "String -\u003e IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCacheRead",
          "normalized": "String-\u003eIOSArrow XmlTree XmlTree",
          "package": "hxt",
          "partial": "Cache Read",
          "signature": "String-\u003eIOSArrow XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioCacheRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCanonicalize",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCanonicalize",
          "package": "hxt",
          "partial": "Canonicalize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioCanonicalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCheckNamespaces",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioCheckNamespaces",
          "package": "hxt",
          "partial": "Check Namespaces",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioCheckNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioDefaultBaseURI",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioDefaultBaseURI",
          "package": "hxt",
          "partial": "Default Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioDefaultBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioDocumentAge",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioDocumentAge",
          "package": "hxt",
          "partial": "Document Age",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioDocumentAge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioEncodingErrors",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioEncodingErrors",
          "package": "hxt",
          "partial": "Encoding Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioEncodingErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorMsgCollect",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorMsgCollect",
          "package": "hxt",
          "partial": "Error Msg Collect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioErrorMsgCollect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorMsgHandler",
          "package": "hxt",
          "signature": "String -\u003e IO ()",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorMsgHandler",
          "normalized": "String-\u003eIO()",
          "package": "hxt",
          "partial": "Error Msg Handler",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioErrorMsgHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorMsgList",
          "package": "hxt",
          "signature": "XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorMsgList",
          "package": "hxt",
          "partial": "Error Msg List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioErrorMsgList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorStatus",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioErrorStatus",
          "package": "hxt",
          "partial": "Error Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioErrorStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioExpat",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioExpat",
          "package": "hxt",
          "partial": "Expat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioExpat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioExpatErrors",
          "package": "hxt",
          "signature": "IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioExpatErrors",
          "package": "hxt",
          "partial": "Expat Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioExpatErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioExpatParser",
          "package": "hxt",
          "signature": "IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioExpatParser",
          "package": "hxt",
          "partial": "Expat Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioExpatParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioFileMimeType",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioFileMimeType",
          "package": "hxt",
          "partial": "File Mime Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioFileMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioHttpHandler",
          "package": "hxt",
          "signature": "IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioHttpHandler",
          "package": "hxt",
          "partial": "Http Handler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioHttpHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioIgnoreNoneXmlContents",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioIgnoreNoneXmlContents",
          "package": "hxt",
          "partial": "Ignore None Xml Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioIgnoreNoneXmlContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioIndent",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioIndent",
          "package": "hxt",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioInputConfig",
          "package": "hxt",
          "signature": "XIOInputConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioInputConfig",
          "package": "hxt",
          "partial": "Input Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioInputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioInputEncoding",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioInputEncoding",
          "package": "hxt",
          "partial": "Input Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioInputEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioInputOptions",
          "package": "hxt",
          "signature": "Attributes",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioInputOptions",
          "package": "hxt",
          "partial": "Input Options",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioInputOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioLowerCaseNames",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioLowerCaseNames",
          "package": "hxt",
          "partial": "Lower Case Names",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioLowerCaseNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioMimeTypeFile",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioMimeTypeFile",
          "package": "hxt",
          "partial": "Mime Type File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioMimeTypeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioMimeTypeHandlers",
          "package": "hxt",
          "signature": "MimeTypeHandlers",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioMimeTypeHandlers",
          "package": "hxt",
          "partial": "Mime Type Handlers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioMimeTypeHandlers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioMimeTypes",
          "package": "hxt",
          "signature": "MimeTypeTable",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioMimeTypes",
          "package": "hxt",
          "partial": "Mime Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioMimeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioNoEmptyElemFor",
          "package": "hxt",
          "signature": "[String]",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioNoEmptyElemFor",
          "normalized": "[String]",
          "package": "hxt",
          "partial": "No Empty Elem For",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioNoEmptyElemFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioOutputConfig",
          "package": "hxt",
          "signature": "XIOOutputConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioOutputConfig",
          "package": "hxt",
          "partial": "Output Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioOutputConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioOutputEncoding",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioOutputEncoding",
          "package": "hxt",
          "partial": "Output Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioOutputEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioOutputFmt",
          "package": "hxt",
          "signature": "XIOXoutConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioOutputFmt",
          "package": "hxt",
          "partial": "Output Fmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioOutputFmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioParseByMimeType",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioParseByMimeType",
          "package": "hxt",
          "partial": "Parse By Mime Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioParseByMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioParseConfig",
          "package": "hxt",
          "signature": "XIOParseConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioParseConfig",
          "package": "hxt",
          "partial": "Parse Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioParseConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioParseHTML",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioParseHTML",
          "package": "hxt",
          "partial": "Parse HTML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioParseHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioPreserveComment",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioPreserveComment",
          "package": "hxt",
          "partial": "Preserve Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioPreserveComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioProxy",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioProxy",
          "package": "hxt",
          "partial": "Proxy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioProxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRedirect",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRedirect",
          "package": "hxt",
          "partial": "Redirect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRedirect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxAttrList",
          "package": "hxt",
          "signature": "AssocList String XmlTrees",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxAttrList",
          "package": "hxt",
          "partial": "Relax Attr List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxAttrList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxCheckRestr",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxCheckRestr",
          "package": "hxt",
          "partial": "Relax Check Restr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxCheckRestr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxCollectErrors",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxCollectErrors",
          "package": "hxt",
          "partial": "Relax Collect Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxCollectErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxConfig",
          "package": "hxt",
          "signature": "XIORelaxConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxConfig",
          "package": "hxt",
          "partial": "Relax Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxDefineId",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxDefineId",
          "package": "hxt",
          "partial": "Relax Define Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxDefineId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxNoOfErrors",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysWriter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxNoOfErrors",
          "package": "hxt",
          "partial": "Relax No Of Errors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxNoOfErrors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxSchema",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxSchema",
          "package": "hxt",
          "partial": "Relax Schema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxSchema"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidate",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidate",
          "package": "hxt",
          "partial": "Relax Validate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxValidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidateExtRef",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidateExtRef",
          "package": "hxt",
          "partial": "Relax Validate Ext Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxValidateExtRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidateInclude",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidateInclude",
          "package": "hxt",
          "partial": "Relax Validate Include",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxValidateInclude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidator",
          "package": "hxt",
          "signature": "IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIORelaxConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRelaxValidator",
          "package": "hxt",
          "partial": "Relax Validator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRelaxValidator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRemoveWS",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioRemoveWS",
          "package": "hxt",
          "partial": "Remove WS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioRemoveWS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioShowHaskell",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioShowHaskell",
          "package": "hxt",
          "partial": "Show Haskell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioShowHaskell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioShowTree",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioShowTree",
          "package": "hxt",
          "partial": "Show Tree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioShowTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioStrictDeserialize",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioStrictDeserialize",
          "package": "hxt",
          "partial": "Strict Deserialize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioStrictDeserialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioStrictInput",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOInputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioStrictInput",
          "package": "hxt",
          "partial": "Strict Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioStrictInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSubstDTDEntities",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSubstDTDEntities",
          "package": "hxt",
          "partial": "Subst DTDEntities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioSubstDTDEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSubstHTMLEntities",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSubstHTMLEntities",
          "package": "hxt",
          "partial": "Subst HTMLEntities",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioSubstHTMLEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSysEnv",
          "package": "hxt",
          "signature": "XIOSysEnv",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSysEnv",
          "package": "hxt",
          "partial": "Sys Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioSysEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSysState",
          "package": "hxt",
          "signature": "XIOSysState",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSysState",
          "package": "hxt",
          "partial": "Sys State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioSysState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSysWriter",
          "package": "hxt",
          "signature": "XIOSysWriter",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioSysWriter",
          "package": "hxt",
          "partial": "Sys Writer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioSysWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTagSoup",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTagSoup",
          "package": "hxt",
          "partial": "Tag Soup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioTagSoup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTagSoupParser",
          "package": "hxt",
          "signature": "IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTagSoupParser",
          "package": "hxt",
          "partial": "Tag Soup Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioTagSoupParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTextMode",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTextMode",
          "package": "hxt",
          "partial": "Text Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioTextMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTraceCmd",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e IO ()",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTraceCmd",
          "normalized": "Int-\u003eString-\u003eIO()",
          "package": "hxt",
          "partial": "Trace Cmd",
          "signature": "Int-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioTraceCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTraceLevel",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioTraceLevel",
          "package": "hxt",
          "partial": "Trace Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioTraceLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioUserState",
          "package": "hxt",
          "signature": "us",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioUserState",
          "package": "hxt",
          "partial": "User State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioUserState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioValidate",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioValidate",
          "package": "hxt",
          "partial": "Validate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioValidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioWarnings",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOParseConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioWarnings",
          "package": "hxt",
          "partial": "Warnings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioWarnings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioWithCache",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOCacheConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioWithCache",
          "package": "hxt",
          "partial": "With Cache",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioWithCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlPi",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOOutputConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlPi",
          "package": "hxt",
          "partial": "Xml Pi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioXmlPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaConfig",
          "package": "hxt",
          "signature": "XIOXmlSchemaConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaConfig",
          "package": "hxt",
          "partial": "Xml Schema Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioXmlSchemaConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaSchema",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXmlSchemaConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaSchema",
          "package": "hxt",
          "partial": "Xml Schema Schema",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioXmlSchemaSchema"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaValidate",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXmlSchemaConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaValidate",
          "package": "hxt",
          "partial": "Xml Schema Validate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioXmlSchemaValidate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaValidator",
          "package": "hxt",
          "signature": "IOSArrow XmlTree XmlTree",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOXmlSchemaConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState TypeDefs",
          "module": "Text.XML.HXT.Arrow.XmlState.TypeDefs",
          "name": "xioXmlSchemaValidator",
          "package": "hxt",
          "partial": "Xml Schema Validator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#v:xioXmlSchemaValidator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethe basic state arrows for URI handling\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "URIHandling",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html",
          "type": "module"
        },
        "index": {
          "description": "the basic state arrows for URI handling",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "URIHandling",
          "package": "hxt",
          "partial": "URIHandling",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echange the base URI with a possibly relative URI, can be used for\n evaluating the xml:base attribute. Returns the new absolute base URI.\n Fails, if input is not parsable with parseURIReference\n\u003c/p\u003e\u003cp\u003esee also: \u003ccode\u003e\u003ca\u003esetBaseURI\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emkAbsURI\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "changeBaseURI",
          "package": "hxt",
          "signature": "IOStateArrow s String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#changeBaseURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:changeBaseURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:changeBaseURI\"]"
        },
        "index": {
          "description": "change the base URI with possibly relative URI can be used for evaluating the xml base attribute Returns the new absolute base URI Fails if input is not parsable with parseURIReference see also setBaseURI mkAbsURI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "changeBaseURI",
          "package": "hxt",
          "partial": "Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:changeBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow variant of \u003ccode\u003e\u003ca\u003eexpandURIString\u003c/a\u003e\u003c/code\u003e, fails if \u003ccode\u003e\u003ca\u003eexpandURIString\u003c/a\u003e\u003c/code\u003e returns Nothing\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "expandURI",
          "package": "hxt",
          "signature": "a (String, String) String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#expandURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:expandURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:expandURI\"]"
        },
        "index": {
          "description": "arrow variant of expandURIString fails if expandURIString returns Nothing",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "expandURI",
          "normalized": "a(String,String)String",
          "package": "hxt",
          "partial": "URI",
          "signature": "a(String,String)String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:expandURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecompute the absolut URI for a given URI and a base URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "expandURIString",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#expandURIString",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:expandURIString\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:expandURIString\"]"
        },
        "index": {
          "description": "compute the absolut URI for given URI and base URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "expandURIString",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "hxt",
          "partial": "URIString",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:expandURIString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eread the base URI from the globale state\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getBaseURI",
          "package": "hxt",
          "signature": "IOStateArrow s b String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getBaseURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getBaseURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getBaseURI\"]"
        },
        "index": {
          "description": "read the base URI from the globale state",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getBaseURI",
          "package": "hxt",
          "partial": "Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eget the default base URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getDefaultBaseURI",
          "package": "hxt",
          "signature": "IOStateArrow s b String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getDefaultBaseURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getDefaultBaseURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getDefaultBaseURI\"]"
        },
        "index": {
          "description": "get the default base URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getDefaultBaseURI",
          "package": "hxt",
          "partial": "Default Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getDefaultBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for computing the fragment component of an URI, fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getFragmentFromURI",
          "package": "hxt",
          "signature": "a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getFragmentFromURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getFragmentFromURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getFragmentFromURI\"]"
        },
        "index": {
          "description": "arrow for computing the fragment component of an URI fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getFragmentFromURI",
          "package": "hxt",
          "partial": "Fragment From URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getFragmentFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for computing the path component of an URI, fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getPartFromURI",
          "package": "hxt",
          "signature": "(URI -\u003e String) -\u003e a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getPartFromURI",
          "type": "function"
        },
        "index": {
          "description": "arrow for computing the path component of an URI fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getPartFromURI",
          "normalized": "(URI-\u003eString)-\u003ea String String",
          "package": "hxt",
          "partial": "Part From URI",
          "signature": "(URI-\u003eString)-\u003ea String String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getPartFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for computing the path component of an URI, fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getPathFromURI",
          "package": "hxt",
          "signature": "a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getPathFromURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getPathFromURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getPathFromURI\"]"
        },
        "index": {
          "description": "arrow for computing the path component of an URI fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getPathFromURI",
          "package": "hxt",
          "partial": "Path From URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getPathFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for selecting the port number of the URI without leading ':', fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getPortFromURI",
          "package": "hxt",
          "signature": "a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getPortFromURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getPortFromURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getPortFromURI\"]"
        },
        "index": {
          "description": "arrow for selecting the port number of the URI without leading fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getPortFromURI",
          "package": "hxt",
          "partial": "Port From URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getPortFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for computing the query component of an URI, fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getQueryFromURI",
          "package": "hxt",
          "signature": "a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getQueryFromURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getQueryFromURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getQueryFromURI\"]"
        },
        "index": {
          "description": "arrow for computing the query component of an URI fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getQueryFromURI",
          "package": "hxt",
          "partial": "Query From URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getQueryFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for selecting the registered name (host) of the URI, fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getRegNameFromURI",
          "package": "hxt",
          "signature": "a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getRegNameFromURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getRegNameFromURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getRegNameFromURI\"]"
        },
        "index": {
          "description": "arrow for selecting the registered name host of the URI fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getRegNameFromURI",
          "package": "hxt",
          "partial": "Reg Name From URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getRegNameFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for selecting the scheme (protocol) of the URI, fails if input is not a legal URI.\n\u003c/p\u003e\u003cp\u003eSee Network.URI for URI components\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getSchemeFromURI",
          "package": "hxt",
          "signature": "a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getSchemeFromURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getSchemeFromURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getSchemeFromURI\"]"
        },
        "index": {
          "description": "arrow for selecting the scheme protocol of the URI fails if input is not legal URI See Network.URI for URI components",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getSchemeFromURI",
          "package": "hxt",
          "partial": "Scheme From URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getSchemeFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for selecting the user info of the URI without trailing '@', fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "getUserInfoFromURI",
          "package": "hxt",
          "signature": "a String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#getUserInfoFromURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getUserInfoFromURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:getUserInfoFromURI\"]"
        },
        "index": {
          "description": "arrow for selecting the user info of the URI without trailing fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "getUserInfoFromURI",
          "package": "hxt",
          "partial": "User Info From URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:getUserInfoFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow for expanding an input URI into an absolute URI using global base URI, fails if input is not a legal URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "mkAbsURI",
          "package": "hxt",
          "signature": "IOStateArrow s String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#mkAbsURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:mkAbsURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:mkAbsURI\"]"
        },
        "index": {
          "description": "arrow for expanding an input URI into an absolute URI using global base URI fails if input is not legal URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "mkAbsURI",
          "package": "hxt",
          "partial": "Abs URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:mkAbsURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a URI reference, in case of a failure,\n try to escape unescaped chars, convert backslashes to slashes for windows paths,\n and try parsing again\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "parseURIReference'",
          "package": "hxt",
          "signature": "String -\u003e Maybe URI",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#parseURIReference%27",
          "type": "function"
        },
        "index": {
          "description": "parse URI reference in case of failure try to escape unescaped chars convert backslashes to slashes for windows paths and try parsing again",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "parseURIReference'",
          "normalized": "String-\u003eMaybe URI",
          "package": "hxt",
          "partial": "URIReference'",
          "signature": "String-\u003eMaybe URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:parseURIReference-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremember base uri, run an arrow and restore the base URI, used with external entity substitution\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "runInLocalURIContext",
          "package": "hxt",
          "signature": "IOStateArrow s b c -\u003e IOStateArrow s b c",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#runInLocalURIContext",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:runInLocalURIContext\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:runInLocalURIContext\"]"
        },
        "index": {
          "description": "remember base uri run an arrow and restore the base URI used with external entity substitution",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "runInLocalURIContext",
          "normalized": "IOStateArrow a b c-\u003eIOStateArrow a b c",
          "package": "hxt",
          "partial": "In Local URIContext",
          "signature": "IOStateArrow s b c-\u003eIOStateArrow s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:runInLocalURIContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the base URI of a document, used e.g. for reading includes, e.g. external entities,\n the input must be an absolute URI\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setBaseURI",
          "package": "hxt",
          "signature": "IOStateArrow s String String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#setBaseURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:setBaseURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setBaseURI\"]"
        },
        "index": {
          "description": "set the base URI of document used e.g for reading includes e.g external entities the input must be an absolute URI",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "setBaseURI",
          "package": "hxt",
          "partial": "Base URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:setBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset the default base URI, if parameter is null, the system base (\u003ccode\u003e file:///\u003ccwd\u003e/ \u003c/code\u003e) is used,\n else the parameter, must be called before any document is read\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlState.URIHandling\",\"Text.XML.HXT.Arrow.XmlState\"]",
          "name": "setDefaultBaseURI",
          "package": "hxt",
          "signature": "String -\u003e IOStateArrow s b String",
          "source": "src/Text-XML-HXT-Arrow-XmlState-URIHandling.html#setDefaultBaseURI",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:setDefaultBaseURI\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#v:setDefaultBaseURI\"]"
        },
        "index": {
          "description": "set the default base URI if parameter is null the system base file cwd is used else the parameter must be called before any document is read",
          "hierarchy": "Text XML HXT Arrow XmlState URIHandling",
          "module": "Text.XML.HXT.Arrow.XmlState.URIHandling",
          "name": "setDefaultBaseURI",
          "normalized": "String-\u003eIOStateArrow a b String",
          "package": "hxt",
          "partial": "Default Base URI",
          "signature": "String-\u003eIOStateArrow s b String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState-URIHandling.html#v:setDefaultBaseURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ethe interface for the basic state maipulation functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "XmlState",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState.html",
          "type": "module"
        },
        "index": {
          "description": "the interface for the basic state maipulation functions",
          "hierarchy": "Text XML HXT Arrow XmlState",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "XmlState",
          "package": "hxt",
          "partial": "Xml State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arrow for stateful arrows with no user defined state\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "IOSArrow",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#IOSArrow",
          "type": "type"
        },
        "index": {
          "description": "The arrow for stateful arrows with no user defined state",
          "hierarchy": "Text XML HXT Arrow XmlState",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "IOSArrow",
          "package": "hxt",
          "partial": "IOSArrow",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#t:IOSArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe arrow type for stateful arrows\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "IOStateArrow",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#IOStateArrow",
          "type": "type"
        },
        "index": {
          "description": "The arrow type for stateful arrows",
          "hierarchy": "Text XML HXT Arrow XmlState",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "IOStateArrow",
          "package": "hxt",
          "partial": "IOState Arrow",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#t:IOStateArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "SysConfig",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#SysConfig",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "SysConfig",
          "package": "hxt",
          "partial": "Sys Config",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#t:SysConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "SysConfigList",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#SysConfigList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlState",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "SysConfigList",
          "package": "hxt",
          "partial": "Sys Config List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#t:SysConfigList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estate datatype consists of a system state and a user state\n the user state is not fixed\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "XIOState",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOState",
          "type": "data"
        },
        "index": {
          "description": "state datatype consists of system state and user state the user state is not fixed",
          "hierarchy": "Text XML HXT Arrow XmlState",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "XIOState",
          "package": "hxt",
          "partial": "XIOState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#t:XIOState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epredefined system state data type with all components for the\n system functions, like trace, error handling, ...\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "XIOSysState",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Arrow-XmlState-TypeDefs.html#XIOSysState",
          "type": "data"
        },
        "index": {
          "description": "predefined system state data type with all components for the system functions like trace error handling",
          "hierarchy": "Text XML HXT Arrow XmlState",
          "module": "Text.XML.HXT.Arrow.XmlState",
          "name": "XIOSysState",
          "package": "hxt",
          "partial": "XIOSys State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlState.html#t:XIOSysState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe HXT arrow interface\n\u003c/p\u003e\u003cp\u003eThe application programming interface to the arrow modules of the Haskell XML Toolbox.\n   This module exports all important arrows for input, output, parsing, validating and transforming XML.\n   It also exports all basic datatypes and functions of the toolbox.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Core",
          "name": "Core",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Core.html",
          "type": "module"
        },
        "index": {
          "description": "The HXT arrow interface The application programming interface to the arrow modules of the Haskell XML Toolbox This module exports all important arrows for input output parsing validating and transforming XML It also exports all basic datatypes and functions of the toolbox",
          "hierarchy": "Text XML HXT Core",
          "module": "Text.XML.HXT.Core",
          "name": "Core",
          "package": "hxt",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFormat a xml tree in tree representation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.FormatXmlTree",
          "name": "FormatXmlTree",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-FormatXmlTree.html",
          "type": "module"
        },
        "index": {
          "description": "Format xml tree in tree representation",
          "hierarchy": "Text XML HXT DOM FormatXmlTree",
          "module": "Text.XML.HXT.DOM.FormatXmlTree",
          "name": "FormatXmlTree",
          "package": "hxt",
          "partial": "Format Xml Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-FormatXmlTree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.FormatXmlTree",
          "name": "formatXmlContents",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-DOM-FormatXmlTree.html#formatXmlContents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM FormatXmlTree",
          "module": "Text.XML.HXT.DOM.FormatXmlTree",
          "name": "formatXmlContents",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Contents",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-FormatXmlTree.html#v:formatXmlContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.FormatXmlTree",
          "name": "formatXmlTree",
          "package": "hxt",
          "signature": "XmlTree -\u003e String",
          "source": "src/Text-XML-HXT-DOM-FormatXmlTree.html#formatXmlTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM FormatXmlTree",
          "module": "Text.XML.HXT.DOM.FormatXmlTree",
          "name": "formatXmlTree",
          "normalized": "XmlTree-\u003eString",
          "package": "hxt",
          "partial": "Xml Tree",
          "signature": "XmlTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-FormatXmlTree.html#v:formatXmlTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe interface to the primitive DOM data types and constants\n   and utility functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.Interface",
          "name": "Interface",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-Interface.html",
          "type": "module"
        },
        "index": {
          "description": "The interface to the primitive DOM data types and constants and utility functions",
          "hierarchy": "Text XML HXT DOM Interface",
          "module": "Text.XML.HXT.DOM.Interface",
          "name": "Interface",
          "package": "hxt",
          "partial": "Interface",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Interface.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003edefault mime type table\n\u003c/p\u003e\u003cp\u003ethis file is generated from file \u003cem\u003eetc\u003c/em\u003emime.types\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.MimeTypeDefaults",
          "name": "MimeTypeDefaults",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-MimeTypeDefaults.html",
          "type": "module"
        },
        "index": {
          "description": "default mime type table this file is generated from file etc mime.types",
          "hierarchy": "Text XML HXT DOM MimeTypeDefaults",
          "module": "Text.XML.HXT.DOM.MimeTypeDefaults",
          "name": "MimeTypeDefaults",
          "package": "hxt",
          "partial": "Mime Type Defaults",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypeDefaults.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe table with the mapping from file name extensions to mime types\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.MimeTypeDefaults",
          "name": "mimeTypeDefaults",
          "package": "hxt",
          "signature": "[(String, String)]",
          "source": "src/Text-XML-HXT-DOM-MimeTypeDefaults.html#mimeTypeDefaults",
          "type": "function"
        },
        "index": {
          "description": "the table with the mapping from file name extensions to mime types",
          "hierarchy": "Text XML HXT DOM MimeTypeDefaults",
          "module": "Text.XML.HXT.DOM.MimeTypeDefaults",
          "name": "mimeTypeDefaults",
          "normalized": "[(String,String)]",
          "package": "hxt",
          "partial": "Type Defaults",
          "signature": "[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypeDefaults.html#v:mimeTypeDefaults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003emime type related data and functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "MimeTypes",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html",
          "type": "module"
        },
        "index": {
          "description": "mime type related data and functions",
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "MimeTypes",
          "package": "hxt",
          "partial": "Mime Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "MimeTypeTable",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#MimeTypeTable",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "MimeTypeTable",
          "package": "hxt",
          "partial": "Mime Type Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#t:MimeTypeTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xhtml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#application_xhtml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xhtml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:application_xhtml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#application_xml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:application_xml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xml_dtd",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#application_xml_dtd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xml_dtd",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:application_xml_dtd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xml_external_parsed_entity",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#application_xml_external_parsed_entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "application_xml_external_parsed_entity",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:application_xml_external_parsed_entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "defaultMimeTypeTable",
          "package": "hxt",
          "signature": "MimeTypeTable",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#defaultMimeTypeTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "defaultMimeTypeTable",
          "package": "hxt",
          "partial": "Mime Type Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:defaultMimeTypeTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "extensionToMimeType",
          "package": "hxt",
          "signature": "String -\u003e MimeTypeTable -\u003e String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#extensionToMimeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "extensionToMimeType",
          "normalized": "String-\u003eMimeTypeTable-\u003eString",
          "package": "hxt",
          "partial": "To Mime Type",
          "signature": "String-\u003eMimeTypeTable-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:extensionToMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "isHtmlMimeType",
          "package": "hxt",
          "signature": "String -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#isHtmlMimeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "isHtmlMimeType",
          "normalized": "String-\u003eBool",
          "package": "hxt",
          "partial": "Html Mime Type",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:isHtmlMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "isTextMimeType",
          "package": "hxt",
          "signature": "String -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#isTextMimeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "isTextMimeType",
          "normalized": "String-\u003eBool",
          "package": "hxt",
          "partial": "Text Mime Type",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:isTextMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "isXmlMimeType",
          "package": "hxt",
          "signature": "String -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#isXmlMimeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "isXmlMimeType",
          "normalized": "String-\u003eBool",
          "package": "hxt",
          "partial": "Xml Mime Type",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:isXmlMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "parseMimeTypeTable",
          "package": "hxt",
          "signature": "String -\u003e [(String, String)]",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#parseMimeTypeTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "parseMimeTypeTable",
          "normalized": "String-\u003e[(String,String)]",
          "package": "hxt",
          "partial": "Mime Type Table",
          "signature": "String-\u003e[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:parseMimeTypeTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "readMimeTypeTable",
          "package": "hxt",
          "signature": "FilePath -\u003e IO MimeTypeTable",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#readMimeTypeTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "readMimeTypeTable",
          "normalized": "FilePath-\u003eIO MimeTypeTable",
          "package": "hxt",
          "partial": "Mime Type Table",
          "signature": "FilePath-\u003eIO MimeTypeTable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:readMimeTypeTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_html",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#text_html",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_html",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:text_html"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_pdf",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#text_pdf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_pdf",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:text_pdf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_plain",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#text_plain",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_plain",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:text_plain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_xdtd",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#text_xdtd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_xdtd",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:text_xdtd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_xml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#text_xml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_xml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:text_xml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_xml_external_parsed_entity",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-MimeTypes.html#text_xml_external_parsed_entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM MimeTypes",
          "module": "Text.XML.HXT.DOM.MimeTypes",
          "name": "text_xml_external_parsed_entity",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-MimeTypes.html#v:text_xml_external_parsed_entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe types and functions for qualified names\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "QualifiedName",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html",
          "type": "module"
        },
        "index": {
          "description": "The types and functions for qualified names",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "QualifiedName",
          "package": "hxt",
          "partial": "Qualified Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for the namespace association list, used when propagating namespaces by\n modifying the \u003ccode\u003e\u003ca\u003eQName\u003c/a\u003e\u003c/code\u003e values in a tree\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "NsEnv",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#NsEnv",
          "type": "type"
        },
        "index": {
          "description": "Type for the namespace association list used when propagating namespaces by modifying the QName values in tree",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "NsEnv",
          "package": "hxt",
          "partial": "Ns Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#t:NsEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace support for element and attribute names.\n\u003c/p\u003e\u003cp\u003eA qualified name consists of a name prefix, a local name\n and a namespace uri.\n All modules, which are not namespace aware, use only the \u003ccode\u003e\u003ca\u003elocalPart\u003c/a\u003e\u003c/code\u003e component.\n When dealing with namespaces, the document tree must be processed by \u003ccode\u003e\u003ca\u003epropagateNamespaces\u003c/a\u003e\u003c/code\u003e\n to split names of structure \"prefix:localPart\" and label the name with the apropriate namespace uri\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "QName",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#QName",
          "type": "data"
        },
        "index": {
          "description": "Namespace support for element and attribute names qualified name consists of name prefix local name and namespace uri All modules which are not namespace aware use only the localPart component When dealing with namespaces the document tree must be processed by propagateNamespaces to split names of structure prefix localPart and label the name with the apropriate namespace uri",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "QName",
          "package": "hxt",
          "partial": "QName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#t:QName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML names are represented by Strings, but these strings do not mix up with normal strings.\n Names are always reduced to normal form, and they are stored internally in a name cache\n for sharing equal names by the same data structure\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "XName",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#XName",
          "type": "data"
        },
        "index": {
          "description": "XML names are represented by Strings but these strings do not mix up with normal strings Names are always reduced to normal form and they are stored internally in name cache for sharing equal names by the same data structure",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "XName",
          "package": "hxt",
          "partial": "XName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#t:XName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilds a string from the namespace uri and the local part. If the namespace uri is empty, the local part is returned, else\n namespace uri and local part are combined with the combining function given by the first parameter\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "buildUniversalName",
          "package": "hxt",
          "signature": "(String -\u003e String -\u003e String) -\u003e QName -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#buildUniversalName",
          "type": "function"
        },
        "index": {
          "description": "builds string from the namespace uri and the local part If the namespace uri is empty the local part is returned else namespace uri and local part are combined with the combining function given by the first parameter",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "buildUniversalName",
          "normalized": "(String-\u003eString-\u003eString)-\u003eQName-\u003eString",
          "package": "hxt",
          "partial": "Universal Name",
          "signature": "(String-\u003eString-\u003eString)-\u003eQName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:buildUniversalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSometimes a weaker equality relation than \u003ccode\u003eequalQName\u003c/code\u003e is appropriate, e.g no case significance in names, ...\n a name normalization function can be applied to the strings before comparing. Called by \u003ccode\u003eequalQName\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eequivQName\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "equalQNameBy",
          "package": "hxt",
          "signature": "(String -\u003e String -\u003e Bool) -\u003e QName -\u003e QName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#equalQNameBy",
          "type": "function"
        },
        "index": {
          "description": "Sometimes weaker equality relation than equalQName is appropriate e.g no case significance in names name normalization function can be applied to the strings before comparing Called by equalQName and equivQName",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "equalQNameBy",
          "normalized": "(String-\u003eString-\u003eBool)-\u003eQName-\u003eQName-\u003eBool",
          "package": "hxt",
          "partial": "QName By",
          "signature": "(String-\u003eString-\u003eBool)-\u003eQName-\u003eQName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:equalQNameBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent QNames are defined as follows: The URIs are normalized before comparison.\n Comparison is done with \u003ccode\u003e\u003ca\u003eequalQNameBy\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eequivUri\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "equivQName",
          "package": "hxt",
          "signature": "QName -\u003e QName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#equivQName",
          "type": "function"
        },
        "index": {
          "description": "Equivalent QNames are defined as follows The URIs are normalized before comparison Comparison is done with equalQNameBy and equivUri",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "equivQName",
          "normalized": "QName-\u003eQName-\u003eBool",
          "package": "hxt",
          "partial": "QName",
          "signature": "QName-\u003eQName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:equivQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComparison of normalized namespace URIs using \u003ccode\u003e\u003ca\u003enormalizeNsUri\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "equivUri",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#equivUri",
          "type": "function"
        },
        "index": {
          "description": "Comparison of normalized namespace URIs using normalizeNsUri",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "equivUri",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "hxt",
          "partial": "Uri",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:equivUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epredicate is used in filter \u003ccode\u003evaldateNamespaces\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isDeclaredNamespace",
          "package": "hxt",
          "signature": "QName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isDeclaredNamespace",
          "type": "function"
        },
        "index": {
          "description": "predicate is used in filter valdateNamespaces",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isDeclaredNamespace",
          "normalized": "QName-\u003eBool",
          "package": "hxt",
          "partial": "Declared Namespace",
          "signature": "QName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isDeclaredNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for wellformed NCName, rule [4] XML Namespaces\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isNCName",
          "package": "hxt",
          "signature": "String -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isNCName",
          "type": "function"
        },
        "index": {
          "description": "test for wellformed NCName rule XML Namespaces",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isNCName",
          "normalized": "String-\u003eBool",
          "package": "hxt",
          "partial": "NCName",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isNCName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether a name is a namespace declaration attribute name\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isNameSpaceName",
          "package": "hxt",
          "signature": "QName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isNameSpaceName",
          "type": "function"
        },
        "index": {
          "description": "test whether name is namespace declaration attribute name",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isNameSpaceName",
          "normalized": "QName-\u003eBool",
          "package": "hxt",
          "partial": "Name Space Name",
          "signature": "QName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isNameSpaceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isNullXName",
          "package": "hxt",
          "signature": "XName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isNullXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isNullXName",
          "normalized": "XName-\u003eBool",
          "package": "hxt",
          "partial": "Null XName",
          "signature": "XName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isNullXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest whether an attribute name is a namesapce declaration name.\n If this is not the case True is the result, else\n the name must be a well formed namespace name:\n All namespace prefixes starting with \"xml\" are reserved for XML related definitions.\n predicate is used in filter \u003ccode\u003evaldateNamespaces\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedNSDecl",
          "package": "hxt",
          "signature": "QName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isWellformedNSDecl",
          "type": "function"
        },
        "index": {
          "description": "test whether an attribute name is namesapce declaration name If this is not the case True is the result else the name must be well formed namespace name All namespace prefixes starting with xml are reserved for XML related definitions predicate is used in filter valdateNamespaces",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedNSDecl",
          "normalized": "QName-\u003eBool",
          "package": "hxt",
          "partial": "Wellformed NSDecl",
          "signature": "QName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isWellformedNSDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for a namespace name to be well formed\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedNameSpaceName",
          "package": "hxt",
          "signature": "QName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isWellformedNameSpaceName",
          "type": "function"
        },
        "index": {
          "description": "test for namespace name to be well formed",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedNameSpaceName",
          "normalized": "QName-\u003eBool",
          "package": "hxt",
          "partial": "Wellformed Name Space Name",
          "signature": "QName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isWellformedNameSpaceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for wellformed QName values.\n A QName is wellformed, if the local part is a NCName, the namePrefix, if not empty, is also a NCName.\n predicate is used in filter \u003ccode\u003evaldateNamespaces\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedQName",
          "package": "hxt",
          "signature": "QName -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isWellformedQName",
          "type": "function"
        },
        "index": {
          "description": "test for wellformed QName values QName is wellformed if the local part is NCName the namePrefix if not empty is also NCName predicate is used in filter valdateNamespaces",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedQName",
          "normalized": "QName-\u003eBool",
          "package": "hxt",
          "partial": "Wellformed QName",
          "signature": "QName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isWellformedQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etest for wellformed QName, rule [6] XML Namespaces\n predicate is used in filter \u003ccode\u003evaldateNamespaces\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedQualifiedName",
          "package": "hxt",
          "signature": "String -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#isWellformedQualifiedName",
          "type": "function"
        },
        "index": {
          "description": "test for wellformed QName rule XML Namespaces predicate is used in filter valdateNamespaces",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "isWellformedQualifiedName",
          "normalized": "String-\u003eBool",
          "package": "hxt",
          "partial": "Wellformed Qualified Name",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:isWellformedQualifiedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "localPart",
          "package": "hxt",
          "signature": "QName -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#localPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "localPart",
          "normalized": "QName-\u003eString",
          "package": "hxt",
          "partial": "Part",
          "signature": "QName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:localPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "localPart'",
          "package": "hxt",
          "signature": "QName -\u003e XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#localPart%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "localPart'",
          "normalized": "QName-\u003eXName",
          "package": "hxt",
          "partial": "Part'",
          "signature": "QName-\u003eXName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:localPart-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructs a simple, namespace unaware name.\n If the name is in \u003ccode\u003eprefix:localpart\u003c/code\u003e form and the prefix is not empty\n the name is split internally into\n a prefix and a local part.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkName",
          "package": "hxt",
          "signature": "String -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#mkName",
          "type": "function"
        },
        "index": {
          "description": "constructs simple namespace unaware name If the name is in prefix localpart form and the prefix is not empty the name is split internally into prefix and local part",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkName",
          "normalized": "String-\u003eQName",
          "package": "hxt",
          "partial": "Name",
          "signature": "String-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:mkName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructs a simple, namespace aware name, with prefix:localPart as first parameter,\n namspace uri as second.\n\u003c/p\u003e\u003cp\u003esee also \u003ccode\u003e\u003ca\u003emkName\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emkPrefixLocalPart\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkNsName",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#mkNsName",
          "type": "function"
        },
        "index": {
          "description": "constructs simple namespace aware name with prefix localPart as first parameter namspace uri as second see also mkName mkPrefixLocalPart",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkNsName",
          "normalized": "String-\u003eString-\u003eQName",
          "package": "hxt",
          "partial": "Ns Name",
          "signature": "String-\u003eString-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:mkNsName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructs a simple name, with prefix and localPart but without a namespace uri.\n\u003c/p\u003e\u003cp\u003esee also \u003ccode\u003e\u003ca\u003emkQName\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emkName\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkPrefixLocalPart",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#mkPrefixLocalPart",
          "type": "function"
        },
        "index": {
          "description": "constructs simple name with prefix and localPart but without namespace uri see also mkQName mkName",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkPrefixLocalPart",
          "normalized": "String-\u003eString-\u003eQName",
          "package": "hxt",
          "partial": "Prefix Local Part",
          "signature": "String-\u003eString-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:mkPrefixLocalPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructs a complete qualified name with \u003ccode\u003e\u003ca\u003enamePrefix\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003elocalPart\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003enamespaceUri\u003c/a\u003e\u003c/code\u003e.\n This function can be used to build not wellformed prefix:localpart names.\n The XPath module uses wildcard names like \u003ccode\u003exxx:*\u003c/code\u003e. These must be build with \u003ccode\u003e\u003ca\u003emkQName\u003c/a\u003e\u003c/code\u003e\n and not with mkName.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkQName",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e String -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#mkQName",
          "type": "function"
        },
        "index": {
          "description": "constructs complete qualified name with namePrefix localPart and namespaceUri This function can be used to build not wellformed prefix localpart names The XPath module uses wildcard names like xxx These must be build with mkQName and not with mkName",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkQName",
          "normalized": "String-\u003eString-\u003eString-\u003eQName",
          "package": "hxt",
          "partial": "QName",
          "signature": "String-\u003eString-\u003eString-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:mkQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use newQName instead with lp px ns param seq \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkQName'",
          "package": "hxt",
          "signature": "XName -\u003e XName -\u003e XName -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#mkQName%27",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use newQName instead with lp px ns param seq",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkQName'",
          "normalized": "XName-\u003eXName-\u003eXName-\u003eQName",
          "package": "hxt",
          "partial": "QName'",
          "signature": "XName-\u003eXName-\u003eXName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:mkQName-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use mkName instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eold name for \u003ccode\u003e\u003ca\u003emkName\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkSNsName",
          "package": "hxt",
          "signature": "String -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#mkSNsName",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use mkName instead old name for mkName",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "mkSNsName",
          "normalized": "String-\u003eQName",
          "package": "hxt",
          "partial": "SNs Name",
          "signature": "String-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:mkSNsName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namePrefix",
          "package": "hxt",
          "signature": "QName -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#namePrefix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namePrefix",
          "normalized": "QName-\u003eString",
          "package": "hxt",
          "partial": "Prefix",
          "signature": "QName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:namePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namePrefix'",
          "package": "hxt",
          "signature": "QName -\u003e XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#namePrefix%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namePrefix'",
          "normalized": "QName-\u003eXName",
          "package": "hxt",
          "partial": "Prefix'",
          "signature": "QName-\u003eXName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:namePrefix-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namespaceUri",
          "package": "hxt",
          "signature": "QName -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#namespaceUri",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namespaceUri",
          "normalized": "QName-\u003eString",
          "package": "hxt",
          "partial": "Uri",
          "signature": "QName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:namespaceUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namespaceUri'",
          "package": "hxt",
          "signature": "QName -\u003e XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#namespaceUri%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "namespaceUri'",
          "normalized": "QName-\u003eXName",
          "package": "hxt",
          "partial": "Uri'",
          "signature": "QName-\u003eXName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:namespaceUri-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "newQName",
          "package": "hxt",
          "signature": "XName -\u003e XName -\u003e XName -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#newQName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "newQName",
          "normalized": "XName-\u003eXName-\u003eXName-\u003eQName",
          "package": "hxt",
          "partial": "QName",
          "signature": "XName-\u003eXName-\u003eXName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:newQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "newXName",
          "package": "hxt",
          "signature": "String -\u003e XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#newXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "newXName",
          "normalized": "String-\u003eXName",
          "package": "hxt",
          "partial": "XName",
          "signature": "String-\u003eXName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:newXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalization of URIs: Normalization is done by conversion into lowercase letters. A trailing \"/\" is ignored\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "normalizeNsUri",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#normalizeNsUri",
          "type": "function"
        },
        "index": {
          "description": "Normalization of URIs Normalization is done by conversion into lowercase letters trailing is ignored",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "normalizeNsUri",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Ns Uri",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:normalizeNsUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "nullXName",
          "package": "hxt",
          "signature": "XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#nullXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "nullXName",
          "package": "hxt",
          "partial": "XName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:nullXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilds the full name \"prefix:localPart\", if prefix is not null, else the local part is the result\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "qualifiedName",
          "package": "hxt",
          "signature": "QName -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#qualifiedName",
          "type": "function"
        },
        "index": {
          "description": "builds the full name prefix localPart if prefix is not null else the local part is the result",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "qualifiedName",
          "normalized": "QName-\u003eString",
          "package": "hxt",
          "partial": "Name",
          "signature": "QName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:qualifiedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunctional list version of qualifiedName used in xshow\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "qualifiedName'",
          "package": "hxt",
          "signature": "QName -\u003e String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#qualifiedName%27",
          "type": "function"
        },
        "index": {
          "description": "functional list version of qualifiedName used in xshow",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "qualifiedName'",
          "normalized": "QName-\u003eString-\u003eString",
          "package": "hxt",
          "partial": "Name'",
          "signature": "QName-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:qualifiedName-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset local part\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setLocalPart'",
          "package": "hxt",
          "signature": "XName -\u003e QName -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#setLocalPart%27",
          "type": "function"
        },
        "index": {
          "description": "set local part",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setLocalPart'",
          "normalized": "XName-\u003eQName-\u003eQName",
          "package": "hxt",
          "partial": "Local Part'",
          "signature": "XName-\u003eQName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:setLocalPart-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset name prefix\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setNamePrefix'",
          "package": "hxt",
          "signature": "XName -\u003e QName -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#setNamePrefix%27",
          "type": "function"
        },
        "index": {
          "description": "set name prefix",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setNamePrefix'",
          "normalized": "XName-\u003eQName-\u003eQName",
          "package": "hxt",
          "partial": "Name Prefix'",
          "signature": "XName-\u003eQName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:setNamePrefix-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the name prefix and the namespace uri for a qualified name.\n\u003c/p\u003e\u003cp\u003eThis function does not test whether the name is a wellformed qualified name.\n see Namespaces in XML Rule [6] to [8]. Error checking is done with separate functions,\n see \u003ccode\u003e\u003ca\u003eisWellformedQName\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eisWellformedQualifiedName\u003c/a\u003e\u003c/code\u003e for error checking.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setNamespace",
          "package": "hxt",
          "signature": "NsEnv -\u003e QName -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#setNamespace",
          "type": "function"
        },
        "index": {
          "description": "Compute the name prefix and the namespace uri for qualified name This function does not test whether the name is wellformed qualified name see Namespaces in XML Rule to Error checking is done with separate functions see isWellformedQName and isWellformedQualifiedName for error checking",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setNamespace",
          "normalized": "NsEnv-\u003eQName-\u003eQName",
          "package": "hxt",
          "partial": "Namespace",
          "signature": "NsEnv-\u003eQName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:setNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eset name prefix\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setNamespaceUri'",
          "package": "hxt",
          "signature": "XName -\u003e QName -\u003e QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#setNamespaceUri%27",
          "type": "function"
        },
        "index": {
          "description": "set name prefix",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "setNamespaceUri'",
          "normalized": "XName-\u003eQName-\u003eQName",
          "package": "hxt",
          "partial": "Namespace Uri'",
          "signature": "XName-\u003eQName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:setNamespaceUri-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "toNsEnv",
          "package": "hxt",
          "signature": "AssocList String String -\u003e NsEnv",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#toNsEnv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "toNsEnv",
          "normalized": "AssocList String String-\u003eNsEnv",
          "package": "hxt",
          "partial": "Ns Env",
          "signature": "AssocList String String-\u003eNsEnv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:toNsEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilds the \"universal\" name, that is the namespace uri surrounded with \"{\" and \"}\" followed by the local part\n (specialisation of \u003ccode\u003e\u003ca\u003ebuildUniversalName\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "universalName",
          "package": "hxt",
          "signature": "QName -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#universalName",
          "type": "function"
        },
        "index": {
          "description": "builds the universal name that is the namespace uri surrounded with and followed by the local part specialisation of buildUniversalName",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "universalName",
          "normalized": "QName-\u003eString",
          "package": "hxt",
          "partial": "Name",
          "signature": "QName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:universalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilds an \"universal\" uri, that is the namespace uri followed by the local part. This is usefull for RDF applications,\n where the subject, predicate and object often are concatenated from namespace uri and local part\n (specialisation of \u003ccode\u003e\u003ca\u003ebuildUniversalName\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "universalUri",
          "package": "hxt",
          "signature": "QName -\u003e String",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#universalUri",
          "type": "function"
        },
        "index": {
          "description": "builds an universal uri that is the namespace uri followed by the local part This is usefull for RDF applications where the subject predicate and object often are concatenated from namespace uri and local part specialisation of buildUniversalName",
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "universalUri",
          "normalized": "QName-\u003eString",
          "package": "hxt",
          "partial": "Uri",
          "signature": "QName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:universalUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlNamespaceXName",
          "package": "hxt",
          "signature": "XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#xmlNamespaceXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlNamespaceXName",
          "package": "hxt",
          "partial": "Namespace XName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:xmlNamespaceXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlXName",
          "package": "hxt",
          "signature": "XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#xmlXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlXName",
          "package": "hxt",
          "partial": "XName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:xmlXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlnsNamespaceXName",
          "package": "hxt",
          "signature": "XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#xmlnsNamespaceXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlnsNamespaceXName",
          "package": "hxt",
          "partial": "Namespace XName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:xmlnsNamespaceXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlnsQN",
          "package": "hxt",
          "signature": "QName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#xmlnsQN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlnsQN",
          "package": "hxt",
          "partial": "QN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:xmlnsQN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlnsXName",
          "package": "hxt",
          "signature": "XName",
          "source": "src/Text-XML-HXT-DOM-QualifiedName.html#xmlnsXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM QualifiedName",
          "module": "Text.XML.HXT.DOM.QualifiedName",
          "name": "xmlnsXName",
          "package": "hxt",
          "partial": "XName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-QualifiedName.html#v:xmlnsXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eXML tree conversion to external string representation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "ShowXml",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-ShowXml.html",
          "type": "module"
        },
        "index": {
          "description": "XML tree conversion to external string representation",
          "hierarchy": "Text XML HXT DOM ShowXml",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "ShowXml",
          "package": "hxt",
          "partial": "Show Xml",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-ShowXml.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a list of trees into a string\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003exmlTreesToText\u003c/code\u003e for filter version, \u003ccode\u003e\u003ca\u003exread\u003c/a\u003e\u003c/code\u003e for the inverse operation\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshow",
          "package": "hxt",
          "signature": "XmlTrees -\u003e String",
          "source": "src/Text-XML-HXT-DOM-ShowXml.html#xshow",
          "type": "function"
        },
        "index": {
          "description": "convert list of trees into string see also xmlTreesToText for filter version xread for the inverse operation",
          "hierarchy": "Text XML HXT DOM ShowXml",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshow",
          "normalized": "XmlTrees-\u003eString",
          "package": "hxt",
          "signature": "XmlTrees-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-ShowXml.html#v:xshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a list of trees into a blob.\n\u003c/p\u003e\u003cp\u003eApply a quoting function for XML quoting of content,\n a 2. quoting funtion for attribute values\n and an encoding function after tree conversion\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshow'",
          "package": "hxt",
          "signature": "(Char -\u003e StringFct) -\u003e (Char -\u003e StringFct) -\u003e (Char -\u003e StringFct) -\u003e XmlTrees -\u003e Blob",
          "source": "src/Text-XML-HXT-DOM-ShowXml.html#xshow%27",
          "type": "function"
        },
        "index": {
          "description": "convert list of trees into blob Apply quoting function for XML quoting of content quoting funtion for attribute values and an encoding function after tree conversion",
          "hierarchy": "Text XML HXT DOM ShowXml",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshow'",
          "normalized": "(Char-\u003eStringFct)-\u003e(Char-\u003eStringFct)-\u003e(Char-\u003eStringFct)-\u003eXmlTrees-\u003eBlob",
          "package": "hxt",
          "signature": "(Char-\u003eStringFct)-\u003e(Char-\u003eStringFct)-\u003e(Char-\u003eStringFct)-\u003eXmlTrees-\u003eBlob",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-ShowXml.html#v:xshow-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshow''",
          "package": "hxt",
          "signature": "(Char -\u003e StringFct) -\u003e (Char -\u003e StringFct) -\u003e XmlTrees -\u003e String",
          "source": "src/Text-XML-HXT-DOM-ShowXml.html#xshow%27%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM ShowXml",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshow''",
          "normalized": "(Char-\u003eStringFct)-\u003e(Char-\u003eStringFct)-\u003eXmlTrees-\u003eString",
          "package": "hxt",
          "signature": "(Char-\u003eStringFct)-\u003e(Char-\u003eStringFct)-\u003eXmlTrees-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-ShowXml.html#v:xshow-39--39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert an XML tree into a binary large object (a bytestring)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshowBlob",
          "package": "hxt",
          "signature": "XmlTrees -\u003e Blob",
          "source": "src/Text-XML-HXT-DOM-ShowXml.html#xshowBlob",
          "type": "function"
        },
        "index": {
          "description": "convert an XML tree into binary large object bytestring",
          "hierarchy": "Text XML HXT DOM ShowXml",
          "module": "Text.XML.HXT.DOM.ShowXml",
          "name": "xshowBlob",
          "normalized": "XmlTrees-\u003eBlob",
          "package": "hxt",
          "partial": "Blob",
          "signature": "XmlTrees-\u003eBlob",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-ShowXml.html#v:xshowBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe core data types of the HXT DOM.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html",
          "type": "module"
        },
        "index": {
          "description": "The core data types of the HXT DOM",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "partial": "Type Defs",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttribute list\n\u003c/p\u003e\u003cp\u003eused for storing option lists and features of DTD parts\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "Attributes",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#Attributes",
          "type": "type"
        },
        "index": {
          "description": "Attribute list used for storing option lists and features of DTD parts",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "Attributes",
          "package": "hxt",
          "partial": "Attributes",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:Attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary large object implemented as a lazy bytestring\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "Blob",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#Blob",
          "type": "type"
        },
        "index": {
          "description": "Binary large object implemented as lazy bytestring",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "Blob",
          "package": "hxt",
          "partial": "Blob",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:Blob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ChildNodes",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#ChildNodes",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ChildNodes",
          "package": "hxt",
          "partial": "Child Nodes",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:ChildNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents a DTD element\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "DTDElem",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "data"
        },
        "index": {
          "description": "Represents DTD element",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "DTDElem",
          "package": "hxt",
          "partial": "DTDElem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:DTDElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents elements\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XNode",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "data"
        },
        "index": {
          "description": "Represents elements",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XNode",
          "package": "hxt",
          "partial": "XNode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNavigatable rose tree with XML nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlNavTree",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlNavTree",
          "type": "type"
        },
        "index": {
          "description": "Navigatable rose tree with XML nodes",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlNavTree",
          "package": "hxt",
          "partial": "Xml Nav Tree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XmlNavTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of navigatable rose trees with XML nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlNavTrees",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlNavTrees",
          "type": "type"
        },
        "index": {
          "description": "List of navigatable rose trees with XML nodes",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlNavTrees",
          "package": "hxt",
          "partial": "Xml Nav Trees",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XmlNavTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata type for representing a set of nodes as a tree structure\n\u003c/p\u003e\u003cp\u003ethis structure is e.g. used to repesent the result of an XPath query\n such that the selected nodes can be processed or selected later in\n processing a document tree\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlNodeSet",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlNodeSet",
          "type": "data"
        },
        "index": {
          "description": "data type for representing set of nodes as tree structure this structure is e.g used to repesent the result of an XPath query such that the selected nodes can be processed or selected later in processing document tree",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlNodeSet",
          "package": "hxt",
          "partial": "Xml Node Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XmlNodeSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRose tree with XML nodes (XNode)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlTree",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlTree",
          "type": "type"
        },
        "index": {
          "description": "Rose tree with XML nodes XNode",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlTree",
          "package": "hxt",
          "partial": "Xml Tree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XmlTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of rose trees with XML nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlTrees",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlTrees",
          "type": "type"
        },
        "index": {
          "description": "List of rose trees with XML nodes",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XmlTrees",
          "package": "hxt",
          "partial": "Xml Trees",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XmlTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattributes:\n  name - name of element\n\u003c/p\u003e\u003cp\u003evalue - name of attribute\n\u003c/p\u003e\u003cp\u003etype: \"CDATA\" | \"ID\" | \"IDREF\" | \"IDREFS\" | \"ENTITY\" | \"ENTITIES\" |\n\u003c/p\u003e\u003cp\u003e\"NMTOKEN\" | \"NMTOKENS\" |\"NOTATION\" | \"ENUMTYPE\"\n\u003c/p\u003e\u003cp\u003ekind: \"\u003ca name=\"REQUIRED\\\" | \\\"\"/\u003eIMPLIED\" | \"DEFAULT\"\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ATTLIST",
          "package": "hxt",
          "signature": "ATTLIST",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "attributes name name of element value name of attribute type CDATA ID IDREF IDREFS ENTITY ENTITIES NMTOKEN NMTOKENS NOTATION ENUMTYPE kind IMPLIED DEFAULT",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ATTLIST",
          "package": "hxt",
          "partial": "ATTLIST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:ATTLIST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor INCLUDEs, IGNOREs and peRefs: attr: type\n\u003c/p\u003e\u003cp\u003etype = INCLUDE, IGNORE or %...;\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "CONDSECT",
          "package": "hxt",
          "signature": "CONDSECT",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "for INCLUDEs IGNOREs and peRefs attr type type INCLUDE IGNORE or",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "CONDSECT",
          "package": "hxt",
          "partial": "CONDSECT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:CONDSECT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eelement content\n\u003c/p\u003e\u003cp\u003eattr: kind, modifier\n\u003c/p\u003e\u003cp\u003emodifier: \"\" | \"?\" | \"*\" | \"+\"\n\u003c/p\u003e\u003cp\u003ekind: seq | choice\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "CONTENT",
          "package": "hxt",
          "signature": "CONTENT",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "element content attr kind modifier modifier kind seq choice",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "CONTENT",
          "package": "hxt",
          "partial": "CONTENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:CONTENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattr: name, system, public,        XDTD elems as children\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "DOCTYPE",
          "package": "hxt",
          "signature": "DOCTYPE",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "attr name system public XDTD elems as children",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "DOCTYPE",
          "package": "hxt",
          "partial": "DOCTYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:DOCTYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattr: name, kind\n\u003c/p\u003e\u003cp\u003ename: element name\n\u003c/p\u003e\u003cp\u003ekind: \"EMPTY\" | \"ANY\" | \"#PCDATA\" | children | mixed\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ELEMENT",
          "package": "hxt",
          "signature": "ELEMENT",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "attr name kind name element name kind EMPTY ANY PCDATA children mixed",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ELEMENT",
          "package": "hxt",
          "partial": "ELEMENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:ELEMENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor entity declarations\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ENTITY",
          "package": "hxt",
          "signature": "ENTITY",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "for entity declarations",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "ENTITY",
          "package": "hxt",
          "partial": "ENTITY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:ENTITY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattr: name\n\u003c/p\u003e\u003cp\u003efor lists of names in notation types or nmtokens in enumeration types\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "NAME",
          "package": "hxt",
          "signature": "NAME",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "attr name for lists of names in notation types or nmtokens in enumeration types",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "NAME",
          "package": "hxt",
          "partial": "NAME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:NAME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor notations\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "NOTATION",
          "package": "hxt",
          "signature": "NOTATION",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "for notations",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "NOTATION",
          "package": "hxt",
          "partial": "NOTATION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:NOTATION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor parameter entity declarations\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "PENTITY",
          "package": "hxt",
          "signature": "PENTITY",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "for parameter entity declarations",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "PENTITY",
          "package": "hxt",
          "partial": "PENTITY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:PENTITY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor Parameter Entity References in DTDs\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "PEREF",
          "package": "hxt",
          "signature": "PEREF",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#DTDElem",
          "type": "function"
        },
        "index": {
          "description": "for Parameter Entity References in DTDs",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "PEREF",
          "package": "hxt",
          "partial": "PEREF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:PEREF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattribute with qualified name, the attribute value is stored in children\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XAttr",
          "package": "hxt",
          "signature": "XAttr QName",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "attribute with qualified name the attribute value is stored in children",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XAttr",
          "package": "hxt",
          "partial": "XAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etext represented more space efficient as bytestring (leaf)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XBlob",
          "package": "hxt",
          "signature": "XBlob Blob",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "text represented more space efficient as bytestring leaf",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XBlob",
          "package": "hxt",
          "partial": "XBlob",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCDATA section                                       (leaf)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XCdata",
          "package": "hxt",
          "signature": "XCdata String",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "CDATA section leaf",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XCdata",
          "package": "hxt",
          "partial": "XCdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echaracter reference                                 (leaf)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XCharRef",
          "package": "hxt",
          "signature": "XCharRef Int",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "character reference leaf",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XCharRef",
          "package": "hxt",
          "partial": "XChar Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecomment                                             (leaf)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XCmt",
          "package": "hxt",
          "signature": "XCmt String",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "comment leaf",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XCmt",
          "package": "hxt",
          "partial": "XCmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDTD element with assoc list for dtd element features\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XDTD",
          "package": "hxt",
          "signature": "XDTD DTDElem Attributes",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "DTD element with assoc list for dtd element features",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XDTD",
          "package": "hxt",
          "partial": "XDTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eentity reference                                    (leaf)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XEntityRef",
          "package": "hxt",
          "signature": "XEntityRef String",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "entity reference leaf",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XEntityRef",
          "package": "hxt",
          "partial": "XEntity Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror message with level and text\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XError",
          "package": "hxt",
          "signature": "XError Int String",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "error message with level and text",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XError",
          "package": "hxt",
          "partial": "XError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XNS",
          "package": "hxt",
          "signature": "XNS",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlNodeSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XNS",
          "package": "hxt",
          "partial": "XNS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XNS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcessing Instr with qualified name                (leaf)\n   with list of attributes.\n   If tag name is xml, attributs are \"version\", \"encoding\", \"standalone\",\n   else attribute list is empty, content is a text child node\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XPi",
          "package": "hxt",
          "signature": "XPi QName XmlTrees",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "Processing Instr with qualified name leaf with list of attributes If tag name is xml attributs are version encoding standalone else attribute list is empty content is text child node",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XPi",
          "package": "hxt",
          "partial": "XPi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etag with qualified name and list of attributes (inner node or leaf)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XTag",
          "package": "hxt",
          "signature": "XTag QName XmlTrees",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "tag with qualified name and list of attributes inner node or leaf",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XTag",
          "package": "hxt",
          "partial": "XTag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary text                                       (leaf)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XText",
          "package": "hxt",
          "signature": "XText String",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XNode",
          "type": "function"
        },
        "index": {
          "description": "ordinary text leaf",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "XText",
          "package": "hxt",
          "partial": "XText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:XText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe set of attribute nodes\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "attrNodes",
          "package": "hxt",
          "signature": "[QName]",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlNodeSet",
          "type": "function"
        },
        "index": {
          "description": "the set of attribute nodes",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "attrNodes",
          "normalized": "[QName]",
          "package": "hxt",
          "partial": "Nodes",
          "signature": "[QName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:attrNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "blobToString",
          "package": "hxt",
          "signature": "Blob -\u003e String",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#blobToString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "blobToString",
          "normalized": "Blob-\u003eString",
          "package": "hxt",
          "partial": "To String",
          "signature": "Blob-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:blobToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eError level for XError, type error\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_err",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#c_err",
          "type": "function"
        },
        "index": {
          "description": "Error level for XError type error",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_err",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:c_err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eError level for XError, type fatal error\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_fatal",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#c_fatal",
          "type": "function"
        },
        "index": {
          "description": "Error level for XError type fatal error",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_fatal",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:c_fatal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eno error, everything is ok\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_ok",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#c_ok",
          "type": "function"
        },
        "index": {
          "description": "no error everything is ok",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_ok",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:c_ok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eError level for XError, type warning\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_warn",
          "package": "hxt",
          "signature": "Int",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#c_warn",
          "type": "function"
        },
        "index": {
          "description": "Error level for XError type warning",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "c_warn",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:c_warn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe set of child nodes, a list of pairs of index and node set\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "childNodes",
          "package": "hxt",
          "signature": "ChildNodes",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlNodeSet",
          "type": "function"
        },
        "index": {
          "description": "the set of child nodes list of pairs of index and node set",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "childNodes",
          "package": "hxt",
          "partial": "Nodes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:childNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate an assoc list of strings\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "rwnfAttributes",
          "package": "hxt",
          "signature": "Attributes -\u003e ()",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#rwnfAttributes",
          "type": "function"
        },
        "index": {
          "description": "Evaluate an assoc list of strings",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "rwnfAttributes",
          "normalized": "Attributes-\u003e()",
          "package": "hxt",
          "partial": "Attributes",
          "signature": "Attributes-\u003e()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:rwnfAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "stringToBlob",
          "package": "hxt",
          "signature": "String -\u003e Blob",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#stringToBlob",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "stringToBlob",
          "normalized": "String-\u003eBlob",
          "package": "hxt",
          "partial": "To Blob",
          "signature": "String-\u003eBlob",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:stringToBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis this node part of the set ?\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "thisNode",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-DOM-TypeDefs.html#XmlNodeSet",
          "type": "function"
        },
        "index": {
          "description": "is this node part of the set",
          "hierarchy": "Text XML HXT DOM TypeDefs",
          "module": "Text.XML.HXT.DOM.TypeDefs",
          "name": "thisNode",
          "package": "hxt",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-TypeDefs.html#v:thisNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLittle useful things for strings, lists and other values\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "Util",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-Util.html",
          "type": "module"
        },
        "index": {
          "description": "Little useful things for strings lists and other values",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "Util",
          "package": "hxt",
          "partial": "Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eescape XML chars in attribute values, same as stringEscapeXml, but none blank whitespace\n is also escaped\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003estringEscapeXml\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "attrEscapeXml",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#attrEscapeXml",
          "type": "function"
        },
        "index": {
          "description": "escape XML chars in attribute values same as stringEscapeXml but none blank whitespace is also escaped see also stringEscapeXml",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "attrEscapeXml",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Escape Xml",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:attrEscapeXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a char (byte) into a 2-digit hexadecimal string\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003estringToHexString\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eintToHexString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "charToHexString",
          "package": "hxt",
          "signature": "Char -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#charToHexString",
          "type": "function"
        },
        "index": {
          "description": "convert char byte into digit hexadecimal string see also stringToHexString intToHexString",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "charToHexString",
          "normalized": "Char-\u003eString",
          "package": "hxt",
          "partial": "To Hex String",
          "signature": "Char-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:charToHexString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a string of digits into an Int\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "decimalStringToInt",
          "package": "hxt",
          "signature": "String -\u003e Int",
          "source": "src/Text-XML-HXT-DOM-Util.html#decimalStringToInt",
          "type": "function"
        },
        "index": {
          "description": "convert string of digits into an Int",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "decimalStringToInt",
          "normalized": "String-\u003eInt",
          "package": "hxt",
          "partial": "String To Int",
          "signature": "String-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:decimalStringToInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etake all elements of a list which occur more than once. The result does not contain doubles.\n (doubles . doubles == doubles)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "doubles",
          "package": "hxt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Text-XML-HXT-DOM-Util.html#doubles",
          "type": "function"
        },
        "index": {
          "description": "take all elements of list which occur more than once The result does not contain doubles doubles doubles doubles",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "doubles",
          "normalized": "[a]-\u003e[a]",
          "package": "hxt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:doubles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEscape all disallowed characters in URI\n references (see \u003ca\u003ehttp://www.w3.org/TR/xlink/#link-locators\u003c/a\u003e)\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "escapeURI",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#escapeURI",
          "type": "function"
        },
        "index": {
          "description": "Escape all disallowed characters in URI references see http www.w3.org TR xlink link-locators",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "escapeURI",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "URI",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:escapeURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a string of hexadecimal digits into an Int\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "hexStringToInt",
          "package": "hxt",
          "signature": "String -\u003e Int",
          "source": "src/Text-XML-HXT-DOM-Util.html#hexStringToInt",
          "type": "function"
        },
        "index": {
          "description": "convert string of hexadecimal digits into an Int",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "hexStringToInt",
          "normalized": "String-\u003eInt",
          "package": "hxt",
          "partial": "String To Int",
          "signature": "String-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:hexStringToInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a none negative Int into a hexadecimal string\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003echarToHexString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "intToHexString",
          "package": "hxt",
          "signature": "Int -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#intToHexString",
          "type": "function"
        },
        "index": {
          "description": "convert none negative Int into hexadecimal string see also charToHexString",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "intToHexString",
          "normalized": "Int-\u003eString",
          "package": "hxt",
          "partial": "To Hex String",
          "signature": "Int-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:intToHexString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove duplicates from list\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "noDoubles",
          "package": "hxt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Text-XML-HXT-DOM-Util.html#noDoubles",
          "type": "function"
        },
        "index": {
          "description": "remove duplicates from list",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "noDoubles",
          "normalized": "[a]-\u003e[a]",
          "package": "hxt",
          "partial": "Doubles",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:noDoubles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereplace all whitespace chars by blanks\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "normalizeBlanks",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#normalizeBlanks",
          "type": "function"
        },
        "index": {
          "description": "replace all whitespace chars by blanks",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "normalizeBlanks",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Blanks",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:normalizeBlanks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemoves leading / trailing whitespaces and leading zeros\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "normalizeNumber",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#normalizeNumber",
          "type": "function"
        },
        "index": {
          "description": "Removes leading trailing whitespaces and leading zeros",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "normalizeNumber",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Number",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:normalizeNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReduce whitespace sequences to a single whitespace\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "normalizeWhitespace",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#normalizeWhitespace",
          "type": "function"
        },
        "index": {
          "description": "Reduce whitespace sequences to single whitespace",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "normalizeWhitespace",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Whitespace",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:normalizeWhitespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.Util",
          "name": "partitionEither",
          "package": "hxt",
          "signature": "[Either a b] -\u003e ([a], [b])",
          "source": "src/Text-XML-HXT-DOM-Util.html#partitionEither",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "partitionEither",
          "normalized": "[Either a b]-\u003e([a],[b])",
          "package": "hxt",
          "partial": "Either",
          "signature": "[Either a b]-\u003e([a],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:partitionEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edrop all elements from a list which occur more than once.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "singles",
          "package": "hxt",
          "signature": "[a] -\u003e [a]",
          "source": "src/Text-XML-HXT-DOM-Util.html#singles",
          "type": "function"
        },
        "index": {
          "description": "drop all elements from list which occur more than once",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "singles",
          "normalized": "[a]-\u003e[a]",
          "package": "hxt",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:singles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efind all positions where a string occurs within another string\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringAll",
          "package": "hxt",
          "signature": "[a] -\u003e [a] -\u003e [Int]",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringAll",
          "type": "function"
        },
        "index": {
          "description": "find all positions where string occurs within another string",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringAll",
          "normalized": "[a]-\u003e[a]-\u003e[Int]",
          "package": "hxt",
          "partial": "All",
          "signature": "[a]-\u003e[a]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eescape XML chars &lt;, &gt;, &quot;,  and ampercent by transforming them into character references\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eattrEscapeXml\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringEscapeXml",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringEscapeXml",
          "type": "function"
        },
        "index": {
          "description": "escape XML chars lt gt quot and ampercent by transforming them into character references see also attrEscapeXml",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringEscapeXml",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Escape Xml",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringEscapeXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efind the position of the first occurence of a string\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringFirst",
          "package": "hxt",
          "signature": "[a] -\u003e [a] -\u003e Maybe Int",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringFirst",
          "type": "function"
        },
        "index": {
          "description": "find the position of the first occurence of string",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringFirst",
          "normalized": "[a]-\u003e[a]-\u003eMaybe Int",
          "package": "hxt",
          "partial": "First",
          "signature": "[a]-\u003e[a]-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efind the position of the last occurence of a string\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringLast",
          "package": "hxt",
          "signature": "[a] -\u003e [a] -\u003e Maybe Int",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringLast",
          "type": "function"
        },
        "index": {
          "description": "find the position of the last occurence of string",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringLast",
          "normalized": "[a]-\u003e[a]-\u003eMaybe Int",
          "package": "hxt",
          "partial": "Last",
          "signature": "[a]-\u003e[a]-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert a string into a hexadecimal string applying charToHexString\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003echarToHexString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToHexString",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringToHexString",
          "type": "function"
        },
        "index": {
          "description": "convert string into hexadecimal string applying charToHexString see also charToHexString",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToHexString",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "To Hex String",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringToHexString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToInt",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e Int",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringToInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToInt",
          "normalized": "Int-\u003eString-\u003eInt",
          "package": "hxt",
          "partial": "To Int",
          "signature": "Int-\u003eString-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringToInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert string to lowercase with standard Haskell toLower function\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToLower",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringToLower",
          "type": "function"
        },
        "index": {
          "description": "convert string to lowercase with standard Haskell toLower function",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToLower",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "To Lower",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringToLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvert string to uppercase with standard Haskell toUpper function\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToUpper",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringToUpper",
          "type": "function"
        },
        "index": {
          "description": "convert string to uppercase with standard Haskell toUpper function",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringToUpper",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "To Upper",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringToUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove leading and trailing whitespace with standard Haskell predicate isSpace\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringTrim",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#stringTrim",
          "type": "function"
        },
        "index": {
          "description": "remove leading and trailing whitespace with standard Haskell predicate isSpace",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "stringTrim",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Trim",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:stringTrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.Util",
          "name": "swap",
          "package": "hxt",
          "signature": "(a, b) -\u003e (b, a)",
          "source": "src/Text-XML-HXT-DOM-Util.html#swap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "swap",
          "normalized": "(a,b)-\u003e(b,a)",
          "package": "hxt",
          "signature": "(a,b)-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eescape XML chars &lt;  and ampercent by transforming them into character references, used for escaping text nodes\n\u003c/p\u003e\u003cp\u003esee also : \u003ccode\u003e\u003ca\u003eattrEscapeXml\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "textEscapeXml",
          "package": "hxt",
          "signature": "String -\u003e String",
          "source": "src/Text-XML-HXT-DOM-Util.html#textEscapeXml",
          "type": "function"
        },
        "index": {
          "description": "escape XML chars lt and ampercent by transforming them into character references used for escaping text nodes see also attrEscapeXml",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "textEscapeXml",
          "normalized": "String-\u003eString",
          "package": "hxt",
          "partial": "Escape Xml",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:textEscapeXml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.Util",
          "name": "toMaybe",
          "package": "hxt",
          "signature": "Bool -\u003e a -\u003e Maybe a",
          "source": "src/Text-XML-HXT-DOM-Util.html#toMaybe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "toMaybe",
          "normalized": "Bool-\u003ea-\u003eMaybe a",
          "package": "hxt",
          "partial": "Maybe",
          "signature": "Bool-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:toMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emothers little helpers for to much curry\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "uncurry3",
          "package": "hxt",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e (a, b, c) -\u003e d",
          "source": "src/Text-XML-HXT-DOM-Util.html#uncurry3",
          "type": "function"
        },
        "index": {
          "description": "mothers little helpers for to much curry",
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "uncurry3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003e(a,b,c)-\u003ed",
          "package": "hxt",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003e(a,b,c)-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:uncurry3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.Util",
          "name": "uncurry4",
          "package": "hxt",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e (a, b, c, d) -\u003e e",
          "source": "src/Text-XML-HXT-DOM-Util.html#uncurry4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM Util",
          "module": "Text.XML.HXT.DOM.Util",
          "name": "uncurry4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003e(a,b,c,d)-\u003ee",
          "package": "hxt",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003e(a,b,c,d)-\u003ee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-Util.html#v:uncurry4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstants for XML keywords, for special attribute names\n   and special attribute values\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "XmlKeywords",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html",
          "type": "module"
        },
        "index": {
          "description": "Constants for XML keywords for special attribute names and special attribute values",
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "XmlKeywords",
          "package": "hxt",
          "partial": "Xml Keywords",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_column",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_column",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_column",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_column"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_contentLength",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_contentLength",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_contentLength",
          "package": "hxt",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_contentLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_default",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_default",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_default",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_encoding",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_encoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_encoding",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_kind",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_kind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_kind",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_kind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_line",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_line",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_line",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_modifier",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_modifier",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_module",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_module",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_module",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_name",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_name",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_output_encoding",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_output_encoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_output_encoding",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_output_encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_peref",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_peref",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_peref",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_peref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_source",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_source",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_source",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_source"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_standalone",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_standalone",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_standalone",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_standalone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_status",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_status",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_status",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_type",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_type",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_url",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_url",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_url",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_url"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_value",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_value",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_version",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_version",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_version",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_xml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_xml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_xml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_xml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_xmlns",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#a_xmlns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "a_xmlns",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:a_xmlns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "dtdPrefix",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#dtdPrefix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "dtdPrefix",
          "package": "hxt",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:dtdPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "httpPrefix",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#httpPrefix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "httpPrefix",
          "package": "hxt",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:httpPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_any",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_any",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_any",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_cdata",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_cdata",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_cdata",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_cdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_default",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_default",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_default",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_empty",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_empty",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_entities",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_entities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_entities",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_entities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_entity",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_entity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_entity",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_entity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_enumeration",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_enumeration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_enumeration",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_enumeration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_fixed",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_fixed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_fixed",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_fixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_id",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_id",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_id",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_id"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_idref",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_idref",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_idref",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_idref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_idrefs",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_idrefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_idrefs",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_idrefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_ignore",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_ignore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_ignore",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_ignore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_implied",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_implied",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_implied",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_implied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_include",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_include",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_include",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_include"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_ndata",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_ndata",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_ndata",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_ndata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_nmtoken",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_nmtoken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_nmtoken",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_nmtoken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_nmtokens",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_nmtokens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_nmtokens",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_nmtokens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_notation",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_notation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_notation",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_notation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_pcdata",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_pcdata",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_pcdata",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_pcdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_peref",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_peref",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_peref",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_peref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_public",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_public",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_public",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_public"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_required",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_required",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_required",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_required"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_system",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#k_system",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "k_system",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:k_system"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelax NG namespace\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "relaxNamespace",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#relaxNamespace",
          "type": "function"
        },
        "index": {
          "description": "Relax NG namespace",
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "relaxNamespace",
          "package": "hxt",
          "partial": "Namespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:relaxNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "stringProtocol",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#stringProtocol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "stringProtocol",
          "package": "hxt",
          "partial": "Protocol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:stringProtocol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "t_root",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#t_root",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "t_root",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:t_root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "t_xml",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#t_xml",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "t_xml",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:t_xml"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferDefaultURI",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferDefaultURI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferDefaultURI",
          "package": "hxt",
          "partial": "Default URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferDefaultURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferEncoding",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferEncoding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferEncoding",
          "package": "hxt",
          "partial": "Encoding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferEncoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferMessage",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferMessage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferMessage",
          "package": "hxt",
          "partial": "Message",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferMessage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferMimeType",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferMimeType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferMimeType",
          "package": "hxt",
          "partial": "Mime Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferMimeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferPrefix",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferPrefix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferPrefix",
          "package": "hxt",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferProtocol",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferProtocol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferProtocol",
          "package": "hxt",
          "partial": "Protocol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferProtocol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferStatus",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferStatus",
          "package": "hxt",
          "partial": "Status",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferURI",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferURI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferURI",
          "package": "hxt",
          "partial": "URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferVersion",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#transferVersion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "transferVersion",
          "package": "hxt",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:transferVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_0",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_0",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_1",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_1",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_2",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_2",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_any",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_any",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_any",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_children",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_children",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_children",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_children"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_choice",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_choice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_choice",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_empty",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_empty",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_mixed",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_mixed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_mixed",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_mixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_no",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_no",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_no",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_no"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_null",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_null",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_option",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_option",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_pcdata",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_pcdata",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_pcdata",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_pcdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_plus",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_plus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_plus",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_seq",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_seq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_seq",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_star",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_star",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_star",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_yes",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#v_yes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "v_yes",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:v_yes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe predefined namespace uri for xml: \"http://www.w3.org/XML/1998/namespace\"\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "xmlNamespace",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#xmlNamespace",
          "type": "function"
        },
        "index": {
          "description": "the predefined namespace uri for xml http www.w3.org XML namespace",
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "xmlNamespace",
          "package": "hxt",
          "partial": "Namespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:xmlNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe predefined namespace uri for xmlns: \"http://www.w3.org/2000/xmlns/\"\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "xmlnsNamespace",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-DOM-XmlKeywords.html#xmlnsNamespace",
          "type": "function"
        },
        "index": {
          "description": "the predefined namespace uri for xmlns http www.w3.org xmlns",
          "hierarchy": "Text XML HXT DOM XmlKeywords",
          "module": "Text.XML.HXT.DOM.XmlKeywords",
          "name": "xmlnsNamespace",
          "package": "hxt",
          "partial": "Namespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlKeywords.html#v:xmlnsNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInterface for XmlArrow to basic data types NTree and XmlTree\n\u003c/p\u003e\u003cp\u003eIf this module must be used in code working with arrows,\n   it should be imported qualified e.g. \u003ccode\u003eas XN\u003c/code\u003e, to prevent name clashes.\n\u003c/p\u003e\u003cp\u003eFor code working on the \"node and tree level\" this module\n   is the interface for writing code without using the\n   constructor functions of \u003ccode\u003e\u003ca\u003eXNode\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNTree\u003c/a\u003e\u003c/code\u003e directly\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "XmlNode",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html",
          "type": "module"
        },
        "index": {
          "description": "Interface for XmlArrow to basic data types NTree and XmlTree If this module must be used in code working with arrows it should be imported qualified e.g as XN to prevent name clashes For code working on the node and tree level this module is the interface for writing code without using the constructor functions of XNode and NTree directly",
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "XmlNode",
          "package": "hxt",
          "partial": "Xml Node",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "XmlNode",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#XmlNode",
          "type": "class"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "XmlNode",
          "package": "hxt",
          "partial": "Xml Node",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#t:XmlNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "addAttr",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#addAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "addAttr",
          "normalized": "XmlTree-\u003eXmlTrees-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Attr",
          "signature": "XmlTree-\u003eXmlTrees-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:addAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeAttrName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeAttrName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeAttrName",
          "normalized": "(QName-\u003eQName)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Attr Name",
          "signature": "(QName-\u003eQName)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeAttrName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeAttrl",
          "package": "hxt",
          "signature": "(XmlTrees -\u003e XmlTrees) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeAttrl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeAttrl",
          "normalized": "(XmlTrees-\u003eXmlTrees)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Attrl",
          "signature": "(XmlTrees-\u003eXmlTrees)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeBlob",
          "package": "hxt",
          "signature": "(Blob -\u003e Blob) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeBlob",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeBlob",
          "normalized": "(Blob-\u003eBlob)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Blob",
          "signature": "(Blob-\u003eBlob)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeCmt",
          "package": "hxt",
          "signature": "(String -\u003e String) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeCmt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeCmt",
          "normalized": "(String-\u003eString)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Cmt",
          "signature": "(String-\u003eString)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeDTDAttrl",
          "package": "hxt",
          "signature": "(Attributes -\u003e Attributes) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeDTDAttrl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeDTDAttrl",
          "normalized": "(Attributes-\u003eAttributes)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "DTDAttrl",
          "signature": "(Attributes-\u003eAttributes)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeDTDAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeElemName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeElemName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeElemName",
          "normalized": "(QName-\u003eQName)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Elem Name",
          "signature": "(QName-\u003eQName)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeElemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeName",
          "normalized": "(QName-\u003eQName)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Name",
          "signature": "(QName-\u003eQName)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changePiName",
          "package": "hxt",
          "signature": "(QName -\u003e QName) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changePiName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changePiName",
          "normalized": "(QName-\u003eQName)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Pi Name",
          "signature": "(QName-\u003eQName)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changePiName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeText",
          "package": "hxt",
          "signature": "(String -\u003e String) -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#changeText",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "changeText",
          "normalized": "(String-\u003eString)-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Text",
          "signature": "(String-\u003eString)-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:changeText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "concText",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#concText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "concText",
          "normalized": "XmlTree-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Text",
          "signature": "XmlTree-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:concText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getAttrName",
          "package": "hxt",
          "signature": "a -\u003e Maybe QName",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getAttrName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getAttrName",
          "normalized": "a-\u003eMaybe QName",
          "package": "hxt",
          "partial": "Attr Name",
          "signature": "a-\u003eMaybe QName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getAttrName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getAttrl",
          "package": "hxt",
          "signature": "a -\u003e Maybe XmlTrees",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getAttrl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getAttrl",
          "normalized": "a-\u003eMaybe XmlTrees",
          "package": "hxt",
          "partial": "Attrl",
          "signature": "a-\u003eMaybe XmlTrees",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getBlob",
          "package": "hxt",
          "signature": "a -\u003e Maybe Blob",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getBlob",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getBlob",
          "normalized": "a-\u003eMaybe Blob",
          "package": "hxt",
          "partial": "Blob",
          "signature": "a-\u003eMaybe Blob",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getCdata",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getCdata",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getCdata",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Cdata",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getCharRef",
          "package": "hxt",
          "signature": "a -\u003e Maybe Int",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getCharRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getCharRef",
          "normalized": "a-\u003eMaybe Int",
          "package": "hxt",
          "partial": "Char Ref",
          "signature": "a-\u003eMaybe Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getCmt",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getCmt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getCmt",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Cmt",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getDTDAttrl",
          "package": "hxt",
          "signature": "a -\u003e Maybe Attributes",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getDTDAttrl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getDTDAttrl",
          "normalized": "a-\u003eMaybe Attributes",
          "package": "hxt",
          "partial": "DTDAttrl",
          "signature": "a-\u003eMaybe Attributes",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getDTDAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getDTDPart",
          "package": "hxt",
          "signature": "a -\u003e Maybe DTDElem",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getDTDPart",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getDTDPart",
          "normalized": "a-\u003eMaybe DTDElem",
          "package": "hxt",
          "partial": "DTDPart",
          "signature": "a-\u003eMaybe DTDElem",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getDTDPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getElemName",
          "package": "hxt",
          "signature": "a -\u003e Maybe QName",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getElemName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getElemName",
          "normalized": "a-\u003eMaybe QName",
          "package": "hxt",
          "partial": "Elem Name",
          "signature": "a-\u003eMaybe QName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getElemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getEntityRef",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getEntityRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getEntityRef",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Entity Ref",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getErrorLevel",
          "package": "hxt",
          "signature": "a -\u003e Maybe Int",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getErrorLevel",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getErrorLevel",
          "normalized": "a-\u003eMaybe Int",
          "package": "hxt",
          "partial": "Error Level",
          "signature": "a-\u003eMaybe Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getErrorLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getErrorMsg",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getErrorMsg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getErrorMsg",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Error Msg",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getErrorMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getLocalPart",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getLocalPart",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getLocalPart",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Local Part",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getLocalPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getName",
          "package": "hxt",
          "signature": "a -\u003e Maybe QName",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getName",
          "normalized": "a-\u003eMaybe QName",
          "package": "hxt",
          "partial": "Name",
          "signature": "a-\u003eMaybe QName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getNamePrefix",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getNamePrefix",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getNamePrefix",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Name Prefix",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getNamePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getNamespaceUri",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getNamespaceUri",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getNamespaceUri",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Namespace Uri",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getNamespaceUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getPiContent",
          "package": "hxt",
          "signature": "a -\u003e Maybe XmlTrees",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getPiContent",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getPiContent",
          "normalized": "a-\u003eMaybe XmlTrees",
          "package": "hxt",
          "partial": "Pi Content",
          "signature": "a-\u003eMaybe XmlTrees",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getPiContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getPiName",
          "package": "hxt",
          "signature": "a -\u003e Maybe QName",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getPiName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getPiName",
          "normalized": "a-\u003eMaybe QName",
          "package": "hxt",
          "partial": "Pi Name",
          "signature": "a-\u003eMaybe QName",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getPiName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getQualifiedName",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getQualifiedName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getQualifiedName",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Qualified Name",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getQualifiedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getText",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getText",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getText",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Text",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getUniversalName",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getUniversalName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getUniversalName",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Universal Name",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getUniversalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getUniversalUri",
          "package": "hxt",
          "signature": "a -\u003e Maybe String",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#getUniversalUri",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "getUniversalUri",
          "normalized": "a-\u003eMaybe String",
          "package": "hxt",
          "partial": "Universal Uri",
          "signature": "a-\u003eMaybe String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:getUniversalUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isAttr",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isAttr",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isAttr",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Attr",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isBlob",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isBlob",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isBlob",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Blob",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isCdata",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isCdata",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isCdata",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Cdata",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isCharRef",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isCharRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isCharRef",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Char Ref",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isCmt",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isCmt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isCmt",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Cmt",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isDTD",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isDTD",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isDTD",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "DTD",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isElem",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isElem",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isElem",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Elem",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isEntityRef",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isEntityRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isEntityRef",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Entity Ref",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isError",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isError",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isError",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Error",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isPi",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isPi",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isPi",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Pi",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isRoot",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isRoot",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isRoot",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Root",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isText",
          "package": "hxt",
          "signature": "a -\u003e Bool",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#isText",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "isText",
          "normalized": "a-\u003eBool",
          "package": "hxt",
          "partial": "Text",
          "signature": "a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:isText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mergeAttrl",
          "package": "hxt",
          "signature": "XmlTrees -\u003e XmlTrees -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mergeAttrl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mergeAttrl",
          "normalized": "XmlTrees-\u003eXmlTrees-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Attrl",
          "signature": "XmlTrees-\u003eXmlTrees-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mergeAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mergeText",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mergeText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mergeText",
          "normalized": "XmlTree-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Text",
          "signature": "XmlTree-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mergeText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkAttr",
          "package": "hxt",
          "signature": "QName -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkAttr",
          "normalized": "QName-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "Attr",
          "signature": "QName-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkAttr'",
          "package": "hxt",
          "signature": "QName -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkAttr%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkAttr'",
          "normalized": "QName-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "Attr'",
          "signature": "QName-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkAttr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkAttrNode",
          "package": "hxt",
          "signature": "QName -\u003e XNode",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkAttrNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkAttrNode",
          "normalized": "QName-\u003eXNode",
          "package": "hxt",
          "partial": "Attr Node",
          "signature": "QName-\u003eXNode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkAttrNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkBlob",
          "package": "hxt",
          "signature": "Blob -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkBlob",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkBlob",
          "normalized": "Blob-\u003ea",
          "package": "hxt",
          "partial": "Blob",
          "signature": "Blob-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCdata",
          "package": "hxt",
          "signature": "String -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkCdata",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCdata",
          "normalized": "String-\u003ea",
          "package": "hxt",
          "partial": "Cdata",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkCdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCdata'",
          "package": "hxt",
          "signature": "String -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkCdata%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCdata'",
          "normalized": "String-\u003eXmlTree",
          "package": "hxt",
          "partial": "Cdata'",
          "signature": "String-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkCdata-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCharRef",
          "package": "hxt",
          "signature": "Int -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkCharRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCharRef",
          "normalized": "Int-\u003ea",
          "package": "hxt",
          "partial": "Char Ref",
          "signature": "Int-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkCharRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCharRef'",
          "package": "hxt",
          "signature": "Int -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkCharRef%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCharRef'",
          "normalized": "Int-\u003eXmlTree",
          "package": "hxt",
          "partial": "Char Ref'",
          "signature": "Int-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkCharRef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCmt",
          "package": "hxt",
          "signature": "String -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkCmt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCmt",
          "normalized": "String-\u003ea",
          "package": "hxt",
          "partial": "Cmt",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCmt'",
          "package": "hxt",
          "signature": "String -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkCmt%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkCmt'",
          "normalized": "String-\u003eXmlTree",
          "package": "hxt",
          "partial": "Cmt'",
          "signature": "String-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkCmt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkDTDElem",
          "package": "hxt",
          "signature": "DTDElem -\u003e Attributes -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkDTDElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkDTDElem",
          "normalized": "DTDElem-\u003eAttributes-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "DTDElem",
          "signature": "DTDElem-\u003eAttributes-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkDTDElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkDTDElem'",
          "package": "hxt",
          "signature": "DTDElem -\u003e Attributes -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkDTDElem%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkDTDElem'",
          "normalized": "DTDElem-\u003eAttributes-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "DTDElem'",
          "signature": "DTDElem-\u003eAttributes-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkDTDElem-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkDTDNode",
          "package": "hxt",
          "signature": "DTDElem -\u003e Attributes -\u003e XNode",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkDTDNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkDTDNode",
          "normalized": "DTDElem-\u003eAttributes-\u003eXNode",
          "package": "hxt",
          "partial": "DTDNode",
          "signature": "DTDElem-\u003eAttributes-\u003eXNode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkDTDNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkElement",
          "package": "hxt",
          "signature": "QName -\u003e XmlTrees -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkElement",
          "normalized": "QName-\u003eXmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "Element",
          "signature": "QName-\u003eXmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eweak normalform versions of constructors\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkElement'",
          "package": "hxt",
          "signature": "QName -\u003e XmlTrees -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkElement%27",
          "type": "function"
        },
        "index": {
          "description": "weak normalform versions of constructors",
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkElement'",
          "normalized": "QName-\u003eXmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "Element'",
          "signature": "QName-\u003eXmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkElement-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkElementNode",
          "package": "hxt",
          "signature": "QName -\u003e XmlTrees -\u003e XNode",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkElementNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkElementNode",
          "normalized": "QName-\u003eXmlTrees-\u003eXNode",
          "package": "hxt",
          "partial": "Element Node",
          "signature": "QName-\u003eXmlTrees-\u003eXNode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkElementNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkEntityRef",
          "package": "hxt",
          "signature": "String -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkEntityRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkEntityRef",
          "normalized": "String-\u003ea",
          "package": "hxt",
          "partial": "Entity Ref",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkEntityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkEntityRef'",
          "package": "hxt",
          "signature": "String -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkEntityRef%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkEntityRef'",
          "normalized": "String-\u003eXmlTree",
          "package": "hxt",
          "partial": "Entity Ref'",
          "signature": "String-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkEntityRef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkError",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkError",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkError",
          "normalized": "Int-\u003eString-\u003ea",
          "package": "hxt",
          "partial": "Error",
          "signature": "Int-\u003eString-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkError'",
          "package": "hxt",
          "signature": "Int -\u003e String -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkError%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkError'",
          "normalized": "Int-\u003eString-\u003eXmlTree",
          "package": "hxt",
          "partial": "Error'",
          "signature": "Int-\u003eString-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkPi",
          "package": "hxt",
          "signature": "QName -\u003e XmlTrees -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkPi",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkPi",
          "normalized": "QName-\u003eXmlTrees-\u003ea",
          "package": "hxt",
          "partial": "Pi",
          "signature": "QName-\u003eXmlTrees-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkPi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkPi'",
          "package": "hxt",
          "signature": "QName -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkPi%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkPi'",
          "normalized": "QName-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "Pi'",
          "signature": "QName-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkPi-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkRoot",
          "package": "hxt",
          "signature": "XmlTrees -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkRoot",
          "normalized": "XmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "Root",
          "signature": "XmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkRoot'",
          "package": "hxt",
          "signature": "XmlTrees -\u003e XmlTrees -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkRoot%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkRoot'",
          "normalized": "XmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "package": "hxt",
          "partial": "Root'",
          "signature": "XmlTrees-\u003eXmlTrees-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkRoot-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkText",
          "package": "hxt",
          "signature": "String -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkText",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkText",
          "normalized": "String-\u003ea",
          "package": "hxt",
          "partial": "Text",
          "signature": "String-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkText'",
          "package": "hxt",
          "signature": "String -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#mkText%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "mkText'",
          "normalized": "String-\u003eXmlTree",
          "package": "hxt",
          "partial": "Text'",
          "signature": "String-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:mkText-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setAttrName",
          "package": "hxt",
          "signature": "QName -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setAttrName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setAttrName",
          "normalized": "QName-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Attr Name",
          "signature": "QName-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setAttrName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setBlob",
          "package": "hxt",
          "signature": "Blob -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setBlob",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setBlob",
          "normalized": "Blob-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Blob",
          "signature": "Blob-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setBlob"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setCmt",
          "package": "hxt",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setCmt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setCmt",
          "normalized": "String-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Cmt",
          "signature": "String-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setCmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setDTDAttrl",
          "package": "hxt",
          "signature": "Attributes -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setDTDAttrl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setDTDAttrl",
          "normalized": "Attributes-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "DTDAttrl",
          "signature": "Attributes-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setDTDAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setElemAttrl",
          "package": "hxt",
          "signature": "XmlTrees -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setElemAttrl",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setElemAttrl",
          "normalized": "XmlTrees-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Elem Attrl",
          "signature": "XmlTrees-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setElemAttrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setElemName",
          "package": "hxt",
          "signature": "QName -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setElemName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setElemName",
          "normalized": "QName-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Elem Name",
          "signature": "QName-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setElemName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setName",
          "package": "hxt",
          "signature": "QName -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setName",
          "normalized": "QName-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Name",
          "signature": "QName-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setPiName",
          "package": "hxt",
          "signature": "QName -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setPiName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setPiName",
          "normalized": "QName-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Pi Name",
          "signature": "QName-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setPiName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setText",
          "package": "hxt",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#setText",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "setText",
          "normalized": "String-\u003ea-\u003ea",
          "package": "hxt",
          "partial": "Text",
          "signature": "String-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:setText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "toText",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTree",
          "source": "src/Text-XML-HXT-DOM-XmlNode.html#toText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DOM XmlNode",
          "module": "Text.XML.HXT.DOM.XmlNode",
          "name": "toText",
          "normalized": "XmlTree-\u003eXmlTree",
          "package": "hxt",
          "partial": "Text",
          "signature": "XmlTree-\u003eXmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DOM-XmlNode.html#v:toText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for validating attributes.\n\u003c/p\u003e\u003cp\u003eThe main functions are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Check if the attribute value meets the lexical constraints of its type\n\u003c/li\u003e\u003cli\u003e Normalization of an attribute value\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.AttributeValueValidation",
          "name": "AttributeValueValidation",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-AttributeValueValidation.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for validating attributes The main functions are Check if the attribute value meets the lexical constraints of its type Normalization of an attribute value",
          "hierarchy": "Text XML HXT DTDValidation AttributeValueValidation",
          "module": "Text.XML.HXT.DTDValidation.AttributeValueValidation",
          "name": "AttributeValueValidation",
          "package": "hxt",
          "partial": "Attribute Value Validation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-AttributeValueValidation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if the attribute value meets the lexical constraints of its type.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter dtdPart :  the children of the \u003ccode\u003eDOCTYPE\u003c/code\u003e node\n\u003c/li\u003e\u003cli\u003e 2.parameter attrDecl :  the declaration of the attribute from the DTD\n\u003c/li\u003e\u003cli\u003e returns : a function which takes an element (XTag or XDTD ATTLIST),\n                    checks if the attribute value meets the lexical constraints\n                    of its type and returns a list of errors\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.AttributeValueValidation",
          "name": "checkAttributeValue",
          "package": "hxt",
          "signature": "XmlTrees -\u003e XmlTree -\u003e XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-AttributeValueValidation.html#checkAttributeValue",
          "type": "function"
        },
        "index": {
          "description": "Checks if the attribute value meets the lexical constraints of its type parameter dtdPart the children of the DOCTYPE node parameter attrDecl the declaration of the attribute from the DTD returns function which takes an element XTag or XDTD ATTLIST checks if the attribute value meets the lexical constraints of its type and returns list of errors",
          "hierarchy": "Text XML HXT DTDValidation AttributeValueValidation",
          "module": "Text.XML.HXT.DTDValidation.AttributeValueValidation",
          "name": "checkAttributeValue",
          "normalized": "XmlTrees-\u003eXmlTree-\u003eXmlArrow",
          "package": "hxt",
          "partial": "Attribute Value",
          "signature": "XmlTrees-\u003eXmlTree-\u003eXmlArrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-AttributeValueValidation.html#v:checkAttributeValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormalizes an attribute value with respect to its type. (3.3.3 / p.29 in Spec)\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter attrDecl :  the declaration of the attribute from the DTD. Expected\n                   is a list. If the list is empty, no declaration exists.\n\u003c/li\u003e\u003cli\u003e 2.parameter value :  the attribute value to be normalized\n\u003c/li\u003e\u003cli\u003e returns : the normalized value\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.AttributeValueValidation",
          "name": "normalizeAttributeValue",
          "package": "hxt",
          "signature": "Maybe XmlTree -\u003e String -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-AttributeValueValidation.html#normalizeAttributeValue",
          "type": "function"
        },
        "index": {
          "description": "Normalizes an attribute value with respect to its type p.29 in Spec parameter attrDecl the declaration of the attribute from the DTD Expected is list If the list is empty no declaration exists parameter value the attribute value to be normalized returns the normalized value",
          "hierarchy": "Text XML HXT DTDValidation AttributeValueValidation",
          "module": "Text.XML.HXT.DTDValidation.AttributeValueValidation",
          "name": "normalizeAttributeValue",
          "normalized": "Maybe XmlTree-\u003eString-\u003eString",
          "package": "hxt",
          "partial": "Attribute Value",
          "signature": "Maybe XmlTree-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-AttributeValueValidation.html#v:normalizeAttributeValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for validating the DTD of XML documents\n   represented as XmlTree.\n\u003c/p\u003e\u003cp\u003eUnlike other popular XML validation tools the validation process returns\n   a list of errors instead of aborting after the first error was found.\n\u003c/p\u003e\u003cp\u003eUnlike validation of the document, the DTD branch is traversed four times:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Validation of Notations\n\u003c/li\u003e\u003cli\u003e Validation of Unparsed Entities\n\u003c/li\u003e\u003cli\u003e Validation of Element declarations\n\u003c/li\u003e\u003cli\u003e Validation of Attribute declarations\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.DTDValidation",
          "name": "DTDValidation",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-DTDValidation.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for validating the DTD of XML documents represented as XmlTree Unlike other popular XML validation tools the validation process returns list of errors instead of aborting after the first error was found Unlike validation of the document the DTD branch is traversed four times Validation of Notations Validation of Unparsed Entities Validation of Element declarations Validation of Attribute declarations",
          "hierarchy": "Text XML HXT DTDValidation DTDValidation",
          "module": "Text.XML.HXT.DTDValidation.DTDValidation",
          "name": "DTDValidation",
          "package": "hxt",
          "partial": "DTDValidation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-DTDValidation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemoves doublicate declarations from the DTD, which first declaration is\n binding. This is the case for ATTLIST and ENTITY declarations.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : A function that replaces the children of DOCTYPE nodes by a list\n               where all multiple declarations are removed.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.DTDValidation",
          "name": "removeDoublicateDefs",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-DTDValidation.html#removeDoublicateDefs",
          "type": "function"
        },
        "index": {
          "description": "Removes doublicate declarations from the DTD which first declaration is binding This is the case for ATTLIST and ENTITY declarations returns function that replaces the children of DOCTYPE nodes by list where all multiple declarations are removed",
          "hierarchy": "Text XML HXT DTDValidation DTDValidation",
          "module": "Text.XML.HXT.DTDValidation.DTDValidation",
          "name": "removeDoublicateDefs",
          "package": "hxt",
          "partial": "Doublicate Defs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-DTDValidation.html#v:removeDoublicateDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValidate a DTD.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : a functions which takes the DTD subset of the XmlTree, checks\n                  if the DTD is valid and returns a list of errors\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.DTDValidation",
          "name": "validateDTD",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-DTDValidation.html#validateDTD",
          "type": "function"
        },
        "index": {
          "description": "Validate DTD returns functions which takes the DTD subset of the XmlTree checks if the DTD is valid and returns list of errors",
          "hierarchy": "Text XML HXT DTDValidation DTDValidation",
          "module": "Text.XML.HXT.DTDValidation.DTDValidation",
          "name": "validateDTD",
          "package": "hxt",
          "partial": "DTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-DTDValidation.html#v:validateDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for transforming XML documents represented as\n   XmlTree with respect to its DTD.\n\u003c/p\u003e\u003cp\u003eTransforming an XML document with respect to its DTD means:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e add all attributes with default values\n\u003c/li\u003e\u003cli\u003e normalize all attribute values\n\u003c/li\u003e\u003cli\u003e sort all attributes in lexical order\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote: Transformation should be started after validation.\n\u003c/p\u003e\u003cp\u003eBefore the document is validated, a lookup-table is build on the basis of\n   the DTD which maps element names to their transformation functions.\n   After this initialization phase the whole document is traversed in preorder\n   and every element is transformed by the XmlFilter from the lookup-table.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.DocTransformation",
          "name": "DocTransformation",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-DocTransformation.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for transforming XML documents represented as XmlTree with respect to its DTD Transforming an XML document with respect to its DTD means add all attributes with default values normalize all attribute values sort all attributes in lexical order Note Transformation should be started after validation Before the document is validated lookup-table is build on the basis of the DTD which maps element names to their transformation functions After this initialization phase the whole document is traversed in preorder and every element is transformed by the XmlFilter from the lookup-table",
          "hierarchy": "Text XML HXT DTDValidation DocTransformation",
          "module": "Text.XML.HXT.DTDValidation.DocTransformation",
          "name": "DocTransformation",
          "package": "hxt",
          "partial": "Doc Transformation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-DocTransformation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efilter for transforming the document.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter dtdPart :  the DTD subset (Node \u003ccode\u003eDOCTYPE\u003c/code\u003e) of the XmlTree\n\u003c/li\u003e\u003cli\u003e 2.parameter doc :  the document subset of the XmlTree\n\u003c/li\u003e\u003cli\u003e returns : a list of errors\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.DocTransformation",
          "name": "transform",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-DocTransformation.html#transform",
          "type": "function"
        },
        "index": {
          "description": "filter for transforming the document parameter dtdPart the DTD subset Node DOCTYPE of the XmlTree parameter doc the document subset of the XmlTree returns list of errors",
          "hierarchy": "Text XML HXT DTDValidation DocTransformation",
          "module": "Text.XML.HXT.DTDValidation.DocTransformation",
          "name": "transform",
          "normalized": "XmlTree-\u003eXmlArrow",
          "package": "hxt",
          "signature": "XmlTree-\u003eXmlArrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-DocTransformation.html#v:transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for validating XML Documents represented as\n   XmlTree.\n\u003c/p\u003e\u003cp\u003eUnlike other popular XML validation tools the validation process returns\n   a list of errors instead of aborting after the first error was found.\n\u003c/p\u003e\u003cp\u003eBefore the document is validated, a lookup-table is build on the basis of\n   the DTD which maps element names to their validation functions.\n   After this initialization phase the whole document is traversed in preorder\n   and every element is validated by the XmlFilter from the lookup-table.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.DocValidation",
          "name": "DocValidation",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-DocValidation.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for validating XML Documents represented as XmlTree Unlike other popular XML validation tools the validation process returns list of errors instead of aborting after the first error was found Before the document is validated lookup-table is build on the basis of the DTD which maps element names to their validation functions After this initialization phase the whole document is traversed in preorder and every element is validated by the XmlFilter from the lookup-table",
          "hierarchy": "Text XML HXT DTDValidation DocValidation",
          "module": "Text.XML.HXT.DTDValidation.DocValidation",
          "name": "DocValidation",
          "package": "hxt",
          "partial": "Doc Validation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-DocValidation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValidate a document.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter dtdPart :  the DTD subset (Node \u003ccode\u003eDOCTYPE\u003c/code\u003e) of the XmlTree\n\u003c/li\u003e\u003cli\u003e 2.parameter doc :  the document subset of the XmlTree\n\u003c/li\u003e\u003cli\u003e returns : a list of errors\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.DocValidation",
          "name": "validateDoc",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-DocValidation.html#validateDoc",
          "type": "function"
        },
        "index": {
          "description": "Validate document parameter dtdPart the DTD subset Node DOCTYPE of the XmlTree parameter doc the document subset of the XmlTree returns list of errors",
          "hierarchy": "Text XML HXT DTDValidation DocValidation",
          "module": "Text.XML.HXT.DTDValidation.DocValidation",
          "name": "validateDoc",
          "normalized": "XmlTree-\u003eXmlArrow",
          "package": "hxt",
          "partial": "Doc",
          "signature": "XmlTree-\u003eXmlArrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-DocValidation.html#v:validateDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for checking special ID\u003cem\u003eIDREF\u003c/em\u003eIDREFS constraints.\n\u003c/p\u003e\u003cp\u003eChecking special ID/IDREF/IDREFS constraints means:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e checking that all ID values are unique.\n\u003c/li\u003e\u003cli\u003e checking that all IDREF/IDREFS values match the value of some ID attribute\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eID-Validation should be started before or after validating the document.\n\u003c/p\u003e\u003cp\u003eFirst all nodes with ID attributes are collected from the document, then\n   it is validated that values of ID attributes do not occure more than once.\n   During a second iteration over the document it is validated that there exists\n   an ID attribute value for IDREF/IDREFS attribute values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.IdValidation",
          "name": "IdValidation",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-IdValidation.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for checking special ID IDREF IDREFS constraints Checking special ID IDREF IDREFS constraints means checking that all ID values are unique checking that all IDREF IDREFS values match the value of some ID attribute ID-Validation should be started before or after validating the document First all nodes with ID attributes are collected from the document then it is validated that values of ID attributes do not occure more than once During second iteration over the document it is validated that there exists an ID attribute value for IDREF IDREFS attribute values",
          "hierarchy": "Text XML HXT DTDValidation IdValidation",
          "module": "Text.XML.HXT.DTDValidation.IdValidation",
          "name": "IdValidation",
          "package": "hxt",
          "partial": "Id Validation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-IdValidation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform the validation of the ID\u003cem\u003eIDREF\u003c/em\u003eIDREFS constraints.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter dtdPart :  the DTD subset (Node \u003ccode\u003eDOCTYPE\u003c/code\u003e) of the XmlTree\n\u003c/li\u003e\u003cli\u003e 2.parameter doc :  the document subset of the XmlTree\n\u003c/li\u003e\u003cli\u003e returns : a list of errors\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.IdValidation",
          "name": "validateIds",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-IdValidation.html#validateIds",
          "type": "function"
        },
        "index": {
          "description": "Perform the validation of the ID IDREF IDREFS constraints parameter dtdPart the DTD subset Node DOCTYPE of the XmlTree parameter doc the document subset of the XmlTree returns list of errors",
          "hierarchy": "Text XML HXT DTDValidation IdValidation",
          "module": "Text.XML.HXT.DTDValidation.IdValidation",
          "name": "validateIds",
          "normalized": "XmlTree-\u003eXmlArrow",
          "package": "hxt",
          "partial": "Ids",
          "signature": "XmlTree-\u003eXmlArrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-IdValidation.html#v:validateIds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for regular expression matching based on derivatives of regular expressions.\n\u003c/p\u003e\u003cp\u003eThe code was taken from Joe English (\u003ca\u003ehttp://www.flightlab.com/~joe/sgml/validate.html\u003c/a\u003e).\n   Tested and extended by Martin Schmidt.\n\u003c/p\u003e\u003cp\u003eFurther references for the algorithm:\n\u003c/p\u003e\u003cp\u003eJanusz A. Brzozowski.\n\u003c/p\u003e\u003cp\u003eDerivatives of Regular Expressions. Journal of the ACM, Volume 11, Issue 4, 1964.\n\u003c/p\u003e\u003cp\u003eMark Hopkins.\n\u003c/p\u003e\u003cp\u003eRegular Expression Package. Posted to comp.compilers, 1994.\n        Available per FTP at \u003ca\u003eftp://iecc.com/pub/file/regex.tar.gz\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html",
          "type": "module"
        },
        "index": {
          "description": "module for regular expression matching based on derivatives of regular expressions The code was taken from Joe English http www.flightlab.com joe sgml validate.html Tested and extended by Martin Schmidt Further references for the algorithm Janusz Brzozowski Derivatives of Regular Expressions Journal of the ACM Volume Issue Mark Hopkins Regular Expression Package Posted to comp.compilers Available per FTP at ftp iecc.com pub file regex.tar.gz",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE",
          "package": "hxt",
          "partial": "RE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData type for regular expressions.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "data"
        },
        "index": {
          "description": "Data type for regular expressions",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE",
          "package": "hxt",
          "partial": "RE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#t:RE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_ALT",
          "package": "hxt",
          "signature": "RE_ALT (RE a) (RE a)",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_ALT",
          "package": "hxt",
          "partial": "RE ALT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_ALT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_DOT",
          "package": "hxt",
          "signature": "RE_DOT",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_DOT",
          "package": "hxt",
          "partial": "RE DOT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_DOT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_OPT",
          "package": "hxt",
          "signature": "RE_OPT (RE a)",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_OPT",
          "package": "hxt",
          "partial": "RE OPT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_OPT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_PLUS",
          "package": "hxt",
          "signature": "RE_PLUS (RE a)",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_PLUS",
          "package": "hxt",
          "partial": "RE PLUS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_PLUS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_REP",
          "package": "hxt",
          "signature": "RE_REP (RE a)",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_REP",
          "package": "hxt",
          "partial": "RE REP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_REP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_SEQ",
          "package": "hxt",
          "signature": "RE_SEQ (RE a) (RE a)",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_SEQ",
          "package": "hxt",
          "partial": "RE SEQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_SEQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_SYM",
          "package": "hxt",
          "signature": "RE_SYM a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_SYM",
          "package": "hxt",
          "partial": "RE SYM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_SYM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_UNIT",
          "package": "hxt",
          "signature": "RE_UNIT",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_UNIT",
          "package": "hxt",
          "partial": "RE UNIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_UNIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_ZERO",
          "package": "hxt",
          "signature": "RE_ZERO String",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "RE_ZERO",
          "package": "hxt",
          "partial": "RE ZERO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:RE_ZERO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if an input matched a regular expression. The function should be\n called after matches.\n\u003c/p\u003e\u003cp\u003eWas the sentence used in \u003ccode\u003ematches\u003c/code\u003e in the language of the regular expression?\n -\u003e matches e s == s `in` L(e)?\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re :  the derived regular expression\n\u003c/li\u003e\u003cli\u003e returns : empty String if input matched the regular expression, otherwise\n               an error message is returned\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "checkRE",
          "package": "hxt",
          "signature": "RE a -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#checkRE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:checkRE\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:checkRE\"]"
        },
        "index": {
          "description": "Checks if an input matched regular expression The function should be called after matches Was the sentence used in matches in the language of the regular expression matches in parameter re the derived regular expression returns empty String if input matched the regular expression otherwise an error message is returned",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "checkRE",
          "normalized": "RE a-\u003eString",
          "package": "hxt",
          "partial": "RE",
          "signature": "RE a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:checkRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerives a regular expression with respect to a sentence.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re :  regular expression\n\u003c/li\u003e\u003cli\u003e 2.parameter s :  sentence to which the regular expression is applied\n\u003c/li\u003e\u003cli\u003e returns : the derived regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "matches",
          "package": "hxt",
          "signature": "RE a -\u003e [a] -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#matches",
          "type": "function"
        },
        "index": {
          "description": "Derives regular expression with respect to sentence parameter re regular expression parameter sentence to which the regular expression is applied returns the derived regular expression",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "matches",
          "normalized": "RE a-\u003e[a]-\u003eRE a",
          "package": "hxt",
          "signature": "RE a-\u003e[a]-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:matches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks if a regular expression matches the empty sequence.\n\u003c/p\u003e\u003cp\u003enullable e == [] `in` L(e)\n\u003c/p\u003e\u003cp\u003eThis check indicates if a regular expression fits to a sentence or not.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re :  regular expression to be checked\n\u003c/li\u003e\u003cli\u003e returns : true if regular expression matches the empty sequence,\n                otherwise false\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "nullable",
          "package": "hxt",
          "signature": "RE a -\u003e Bool",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#nullable",
          "type": "function"
        },
        "index": {
          "description": "Checks if regular expression matches the empty sequence nullable in This check indicates if regular expression fits to sentence or not parameter re regular expression to be checked returns true if regular expression matches the empty sequence otherwise false",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "nullable",
          "normalized": "RE a-\u003eBool",
          "package": "hxt",
          "signature": "RE a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:nullable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a string representation of a regular expression.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re :  a regular expression\n\u003c/li\u003e\u003cli\u003e returns : the string representation of the regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "printRE",
          "package": "hxt",
          "signature": "RE a -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#printRE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:printRE\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:printRE\"]"
        },
        "index": {
          "description": "Constructs string representation of regular expression parameter re regular expression returns the string representation of the regular expression",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "printRE",
          "normalized": "RE a-\u003eString",
          "package": "hxt",
          "partial": "RE",
          "signature": "RE a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:printRE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an alternative (|) of two regular expressions\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re_a :  first regular expression of alternative\n\u003c/li\u003e\u003cli\u003e 2.parameter re_b :  second regular expression of alternative\n\u003c/li\u003e\u003cli\u003e returns : new regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_alt",
          "package": "hxt",
          "signature": "RE a -\u003e RE a -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_alt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_alt\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_alt\"]"
        },
        "index": {
          "description": "Constructs an alternative of two regular expressions parameter re first regular expression of alternative parameter re second regular expression of alternative returns new regular expression",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_alt",
          "normalized": "RE a-\u003eRE a-\u003eRE a",
          "package": "hxt",
          "signature": "RE a-\u003eRE a-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a regular expression for accepting any singel symbol\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : regular expression for accepting any singel symbol\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_dot",
          "package": "hxt",
          "signature": "RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_dot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_dot\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_dot\"]"
        },
        "index": {
          "description": "Constructs regular expression for accepting any singel symbol returns regular expression for accepting any singel symbol",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_dot",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an option (?) of a regular expression\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re_a :  regular expression to be optional\n\u003c/li\u003e\u003cli\u003e returns : new regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_opt",
          "package": "hxt",
          "signature": "RE a -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_opt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_opt\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_opt\"]"
        },
        "index": {
          "description": "Constructs an option of regular expression parameter re regular expression to be optional returns new regular expression",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_opt",
          "normalized": "RE a-\u003eRE a",
          "package": "hxt",
          "signature": "RE a-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_opt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a repetition (+) of a regular expression\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re_a :  regular expression to be repeted\n\u003c/li\u003e\u003cli\u003e returns : new regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_plus",
          "package": "hxt",
          "signature": "RE a -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_plus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_plus\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_plus\"]"
        },
        "index": {
          "description": "Constructs repetition of regular expression parameter re regular expression to be repeted returns new regular expression",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_plus",
          "normalized": "RE a-\u003eRE a",
          "package": "hxt",
          "signature": "RE a-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_plus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an optional repetition (*) of a regular expression\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re_a :  regular expression to be repeted\n\u003c/li\u003e\u003cli\u003e returns : new regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_rep",
          "package": "hxt",
          "signature": "RE a -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_rep",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_rep\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_rep\"]"
        },
        "index": {
          "description": "Constructs an optional repetition of regular expression parameter re regular expression to be repeted returns new regular expression",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_rep",
          "normalized": "RE a-\u003eRE a",
          "package": "hxt",
          "signature": "RE a-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_rep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a sequence (,) of two regular expressions\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re_a :  first regular expression in sequence\n\u003c/li\u003e\u003cli\u003e 2.parameter re_b :  second regular expression in sequence\n\u003c/li\u003e\u003cli\u003e returns : new regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_seq",
          "package": "hxt",
          "signature": "RE a -\u003e RE a -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_seq",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_seq\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_seq\"]"
        },
        "index": {
          "description": "Constructs sequence of two regular expressions parameter re first regular expression in sequence parameter re second regular expression in sequence returns new regular expression",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_seq",
          "normalized": "RE a-\u003eRE a-\u003eRE a",
          "package": "hxt",
          "signature": "RE a-\u003eRE a-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a regular expression for accepting a symbol\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter sym :  the symbol to be accepted\n\u003c/li\u003e\u003cli\u003e returns : regular expression for accepting a symbol\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_sym",
          "package": "hxt",
          "signature": "a -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_sym",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_sym\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_sym\"]"
        },
        "index": {
          "description": "Constructs regular expression for accepting symbol parameter sym the symbol to be accepted returns regular expression for accepting symbol",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_sym",
          "normalized": "a-\u003eRE a",
          "package": "hxt",
          "signature": "a-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a regular expression for an empty sequence.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : regular expression for an empty sequence\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_unit",
          "package": "hxt",
          "signature": "RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_unit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_unit\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_unit\"]"
        },
        "index": {
          "description": "Constructs regular expression for an empty sequence returns regular expression for an empty sequence",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_unit",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_unit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a regular expression for an empty set.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter errMsg :  error message\n\u003c/li\u003e\u003cli\u003e returns : regular expression for an empty set\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Text.XML.HXT.DTDValidation.RE\",\"Text.XML.HXT.DTDValidation.XmlRE\"]",
          "name": "re_zero",
          "package": "hxt",
          "signature": "String -\u003e RE a",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#re_zero",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_zero\",\"http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:re_zero\"]"
        },
        "index": {
          "description": "Constructs regular expression for an empty set parameter errMsg error message returns regular expression for an empty set",
          "hierarchy": "Text XML HXT DTDValidation RE",
          "module": "Text.XML.HXT.DTDValidation.RE",
          "name": "re_zero",
          "normalized": "String-\u003eRE a",
          "package": "hxt",
          "signature": "String-\u003eRE a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-RE.html#v:re_zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides all datatypes for DTD validation\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides all datatypes for DTD validation",
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "TypeDefs",
          "package": "hxt",
          "partial": "Type Defs",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "XmlArrow",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#XmlArrow",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "XmlArrow",
          "package": "hxt",
          "partial": "Xml Arrow",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#t:XmlArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "XmlArrowS",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#XmlArrowS",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "XmlArrowS",
          "package": "hxt",
          "partial": "Xml Arrow",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#t:XmlArrowS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix operator for applying an arrow to a list of trees\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter f :  the arrow\n\u003c/li\u003e\u003cli\u003e 2.parameter ts :  the list of trees\n\u003c/li\u003e\u003cli\u003e returns : list of results\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "($$)",
          "package": "hxt",
          "signature": "XmlArrow -\u003e XmlTrees -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#%24%24",
          "type": "function"
        },
        "index": {
          "description": "infix operator for applying an arrow to list of trees parameter the arrow parameter ts the list of trees returns list of results",
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "($$) $$",
          "normalized": "XmlArrow-\u003eXmlTrees-\u003eXmlTrees",
          "package": "hxt",
          "signature": "XmlArrow-\u003eXmlTrees-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:-36--36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_default",
          "package": "hxt",
          "signature": "Attributes -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#dtd_default",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_default",
          "normalized": "Attributes-\u003eString",
          "package": "hxt",
          "signature": "Attributes-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:dtd_default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_kind",
          "package": "hxt",
          "signature": "Attributes -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#dtd_kind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_kind",
          "normalized": "Attributes-\u003eString",
          "package": "hxt",
          "signature": "Attributes-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:dtd_kind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_modifier",
          "package": "hxt",
          "signature": "Attributes -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#dtd_modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_modifier",
          "normalized": "Attributes-\u003eString",
          "package": "hxt",
          "signature": "Attributes-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:dtd_modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_name",
          "package": "hxt",
          "signature": "Attributes -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#dtd_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_name",
          "normalized": "Attributes-\u003eString",
          "package": "hxt",
          "signature": "Attributes-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:dtd_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_type",
          "package": "hxt",
          "signature": "Attributes -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#dtd_type",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_type",
          "normalized": "Attributes-\u003eString",
          "package": "hxt",
          "signature": "Attributes-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:dtd_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_value",
          "package": "hxt",
          "signature": "Attributes -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#dtd_value",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "dtd_value",
          "normalized": "Attributes-\u003eString",
          "package": "hxt",
          "signature": "Attributes-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:dtd_value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "getDTDAttributes",
          "package": "hxt",
          "signature": "XmlTree -\u003e Attributes",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#getDTDAttributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "getDTDAttributes",
          "normalized": "XmlTree-\u003eAttributes",
          "package": "hxt",
          "partial": "DTDAttributes",
          "signature": "XmlTree-\u003eAttributes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:getDTDAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "hasDTDAttrValue",
          "package": "hxt",
          "signature": "String -\u003e (String -\u003e Bool) -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#hasDTDAttrValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "hasDTDAttrValue",
          "normalized": "String-\u003e(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "DTDAttr Value",
          "signature": "String-\u003e(String-\u003eBool)-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:hasDTDAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isAttlistOfElement",
          "package": "hxt",
          "signature": "String -\u003e a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isAttlistOfElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isAttlistOfElement",
          "normalized": "String-\u003ea XmlTree XmlTree",
          "package": "hxt",
          "partial": "Attlist Of Element",
          "signature": "String-\u003ea XmlTree XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isAttlistOfElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDAttlistNode",
          "package": "hxt",
          "signature": "XmlTree -\u003e Bool",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isDTDAttlistNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDAttlistNode",
          "normalized": "XmlTree-\u003eBool",
          "package": "hxt",
          "partial": "DTDAttlist Node",
          "signature": "XmlTree-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isDTDAttlistNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDContentNode",
          "package": "hxt",
          "signature": "XmlTree -\u003e Bool",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isDTDContentNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDContentNode",
          "normalized": "XmlTree-\u003eBool",
          "package": "hxt",
          "partial": "DTDContent Node",
          "signature": "XmlTree-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isDTDContentNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDDoctypeNode",
          "package": "hxt",
          "signature": "XmlTree -\u003e Bool",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isDTDDoctypeNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDDoctypeNode",
          "normalized": "XmlTree-\u003eBool",
          "package": "hxt",
          "partial": "DTDDoctype Node",
          "signature": "XmlTree-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isDTDDoctypeNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDElementNode",
          "package": "hxt",
          "signature": "XmlTree -\u003e Bool",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isDTDElementNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDElementNode",
          "normalized": "XmlTree-\u003eBool",
          "package": "hxt",
          "partial": "DTDElement Node",
          "signature": "XmlTree-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isDTDElementNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDNameNode",
          "package": "hxt",
          "signature": "XmlTree -\u003e Bool",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isDTDNameNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDTDNameNode",
          "normalized": "XmlTree-\u003eBool",
          "package": "hxt",
          "partial": "DTDName Node",
          "signature": "XmlTree-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isDTDNameNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDefaultAttrKind",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isDefaultAttrKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isDefaultAttrKind",
          "package": "hxt",
          "partial": "Default Attr Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isDefaultAttrKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isElemNode",
          "package": "hxt",
          "signature": "XmlTree -\u003e Bool",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isElemNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isElemNode",
          "normalized": "XmlTree-\u003eBool",
          "package": "hxt",
          "partial": "Elem Node",
          "signature": "XmlTree-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isElemNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isEmptyElement",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isEmptyElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isEmptyElement",
          "package": "hxt",
          "partial": "Empty Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isEmptyElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isEnumAttrType",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isEnumAttrType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isEnumAttrType",
          "package": "hxt",
          "partial": "Enum Attr Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isEnumAttrType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isFixedAttrKind",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isFixedAttrKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isFixedAttrKind",
          "package": "hxt",
          "partial": "Fixed Attr Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isFixedAttrKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isIdAttrType",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isIdAttrType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isIdAttrType",
          "package": "hxt",
          "partial": "Id Attr Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isIdAttrType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isIdRefAttrType",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isIdRefAttrType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isIdRefAttrType",
          "package": "hxt",
          "partial": "Id Ref Attr Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isIdRefAttrType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isMixedContentElement",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isMixedContentElement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isMixedContentElement",
          "package": "hxt",
          "partial": "Mixed Content Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isMixedContentElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isNotationAttrType",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isNotationAttrType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isNotationAttrType",
          "package": "hxt",
          "partial": "Notation Attr Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isNotationAttrType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isRequiredAttrKind",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isRequiredAttrKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isRequiredAttrKind",
          "package": "hxt",
          "partial": "Required Attr Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isRequiredAttrKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isUnparsedEntity",
          "package": "hxt",
          "signature": "a XmlTree XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#isUnparsedEntity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "isUnparsedEntity",
          "package": "hxt",
          "partial": "Unparsed Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:isUnparsedEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate an error message\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "msgToErr",
          "package": "hxt",
          "signature": "(String -\u003e String) -\u003e LA String XmlTree",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#msgToErr",
          "type": "function"
        },
        "index": {
          "description": "create an error message",
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "msgToErr",
          "normalized": "(String-\u003eString)-\u003eLA String XmlTree",
          "package": "hxt",
          "partial": "To Err",
          "signature": "(String-\u003eString)-\u003eLA String XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:msgToErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "nameOfAttr",
          "package": "hxt",
          "signature": "XmlTree -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#nameOfAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "nameOfAttr",
          "normalized": "XmlTree-\u003eString",
          "package": "hxt",
          "partial": "Of Attr",
          "signature": "XmlTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:nameOfAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "nameOfElem",
          "package": "hxt",
          "signature": "XmlTree -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#nameOfElem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "nameOfElem",
          "normalized": "XmlTree-\u003eString",
          "package": "hxt",
          "partial": "Of Elem",
          "signature": "XmlTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:nameOfElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "valueOf",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#valueOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "valueOf",
          "normalized": "String-\u003eXmlTree-\u003eString",
          "package": "hxt",
          "partial": "Of",
          "signature": "String-\u003eXmlTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:valueOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "valueOfDTD",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e String",
          "source": "src/Text-XML-HXT-DTDValidation-TypeDefs.html#valueOfDTD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation TypeDefs",
          "module": "Text.XML.HXT.DTDValidation.TypeDefs",
          "name": "valueOfDTD",
          "normalized": "String-\u003eXmlTree-\u003eString",
          "package": "hxt",
          "partial": "Of DTD",
          "signature": "String-\u003eXmlTree-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-TypeDefs.html#v:valueOfDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides functions for validating XML documents represented as\n   XmlTree.\n\u003c/p\u003e\u003cp\u003eUnlike other popular XML validation tools the validation functions return\n   a list of errors instead of aborting after the first error was found.\n\u003c/p\u003e\u003cp\u003eNote: The validation process has been split into validation and transformation!\n   If \u003ccode\u003evalidate\u003c/code\u003e did not report any errors, \u003ccode\u003etransform\u003c/code\u003e\n   should be called, to change the document the way a validating parser\n   is expected to do.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "Validation",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides functions for validating XML documents represented as XmlTree Unlike other popular XML validation tools the validation functions return list of errors instead of aborting after the first error was found Note The validation process has been split into validation and transformation If validate did not report any errors transform should be called to change the document the way validating parser is expected to do",
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "Validation",
          "package": "hxt",
          "partial": "Validation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "generalEntitiesDefined",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html#generalEntitiesDefined",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "generalEntitiesDefined",
          "package": "hxt",
          "partial": "Entities Defined",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#v:generalEntitiesDefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "getDTDSubset",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html#getDTDSubset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "getDTDSubset",
          "package": "hxt",
          "partial": "DTDSubset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#v:getDTDSubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemoves doublicate declarations from the DTD which first declaration is\n binding. This is the case for ATTLIST and ENTITY declarations.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : A function that replaces the children of DOCTYPE nodes by a list\n               where all multiple declarations are removed.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "removeDoublicateDefs",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html#removeDoublicateDefs",
          "type": "function"
        },
        "index": {
          "description": "Removes doublicate declarations from the DTD which first declaration is binding This is the case for ATTLIST and ENTITY declarations returns function that replaces the children of DOCTYPE nodes by list where all multiple declarations are removed",
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "removeDoublicateDefs",
          "package": "hxt",
          "partial": "Doublicate Defs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#v:removeDoublicateDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efilter for transforming a document with respect to the given DTD.\n\u003c/p\u003e\u003cp\u003eValidating parsers\n are expected to  normalize attribute values and add default values.\n This function should be called after a successful validation.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : a function which expects a complete XML document tree\n                and returns the transformed XmlTree\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "transform",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html#transform",
          "type": "function"
        },
        "index": {
          "description": "filter for transforming document with respect to the given DTD Validating parsers are expected to normalize attribute values and add default values This function should be called after successful validation returns function which expects complete XML document tree and returns the transformed XmlTree",
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "transform",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#v:transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMain validation filter. Check if the DTD and the document are valid.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : a function which expects a complete document as XmlTree input\n                     and returns a list of all errors found.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "validate",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html#validate",
          "type": "function"
        },
        "index": {
          "description": "Main validation filter Check if the DTD and the document are valid returns function which expects complete document as XmlTree input and returns list of all errors found",
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "validate",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#v:validate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the DTD is valid.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : a function which expects an XmlTree from the parser as input\n                     and returns a list of all errors found in the DTD.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "validateDTD",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html#validateDTD",
          "type": "function"
        },
        "index": {
          "description": "Check if the DTD is valid returns function which expects an XmlTree from the parser as input and returns list of all errors found in the DTD",
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "validateDTD",
          "package": "hxt",
          "partial": "DTD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#v:validateDTD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the document corresponds to the given DTD.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e returns : a function which expects a complete document as XmlTree input\n                     and returns a list of all errors found in the content part.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "validateDoc",
          "package": "hxt",
          "signature": "XmlArrow",
          "source": "src/Text-XML-HXT-DTDValidation-Validation.html#validateDoc",
          "type": "function"
        },
        "index": {
          "description": "Check if the document corresponds to the given DTD returns function which expects complete document as XmlTree input and returns list of all errors found in the content part",
          "hierarchy": "Text XML HXT DTDValidation Validation",
          "module": "Text.XML.HXT.DTDValidation.Validation",
          "name": "validateDoc",
          "package": "hxt",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-Validation.html#v:validateDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for regular expression matching, adapted for XML DTDs.\n\u003c/p\u003e\u003cp\u003eThis module is based on the module RE.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.DTDValidation.XmlRE",
          "name": "XmlRE",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-XmlRE.html",
          "type": "module"
        },
        "index": {
          "description": "module for regular expression matching adapted for XML DTDs This module is based on the module RE",
          "hierarchy": "Text XML HXT DTDValidation XmlRE",
          "module": "Text.XML.HXT.DTDValidation.XmlRE",
          "name": "XmlRE",
          "package": "hxt",
          "partial": "Xml RE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData type for regular expressions.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.DTDValidation.XmlRE",
          "name": "RE",
          "package": "hxt",
          "source": "src/Text-XML-HXT-DTDValidation-RE.html#RE",
          "type": "data"
        },
        "index": {
          "description": "Data type for regular expressions",
          "hierarchy": "Text XML HXT DTDValidation XmlRE",
          "module": "Text.XML.HXT.DTDValidation.XmlRE",
          "name": "RE",
          "package": "hxt",
          "partial": "RE",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#t:RE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerives a regular expression with respect to a list of elements.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter re :  regular expression\n\u003c/li\u003e\u003cli\u003e 2.parameter list :  list of elements to which the regular expression is applied\n\u003c/li\u003e\u003cli\u003e returns : the derived regular expression\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.DTDValidation.XmlRE",
          "name": "matches",
          "package": "hxt",
          "signature": "RE String -\u003e XmlTrees -\u003e RE String",
          "source": "src/Text-XML-HXT-DTDValidation-XmlRE.html#matches",
          "type": "function"
        },
        "index": {
          "description": "Derives regular expression with respect to list of elements parameter re regular expression parameter list list of elements to which the regular expression is applied returns the derived regular expression",
          "hierarchy": "Text XML HXT DTDValidation XmlRE",
          "module": "Text.XML.HXT.DTDValidation.XmlRE",
          "name": "matches",
          "normalized": "RE String-\u003eXmlTrees-\u003eRE String",
          "package": "hxt",
          "signature": "RE String-\u003eXmlTrees-\u003eRE String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-DTDValidation-XmlRE.html#v:matches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe GET method for file protocol\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.IO.GetFILE",
          "name": "GetFILE",
          "package": "hxt",
          "source": "src/Text-XML-HXT-IO-GetFILE.html",
          "type": "module"
        },
        "index": {
          "description": "The GET method for file protocol",
          "hierarchy": "Text XML HXT IO GetFILE",
          "module": "Text.XML.HXT.IO.GetFILE",
          "name": "GetFILE",
          "package": "hxt",
          "partial": "Get FILE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-IO-GetFILE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.IO.GetFILE",
          "name": "getCont",
          "package": "hxt",
          "signature": "Bool -\u003e String -\u003e IO (Either ([(String, String)], String) ByteString)",
          "source": "src/Text-XML-HXT-IO-GetFILE.html#getCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT IO GetFILE",
          "module": "Text.XML.HXT.IO.GetFILE",
          "name": "getCont",
          "normalized": "Bool-\u003eString-\u003eIO(Either([(String,String)],String)ByteString)",
          "package": "hxt",
          "partial": "Cont",
          "signature": "Bool-\u003eString-\u003eIO(Either([(String,String)],String)ByteString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-IO-GetFILE.html#v:getCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.IO.GetFILE",
          "name": "getStdinCont",
          "package": "hxt",
          "signature": "Bool -\u003e IO (Either ([(String, String)], String) ByteString)",
          "source": "src/Text-XML-HXT-IO-GetFILE.html#getStdinCont",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT IO GetFILE",
          "module": "Text.XML.HXT.IO.GetFILE",
          "name": "getStdinCont",
          "normalized": "Bool-\u003eIO(Either([(String,String)],String)ByteString)",
          "package": "hxt",
          "partial": "Stdin Cont",
          "signature": "Bool-\u003eIO(Either([(String,String)],String)ByteString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-IO-GetFILE.html#v:getStdinCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis parser tries to interprete everything as HTML\n   no errors are emitted during parsing. If something looks\n   weired, warning messages are inserted in the document tree.\n\u003c/p\u003e\u003cp\u003eAll filter are pure XmlFilter,\n   errror handling and IO is done in \u003ccode\u003e\u003ca\u003eHtmlParser\u003c/a\u003e\u003c/code\u003e\n   or other modules\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "HtmlParsec",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html",
          "type": "module"
        },
        "index": {
          "description": "This parser tries to interprete everything as HTML no errors are emitted during parsing If something looks weired warning messages are inserted in the document tree All filter are pure XmlFilter errror handling and IO is done in HtmlParser or other modules",
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "HtmlParsec",
          "package": "hxt",
          "partial": "Html Parsec",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "closesHtmlTag",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html#closesHtmlTag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "closesHtmlTag",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "hxt",
          "partial": "Html Tag",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#v:closesHtmlTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "emptyHtmlTags",
          "package": "hxt",
          "signature": "[String]",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html#emptyHtmlTags",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "emptyHtmlTags",
          "normalized": "[String]",
          "package": "hxt",
          "partial": "Html Tags",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#v:emptyHtmlTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "isEmptyHtmlTag",
          "package": "hxt",
          "signature": "String -\u003e Bool",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html#isEmptyHtmlTag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "isEmptyHtmlTag",
          "normalized": "String-\u003eBool",
          "package": "hxt",
          "partial": "Empty Html Tag",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#v:isEmptyHtmlTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "isInnerHtmlTagOf",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html#isInnerHtmlTagOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "isInnerHtmlTagOf",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "hxt",
          "partial": "Inner Html Tag Of",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#v:isInnerHtmlTagOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "parseHtmlContent",
          "package": "hxt",
          "signature": "String -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html#parseHtmlContent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "parseHtmlContent",
          "normalized": "String-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Html Content",
          "signature": "String-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#v:parseHtmlContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "parseHtmlDocument",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html#parseHtmlDocument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "parseHtmlDocument",
          "normalized": "String-\u003eString-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Html Document",
          "signature": "String-\u003eString-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#v:parseHtmlDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "parseHtmlText",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-HtmlParsec.html#parseHtmlText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser HtmlParsec",
          "module": "Text.XML.HXT.Parser.HtmlParsec",
          "name": "parseHtmlText",
          "normalized": "String-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Html Text",
          "signature": "String-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-HtmlParsec.html#v:parseHtmlText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.ProtocolHandlerUtil",
          "name": "ProtocolHandlerUtil",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-ProtocolHandlerUtil.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser ProtocolHandlerUtil",
          "module": "Text.XML.HXT.Parser.ProtocolHandlerUtil",
          "name": "ProtocolHandlerUtil",
          "package": "hxt",
          "partial": "Protocol Handler Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-ProtocolHandlerUtil.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to extract charset spec from Content-Type header\n e.g. \"text/html; charset=ISO-8859-1\"\n\u003c/p\u003e\u003cp\u003eSometimes the server deliver the charset spec in quotes\n these are removed\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.ProtocolHandlerUtil",
          "name": "parseContentType",
          "package": "hxt",
          "signature": "Parser [(String, String)]",
          "source": "src/Text-XML-HXT-Parser-ProtocolHandlerUtil.html#parseContentType",
          "type": "function"
        },
        "index": {
          "description": "Try to extract charset spec from Content-Type header e.g text html charset ISO-8859-1 Sometimes the server deliver the charset spec in quotes these are removed",
          "hierarchy": "Text XML HXT Parser ProtocolHandlerUtil",
          "module": "Text.XML.HXT.Parser.ProtocolHandlerUtil",
          "name": "parseContentType",
          "normalized": "Parser[(String,String)]",
          "package": "hxt",
          "partial": "Content Type",
          "signature": "Parser[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-ProtocolHandlerUtil.html#v:parseContentType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eXHTML Entity References\n\u003c/p\u003e\u003cp\u003eThis module defines a table of all\n predefined XHTML entity references\n for special or none ASCII chars including the\n predefined XML entity refs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.XhtmlEntities",
          "name": "XhtmlEntities",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XhtmlEntities.html",
          "type": "module"
        },
        "index": {
          "description": "XHTML Entity References This module defines table of all predefined XHTML entity references for special or none ASCII chars including the predefined XML entity refs",
          "hierarchy": "Text XML HXT Parser XhtmlEntities",
          "module": "Text.XML.HXT.Parser.XhtmlEntities",
          "name": "XhtmlEntities",
          "package": "hxt",
          "partial": "Xhtml Entities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XhtmlEntities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etable with all XHTML entity refs and corresponding unicode values\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XhtmlEntities",
          "name": "xhtmlEntities",
          "package": "hxt",
          "signature": "[(String, Int)]",
          "source": "src/Text-XML-HXT-Parser-XhtmlEntities.html#xhtmlEntities",
          "type": "function"
        },
        "index": {
          "description": "table with all XHTML entity refs and corresponding unicode values",
          "hierarchy": "Text XML HXT Parser XhtmlEntities",
          "module": "Text.XML.HXT.Parser.XhtmlEntities",
          "name": "xhtmlEntities",
          "normalized": "[(String,Int)]",
          "package": "hxt",
          "partial": "Entities",
          "signature": "[(String,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XhtmlEntities.html#v:xhtmlEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUTF-8 character parser and simple XML token parsers\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XmlCharParser",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html",
          "type": "module"
        },
        "index": {
          "description": "UTF-8 character parser and simple XML token parsers",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XmlCharParser",
          "package": "hxt",
          "partial": "Xml Char Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "SimpleXParser",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#SimpleXParser",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "SimpleXParser",
          "package": "hxt",
          "partial": "Simple XParser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#t:SimpleXParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XPState",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#XPState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XPState",
          "package": "hxt",
          "partial": "XPState",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#t:XPState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XParser",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#XParser",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XParser",
          "package": "hxt",
          "partial": "XParser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#t:XParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XPState",
          "package": "hxt",
          "signature": "XPState",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#XPState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "XPState",
          "package": "hxt",
          "partial": "XPState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:XPState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "withNormNewline",
          "package": "hxt",
          "signature": "a -\u003e XPState a",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#withNormNewline",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "withNormNewline",
          "normalized": "a-\u003eXPState a",
          "package": "hxt",
          "partial": "Norm Newline",
          "signature": "a-\u003eXPState a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:withNormNewline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "withoutNormNewline",
          "package": "hxt",
          "signature": "a -\u003e XPState a",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#withoutNormNewline",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "withoutNormNewline",
          "normalized": "a-\u003eXPState a",
          "package": "hxt",
          "partial": "Norm Newline",
          "signature": "a-\u003eXPState a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:withoutNormNewline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhite Space Normalization\n\u003c/p\u003e\u003cp\u003eend of line handling (2.11)\n #x0D and #x0D#x0A are mapped to #x0A\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlCRLFChar",
          "package": "hxt",
          "signature": "XParser s Char",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlCRLFChar",
          "type": "function"
        },
        "index": {
          "description": "White Space Normalization end of line handling x0D and x0D x0A are mapped to x0A",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlCRLFChar",
          "package": "hxt",
          "partial": "CRLFChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlCRLFChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a single Unicode character\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlChar",
          "package": "hxt",
          "signature": "XParser s Unicode",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlChar",
          "type": "function"
        },
        "index": {
          "description": "parse single Unicode character",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlChar",
          "package": "hxt",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a XML letter character\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlLetter",
          "package": "hxt",
          "signature": "XParser s Unicode",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlLetter",
          "type": "function"
        },
        "index": {
          "description": "parse XML letter character",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlLetter",
          "package": "hxt",
          "partial": "Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a XML NCName character\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNCNameChar",
          "package": "hxt",
          "signature": "XParser s Unicode",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlNCNameChar",
          "type": "function"
        },
        "index": {
          "description": "parse XML NCName character",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNCNameChar",
          "package": "hxt",
          "partial": "NCName Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlNCNameChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a XML NCName start character\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNCNameStartChar",
          "package": "hxt",
          "signature": "XParser s Unicode",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlNCNameStartChar",
          "type": "function"
        },
        "index": {
          "description": "parse XML NCName start character",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNCNameStartChar",
          "package": "hxt",
          "partial": "NCName Start Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlNCNameStartChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a XML name character\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNameChar",
          "package": "hxt",
          "signature": "XParser s Unicode",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlNameChar",
          "type": "function"
        },
        "index": {
          "description": "parse XML name character",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNameChar",
          "package": "hxt",
          "partial": "Name Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlNameChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a XML name start character\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNameStartChar",
          "package": "hxt",
          "signature": "XParser s Unicode",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlNameStartChar",
          "type": "function"
        },
        "index": {
          "description": "parse XML name start character",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlNameStartChar",
          "package": "hxt",
          "partial": "Name Start Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlNameStartChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhite Space (2.3)\n\u003c/p\u003e\u003cp\u003eend of line handling (2.11) will be done before or with \u003ccode\u003e\u003ca\u003exmlCRLFChar\u003c/a\u003e\u003c/code\u003e parser\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlSpaceChar",
          "package": "hxt",
          "signature": "XParser s Char",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#xmlSpaceChar",
          "type": "function"
        },
        "index": {
          "description": "White Space end of line handling will be done before or with xmlCRLFChar parser",
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xmlSpaceChar",
          "package": "hxt",
          "partial": "Space Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xmlSpaceChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xps_normalizeNewline",
          "package": "hxt",
          "signature": "Bool",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#XPState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xps_normalizeNewline",
          "package": "hxt",
          "partial": "Newline",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xps_normalizeNewline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xps_userState",
          "package": "hxt",
          "signature": "s",
          "source": "src/Text-XML-HXT-Parser-XmlCharParser.html#XPState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlCharParser",
          "module": "Text.XML.HXT.Parser.XmlCharParser",
          "name": "xps_userState",
          "package": "hxt",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlCharParser.html#v:xps_userState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParsec parser for DTD declarations for ELEMENT, ATTLIST, ENTITY and NOTATION declarations\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "XmlDTDParser",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html",
          "type": "module"
        },
        "index": {
          "description": "Parsec parser for DTD declarations for ELEMENT ATTLIST ENTITY and NOTATION declarations",
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "XmlDTDParser",
          "package": "hxt",
          "partial": "Xml DTDParser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "attlistDecl",
          "package": "hxt",
          "signature": "SParser XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html#attlistDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "attlistDecl",
          "package": "hxt",
          "partial": "Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#v:attlistDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "elementDecl",
          "package": "hxt",
          "signature": "SParser XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html#elementDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "elementDecl",
          "package": "hxt",
          "partial": "Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#v:elementDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "entityDecl",
          "package": "hxt",
          "signature": "SParser XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html#entityDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "entityDecl",
          "package": "hxt",
          "partial": "Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#v:entityDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "notationDecl",
          "package": "hxt",
          "signature": "SParser XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html#notationDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "notationDecl",
          "package": "hxt",
          "partial": "Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#v:notationDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "parseXmlDTDEntityValue",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html#parseXmlDTDEntityValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "parseXmlDTDEntityValue",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml DTDEntity Value",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#v:parseXmlDTDEntityValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparse a tokenized DTD declaration represented by a DTD tree.\n The content is represented by the children containing text and parameter entity reference nodes.\n The parameter entity reference nodes contain their value in the children list, consisting of text\n and possibly again parameter entity reference nodes. This structure is build by the parameter entity\n substitution.\n Output is again a DTD declaration node, but this time completely parsed and ready for further DTD processing\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "parseXmlDTDdecl",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html#parseXmlDTDdecl",
          "type": "function"
        },
        "index": {
          "description": "parse tokenized DTD declaration represented by DTD tree The content is represented by the children containing text and parameter entity reference nodes The parameter entity reference nodes contain their value in the children list consisting of text and possibly again parameter entity reference nodes This structure is build by the parameter entity substitution Output is again DTD declaration node but this time completely parsed and ready for further DTD processing",
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "parseXmlDTDdecl",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml DTDdecl",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#v:parseXmlDTDdecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "parseXmlDTDdeclPart",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlDTDParser.html#parseXmlDTDdeclPart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDParser",
          "module": "Text.XML.HXT.Parser.XmlDTDParser",
          "name": "parseXmlDTDdeclPart",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml DTDdecl Part",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDParser.html#v:parseXmlDTDdeclPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParsec parser for tokenizing DTD declarations for ELEMENT, ATTLIST, ENTITY and NOTATION\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "XmlDTDTokenParser",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html",
          "type": "module"
        },
        "index": {
          "description": "Parsec parser for tokenizing DTD declarations for ELEMENT ATTLIST ENTITY and NOTATION",
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "XmlDTDTokenParser",
          "package": "hxt",
          "partial": "Xml DTDToken Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdChars",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#dtdChars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdChars",
          "package": "hxt",
          "partial": "Chars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:dtdChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdDeclEnd",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#dtdDeclEnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdDeclEnd",
          "normalized": "XParser a()",
          "package": "hxt",
          "partial": "Decl End",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:dtdDeclEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdDeclStart",
          "package": "hxt",
          "signature": "XParser s (DTDElem, Attributes)",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#dtdDeclStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdDeclStart",
          "normalized": "XParser a(DTDElem,Attributes)",
          "package": "hxt",
          "partial": "Decl Start",
          "signature": "XParser s(DTDElem,Attributes)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:dtdDeclStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdDeclTokenizer",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#dtdDeclTokenizer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdDeclTokenizer",
          "package": "hxt",
          "partial": "Decl Tokenizer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:dtdDeclTokenizer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdToken",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#dtdToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "dtdToken",
          "package": "hxt",
          "partial": "Token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:dtdToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "entityValue",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#entityValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "entityValue",
          "package": "hxt",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:entityValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "peReference",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#peReference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "peReference",
          "package": "hxt",
          "partial": "Reference",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:peReference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "percent",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlDTDTokenParser.html#percent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlDTDTokenParser",
          "module": "Text.XML.HXT.Parser.XmlDTDTokenParser",
          "name": "percent",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlDTDTokenParser.html#v:percent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePredefined XML Entity References\n\u003c/p\u003e\u003cp\u003eThis module defines a table of all\n predefined XML entity references\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.XmlEntities",
          "name": "XmlEntities",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlEntities.html",
          "type": "module"
        },
        "index": {
          "description": "Predefined XML Entity References This module defines table of all predefined XML entity references",
          "hierarchy": "Text XML HXT Parser XmlEntities",
          "module": "Text.XML.HXT.Parser.XmlEntities",
          "name": "XmlEntities",
          "package": "hxt",
          "partial": "Xml Entities",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlEntities.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist of predefined XML entity names and their unicode values\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlEntities",
          "name": "xmlEntities",
          "package": "hxt",
          "signature": "[(String, Int)]",
          "source": "src/Text-XML-HXT-Parser-XmlEntities.html#xmlEntities",
          "type": "function"
        },
        "index": {
          "description": "list of predefined XML entity names and their unicode values",
          "hierarchy": "Text XML HXT Parser XmlEntities",
          "module": "Text.XML.HXT.Parser.XmlEntities",
          "name": "xmlEntities",
          "normalized": "[(String,Int)]",
          "package": "hxt",
          "partial": "Entities",
          "signature": "[(String,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlEntities.html#v:xmlEntities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eXml Parsec parser with pure filter interface\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "XmlParsec",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html",
          "type": "module"
        },
        "index": {
          "description": "Xml Parsec parser with pure filter interface",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "XmlParsec",
          "package": "hxt",
          "partial": "Xml Parsec",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "cDSect",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#cDSect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "cDSect",
          "package": "hxt",
          "partial": "DSect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:cDSect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "charData",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#charData",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "charData",
          "package": "hxt",
          "partial": "Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:charData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "charData'",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#charData%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "charData'",
          "package": "hxt",
          "partial": "Data'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:charData-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "comment",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#comment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "comment",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "content",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#content",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "content",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "contentWithTextDecl",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#contentWithTextDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "contentWithTextDecl",
          "package": "hxt",
          "partial": "With Text Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:contentWithTextDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "doctypedecl",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#doctypedecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "doctypedecl",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:doctypedecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "document",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#document",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "document",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:document"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "document'",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#document%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "document'",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:document-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "element",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#element",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "element",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "encodingDecl",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#encodingDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "encodingDecl",
          "package": "hxt",
          "partial": "Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:encodingDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "markupdecl",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#markupdecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "markupdecl",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:markupdecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "misc",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#misc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "misc",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:misc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "pI",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#pI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "pI",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:pI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for NMTOKENs\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseNMToken",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseNMToken",
          "type": "function"
        },
        "index": {
          "description": "Parser for NMTOKENs",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseNMToken",
          "normalized": "String-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "NMToken",
          "signature": "String-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseNMToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for XML names\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseName",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseName",
          "type": "function"
        },
        "index": {
          "description": "Parser for XML names",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseName",
          "normalized": "String-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Name",
          "signature": "String-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe filter version of \u003ccode\u003e\u003ca\u003exread\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlContent",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlContent",
          "type": "function"
        },
        "index": {
          "description": "the filter version of xread",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlContent",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Content",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for parts of a DTD\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlDTDPart",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlDTDPart",
          "type": "function"
        },
        "index": {
          "description": "Parser for parts of DTD",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlDTDPart",
          "normalized": "String-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml DTDPart",
          "signature": "String-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlDTDPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlDocEncodingSpec",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlDocEncodingSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlDocEncodingSpec",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Doc Encoding Spec",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlDocEncodingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlDocument",
          "package": "hxt",
          "signature": "String -\u003e String -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlDocument",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlDocument",
          "normalized": "String-\u003eString-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Document",
          "signature": "String-\u003eString-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etry to parse a xml encoding spec.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 1.parameter encParse :  the parser for the encoding decl\n\u003c/li\u003e\u003cli\u003e 2.parameter root :  a document root\n\u003c/li\u003e\u003cli\u003e returns : the same tree, but with an additional\n                        attribute \"encoding\" in the root node\n                        in case of a valid encoding spec\n                        else the unchanged tree\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEncodingSpec",
          "package": "hxt",
          "signature": "SimpleXParser XmlTree -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlEncodingSpec",
          "type": "function"
        },
        "index": {
          "description": "try to parse xml encoding spec parameter encParse the parser for the encoding decl parameter root document root returns the same tree but with an additional attribute encoding in the root node in case of valid encoding spec else the unchanged tree",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEncodingSpec",
          "normalized": "SimpleXParser XmlTree-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Encoding Spec",
          "signature": "SimpleXParser XmlTree-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlEncodingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEntityEncodingSpec",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlEntityEncodingSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEntityEncodingSpec",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Entity Encoding Spec",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlEntityEncodingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for entity substitution within attribute values\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEntityValueAsAttrValue",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlEntityValueAsAttrValue",
          "type": "function"
        },
        "index": {
          "description": "Parser for entity substitution within attribute values",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEntityValueAsAttrValue",
          "normalized": "String-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Entity Value As Attr Value",
          "signature": "String-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlEntityValueAsAttrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for general entites\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEntityValueAsContent",
          "package": "hxt",
          "signature": "String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlEntityValueAsContent",
          "type": "function"
        },
        "index": {
          "description": "Parser for general entites",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlEntityValueAsContent",
          "normalized": "String-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Entity Value As Content",
          "signature": "String-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlEntityValueAsContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneral parser for parsing arbitray parts of a XML document\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlPart",
          "package": "hxt",
          "signature": "SimpleXParser XmlTrees -\u003e String -\u003e String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlPart",
          "type": "function"
        },
        "index": {
          "description": "general parser for parsing arbitray parts of XML document",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlPart",
          "normalized": "SimpleXParser XmlTrees-\u003eString-\u003eString-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Part",
          "signature": "SimpleXParser XmlTrees-\u003eString-\u003eString-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea more general version of \u003ccode\u003e\u003ca\u003eparseXmlContent\u003c/a\u003e\u003c/code\u003e.\n The parser to be used and the context are extra parameter\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlText",
          "package": "hxt",
          "signature": "SimpleXParser XmlTrees -\u003e XPState () -\u003e String -\u003e XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#parseXmlText",
          "type": "function"
        },
        "index": {
          "description": "more general version of parseXmlContent The parser to be used and the context are extra parameter",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "parseXmlText",
          "normalized": "SimpleXParser XmlTrees-\u003eXPState()-\u003eString-\u003eXmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Xml Text",
          "signature": "SimpleXParser XmlTrees-\u003eXPState()-\u003eString-\u003eXmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:parseXmlText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "prolog",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#prolog",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "prolog",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:prolog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "removeEncodingSpec",
          "package": "hxt",
          "signature": "XmlTree -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#removeEncodingSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "removeEncodingSpec",
          "normalized": "XmlTree-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Encoding Spec",
          "signature": "XmlTree-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:removeEncodingSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "sDDecl",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#sDDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "sDDecl",
          "package": "hxt",
          "partial": "DDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:sDDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "textDecl",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#textDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "textDecl",
          "package": "hxt",
          "partial": "Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:textDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "versionInfo",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#versionInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "versionInfo",
          "package": "hxt",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:versionInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xMLDecl",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#xMLDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xMLDecl",
          "package": "hxt",
          "partial": "MLDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:xMLDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xMLDecl'",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#xMLDecl%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xMLDecl'",
          "package": "hxt",
          "partial": "MLDecl'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:xMLDecl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe inverse function to \u003ccode\u003e\u003ca\u003exshow\u003c/a\u003e\u003c/code\u003e, (for XML content).\n\u003c/p\u003e\u003cp\u003ethe string parameter is parsed with the XML content parser.\n result is the list of trees or in case of an error a single element list with the\n error message as node. No entity or character subtitution is done here,\n but the XML parser can do this for the predefined XML or the char references for performance reasons\n\u003c/p\u003e\u003cp\u003esee also: \u003ccode\u003e\u003ca\u003eparseXmlContent\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xread",
          "package": "hxt",
          "signature": "String -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#xread",
          "type": "function"
        },
        "index": {
          "description": "the inverse function to xshow for XML content the string parameter is parsed with the XML content parser result is the list of trees or in case of an error single element list with the error message as node No entity or character subtitution is done here but the XML parser can do this for the predefined XML or the char references for performance reasons see also parseXmlContent",
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xread",
          "normalized": "String-\u003eXmlTrees",
          "package": "hxt",
          "signature": "String-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:xread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xreadDoc",
          "package": "hxt",
          "signature": "String -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlParsec.html#xreadDoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlParsec",
          "module": "Text.XML.HXT.Parser.XmlParsec",
          "name": "xreadDoc",
          "normalized": "String-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Doc",
          "signature": "String-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlParsec.html#v:xreadDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParsec parser for XML tokens\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "XmlTokenParser",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html",
          "type": "module"
        },
        "index": {
          "description": "Parsec parser for XML tokens",
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "XmlTokenParser",
          "package": "hxt",
          "partial": "Xml Token Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "allBut",
          "package": "hxt",
          "signature": "(XParser s Char -\u003e XParser s String) -\u003e String -\u003e XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#allBut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "allBut",
          "normalized": "(XParser a Char-\u003eXParser a String)-\u003eString-\u003eXParser a String",
          "package": "hxt",
          "partial": "But",
          "signature": "(XParser s Char-\u003eXParser s String)-\u003eString-\u003eXParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:allBut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "allBut1",
          "package": "hxt",
          "signature": "(XParser s Char -\u003e XParser s String) -\u003e (Char -\u003e Bool) -\u003e String -\u003e XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#allBut1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "allBut1",
          "normalized": "(XParser a Char-\u003eXParser a String)-\u003e(Char-\u003eBool)-\u003eString-\u003eXParser a String",
          "package": "hxt",
          "partial": "But",
          "signature": "(XParser s Char-\u003eXParser s String)-\u003e(Char-\u003eBool)-\u003eString-\u003eXParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:allBut1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "amp",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#amp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "amp",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:amp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "asciiLetter",
          "package": "hxt",
          "signature": "XParser s Char",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#asciiLetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "asciiLetter",
          "package": "hxt",
          "partial": "Letter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:asciiLetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrChar",
          "package": "hxt",
          "signature": "String -\u003e XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#attrChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrChar",
          "normalized": "String-\u003eXParser a String",
          "package": "hxt",
          "partial": "Char",
          "signature": "String-\u003eXParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:attrChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrValue",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#attrValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrValue",
          "package": "hxt",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:attrValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrValueT",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#attrValueT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrValueT",
          "package": "hxt",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:attrValueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrValueT'",
          "package": "hxt",
          "signature": "String -\u003e XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#attrValueT%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "attrValueT'",
          "normalized": "String-\u003eXParser a XmlTrees",
          "package": "hxt",
          "partial": "Value T'",
          "signature": "String-\u003eXParser s XmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:attrValueT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "bar",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#bar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "bar",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:bar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "charRef",
          "package": "hxt",
          "signature": "XParser s Int",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#charRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "charRef",
          "package": "hxt",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:charRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "charRefT",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#charRefT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "charRefT",
          "package": "hxt",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:charRefT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "checkString",
          "package": "hxt",
          "signature": "String -\u003e XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#checkString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "checkString",
          "normalized": "String-\u003eXParser a()",
          "package": "hxt",
          "partial": "String",
          "signature": "String-\u003eXParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:checkString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "comma",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#comma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "comma",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "concRes",
          "package": "hxt",
          "signature": "XParser s [[a]] -\u003e XParser s [a]",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#concRes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "concRes",
          "normalized": "XParser a[[b]]-\u003eXParser a[b]",
          "package": "hxt",
          "partial": "Res",
          "signature": "XParser s[[a]]-\u003eXParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:concRes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "dq",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#dq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "dq",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:dq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "encName",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#encName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "encName",
          "package": "hxt",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:encName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityCharT",
          "package": "hxt",
          "signature": "String -\u003e XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#entityCharT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityCharT",
          "normalized": "String-\u003eXParser a XmlTree",
          "package": "hxt",
          "partial": "Char",
          "signature": "String-\u003eXParser s XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:entityCharT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityRef",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#entityRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityRef",
          "package": "hxt",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:entityRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityRefT",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#entityRefT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityRefT",
          "package": "hxt",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:entityRefT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityTokensT",
          "package": "hxt",
          "signature": "String -\u003e XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#entityTokensT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityTokensT",
          "normalized": "String-\u003eXParser a XmlTrees",
          "package": "hxt",
          "partial": "Tokens",
          "signature": "String-\u003eXParser s XmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:entityTokensT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityValue",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#entityValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityValue",
          "package": "hxt",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:entityValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityValueT",
          "package": "hxt",
          "signature": "XParser s XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#entityValueT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "entityValueT",
          "package": "hxt",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:entityValueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "eq",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#eq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "eq",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "gt",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#gt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "gt",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:gt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "keyword",
          "package": "hxt",
          "signature": "String -\u003e XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#keyword",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "keyword",
          "normalized": "String-\u003eXParser a String",
          "package": "hxt",
          "signature": "String-\u003eXParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:keyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "keywords",
          "package": "hxt",
          "signature": "[String] -\u003e XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#keywords",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "keywords",
          "normalized": "[String]-\u003eXParser a String",
          "package": "hxt",
          "signature": "[String]-\u003eXParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:keywords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "lpar",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#lpar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "lpar",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:lpar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "lt",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#lt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "lt",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:lt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "mergeTextNodes",
          "package": "hxt",
          "signature": "XmlTrees -\u003e XmlTrees",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#mergeTextNodes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "mergeTextNodes",
          "normalized": "XmlTrees-\u003eXmlTrees",
          "package": "hxt",
          "partial": "Text Nodes",
          "signature": "XmlTrees-\u003eXmlTrees",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:mergeTextNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "mkList",
          "package": "hxt",
          "signature": "XParser s a -\u003e XParser s [a]",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#mkList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "mkList",
          "normalized": "XParser a b-\u003eXParser a[b]",
          "package": "hxt",
          "partial": "List",
          "signature": "XParser s a-\u003eXParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:mkList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "name",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "name",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nameT",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#nameT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nameT",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:nameT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "names",
          "package": "hxt",
          "signature": "XParser s [String]",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#names",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "names",
          "normalized": "XParser a[String]",
          "package": "hxt",
          "signature": "XParser s[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:names"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "ncName",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#ncName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "ncName",
          "package": "hxt",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:ncName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nmtoken",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#nmtoken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nmtoken",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:nmtoken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nmtokenT",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#nmtokenT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nmtokenT",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:nmtokenT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nmtokens",
          "package": "hxt",
          "signature": "XParser s [String]",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#nmtokens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "nmtokens",
          "normalized": "XParser a[String]",
          "package": "hxt",
          "signature": "XParser s[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:nmtokens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "peReference",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#peReference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "peReference",
          "package": "hxt",
          "partial": "Reference",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:peReference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "peReferenceT",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#peReferenceT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "peReferenceT",
          "package": "hxt",
          "partial": "Reference",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:peReferenceT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "pubidLiteral",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#pubidLiteral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "pubidLiteral",
          "package": "hxt",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:pubidLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "qName",
          "package": "hxt",
          "signature": "XParser s (String, String)",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#qName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "qName",
          "normalized": "XParser a(String,String)",
          "package": "hxt",
          "partial": "Name",
          "signature": "XParser s(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:qName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "quoted",
          "package": "hxt",
          "signature": "XParser s a -\u003e XParser s a",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#quoted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "quoted",
          "normalized": "XParser a b-\u003eXParser a b",
          "package": "hxt",
          "signature": "XParser s a-\u003eXParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:quoted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "reference",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#reference",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "reference",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:reference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "referenceT",
          "package": "hxt",
          "signature": "XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#referenceT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "referenceT",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:referenceT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "rpar",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#rpar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "rpar",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:rpar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "sPace",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#sPace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "sPace",
          "package": "hxt",
          "partial": "Pace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:sPace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "sPace0",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#sPace0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "sPace0",
          "package": "hxt",
          "partial": "Pace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:sPace0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "semi",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#semi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "semi",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:semi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "separator",
          "package": "hxt",
          "signature": "Char -\u003e XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#separator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "separator",
          "normalized": "Char-\u003eXParser a()",
          "package": "hxt",
          "signature": "Char-\u003eXParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:separator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "singleChar",
          "package": "hxt",
          "signature": "String -\u003e XParser s Char",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#singleChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "singleChar",
          "normalized": "String-\u003eXParser a Char",
          "package": "hxt",
          "partial": "Char",
          "signature": "String-\u003eXParser s Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:singleChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "singleChars",
          "package": "hxt",
          "signature": "String -\u003e XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#singleChars",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "singleChars",
          "normalized": "String-\u003eXParser a String",
          "package": "hxt",
          "partial": "Chars",
          "signature": "String-\u003eXParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:singleChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "singleCharsT",
          "package": "hxt",
          "signature": "String -\u003e XParser s XmlTree",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#singleCharsT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "singleCharsT",
          "normalized": "String-\u003eXParser a XmlTree",
          "package": "hxt",
          "partial": "Chars",
          "signature": "String-\u003eXParser s XmlTree",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:singleCharsT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "skipS",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#skipS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "skipS",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:skipS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "skipS0",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#skipS0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "skipS0",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:skipS0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "sq",
          "package": "hxt",
          "signature": "XParser s ()",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#sq",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "sq",
          "normalized": "XParser a()",
          "package": "hxt",
          "signature": "XParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:sq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "systemLiteral",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#systemLiteral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "systemLiteral",
          "package": "hxt",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:systemLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "versionNum",
          "package": "hxt",
          "signature": "XParser s String",
          "source": "src/Text-XML-HXT-Parser-XmlTokenParser.html#versionNum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Parser XmlTokenParser",
          "module": "Text.XML.HXT.Parser.XmlTokenParser",
          "name": "versionNum",
          "package": "hxt",
          "partial": "Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Parser-XmlTokenParser.html#v:versionNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Version",
          "name": "Version",
          "package": "hxt",
          "source": "src/Text-XML-HXT-Version.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text XML HXT Version",
          "module": "Text.XML.HXT.Version",
          "name": "Version",
          "package": "hxt",
          "partial": "Version",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Version.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Version",
          "name": "hxt_version",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-Version.html#hxt_version",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Version",
          "module": "Text.XML.HXT.Version",
          "name": "hxt_version",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Version.html#v:hxt_version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVersion    : $Id$\n\u003c/p\u003e\u003cp\u003eDatatype library for the W3C XML schema datatypes\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "DataTypeLibW3CNames",
          "package": "hxt",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html",
          "type": "module"
        },
        "index": {
          "description": "Version Id Datatype library for the W3C XML schema datatypes",
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "DataTypeLibW3CNames",
          "package": "hxt",
          "partial": "Data Type Lib CNames",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace of the W3C XML schema datatype library\n\u003c/p\u003e",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "w3cNS",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#w3cNS",
          "type": "function"
        },
        "index": {
          "description": "Namespace of the W3C XML schema datatype library",
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "w3cNS",
          "package": "hxt",
          "partial": "NS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:w3cNS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_ENTITIES",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_ENTITIES",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_ENTITIES",
          "package": "hxt",
          "partial": "ENTITIES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_ENTITIES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_ENTITY",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_ENTITY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_ENTITY",
          "package": "hxt",
          "partial": "ENTITY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_ENTITY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_ID",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_ID",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_ID",
          "package": "hxt",
          "partial": "ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_ID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_IDREF",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_IDREF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_IDREF",
          "package": "hxt",
          "partial": "IDREF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_IDREF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_IDREFS",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_IDREFS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_IDREFS",
          "package": "hxt",
          "partial": "IDREFS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_IDREFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NCName",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_NCName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NCName",
          "package": "hxt",
          "partial": "NCName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_NCName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NMTOKEN",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_NMTOKEN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NMTOKEN",
          "package": "hxt",
          "partial": "NMTOKEN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_NMTOKEN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NMTOKENS",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_NMTOKENS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NMTOKENS",
          "package": "hxt",
          "partial": "NMTOKENS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_NMTOKENS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NOTATION",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_NOTATION",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_NOTATION",
          "package": "hxt",
          "partial": "NOTATION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_NOTATION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_Name",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_Name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_Name",
          "package": "hxt",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_QName",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_QName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_QName",
          "package": "hxt",
          "partial": "QName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_QName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_anyURI",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_anyURI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_anyURI",
          "package": "hxt",
          "partial": "URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_anyURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_base64Binary",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_base64Binary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_base64Binary",
          "package": "hxt",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_base64Binary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_boolean",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_boolean",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_boolean",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_boolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_byte",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_byte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_byte",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_byte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_date",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_date",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_date",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_date"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_dateTime",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_dateTime",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_dateTime",
          "package": "hxt",
          "partial": "Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_dateTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_decimal",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_decimal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_decimal",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_decimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_double",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_double",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_double",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_duration",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_duration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_duration",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_duration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_enumeration",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_enumeration",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_enumeration",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_enumeration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_float",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_float",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_float",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_fractionDigits",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_fractionDigits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_fractionDigits",
          "package": "hxt",
          "partial": "Digits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_fractionDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gDay",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_gDay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gDay",
          "package": "hxt",
          "partial": "Day",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_gDay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gMonth",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_gMonth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gMonth",
          "package": "hxt",
          "partial": "Month",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_gMonth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gMonthDay",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_gMonthDay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gMonthDay",
          "package": "hxt",
          "partial": "Month Day",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_gMonthDay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gYear",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_gYear",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gYear",
          "package": "hxt",
          "partial": "Year",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_gYear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gYearMonth",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_gYearMonth",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_gYearMonth",
          "package": "hxt",
          "partial": "Year Month",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_gYearMonth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_hexBinary",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_hexBinary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_hexBinary",
          "package": "hxt",
          "partial": "Binary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_hexBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_int",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_int",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_int",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_integer",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_integer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_integer",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_language",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_language",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_language",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_language"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_length",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_length",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_long",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_long",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_long",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_long"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_maxExclusive",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_maxExclusive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_maxExclusive",
          "package": "hxt",
          "partial": "Exclusive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_maxExclusive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_maxInclusive",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_maxInclusive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_maxInclusive",
          "package": "hxt",
          "partial": "Inclusive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_maxInclusive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_maxLength",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_maxLength",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_maxLength",
          "package": "hxt",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_maxLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_minExclusive",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_minExclusive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_minExclusive",
          "package": "hxt",
          "partial": "Exclusive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_minExclusive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_minInclusive",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_minInclusive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_minInclusive",
          "package": "hxt",
          "partial": "Inclusive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_minInclusive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_minLength",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_minLength",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_minLength",
          "package": "hxt",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_minLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_negativeInteger",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_negativeInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_negativeInteger",
          "package": "hxt",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_negativeInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_nonNegativeInteger",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_nonNegativeInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_nonNegativeInteger",
          "package": "hxt",
          "partial": "Negative Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_nonNegativeInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_nonPositiveInteger",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_nonPositiveInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_nonPositiveInteger",
          "package": "hxt",
          "partial": "Positive Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_nonPositiveInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_normalizedString",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_normalizedString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_normalizedString",
          "package": "hxt",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_normalizedString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_pattern",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_pattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_pattern",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_pattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_positiveInteger",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_positiveInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_positiveInteger",
          "package": "hxt",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_positiveInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_short",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_short",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_short",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_short"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_string",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_string",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_string",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_time",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_time",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_time",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_time"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_token",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_token",
          "package": "hxt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_totalDigits",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_totalDigits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_totalDigits",
          "package": "hxt",
          "partial": "Digits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_totalDigits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedByte",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_unsignedByte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedByte",
          "package": "hxt",
          "partial": "Byte",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_unsignedByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedInt",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_unsignedInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedInt",
          "package": "hxt",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_unsignedInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedLong",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_unsignedLong",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedLong",
          "package": "hxt",
          "partial": "Long",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_unsignedLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedShort",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_unsignedShort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_unsignedShort",
          "package": "hxt",
          "partial": "Short",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_unsignedShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_whiteSpace",
          "package": "hxt",
          "signature": "String",
          "source": "src/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#xsd_whiteSpace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT XMLSchema DataTypeLibW3CNames",
          "module": "Text.XML.HXT.XMLSchema.DataTypeLibW3CNames",
          "name": "xsd_whiteSpace",
          "package": "hxt",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-XMLSchema-DataTypeLibW3CNames.html#v:xsd_whiteSpace"
      }
    }
  ]
]