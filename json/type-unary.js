[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "type-unary"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExperiment in length-typed vectors\n\u003c/p\u003e\u003c/div\u003e",
          "module": "TypeUnary.Nat",
          "name": "Nat",
          "package": "type-unary",
          "source": "src/TypeUnary-Nat.html",
          "type": "module"
        },
        "index": {
          "description": "Experiment in length-typed vectors",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "Nat",
          "package": "type-unary",
          "partial": "Nat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProof that \u003ccode\u003em \u003c n\u003c/code\u003e\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": ":\u003c:",
          "package": "type-unary",
          "source": "src/TypeUnary-Nat.html#%3A%3C%3A",
          "type": "data"
        },
        "index": {
          "description": "Proof that",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": ":\u003c:",
          "package": "type-unary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#t::-60-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA number under the given limit, with proof\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "Index",
          "package": "type-unary",
          "source": "src/TypeUnary-Nat.html#Index",
          "type": "data"
        },
        "index": {
          "description": "number under the given limit with proof",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "Index",
          "package": "type-unary",
          "partial": "Index",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#t:Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003en\u003c/code\u003e a natural number type?\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "IsNat",
          "package": "type-unary",
          "source": "src/TypeUnary-Nat.html#IsNat",
          "type": "class"
        },
        "index": {
          "description": "Is natural number type",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "IsNat",
          "package": "type-unary",
          "partial": "Is Nat",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#t:IsNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "Nat",
          "package": "type-unary",
          "source": "src/TypeUnary-Nat.html#Nat",
          "type": "data"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "Nat",
          "package": "type-unary",
          "partial": "Nat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#t:Nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "Index",
          "package": "type-unary",
          "signature": "Index (n :\u003c: lim) (Nat n)",
          "source": "src/TypeUnary-Nat.html#Index",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "Index",
          "package": "type-unary",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "SLess",
          "package": "type-unary",
          "signature": "(m :\u003c: n) -\u003e S m :\u003c: S n",
          "source": "src/TypeUnary-Nat.html#%3A%3C%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "SLess",
          "normalized": "(a b)-\u003eS a S b",
          "package": "type-unary",
          "partial": "SLess",
          "signature": "(m n)-\u003eS m S n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:SLess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "Succ",
          "package": "type-unary",
          "signature": "Nat n -\u003e Nat (S n)",
          "source": "src/TypeUnary-Nat.html#Nat",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "Succ",
          "normalized": "Nat a-\u003eNat(S a)",
          "package": "type-unary",
          "partial": "Succ",
          "signature": "Nat n-\u003eNat(S n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:Succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "ZLess",
          "package": "type-unary",
          "signature": "Z :\u003c: S n",
          "source": "src/TypeUnary-Nat.html#%3A%3C%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "ZLess",
          "package": "type-unary",
          "partial": "ZLess",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:ZLess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "Zero",
          "package": "type-unary",
          "signature": "Nat Z",
          "source": "src/TypeUnary-Nat.html#Nat",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "Zero",
          "package": "type-unary",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndex generation from integer. Can fail dynamically if the integer is\n too large.\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "coerceToIndex",
          "package": "type-unary",
          "signature": "i -\u003e Index m",
          "source": "src/TypeUnary-Nat.html#coerceToIndex",
          "type": "function"
        },
        "index": {
          "description": "Index generation from integer Can fail dynamically if the integer is too large",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "coerceToIndex",
          "normalized": "a-\u003eIndex b",
          "package": "type-unary",
          "partial": "To Index",
          "signature": "i-\u003eIndex m",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:coerceToIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "four",
          "package": "type-unary",
          "signature": "Nat N4",
          "source": "src/TypeUnary-Nat.html#four",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "four",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:four"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "index0",
          "package": "type-unary",
          "signature": "Index (N1 :+: m)",
          "source": "src/TypeUnary-Nat.html#index0",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "index0",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:index0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "index1",
          "package": "type-unary",
          "signature": "Index (N2 :+: m)",
          "source": "src/TypeUnary-Nat.html#index1",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "index1",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:index1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "index2",
          "package": "type-unary",
          "signature": "Index (N3 :+: m)",
          "source": "src/TypeUnary-Nat.html#index2",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "index2",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:index2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "index3",
          "package": "type-unary",
          "signature": "Index (N4 :+: m)",
          "source": "src/TypeUnary-Nat.html#index3",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "index3",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:index3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePeano's induction principle\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "induction",
          "package": "type-unary",
          "signature": "p n",
          "source": "src/TypeUnary-Nat.html#induction",
          "type": "function"
        },
        "index": {
          "description": "Peano induction principle",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "induction",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:induction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "nat",
          "package": "type-unary",
          "signature": "Nat n",
          "source": "src/TypeUnary-Nat.html#nat",
          "type": "method"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "nat",
          "package": "type-unary",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:nat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum of naturals\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "natAdd",
          "package": "type-unary",
          "signature": "Nat m -\u003e Nat n -\u003e Nat (m :+: n)",
          "source": "src/TypeUnary-Nat.html#natAdd",
          "type": "function"
        },
        "index": {
          "description": "Sum of naturals",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "natAdd",
          "normalized": "Nat a-\u003eNat b-\u003eNat(a b)",
          "package": "type-unary",
          "partial": "Add",
          "signature": "Nat m-\u003eNat n-\u003eNat(m n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:natAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquality test\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "natEq",
          "package": "type-unary",
          "signature": "Nat m -\u003e Nat n -\u003e Maybe (m :=: n)",
          "source": "src/TypeUnary-Nat.html#natEq",
          "type": "function"
        },
        "index": {
          "description": "Equality test",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "natEq",
          "normalized": "Nat a-\u003eNat b-\u003eMaybe(a b)",
          "package": "type-unary",
          "partial": "Eq",
          "signature": "Nat m-\u003eNat n-\u003eMaybe(m n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:natEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "natIsNat",
          "package": "type-unary",
          "signature": "Nat n",
          "source": "src/TypeUnary-Nat.html#natIsNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "natIsNat",
          "package": "type-unary",
          "partial": "Is Nat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:natIsNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduct of naturals\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "natMul",
          "package": "type-unary",
          "signature": "forall m n.  Nat m -\u003e Nat n -\u003e Nat (m :*: n)",
          "source": "src/TypeUnary-Nat.html#natMul",
          "type": "function"
        },
        "index": {
          "description": "Product of naturals",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "natMul",
          "normalized": "a b c Nat b-\u003eNat d-\u003eNat(b*d)",
          "package": "type-unary",
          "partial": "Mul",
          "signature": "forall m n. Nat m-\u003eNat n-\u003eNat(m*n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:natMul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "natSucc",
          "package": "type-unary",
          "signature": "Nat n -\u003e Nat (S n)",
          "source": "src/TypeUnary-Nat.html#natSucc",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "natSucc",
          "normalized": "Nat a-\u003eNat(S a)",
          "package": "type-unary",
          "partial": "Succ",
          "signature": "Nat n-\u003eNat(S n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:natSucc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpret a \u003ccode\u003e\u003ca\u003eNat\u003c/a\u003e\u003c/code\u003e as a plain number\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "natToZ",
          "package": "type-unary",
          "signature": "Nat n -\u003e a",
          "source": "src/TypeUnary-Nat.html#natToZ",
          "type": "function"
        },
        "index": {
          "description": "Interpret Nat as plain number",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "natToZ",
          "normalized": "Nat a-\u003eb",
          "package": "type-unary",
          "partial": "To",
          "signature": "Nat n-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:natToZ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "one",
          "package": "type-unary",
          "signature": "Nat N1",
          "source": "src/TypeUnary-Nat.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "one",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "succI",
          "package": "type-unary",
          "signature": "Index m -\u003e Index (S m)",
          "source": "src/TypeUnary-Nat.html#succI",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "succI",
          "normalized": "Index a-\u003eIndex(S a)",
          "package": "type-unary",
          "signature": "Index m-\u003eIndex(S m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:succI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrease the upper limit in an inequality proof\n\u003c/p\u003e",
          "module": "TypeUnary.Nat",
          "name": "succLim",
          "package": "type-unary",
          "signature": "(m :\u003c: n) -\u003e m :\u003c: S n",
          "source": "src/TypeUnary-Nat.html#succLim",
          "type": "function"
        },
        "index": {
          "description": "Increase the upper limit in an inequality proof",
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "succLim",
          "normalized": "(a b)-\u003ea S b",
          "package": "type-unary",
          "partial": "Lim",
          "signature": "(m n)-\u003em S n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:succLim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "three",
          "package": "type-unary",
          "signature": "Nat N3",
          "source": "src/TypeUnary-Nat.html#three",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "three",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:three"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "two",
          "package": "type-unary",
          "signature": "Nat N2",
          "source": "src/TypeUnary-Nat.html#two",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "two",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:two"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "unIndex",
          "package": "type-unary",
          "signature": "Index m -\u003e a",
          "source": "src/TypeUnary-Nat.html#unIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "unIndex",
          "normalized": "Index a-\u003eb",
          "package": "type-unary",
          "partial": "Index",
          "signature": "Index m-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:unIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "withIsNat",
          "package": "type-unary",
          "signature": "Nat n -\u003e a) -\u003e Nat n -\u003e a",
          "source": "src/TypeUnary-Nat.html#withIsNat",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "withIsNat",
          "normalized": "Nat a-\u003eb)-\u003eNat a-\u003eb",
          "package": "type-unary",
          "partial": "Is Nat",
          "signature": "Nat n-\u003ea)-\u003eNat n-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:withIsNat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Nat",
          "name": "zero",
          "package": "type-unary",
          "signature": "Nat N0",
          "source": "src/TypeUnary-Nat.html#zero",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Nat",
          "module": "TypeUnary.Nat",
          "name": "zero",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Nat.html#v:zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType-level unary natural numbers\n\u003c/p\u003e\u003c/div\u003e",
          "module": "TypeUnary.TyNat",
          "name": "TyNat",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html",
          "type": "module"
        },
        "index": {
          "description": "Type-level unary natural numbers",
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "TyNat",
          "package": "type-unary",
          "partial": "Ty Nat",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduct of type-level numbers\n\u003c/p\u003e",
          "module": "TypeUnary.TyNat",
          "name": ":*:",
          "package": "type-unary",
          "signature": ":*:",
          "type": "function"
        },
        "index": {
          "description": "Product of type-level numbers",
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": ":*:",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t::-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum of type-level numbers\n\u003c/p\u003e",
          "module": "TypeUnary.TyNat",
          "name": ":+:",
          "package": "type-unary",
          "signature": ":+:",
          "type": "function"
        },
        "index": {
          "description": "Sum of type-level numbers",
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": ":+:",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t::-43-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": ":-:",
          "package": "type-unary",
          "signature": ":-:",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": ":-:",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t::-45-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N0",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N0",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N0",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N1",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N1",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N1",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N10",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N10",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N10",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N11",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N11",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N11",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N12",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N12",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N12",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N13",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N13",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N13",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N14",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N14",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N14",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N14"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N15",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N15",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N15",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N15"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N16",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N16",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N16",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N2",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N2",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N2",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N3",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N3",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N3",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N4",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N4",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N4",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N5",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N5",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N5",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N6",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N6",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N6",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N7",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N7",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N7",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N8",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N8",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N8",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.TyNat",
          "name": "N9",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#N9",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "N9",
          "package": "type-unary",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:N9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-level representation of successor\n\u003c/p\u003e",
          "module": "TypeUnary.TyNat",
          "name": "S",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#S",
          "type": "data"
        },
        "index": {
          "description": "Type-level representation of successor",
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "S",
          "package": "type-unary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:S"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-level representation of zero\n\u003c/p\u003e",
          "module": "TypeUnary.TyNat",
          "name": "Z",
          "package": "type-unary",
          "source": "src/TypeUnary-TyNat.html#Z",
          "type": "data"
        },
        "index": {
          "description": "Type-level representation of zero",
          "hierarchy": "TypeUnary TyNat",
          "module": "TypeUnary.TyNat",
          "name": "Z",
          "package": "type-unary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-TyNat.html#t:Z"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExperiment in length-typed vectors\n\u003c/p\u003e\u003c/div\u003e",
          "module": "TypeUnary.Vec",
          "name": "Vec",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html",
          "type": "module"
        },
        "index": {
          "description": "Experiment in length-typed vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec",
          "package": "type-unary",
          "partial": "Vec",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "ToVec",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#ToVec",
          "type": "class"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "ToVec",
          "package": "type-unary",
          "partial": "To Vec",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:ToVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVectors with type-determined length, having empty vector (\u003ccode\u003e\u003ca\u003eZVec\u003c/a\u003e\u003c/code\u003e) and\n vector cons ('(:\u003c)').\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "Vec",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec",
          "type": "data"
        },
        "index": {
          "description": "Vectors with type-determined length having empty vector ZVec and vector cons",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec",
          "package": "type-unary",
          "partial": "Vec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec0",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec0",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec0",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec1",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec1",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec1",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec10",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec10",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec10",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec11",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec11",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec11",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec12",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec12",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec12",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec12"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec13",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec13",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec13",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec13"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec14",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec14",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec14",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec14"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec15",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec15",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec15",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec15"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec16",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec16",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec16",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec2",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec2",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec2",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec3",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec3",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec3",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec4",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec4",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec4",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec5",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec5",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec5",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec6",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec6",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec6",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec7",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec7",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec7",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec8",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec8",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec8",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "Vec9",
          "package": "type-unary",
          "source": "src/TypeUnary-Vec.html#Vec9",
          "type": "type"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "Vec9",
          "package": "type-unary",
          "partial": "Vec",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#t:Vec9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcatenation of vectors\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "(\u003c+\u003e)",
          "package": "type-unary",
          "signature": "Vec m a -\u003e Vec n a -\u003e Vec (m :+: n) a",
          "source": "src/TypeUnary-Vec.html#%3C%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Concatenation of vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "(\u003c+\u003e) \u003c+\u003e",
          "normalized": "Vec a b-\u003eVec c b-\u003eVec(a c)b",
          "package": "type-unary",
          "signature": "Vec m a-\u003eVec n a-\u003eVec(m n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:-60--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": ":\u003c",
          "package": "type-unary",
          "signature": "a -\u003e Vec n a -\u003e Vec (S n) a",
          "source": "src/TypeUnary-Vec.html#Vec",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": ":\u003c",
          "normalized": "a-\u003eVec b a-\u003eVec(S b)a",
          "package": "type-unary",
          "signature": "a-\u003eVec n a-\u003eVec(S n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v::-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "ZVec",
          "package": "type-unary",
          "signature": "Vec Z a",
          "source": "src/TypeUnary-Vec.html#Vec",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "ZVec",
          "package": "type-unary",
          "partial": "ZVec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:ZVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChunk a vector into a vector of vectors (a 2D array)\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "chunkV",
          "package": "type-unary",
          "signature": "Vec (n :*: m) a -\u003e Vec n (Vec m a)",
          "source": "src/TypeUnary-Vec.html#chunkV",
          "type": "function"
        },
        "index": {
          "description": "Chunk vector into vector of vectors array",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "chunkV",
          "normalized": "Vec(a*b)c-\u003eVec a(Vec b c)",
          "package": "type-unary",
          "signature": "Vec(n*m)a-\u003eVec n(Vec m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:chunkV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCross-product of two vectors, in the set-theory sense, not the geometric\n sense. You can \u003ccode\u003e\u003ca\u003eflattenV\u003c/a\u003e\u003c/code\u003e the resulting vector of vectors.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "cross",
          "package": "type-unary",
          "signature": "Vec m a -\u003e Vec n b -\u003e Vec m (Vec n (a, b))",
          "source": "src/TypeUnary-Vec.html#cross",
          "type": "function"
        },
        "index": {
          "description": "Cross-product of two vectors in the set-theory sense not the geometric sense You can flattenV the resulting vector of vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "cross",
          "normalized": "Vec a b-\u003eVec c d-\u003eVec a(Vec c(b,d))",
          "package": "type-unary",
          "signature": "Vec m a-\u003eVec n b-\u003eVec m(Vec n(a,b))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:cross"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete exactly one occurrence of an element from a vector, raising an\n error if the element isn't present.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "deleteV",
          "package": "type-unary",
          "signature": "a -\u003e Vec (S n) a -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#deleteV",
          "type": "function"
        },
        "index": {
          "description": "Delete exactly one occurrence of an element from vector raising an error if the element isn present",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "deleteV",
          "normalized": "a-\u003eVec(S b)a-\u003eVec b a",
          "package": "type-unary",
          "signature": "a-\u003eVec(S n)a-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:deleteV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list into a vector. Error if the list is too short or too long\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "elemsV",
          "package": "type-unary",
          "signature": "[a] -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#elemsV",
          "type": "function"
        },
        "index": {
          "description": "Convert list into vector Error if the list is too short or too long",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "elemsV",
          "normalized": "[a]-\u003eVec b a",
          "package": "type-unary",
          "signature": "[a]-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:elemsV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a vector of vectors (a 2D array) into a vector\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "flattenV",
          "package": "type-unary",
          "signature": "Vec n (Vec m a) -\u003e Vec (n :*: m) a",
          "source": "src/TypeUnary-Vec.html#flattenV",
          "type": "function"
        },
        "index": {
          "description": "Flatten vector of vectors array into vector",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "flattenV",
          "normalized": "Vec a(Vec b c)-\u003eVec(a*b)c",
          "package": "type-unary",
          "signature": "Vec n(Vec m a)-\u003eVec(n*m)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:flattenV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a vector element, taking a proof that the index is within bounds.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "get",
          "package": "type-unary",
          "signature": "Index n -\u003e Vec n a -\u003e a",
          "source": "src/TypeUnary-Vec.html#get",
          "type": "function"
        },
        "index": {
          "description": "Extract vector element taking proof that the index is within bounds",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "get",
          "normalized": "Index a-\u003eVec a b-\u003eb",
          "package": "type-unary",
          "signature": "Index n-\u003eVec n a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "get0",
          "package": "type-unary",
          "signature": "Vec (N1 :+: n) a-\u003e a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "get0",
          "normalized": "Vec(N a)b-\u003eb",
          "package": "type-unary",
          "signature": "Vec(N n)a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:get0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "get1",
          "package": "type-unary",
          "signature": "Vec (N2 :+: n) a-\u003e a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "get1",
          "normalized": "Vec(N a)b-\u003eb",
          "package": "type-unary",
          "signature": "Vec(N n)a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:get1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "get2",
          "package": "type-unary",
          "signature": "Vec (N3 :+: n) a-\u003e a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "get2",
          "normalized": "Vec(N a)b-\u003eb",
          "package": "type-unary",
          "signature": "Vec(N n)a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:get2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "get3",
          "package": "type-unary",
          "signature": "Vec (N4 :+: n) a-\u003e a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "get3",
          "normalized": "Vec(N a)b-\u003eb",
          "package": "type-unary",
          "signature": "Vec(N n)a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:get3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eget\u003c/a\u003e\u003c/code\u003e in which the index size is checked at run-time\n instead of compile-time.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "getI",
          "package": "type-unary",
          "signature": "i -\u003e Vec n a -\u003e a",
          "source": "src/TypeUnary-Vec.html#getI",
          "type": "function"
        },
        "index": {
          "description": "Variant of get in which the index size is checked at run-time instead of compile-time",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "getI",
          "normalized": "a-\u003eVec b c-\u003ec",
          "package": "type-unary",
          "signature": "i-\u003eVec n a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:getI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-safe head for vectors\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "headV",
          "package": "type-unary",
          "signature": "Vec (S n) a -\u003e a",
          "source": "src/TypeUnary-Vec.html#headV",
          "type": "function"
        },
        "index": {
          "description": "Type-safe head for vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "headV",
          "normalized": "Vec(S a)b-\u003eb",
          "package": "type-unary",
          "signature": "Vec(S n)a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:headV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndices under \u003ccode\u003en\u003c/code\u003e: \u003ccode\u003e\u003ca\u003eindex0\u003c/a\u003e\u003c/code\u003e :\u003c \u003ccode\u003e\u003ca\u003eindex1\u003c/a\u003e\u003c/code\u003e :\u003c ...\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "indices",
          "package": "type-unary",
          "signature": "Vec n (Index n)",
          "source": "src/TypeUnary-Vec.html#indices",
          "type": "function"
        },
        "index": {
          "description": "Indices under index0 index1",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "indices",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:indices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVector of ints from 0 to n-1. Named for APL iota operation (but 0 based).\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "iota",
          "package": "type-unary",
          "signature": "Vec n a",
          "source": "src/TypeUnary-Vec.html#iota",
          "type": "function"
        },
        "index": {
          "description": "Vector of ints from to n-1 Named for APL iota operation but based",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "iota",
          "package": "type-unary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:iota"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to monad \u003ccode\u003ejoin\u003c/code\u003e for vectors\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "joinV",
          "package": "type-unary",
          "signature": "Vec n (Vec n a) -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#joinV",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to monad join for vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "joinV",
          "normalized": "Vec a(Vec a b)-\u003eVec a b",
          "package": "type-unary",
          "signature": "Vec n(Vec n a)-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:joinV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a vector element, taking a proof that the index is within bounds.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "set",
          "package": "type-unary",
          "signature": "Index n -\u003e a -\u003e Vec n a -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#set",
          "type": "function"
        },
        "index": {
          "description": "Replace vector element taking proof that the index is within bounds",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "set",
          "normalized": "Index a-\u003eb-\u003eVec a b-\u003eVec a b",
          "package": "type-unary",
          "signature": "Index n-\u003ea-\u003eVec n a-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "set0",
          "package": "type-unary",
          "signature": "a-\u003e Vec (N1 :+: n) a-\u003e Vec (N1 :+: n) a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "set0",
          "normalized": "a-\u003eVec(N b)a-\u003eVec(N b)a",
          "package": "type-unary",
          "signature": "a-\u003eVec(N n)a-\u003eVec(N n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:set0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "set1",
          "package": "type-unary",
          "signature": "a-\u003e Vec (N2 :+: n) a-\u003e Vec (N2 :+: n) a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "set1",
          "normalized": "a-\u003eVec(N b)a-\u003eVec(N b)a",
          "package": "type-unary",
          "signature": "a-\u003eVec(N n)a-\u003eVec(N n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:set1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "set2",
          "package": "type-unary",
          "signature": "a-\u003e Vec (N3 :+: n) a-\u003e Vec (N3 :+: n) a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "set2",
          "normalized": "a-\u003eVec(N b)a-\u003eVec(N b)a",
          "package": "type-unary",
          "signature": "a-\u003eVec(N n)a-\u003eVec(N n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:set2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "set3",
          "package": "type-unary",
          "signature": "a-\u003e Vec (N4 :+: n) a-\u003e Vec (N4 :+: n) a",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "set3",
          "normalized": "a-\u003eVec(N b)a-\u003eVec(N b)a",
          "package": "type-unary",
          "signature": "a-\u003eVec(N n)a-\u003eVec(N n)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:set3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariant of \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e in which the index size is checked at run-time\n instead of compile-time.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "setI",
          "package": "type-unary",
          "signature": "i -\u003e a -\u003e Vec n a -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#setI",
          "type": "function"
        },
        "index": {
          "description": "Variant of set in which the index size is checked at run-time instead of compile-time",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "setI",
          "normalized": "a-\u003eb-\u003eVec c b-\u003eVec c b",
          "package": "type-unary",
          "signature": "i-\u003ea-\u003eVec n a-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:setI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a vector\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "split",
          "package": "type-unary",
          "signature": "Vec (n :+: m) a -\u003e (Vec n a, Vec m a)",
          "source": "src/TypeUnary-Vec.html#split",
          "type": "function"
        },
        "index": {
          "description": "Split vector",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "split",
          "normalized": "Vec(a b)c-\u003e(Vec a c,Vec b c)",
          "package": "type-unary",
          "signature": "Vec(n m)a-\u003e(Vec n a,Vec m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwizzling.  Extract multiple elements simultaneously.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "swizzle",
          "package": "type-unary",
          "signature": "Vec n (Index m) -\u003e Vec m a -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#swizzle",
          "type": "function"
        },
        "index": {
          "description": "Swizzling Extract multiple elements simultaneously",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "swizzle",
          "normalized": "Vec a(Index b)-\u003eVec b c-\u003eVec a c",
          "package": "type-unary",
          "signature": "Vec n(Index m)-\u003eVec m a-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:swizzle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-safe tail for vectors\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "tailV",
          "package": "type-unary",
          "signature": "Vec (S n) a -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#tailV",
          "type": "function"
        },
        "index": {
          "description": "Type-safe tail for vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "tailV",
          "normalized": "Vec(S a)b-\u003eVec a b",
          "package": "type-unary",
          "signature": "Vec(S n)a-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:tailV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "toVec",
          "package": "type-unary",
          "signature": "c -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#toVec",
          "type": "method"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "toVec",
          "normalized": "a-\u003eVec b c",
          "package": "type-unary",
          "partial": "Vec",
          "signature": "c-\u003eVec n a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:toVec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix transposition. Specialization of \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "transpose",
          "package": "type-unary",
          "signature": "Vec m (Vec n a) -\u003e Vec n (Vec m a)",
          "source": "src/TypeUnary-Vec.html#transpose",
          "type": "function"
        },
        "index": {
          "description": "Matrix transposition Specialization of sequenceA",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "transpose",
          "normalized": "Vec a(Vec b c)-\u003eVec b(Vec a c)",
          "package": "type-unary",
          "signature": "Vec m(Vec n a)-\u003eVec n(Vec m a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract element\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "un1",
          "package": "type-unary",
          "signature": "Vec1 a -\u003e a",
          "source": "src/TypeUnary-Vec.html#un1",
          "type": "function"
        },
        "index": {
          "description": "Extract element",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "un1",
          "normalized": "Vec a-\u003ea",
          "package": "type-unary",
          "signature": "Vec a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:un1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract elements\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "un2",
          "package": "type-unary",
          "signature": "Vec2 a -\u003e (a, a)",
          "source": "src/TypeUnary-Vec.html#un2",
          "type": "function"
        },
        "index": {
          "description": "Extract elements",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "un2",
          "normalized": "Vec a-\u003e(a,a)",
          "package": "type-unary",
          "signature": "Vec a-\u003e(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:un2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract elements\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "un3",
          "package": "type-unary",
          "signature": "Vec3 a -\u003e (a, a, a)",
          "source": "src/TypeUnary-Vec.html#un3",
          "type": "function"
        },
        "index": {
          "description": "Extract elements",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "un3",
          "normalized": "Vec a-\u003e(a,a,a)",
          "package": "type-unary",
          "signature": "Vec a-\u003e(a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:un3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract elements\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "un4",
          "package": "type-unary",
          "signature": "Vec4 a -\u003e (a, a, a, a)",
          "source": "src/TypeUnary-Vec.html#un4",
          "type": "function"
        },
        "index": {
          "description": "Extract elements",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "un4",
          "normalized": "Vec a-\u003e(a,a,a,a)",
          "package": "type-unary",
          "signature": "Vec a-\u003e(a,a,a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:un4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType-safe un-cons for vectors\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "unConsV",
          "package": "type-unary",
          "signature": "Vec (S n) a -\u003e (a, Vec n a)",
          "source": "src/TypeUnary-Vec.html#unConsV",
          "type": "function"
        },
        "index": {
          "description": "Type-safe un-cons for vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "unConsV",
          "normalized": "Vec(S a)b-\u003e(b,Vec a b)",
          "package": "type-unary",
          "partial": "Cons",
          "signature": "Vec(S n)a-\u003e(a,Vec n a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:unConsV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnzip a vector of pairs into a pair of vectors\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "unzipV",
          "package": "type-unary",
          "signature": "Vec n (a, b) -\u003e (Vec n a, Vec n b)",
          "source": "src/TypeUnary-Vec.html#unzipV",
          "type": "function"
        },
        "index": {
          "description": "Unzip vector of pairs into pair of vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "unzipV",
          "normalized": "Vec a(b,c)-\u003e(Vec a b,Vec a c)",
          "package": "type-unary",
          "signature": "Vec n(a,b)-\u003e(Vec n a,Vec n b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:unzipV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnzip a vector of pairs into a pair of vectors\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "unzipV3",
          "package": "type-unary",
          "signature": "Vec n (a, b, c) -\u003e (Vec n a, Vec n b, Vec n c)",
          "source": "src/TypeUnary-Vec.html#unzipV3",
          "type": "function"
        },
        "index": {
          "description": "Unzip vector of pairs into pair of vectors",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "unzipV3",
          "normalized": "Vec a(b,c,d)-\u003e(Vec a b,Vec a c,Vec a d)",
          "package": "type-unary",
          "signature": "Vec n(a,b,c)-\u003e(Vec n a,Vec n b,Vec n c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:unzipV3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate a vector element, taking a proof that the index is within bounds.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "update",
          "package": "type-unary",
          "signature": "Index n -\u003e (a -\u003e a) -\u003e Vec n a -\u003e Vec n a",
          "source": "src/TypeUnary-Vec.html#update",
          "type": "function"
        },
        "index": {
          "description": "Update vector element taking proof that the index is within bounds",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "update",
          "normalized": "Index a-\u003e(b-\u003eb)-\u003eVec a b-\u003eVec a b",
          "package": "type-unary",
          "signature": "Index n-\u003e(a-\u003ea)-\u003eVec n a-\u003eVec n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec1",
          "package": "type-unary",
          "signature": "a -\u003e Vec1 a",
          "source": "src/TypeUnary-Vec.html#vec1",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec1",
          "normalized": "a-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec2",
          "package": "type-unary",
          "signature": "a -\u003e a -\u003e Vec2 a",
          "source": "src/TypeUnary-Vec.html#vec2",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec2",
          "normalized": "a-\u003ea-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003ea-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec3",
          "package": "type-unary",
          "signature": "a -\u003e a -\u003e a -\u003e Vec3 a",
          "source": "src/TypeUnary-Vec.html#vec3",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec3",
          "normalized": "a-\u003ea-\u003ea-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003ea-\u003ea-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec4",
          "package": "type-unary",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e Vec4 a",
          "source": "src/TypeUnary-Vec.html#vec4",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec4",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec5",
          "package": "type-unary",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e Vec5 a",
          "source": "src/TypeUnary-Vec.html#vec5",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec5",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec6",
          "package": "type-unary",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e Vec6 a",
          "source": "src/TypeUnary-Vec.html#vec6",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec6",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec7",
          "package": "type-unary",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e Vec7 a",
          "source": "src/TypeUnary-Vec.html#vec7",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec7",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "TypeUnary.Vec",
          "name": "vec8",
          "package": "type-unary",
          "signature": "a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e a -\u003e Vec8 a",
          "source": "src/TypeUnary-Vec.html#vec8",
          "type": "function"
        },
        "index": {
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "vec8",
          "normalized": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "package": "type-unary",
          "signature": "a-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003eVec a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:vec8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip two vectors into one. Like \u003ccode\u003e\u003ccode\u003e\u003ca\u003eliftA2\u003c/a\u003e\u003c/code\u003e '(,)'\u003c/code\u003e, but the former requires\n \u003ccode\u003eIsNat n\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "zipV",
          "package": "type-unary",
          "signature": "Vec n a -\u003e Vec n b -\u003e Vec n (a, b)",
          "source": "src/TypeUnary-Vec.html#zipV",
          "type": "function"
        },
        "index": {
          "description": "Zip two vectors into one Like liftA2 but the former requires IsNat",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "zipV",
          "normalized": "Vec a b-\u003eVec a c-\u003eVec a(b,c)",
          "package": "type-unary",
          "signature": "Vec n a-\u003eVec n b-\u003eVec n(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:zipV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip three vectors into one. Like \u003ccode\u003e\u003ccode\u003eliftA3\u003c/code\u003e '(,)'\u003c/code\u003e, but the former requires\n \u003ccode\u003eIsNat n\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "zipV3",
          "package": "type-unary",
          "signature": "Vec n a -\u003e Vec n b -\u003e Vec n c -\u003e Vec n (a, b, c)",
          "source": "src/TypeUnary-Vec.html#zipV3",
          "type": "function"
        },
        "index": {
          "description": "Zip three vectors into one Like liftA3 but the former requires IsNat",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "zipV3",
          "normalized": "Vec a b-\u003eVec a c-\u003eVec a d-\u003eVec a(b,c,d)",
          "package": "type-unary",
          "signature": "Vec n a-\u003eVec n b-\u003eVec n c-\u003eVec n(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:zipV3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnzip one vector into two. Like \u003ccode\u003e\u003ca\u003eliftA2\u003c/a\u003e\u003c/code\u003e, but the former requires\n \u003ccode\u003eIsNat n\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "zipWithV",
          "package": "type-unary",
          "signature": "(a -\u003e b -\u003e c) -\u003e Vec n a -\u003e Vec n b -\u003e Vec n c",
          "source": "src/TypeUnary-Vec.html#zipWithV",
          "type": "function"
        },
        "index": {
          "description": "Unzip one vector into two Like liftA2 but the former requires IsNat",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "zipWithV",
          "normalized": "(a-\u003eb-\u003ec)-\u003eVec d a-\u003eVec d b-\u003eVec d c",
          "package": "type-unary",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eVec n a-\u003eVec n b-\u003eVec n c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:zipWithV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnzip one vector into two. Like \u003ccode\u003e\u003ca\u003eliftA2\u003c/a\u003e\u003c/code\u003e, but the former requires\n \u003ccode\u003eIsNat n\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "TypeUnary.Vec",
          "name": "zipWithV3",
          "package": "type-unary",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Vec n a -\u003e Vec n b -\u003e Vec n c -\u003e Vec n d",
          "source": "src/TypeUnary-Vec.html#zipWithV3",
          "type": "function"
        },
        "index": {
          "description": "Unzip one vector into two Like liftA2 but the former requires IsNat",
          "hierarchy": "TypeUnary Vec",
          "module": "TypeUnary.Vec",
          "name": "zipWithV3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eVec e a-\u003eVec e b-\u003eVec e c-\u003eVec e d",
          "package": "type-unary",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eVec n a-\u003eVec n b-\u003eVec n c-\u003eVec n d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/type-unary/docs/TypeUnary-Vec.html#v:zipWithV3"
      }
    }
  ]
]