[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "ddc-core"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Annot.AnT",
          "name": "AnT",
          "package": "ddc-core",
          "source": "src/DDC-Core-Annot-AnT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnT",
          "module": "DDC.Core.Annot.AnT",
          "name": "AnT",
          "package": "ddc-core",
          "partial": "An",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type checker for witnesses adds this annotation to every node in the,\n   giving the type of each component of the witness.\n\u003c/p\u003e",
          "module": "DDC.Core.Annot.AnT",
          "name": "AnT",
          "package": "ddc-core",
          "source": "src/DDC-Core-Annot-AnT.html#AnT",
          "type": "data"
        },
        "index": {
          "description": "The type checker for witnesses adds this annotation to every node in the giving the type of each component of the witness",
          "hierarchy": "DDC Core Annot AnT",
          "module": "DDC.Core.Annot.AnT",
          "name": "AnT",
          "package": "ddc-core",
          "partial": "An",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnT.html#t:AnT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Annot.AnT",
          "name": "AnT",
          "package": "ddc-core",
          "signature": "AnT",
          "source": "src/DDC-Core-Annot-AnT.html#AnT",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnT",
          "module": "DDC.Core.Annot.AnT",
          "name": "AnT",
          "package": "ddc-core",
          "partial": "An",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnT.html#v:AnT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Annot.AnT",
          "name": "annotTail",
          "package": "ddc-core",
          "signature": "a",
          "source": "src/DDC-Core-Annot-AnT.html#AnT",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnT",
          "module": "DDC.Core.Annot.AnT",
          "name": "annotTail",
          "package": "ddc-core",
          "partial": "Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnT.html#v:annotTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Annot.AnT",
          "name": "annotType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Annot-AnT.html#AnT",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnT",
          "module": "DDC.Core.Annot.AnT",
          "name": "annotType",
          "package": "ddc-core",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnT.html#v:annotType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Annot.AnTEC",
          "name": "AnTEC",
          "package": "ddc-core",
          "source": "src/DDC-Core-Annot-AnTEC.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "AnTEC",
          "package": "ddc-core",
          "partial": "An TEC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type checker adds this annotation to every node in the AST, \n   giving its type, effect and closure.\n\u003c/p\u003e",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "AnTEC",
          "package": "ddc-core",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "data"
        },
        "index": {
          "description": "The type checker adds this annotation to every node in the AST giving its type effect and closure",
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "AnTEC",
          "package": "ddc-core",
          "partial": "An TEC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#t:AnTEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Annot.AnTEC\",\"DDC.Core.Check\",\"DDC.Core.Load\"]",
          "name": "AnTEC",
          "package": "ddc-core",
          "signature": "AnTEC",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:AnTEC\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:AnTEC\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:AnTEC\"]"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "AnTEC",
          "package": "ddc-core",
          "partial": "An TEC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:AnTEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Annot.AnTEC\",\"DDC.Core.Check\",\"DDC.Core.Load\"]",
          "name": "annotClosure",
          "package": "ddc-core",
          "signature": "Closure n",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotClosure\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:annotClosure\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:annotClosure\"]"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "annotClosure",
          "package": "ddc-core",
          "partial": "Closure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Annot.AnTEC\",\"DDC.Core.Check\",\"DDC.Core.Load\"]",
          "name": "annotEffect",
          "package": "ddc-core",
          "signature": "Effect n",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotEffect\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:annotEffect\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:annotEffect\"]"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "annotEffect",
          "package": "ddc-core",
          "partial": "Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Annot.AnTEC\",\"DDC.Core.Check\",\"DDC.Core.Load\"]",
          "name": "annotTail",
          "package": "ddc-core",
          "signature": "a",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotTail\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:annotTail\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:annotTail\"]"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "annotTail",
          "package": "ddc-core",
          "partial": "Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Annot.AnTEC\",\"DDC.Core.Check\",\"DDC.Core.Load\"]",
          "name": "annotType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotType\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:annotType\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:annotType\"]"
        },
        "index": {
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "annotType",
          "package": "ddc-core",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:annotType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePromote an \u003ccode\u003e\u003ca\u003eAnT\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eAnTEC\u003c/a\u003e\u003c/code\u003e by filling in the effect and closure\n   portions with bottoms.\n\u003c/p\u003e",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "fromAnT",
          "package": "ddc-core",
          "signature": "AnT a n -\u003e AnTEC a n",
          "source": "src/DDC-Core-Annot-AnTEC.html#fromAnT",
          "type": "function"
        },
        "index": {
          "description": "Promote an AnT to an AnTEC by filling in the effect and closure portions with bottoms",
          "hierarchy": "DDC Core Annot AnTEC",
          "module": "DDC.Core.Annot.AnTEC",
          "name": "fromAnT",
          "normalized": "AnT a b-\u003eAnTEC a b",
          "package": "ddc-core",
          "partial": "An",
          "signature": "AnT a n-\u003eAnTEC a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Annot-AnTEC.html#v:fromAnT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType checker for the Disciple Core language.\n\u003c/p\u003e\u003cp\u003eThe functions in this module do not check for language fragment compliance.\n   This needs to be done separately via \u003ca\u003eDDC.Core.Fragment\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Check",
          "name": "Check",
          "package": "ddc-core",
          "source": "src/DDC-Core-Check.html",
          "type": "module"
        },
        "index": {
          "description": "Type checker for the Disciple Core language The functions in this module do not check for language fragment compliance This needs to be done separately via DDC.Core.Fragment",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "Check",
          "package": "ddc-core",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type checker adds this annotation to every node in the AST, \n   giving its type, effect and closure.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "AnTEC",
          "package": "ddc-core",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "data"
        },
        "index": {
          "description": "The type checker adds this annotation to every node in the AST giving its type effect and closure",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "AnTEC",
          "package": "ddc-core",
          "partial": "An TEC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#t:AnTEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatic configuration for the type checker.\n   These fields don't change as we decend into the tree.\n\u003c/p\u003e\u003cp\u003eThe starting configuration should be converted from the profile that\n   defines the language fragment you are checking. \n   See \u003ca\u003eDDC.Core.Fragment\u003c/a\u003e and use \u003ccode\u003e\u003ca\u003econfigOfProfile\u003c/a\u003e\u003c/code\u003e below.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "Config",
          "package": "ddc-core",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "data"
        },
        "index": {
          "description": "Static configuration for the type checker These fields don change as we decend into the tree The starting configuration should be converted from the profile that defines the language fragment you are checking See DDC.Core.Fragment and use configOfProfile below",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "Config",
          "package": "ddc-core",
          "partial": "Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#t:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll the things that can go wrong when type checking an expression\n   or witness.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "Error",
          "package": "ddc-core",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "data"
        },
        "index": {
          "description": "All the things that can go wrong when type checking an expression or witness",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "Error",
          "package": "ddc-core",
          "partial": "Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#t:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "Config",
          "package": "ddc-core",
          "signature": "Config",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:Config\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:Config\"]"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "Config",
          "package": "ddc-core",
          "partial": "Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function application where the parameter and argument don't match.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorAppMismatch",
          "package": "ddc-core",
          "signature": "ErrorAppMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "function application where the parameter and argument don match",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorAppMismatch",
          "package": "ddc-core",
          "partial": "Error App Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorAppMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTried to apply something that is not a function.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorAppNotFun",
          "package": "ddc-core",
          "signature": "ErrorAppNotFun",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Tried to apply something that is not function",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorAppNotFun",
          "package": "ddc-core",
          "partial": "Error App Not Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorAppNotFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn invalid witness join.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCannotJoin",
          "package": "ddc-core",
          "signature": "ErrorCannotJoin",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "An invalid witness join",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCannotJoin",
          "package": "ddc-core",
          "partial": "Error Cannot Join",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCannotJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the result types of the alternatives are not\n   identical.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseAltResultMismatch",
          "package": "ddc-core",
          "signature": "ErrorCaseAltResultMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the result types of the alternatives are not identical",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseAltResultMismatch",
          "package": "ddc-core",
          "partial": "Error Case Alt Result Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseAltResultMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the pattern types could not be instantiated\n   with the arguments of the scrutinee type.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseCannotInstantiate",
          "package": "ddc-core",
          "signature": "ErrorCaseCannotInstantiate",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the pattern types could not be instantiated with the arguments of the scrutinee type",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseCannotInstantiate",
          "package": "ddc-core",
          "partial": "Error Case Cannot Instantiate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseCannotInstantiate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the annotation on a pattern variable binder\n   does not match the field type of the constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseFieldTypeMismatch",
          "package": "ddc-core",
          "signature": "ErrorCaseFieldTypeMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the annotation on pattern variable binder does not match the field type of the constructor",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseFieldTypeMismatch",
          "package": "ddc-core",
          "partial": "Error Case Field Type Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseFieldTypeMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression with no alternatives.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseNoAlternatives",
          "package": "ddc-core",
          "signature": "ErrorCaseNoAlternatives",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression with no alternatives",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseNoAlternatives",
          "package": "ddc-core",
          "partial": "Error Case No Alternatives",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseNoAlternatives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the alternatives don't cover all the\n   possible data constructors.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseNonExhaustive",
          "package": "ddc-core",
          "signature": "ErrorCaseNonExhaustive",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the alternatives don cover all the possible data constructors",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseNonExhaustive",
          "package": "ddc-core",
          "partial": "Error Case Non Exhaustive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseNonExhaustive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the alternatives don't cover all the\n   possible constructors, and the type has too many data constructors\n   to list.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseNonExhaustiveLarge",
          "package": "ddc-core",
          "signature": "ErrorCaseNonExhaustiveLarge",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the alternatives don cover all the possible constructors and the type has too many data constructors to list",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseNonExhaustiveLarge",
          "package": "ddc-core",
          "partial": "Error Case Non Exhaustive Large",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseNonExhaustiveLarge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression with overlapping alternatives.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseOverlapping",
          "package": "ddc-core",
          "signature": "ErrorCaseOverlapping",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression with overlapping alternatives",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseOverlapping",
          "package": "ddc-core",
          "partial": "Error Case Overlapping",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseOverlapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the scrutinee type is not algebraic.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseScrutineeNotAlgebraic",
          "package": "ddc-core",
          "signature": "ErrorCaseScrutineeNotAlgebraic",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the scrutinee type is not algebraic",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseScrutineeNotAlgebraic",
          "package": "ddc-core",
          "partial": "Error Case Scrutinee Not Algebraic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseScrutineeNotAlgebraic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the type of the scrutinee does not match\n   the type of the pattern.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseScrutineeTypeMismatch",
          "package": "ddc-core",
          "signature": "ErrorCaseScrutineeTypeMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the type of the scrutinee does not match the type of the pattern",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseScrutineeTypeMismatch",
          "package": "ddc-core",
          "partial": "Error Case Scrutinee Type Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseScrutineeTypeMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where the scrutinee type is not in our set\n   of data type declarations.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseScrutineeTypeUndeclared",
          "package": "ddc-core",
          "signature": "ErrorCaseScrutineeTypeUndeclared",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where the scrutinee type is not in our set of data type declarations",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseScrutineeTypeUndeclared",
          "package": "ddc-core",
          "partial": "Error Case Scrutinee Type Undeclared",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseScrutineeTypeUndeclared"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA case-expression where one of the patterns has too many binders.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseTooManyBinders",
          "package": "ddc-core",
          "signature": "ErrorCaseTooManyBinders",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "case-expression where one of the patterns has too many binders",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorCaseTooManyBinders",
          "package": "ddc-core",
          "partial": "Error Case Too Many Binders",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorCaseTooManyBinders"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType signature of exported binding does not match the type at\n   the definition site.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorExportMismatch",
          "package": "ddc-core",
          "signature": "ErrorExportMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Type signature of exported binding does not match the type at the definition site",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorExportMismatch",
          "package": "ddc-core",
          "partial": "Error Export Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorExportMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExported value is undefined.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorExportUndefined",
          "package": "ddc-core",
          "signature": "ErrorExportUndefined",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Exported value is undefined",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorExportUndefined",
          "package": "ddc-core",
          "partial": "Error Export Undefined",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorExportUndefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value function where the parameter does not have data kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLamBindNotData",
          "package": "ddc-core",
          "signature": "ErrorLamBindNotData",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "value function where the parameter does not have data kind",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLamBindNotData",
          "package": "ddc-core",
          "partial": "Error Lam Bind Not Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLamBindNotData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstraction where the body does not have data kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLamBodyNotData",
          "package": "ddc-core",
          "signature": "ErrorLamBodyNotData",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "An abstraction where the body does not have data kind",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLamBodyNotData",
          "package": "ddc-core",
          "partial": "Error Lam Body Not Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLamBodyNotData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstraction where the body has a visible closure that \n   is not supported by the current language fragment.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLamNotEmpty",
          "package": "ddc-core",
          "signature": "ErrorLamNotEmpty",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "An abstraction where the body has visible closure that is not supported by the current language fragment",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLamNotEmpty",
          "package": "ddc-core",
          "partial": "Error Lam Not Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLamNotEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstraction where the body has a visible side effect that \n   is not supported by the current language fragment.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLamNotPure",
          "package": "ddc-core",
          "signature": "ErrorLamNotPure",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "An abstraction where the body has visible side effect that is not supported by the current language fragment",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLamNotPure",
          "package": "ddc-core",
          "partial": "Error Lam Not Pure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLamNotPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type abstraction that tries to shadow a type variable that is\n   already in the environment.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLamShadow",
          "package": "ddc-core",
          "signature": "ErrorLamShadow",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "type abstraction that tries to shadow type variable that is already in the environment",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLamShadow",
          "package": "ddc-core",
          "partial": "Error Lam Shadow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLamShadow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA let-expression where the right of the binding does not have data kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetBindingNotData",
          "package": "ddc-core",
          "signature": "ErrorLetBindingNotData",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "let-expression where the right of the binding does not have data kind",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetBindingNotData",
          "package": "ddc-core",
          "partial": "Error Let Binding Not Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetBindingNotData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA let-expression where the body does not have data kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetBodyNotData",
          "package": "ddc-core",
          "signature": "ErrorLetBodyNotData",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "let-expression where the body does not have data kind",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetBodyNotData",
          "package": "ddc-core",
          "partial": "Error Let Body Not Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetBodyNotData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA let-expression where the type of the binder does not match the right\n   of the binding.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetMismatch",
          "package": "ddc-core",
          "signature": "ErrorLetMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "let-expression where the type of the binder does not match the right of the binding",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetMismatch",
          "package": "ddc-core",
          "partial": "Error Let Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression where some of the the bound region variables\n   are free in the type of the body.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionFree",
          "package": "ddc-core",
          "signature": "ErrorLetRegionFree",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression where some of the the bound region variables are free in the type of the body",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionFree",
          "package": "ddc-core",
          "partial": "Error Let Region Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetRegionFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression that tried to create conflicting witnesses.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionWitnessConflict",
          "package": "ddc-core",
          "signature": "ErrorLetRegionWitnessConflict",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression that tried to create conflicting witnesses",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionWitnessConflict",
          "package": "ddc-core",
          "partial": "Error Let Region Witness Conflict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetRegionWitnessConflict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression where the witness binding references some\n   free region variable that is not the one being introduced.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionWitnessFree",
          "package": "ddc-core",
          "signature": "ErrorLetRegionWitnessFree",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression where the witness binding references some free region variable that is not the one being introduced",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionWitnessFree",
          "package": "ddc-core",
          "partial": "Error Let Region Witness Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetRegionWitnessFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression that tried to create a witness with an \n   invalid type.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionWitnessInvalid",
          "package": "ddc-core",
          "signature": "ErrorLetRegionWitnessInvalid",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression that tried to create witness with an invalid type",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionWitnessInvalid",
          "package": "ddc-core",
          "partial": "Error Let Region Witness Invalid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetRegionWitnessInvalid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression where the some of the bound variables do not\n   have region kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionsNotRegion",
          "package": "ddc-core",
          "signature": "ErrorLetRegionsNotRegion",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression where the some of the bound variables do not have region kind",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionsNotRegion",
          "package": "ddc-core",
          "partial": "Error Let Regions Not Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetRegionsNotRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression that tried to shadow some pre-existing named\n   region variables.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionsRebound",
          "package": "ddc-core",
          "signature": "ErrorLetRegionsRebound",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression that tried to shadow some pre-existing named region variables",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionsRebound",
          "package": "ddc-core",
          "partial": "Error Let Regions Rebound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetRegionsRebound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression where a bound witnesses was not for the\n   the region variable being introduced.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionsWitnessOther",
          "package": "ddc-core",
          "signature": "ErrorLetRegionsWitnessOther",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression where bound witnesses was not for the the region variable being introduced",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetRegionsWitnessOther",
          "package": "ddc-core",
          "partial": "Error Let Regions Witness Other",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetRegionsWitnessOther"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA recursive let-expression where the right of the binding is not\n   a lambda abstraction.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetrecBindingNotLambda",
          "package": "ddc-core",
          "signature": "ErrorLetrecBindingNotLambda",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "recursive let-expression where the right of the binding is not lambda abstraction",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetrecBindingNotLambda",
          "package": "ddc-core",
          "partial": "Error Letrec Binding Not Lambda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetrecBindingNotLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA recursive let-expression that has more than one binding\n   with the same name.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorLetrecRebound",
          "package": "ddc-core",
          "signature": "ErrorLetrecRebound",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "recursive let-expression that has more than one binding with the same name",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorLetrecRebound",
          "package": "ddc-core",
          "partial": "Error Letrec Rebound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorLetrecRebound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a malformed expression, \n   and we don't have a more specific diagnosis.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorMalformedExp",
          "package": "ddc-core",
          "signature": "ErrorMalformedExp",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found malformed expression and we don have more specific diagnosis",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorMalformedExp",
          "package": "ddc-core",
          "partial": "Error Malformed Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorMalformedExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a malformed type,\n   and we don't have a more specific diagnosis.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorMalformedType",
          "package": "ddc-core",
          "signature": "ErrorMalformedType",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found malformed type and we don have more specific diagnosis",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorMalformedType",
          "package": "ddc-core",
          "partial": "Error Malformed Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorMalformedType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a naked \u003ccode\u003e\u003ca\u003eXType\u003c/a\u003e\u003c/code\u003e that wasn't the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorNakedType",
          "package": "ddc-core",
          "signature": "ErrorNakedType",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found naked XType that wasn the argument of an application",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorNakedType",
          "package": "ddc-core",
          "partial": "Error Naked Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorNakedType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a naked \u003ccode\u003e\u003ca\u003eXWitness\u003c/a\u003e\u003c/code\u003e that wasn't the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorNakedWitness",
          "package": "ddc-core",
          "signature": "ErrorNakedWitness",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found naked XWitness that wasn the argument of an application",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorNakedWitness",
          "package": "ddc-core",
          "partial": "Error Naked Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorNakedWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA run cast applied to a non-suspension.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorRunNotSuspension",
          "package": "ddc-core",
          "signature": "ErrorRunNotSuspension",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "run cast applied to non-suspension",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorRunNotSuspension",
          "package": "ddc-core",
          "partial": "Error Run Not Suspension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorRunNotSuspension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a kind error when checking a type.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorType",
          "package": "ddc-core",
          "signature": "ErrorType",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found kind error when checking type",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorType",
          "package": "ddc-core",
          "partial": "Error Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data constructor that wasn't in the set of data definitions.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorUndefinedCtor",
          "package": "ddc-core",
          "signature": "ErrorUndefinedCtor",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "data constructor that wasn in the set of data definitions",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorUndefinedCtor",
          "package": "ddc-core",
          "partial": "Error Undefined Ctor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorUndefinedCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn undefined type variable.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorUndefinedVar",
          "package": "ddc-core",
          "signature": "ErrorUndefinedVar",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "An undefined type variable",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorUndefinedVar",
          "package": "ddc-core",
          "partial": "Error Undefined Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorUndefinedVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA bound occurrence of a variable whose type annotation does not match\n   the corresponding annotation in the environment.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorVarAnnotMismatch",
          "package": "ddc-core",
          "signature": "ErrorVarAnnotMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "bound occurrence of variable whose type annotation does not match the corresponding annotation in the environment",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorVarAnnotMismatch",
          "package": "ddc-core",
          "partial": "Error Var Annot Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorVarAnnotMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA witness application where the argument type does not match\n   the parameter type.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorWAppMismatch",
          "package": "ddc-core",
          "signature": "ErrorWAppMismatch",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "witness application where the argument type does not match the parameter type",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorWAppMismatch",
          "package": "ddc-core",
          "partial": "Error WApp Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorWAppMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTried to perform a witness application with a non-witness.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorWAppNotCtor",
          "package": "ddc-core",
          "signature": "ErrorWAppNotCtor",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Tried to perform witness application with non-witness",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorWAppNotCtor",
          "package": "ddc-core",
          "partial": "Error WApp Not Ctor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorWAppNotCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA weakeff-cast where the type provided does not have effect kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorWeakEffNotEff",
          "package": "ddc-core",
          "signature": "ErrorWeakEffNotEff",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "weakeff-cast where the type provided does not have effect kind",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorWeakEffNotEff",
          "package": "ddc-core",
          "partial": "Error Weak Eff Not Eff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorWeakEffNotEff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA letregion-expression where some of the the bound region variables\n   are free in the type of the body.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorWithRegionFree",
          "package": "ddc-core",
          "signature": "ErrorWithRegionFree",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "letregion-expression where some of the the bound region variables are free in the type of the body",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorWithRegionFree",
          "package": "ddc-core",
          "partial": "Error With Region Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorWithRegionFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA withregion-expression where the handle does not have region kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorWithRegionNotRegion",
          "package": "ddc-core",
          "signature": "ErrorWithRegionNotRegion",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "withregion-expression where the handle does not have region kind",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorWithRegionNotRegion",
          "package": "ddc-core",
          "partial": "Error With Region Not Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorWithRegionNotRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA witness provided for a forget cast that does not witness emptiness.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorWitnessNotEmpty",
          "package": "ddc-core",
          "signature": "ErrorWitnessNotEmpty",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "witness provided for forget cast that does not witness emptiness",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorWitnessNotEmpty",
          "package": "ddc-core",
          "partial": "Error Witness Not Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorWitnessNotEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA witness provided for a purify cast that does not witness purity.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "ErrorWitnessNotPurity",
          "package": "ddc-core",
          "signature": "ErrorWitnessNotPurity",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "witness provided for purify cast that does not witness purity",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "ErrorWitnessNotPurity",
          "package": "ddc-core",
          "partial": "Error Witness Not Purity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:ErrorWitnessNotPurity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType check an expression. \n\u003c/p\u003e\u003cp\u003eIf it's good, you get a new version with types attached to all the bound\n   variables, as well its the type, effect and closure. \n\u003c/p\u003e\u003cp\u003eIf it's bad, you get a description of the error.\n\u003c/p\u003e\u003cp\u003eThe returned expression has types attached to all variable occurrences, \n   so you can call \u003ccode\u003e\u003ca\u003etypeOfExp\u003c/a\u003e\u003c/code\u003e on any open subterm.\n\u003c/p\u003e\u003cp\u003eThe kinds and types of primitives are added to the environments \n   automatically, you don't need to supply these as part of the \n   starting environments.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "checkExp",
          "package": "ddc-core",
          "signature": "Config n-\u003e KindEnv n-\u003e TypeEnv n-\u003e Exp a n-\u003e Either (Error a n) (Exp (AnTEC a n) n, Type n, Effect n, Closure n)",
          "type": "function"
        },
        "index": {
          "description": "Type check an expression If it good you get new version with types attached to all the bound variables as well its the type effect and closure If it bad you get description of the error The returned expression has types attached to all variable occurrences so you can call typeOfExp on any open subterm The kinds and types of primitives are added to the environments automatically you don need to supply these as part of the starting environments",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "checkExp",
          "normalized": "Config a-\u003eKindEnv a-\u003eTypeEnv a-\u003eExp b a-\u003eEither(Error b a)(Exp(AnTEC b a)a,Type a,Effect a,Closure a)",
          "package": "ddc-core",
          "partial": "Exp",
          "signature": "Config n-\u003eKindEnv n-\u003eTypeEnv n-\u003eExp a n-\u003eEither(Error a n)(Exp(AnTEC a n)n,Type n,Effect n,Closure n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:checkExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType check a module.\n\u003c/p\u003e\u003cp\u003eIf it's good, you get a new version with types attached to all the bound\n   variables\n\u003c/p\u003e\u003cp\u003eIf it's bad, you get a description of the error.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "checkModule",
          "package": "ddc-core",
          "signature": "Config n-\u003e Module a n-\u003e Either (Error a n) (Module (AnTEC a n) n)",
          "type": "function"
        },
        "index": {
          "description": "Type check module If it good you get new version with types attached to all the bound variables If it bad you get description of the error",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "checkModule",
          "normalized": "Config a-\u003eModule b a-\u003eEither(Error b a)(Module(AnTEC b a)a)",
          "package": "ddc-core",
          "partial": "Module",
          "signature": "Config n-\u003eModule a n-\u003eEither(Error a n)(Module(AnTEC a n)n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:checkModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck a witness.\n\u003c/p\u003e\u003cp\u003eIf it's good, you get a new version with types attached to all the bound\n   variables, as well as the type of the overall witness.\n\u003c/p\u003e\u003cp\u003eIf it's bad, you get a description of the error.\n\u003c/p\u003e\u003cp\u003eThe returned expression has types attached to all variable occurrences, \n   so you can call \u003ccode\u003e\u003ca\u003etypeOfWitness\u003c/a\u003e\u003c/code\u003e on any open subterm.\n\u003c/p\u003e\u003cp\u003eThe kinds and types of primitives are added to the environments \n   automatically, you don't need to supply these as part of the \n   starting environments.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "checkWitness",
          "package": "ddc-core",
          "signature": "Config n-\u003e KindEnv n-\u003e TypeEnv n-\u003e Witness a n-\u003e Either (Error a n) (Witness (AnT a n) n, Type n)",
          "type": "function"
        },
        "index": {
          "description": "Check witness If it good you get new version with types attached to all the bound variables as well as the type of the overall witness If it bad you get description of the error The returned expression has types attached to all variable occurrences so you can call typeOfWitness on any open subterm The kinds and types of primitives are added to the environments automatically you don need to supply these as part of the starting environments",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "checkWitness",
          "normalized": "Config a-\u003eKindEnv a-\u003eTypeEnv a-\u003eWitness b a-\u003eEither(Error b a)(Witness(AnT b a)a,Type a)",
          "package": "ddc-core",
          "partial": "Witness",
          "signature": "Config n-\u003eKindEnv n-\u003eTypeEnv n-\u003eWitness a n-\u003eEither(Error a n)(Witness(AnT a n)n,Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:checkWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach closure information to function types.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configFunctionalClosures",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configFunctionalClosures\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configFunctionalClosures\"]"
        },
        "index": {
          "description": "Attach closure information to function types",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configFunctionalClosures",
          "package": "ddc-core",
          "partial": "Functional Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configFunctionalClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach effect information to function types.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configFunctionalEffects",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configFunctionalEffects\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configFunctionalEffects\"]"
        },
        "index": {
          "description": "Attach effect information to function types",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configFunctionalEffects",
          "package": "ddc-core",
          "partial": "Functional Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configFunctionalEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a langage profile to a type checker configuration.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configOfProfile",
          "package": "ddc-core",
          "signature": "Profile n -\u003e Config n",
          "source": "src/DDC-Type-Check-Config.html#configOfProfile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configOfProfile\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configOfProfile\"]"
        },
        "index": {
          "description": "Convert langage profile to type checker configuration",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configOfProfile",
          "normalized": "Profile a-\u003eConfig a",
          "package": "ddc-core",
          "partial": "Of Profile",
          "signature": "Profile n-\u003eConfig n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configOfProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData type definitions.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configPrimDataDefs",
          "package": "ddc-core",
          "signature": "DataDefs n",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimDataDefs\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configPrimDataDefs\"]"
        },
        "index": {
          "description": "Data type definitions",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configPrimDataDefs",
          "package": "ddc-core",
          "partial": "Prim Data Defs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimDataDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKinds of primitive types.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configPrimKinds",
          "package": "ddc-core",
          "signature": "KindEnv n",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimKinds\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configPrimKinds\"]"
        },
        "index": {
          "description": "Kinds of primitive types",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configPrimKinds",
          "package": "ddc-core",
          "partial": "Prim Kinds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuper kinds of primitive kinds.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configPrimSupers",
          "package": "ddc-core",
          "signature": "SuperEnv n",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimSupers\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configPrimSupers\"]"
        },
        "index": {
          "description": "Super kinds of primitive kinds",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configPrimSupers",
          "package": "ddc-core",
          "partial": "Prim Supers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimSupers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of primitive operators.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configPrimTypes",
          "package": "ddc-core",
          "signature": "TypeEnv n",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimTypes\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configPrimTypes\"]"
        },
        "index": {
          "description": "Types of primitive operators",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configPrimTypes",
          "package": "ddc-core",
          "partial": "Prim Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configPrimTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrack closure type information.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configTrackedClosures",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configTrackedClosures\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configTrackedClosures\"]"
        },
        "index": {
          "description": "Track closure type information",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configTrackedClosures",
          "package": "ddc-core",
          "partial": "Tracked Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configTrackedClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrack effect type information.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Check\",\"DDC.Type.Check\"]",
          "name": "configTrackedEffects",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configTrackedEffects\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:configTrackedEffects\"]"
        },
        "index": {
          "description": "Track effect type information",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "configTrackedEffects",
          "package": "ddc-core",
          "partial": "Tracked Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:configTrackedEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorAltType1",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorAltType1",
          "package": "ddc-core",
          "partial": "Alt Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorAltType1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorAltType2",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorAltType2",
          "package": "ddc-core",
          "partial": "Alt Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorAltType2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorArgType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorArgType",
          "package": "ddc-core",
          "partial": "Arg Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorArgType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorBind",
          "package": "ddc-core",
          "signature": "Bind n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorBind",
          "package": "ddc-core",
          "partial": "Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorBindWitness",
          "package": "ddc-core",
          "signature": "Bind n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorBindWitness",
          "package": "ddc-core",
          "partial": "Bind Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorBindWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorBindWitness1",
          "package": "ddc-core",
          "signature": "Bind n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorBindWitness1",
          "package": "ddc-core",
          "partial": "Bind Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorBindWitness1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorBindWitness2",
          "package": "ddc-core",
          "signature": "Bind n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorBindWitness2",
          "package": "ddc-core",
          "partial": "Bind Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorBindWitness2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorBinds",
          "package": "ddc-core",
          "signature": "[Bind n]",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorBinds",
          "normalized": "[Bind a]",
          "package": "ddc-core",
          "partial": "Binds",
          "signature": "[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorBound",
          "package": "ddc-core",
          "signature": "Bound n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorBound",
          "package": "ddc-core",
          "partial": "Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorBoundRegions",
          "package": "ddc-core",
          "signature": "[Bound n]",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorBoundRegions",
          "normalized": "[Bound a]",
          "package": "ddc-core",
          "partial": "Bound Regions",
          "signature": "[Bound n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorBoundRegions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorChecking",
          "package": "ddc-core",
          "signature": "Exp a n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorChecking",
          "package": "ddc-core",
          "partial": "Checking",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorChecking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorClosure",
          "package": "ddc-core",
          "signature": "Closure n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorClosure",
          "package": "ddc-core",
          "partial": "Closure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorCtorDaCon",
          "package": "ddc-core",
          "signature": "DaCon n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorCtorDaCon",
          "package": "ddc-core",
          "partial": "Ctor Da Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorCtorDaCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorCtorFields",
          "package": "ddc-core",
          "signature": "Int",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorCtorFields",
          "package": "ddc-core",
          "partial": "Ctor Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorCtorFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorCtorNamesMissing",
          "package": "ddc-core",
          "signature": "[n]",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorCtorNamesMissing",
          "normalized": "[a]",
          "package": "ddc-core",
          "partial": "Ctor Names Missing",
          "signature": "[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorCtorNamesMissing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorDefType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorDefType",
          "package": "ddc-core",
          "partial": "Def Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorDefType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorEffect",
          "package": "ddc-core",
          "signature": "Effect n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorEffect",
          "package": "ddc-core",
          "partial": "Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorExp",
          "package": "ddc-core",
          "signature": "Exp a n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorExp",
          "package": "ddc-core",
          "partial": "Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorExportType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorExportType",
          "package": "ddc-core",
          "partial": "Export Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorExportType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorKind",
          "package": "ddc-core",
          "partial": "Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorKinds",
          "package": "ddc-core",
          "signature": "[Kind n]",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorKinds",
          "normalized": "[Kind a]",
          "package": "ddc-core",
          "partial": "Kinds",
          "signature": "[Kind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorName",
          "package": "ddc-core",
          "signature": "n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorName",
          "package": "ddc-core",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorNotFunType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorNotFunType",
          "package": "ddc-core",
          "partial": "Not Fun Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorNotFunType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorParamType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorParamType",
          "package": "ddc-core",
          "partial": "Param Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorParamType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorPatternFields",
          "package": "ddc-core",
          "signature": "Int",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorPatternFields",
          "package": "ddc-core",
          "partial": "Pattern Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorPatternFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorType",
          "package": "ddc-core",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeAnnot",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeAnnot",
          "package": "ddc-core",
          "partial": "Type Annot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeAnnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeCtor",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeCtor",
          "package": "ddc-core",
          "partial": "Type Ctor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeEnv",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeEnv",
          "package": "ddc-core",
          "partial": "Type Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeError",
          "package": "ddc-core",
          "signature": "Error n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeError",
          "package": "ddc-core",
          "partial": "Type Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeField",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeField",
          "package": "ddc-core",
          "partial": "Type Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeLeft",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeLeft",
          "package": "ddc-core",
          "partial": "Type Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypePattern",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypePattern",
          "package": "ddc-core",
          "partial": "Type Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypePattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeRight",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeRight",
          "package": "ddc-core",
          "partial": "Type Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorTypeScrutinee",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorTypeScrutinee",
          "package": "ddc-core",
          "partial": "Type Scrutinee",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorTypeScrutinee"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorUniverse",
          "package": "ddc-core",
          "signature": "Universe",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorUniverse",
          "package": "ddc-core",
          "partial": "Universe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorUniverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorWitness",
          "package": "ddc-core",
          "signature": "Witness a n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorWitness",
          "package": "ddc-core",
          "partial": "Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorWitnessLeft",
          "package": "ddc-core",
          "signature": "Witness a n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorWitnessLeft",
          "package": "ddc-core",
          "partial": "Witness Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorWitnessLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Check",
          "name": "errorWitnessRight",
          "package": "ddc-core",
          "signature": "Witness a n",
          "source": "src/DDC-Core-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "errorWitnessRight",
          "package": "ddc-core",
          "partial": "Witness Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:errorWitnessRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003echeckExp\u003c/a\u003e\u003c/code\u003e, but only return the value type of an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "typeOfExp",
          "package": "ddc-core",
          "signature": "Config n-\u003e KindEnv n-\u003e TypeEnv n-\u003e Exp a n-\u003e Either (Error a n) (Type n)",
          "type": "function"
        },
        "index": {
          "description": "Like checkExp but only return the value type of an expression",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "typeOfExp",
          "normalized": "Config a-\u003eKindEnv a-\u003eTypeEnv a-\u003eExp b a-\u003eEither(Error b a)(Type a)",
          "package": "ddc-core",
          "partial": "Of Exp",
          "signature": "Config n-\u003eKindEnv n-\u003eTypeEnv n-\u003eExp a n-\u003eEither(Error a n)(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:typeOfExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the type of a witness constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "typeOfWiCon",
          "package": "ddc-core",
          "signature": "WiCon n -\u003e Type n",
          "source": "src/DDC-Core-Check-CheckWitness.html#typeOfWiCon",
          "type": "function"
        },
        "index": {
          "description": "Take the type of witness constructor",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "typeOfWiCon",
          "normalized": "WiCon a-\u003eType a",
          "package": "ddc-core",
          "partial": "Of Wi Con",
          "signature": "WiCon n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:typeOfWiCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003echeckWitness\u003c/a\u003e\u003c/code\u003e, but check in an empty environment.\n\u003c/p\u003e\u003cp\u003eAs this function is not given an environment, the types of free variables\n   must be attached directly to the bound occurrences.\n   This attachment is performed by \u003ccode\u003e\u003ca\u003echeckWitness\u003c/a\u003e\u003c/code\u003e above.\n\u003c/p\u003e",
          "module": "DDC.Core.Check",
          "name": "typeOfWitness",
          "package": "ddc-core",
          "signature": "Config n -\u003e Witness a n -\u003e Either (Error a n) (Type n)",
          "source": "src/DDC-Core-Check-CheckWitness.html#typeOfWitness",
          "type": "function"
        },
        "index": {
          "description": "Like checkWitness but check in an empty environment As this function is not given an environment the types of free variables must be attached directly to the bound occurrences This attachment is performed by checkWitness above",
          "hierarchy": "DDC Core Check",
          "module": "DDC.Core.Check",
          "name": "typeOfWitness",
          "normalized": "Config a-\u003eWitness b a-\u003eEither(Error b a)(Type a)",
          "package": "ddc-core",
          "partial": "Of Witness",
          "signature": "Config n-\u003eWitness a n-\u003eEither(Error a n)(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Check.html#v:typeOfWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCollecting sets of variables and constructors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Collect",
          "name": "Collect",
          "package": "ddc-core",
          "source": "src/DDC-Core-Collect.html",
          "type": "module"
        },
        "index": {
          "description": "Collecting sets of variables and constructors",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "Collect",
          "package": "ddc-core",
          "partial": "Collect",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Collect",
          "name": "Support",
          "package": "ddc-core",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "data"
        },
        "index": {
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "Support",
          "package": "ddc-core",
          "partial": "Support",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#t:Support"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Collect",
          "name": "SupportX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Collect-Support.html#SupportX",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "SupportX",
          "package": "ddc-core",
          "partial": "Support",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#t:SupportX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Collect",
          "name": "Support",
          "package": "ddc-core",
          "signature": "Support",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "Support",
          "package": "ddc-core",
          "partial": "Support",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:Support"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect all the spec and exp binders in a thing.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Collect\",\"DDC.Type.Collect\"]",
          "name": "collectBinds",
          "package": "ddc-core",
          "signature": "c n -\u003e ([Bind n], [Bind n])",
          "source": "src/DDC-Type-Collect.html#collectBinds",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:collectBinds\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:collectBinds\"]"
        },
        "index": {
          "description": "Collect all the spec and exp binders in thing",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "collectBinds",
          "normalized": "a b-\u003e([Bind b],[Bind b])",
          "package": "ddc-core",
          "partial": "Binds",
          "signature": "c n-\u003e([Bind n],[Bind n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:collectBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect all the bound variables in a thing, \n   independent of whether they are free or not.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Collect\",\"DDC.Type.Collect\"]",
          "name": "collectBound",
          "package": "ddc-core",
          "signature": "c n -\u003e Set (Bound n)",
          "source": "src/DDC-Type-Collect.html#collectBound",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:collectBound\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:collectBound\"]"
        },
        "index": {
          "description": "Collect all the bound variables in thing independent of whether they are free or not",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "collectBound",
          "normalized": "a b-\u003eSet(Bound b)",
          "package": "ddc-core",
          "partial": "Bound",
          "signature": "c n-\u003eSet(Bound n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:collectBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect the free Spec variables in a thing (level-1).\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Collect\",\"DDC.Type.Collect\"]",
          "name": "freeT",
          "package": "ddc-core",
          "signature": "Env n -\u003e c n -\u003e Set (Bound n)",
          "source": "src/DDC-Type-Collect.html#freeT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:freeT\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:freeT\"]"
        },
        "index": {
          "description": "Collect the free Spec variables in thing level-1",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "freeT",
          "normalized": "Env a-\u003eb a-\u003eSet(Bound a)",
          "package": "ddc-core",
          "signature": "Env n-\u003ec n-\u003eSet(Bound n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:freeT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCollect the free Data and Witness variables in a thing (level-0).\n\u003c/p\u003e",
          "module": "DDC.Core.Collect",
          "name": "freeX",
          "package": "ddc-core",
          "signature": "Env n -\u003e c n -\u003e Set (Bound n)",
          "source": "src/DDC-Core-Collect-Free.html#freeX",
          "type": "function"
        },
        "index": {
          "description": "Collect the free Data and Witness variables in thing level-0",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "freeX",
          "normalized": "Env a-\u003eb a-\u003eSet(Bound a)",
          "package": "ddc-core",
          "signature": "Env n-\u003ec n-\u003eSet(Bound n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:freeX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Collect",
          "name": "support",
          "package": "ddc-core",
          "signature": "KindEnv n -\u003e TypeEnv n -\u003e c n -\u003e Support n",
          "source": "src/DDC-Core-Collect-Support.html#support",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "support",
          "normalized": "KindEnv a-\u003eTypeEnv a-\u003eb a-\u003eSupport a",
          "package": "ddc-core",
          "signature": "KindEnv n-\u003eTypeEnv n-\u003ec n-\u003eSupport n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:support"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFree value variables in an expression.\n   (from the Data universe)\n\u003c/p\u003e",
          "module": "DDC.Core.Collect",
          "name": "supportDaVar",
          "package": "ddc-core",
          "signature": "Set (Bound n)",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "function"
        },
        "index": {
          "description": "Free value variables in an expression from the Data universe",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "supportDaVar",
          "package": "ddc-core",
          "partial": "Da Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:supportDaVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFree spec variables in an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Collect",
          "name": "supportSpVar",
          "package": "ddc-core",
          "signature": "Set (Bound n)",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "function"
        },
        "index": {
          "description": "Free spec variables in an expression",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "supportSpVar",
          "package": "ddc-core",
          "partial": "Sp Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:supportSpVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors used in the argument of a value-type application.\n\u003c/p\u003e",
          "module": "DDC.Core.Collect",
          "name": "supportSpVarXArg",
          "package": "ddc-core",
          "signature": "Set (Bound n)",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "function"
        },
        "index": {
          "description": "Type constructors used in the argument of value-type application",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "supportSpVarXArg",
          "package": "ddc-core",
          "partial": "Sp Var XArg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:supportSpVarXArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors used in the expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Collect",
          "name": "supportTyCon",
          "package": "ddc-core",
          "signature": "Set (Bound n)",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "function"
        },
        "index": {
          "description": "Type constructors used in the expression",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "supportTyCon",
          "package": "ddc-core",
          "partial": "Ty Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:supportTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructors used in the argument of a value-type application.\n\u003c/p\u003e",
          "module": "DDC.Core.Collect",
          "name": "supportTyConXArg",
          "package": "ddc-core",
          "signature": "Set (Bound n)",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "function"
        },
        "index": {
          "description": "Type constructors used in the argument of value-type application",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "supportTyConXArg",
          "package": "ddc-core",
          "partial": "Ty Con XArg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:supportTyConXArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFree witness variables in an expression.\n   (from the Witness universe)\n\u003c/p\u003e",
          "module": "DDC.Core.Collect",
          "name": "supportWiVar",
          "package": "ddc-core",
          "signature": "Set (Bound n)",
          "source": "src/DDC-Core-Collect-Support.html#Support",
          "type": "function"
        },
        "index": {
          "description": "Free witness variables in an expression from the Witness universe",
          "hierarchy": "DDC Core Collect",
          "module": "DDC.Core.Collect",
          "name": "supportWiVar",
          "package": "ddc-core",
          "partial": "Wi Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Collect.html#v:supportWiVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for constructing and destructing compound expressions.\n\u003c/p\u003e\u003cp\u003eFor the annotated version of the AST.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "Annot",
          "package": "ddc-core",
          "source": "src/DDC-Core-Compounds-Annot.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for constructing and destructing compound expressions For the annotated version of the AST",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "Annot",
          "package": "ddc-core",
          "partial": "Annot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the binds of a \u003ccode\u003e\u003ca\u003eLets\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe level-1 and level-0 binders are returned separately.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "bindsOfLets",
          "package": "ddc-core",
          "signature": "Lets a n -\u003e ([Bind n], [Bind n])",
          "source": "src/DDC-Core-Compounds-Annot.html#bindsOfLets",
          "type": "function"
        },
        "index": {
          "description": "Take the binds of Lets The level-1 and level-0 binders are returned separately",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "bindsOfLets",
          "normalized": "Lets a b-\u003e([Bind b],[Bind b])",
          "package": "ddc-core",
          "partial": "Of Lets",
          "signature": "Lets a n-\u003e([Bind n],[Bind n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:bindsOfLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the binds of a \u003ccode\u003e\u003ca\u003ePat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "bindsOfPat",
          "package": "ddc-core",
          "signature": "Pat n -\u003e [Bind n]",
          "source": "src/DDC-Core-Compounds-Annot.html#bindsOfPat",
          "type": "function"
        },
        "index": {
          "description": "Take the binds of Pat",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "bindsOfPat",
          "normalized": "Pat a-\u003e[Bind a]",
          "package": "ddc-core",
          "partial": "Of Pat",
          "signature": "Pat n-\u003e[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:bindsOfPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit data constructor.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Compounds.Annot\",\"DDC.Core.Compounds.Simple\"]",
          "name": "dcUnit",
          "package": "ddc-core",
          "signature": "DaCon n",
          "source": "src/DDC-Core-Exp-DaCon.html#dcUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:dcUnit\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:dcUnit\"]"
        },
        "index": {
          "description": "The unit data constructor",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "dcUnit",
          "package": "ddc-core",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:dcUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild sequence of applications.\n   Similar to \u003ccode\u003e\u003ca\u003exApps\u003c/a\u003e\u003c/code\u003e but also takes list of annotations for \n   the \u003ccode\u003e\u003ca\u003eXApp\u003c/a\u003e\u003c/code\u003e constructors.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "makeXAppsWithAnnots",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e [(Exp a n, a)] -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#makeXAppsWithAnnots",
          "type": "function"
        },
        "index": {
          "description": "Build sequence of applications Similar to xApps but also takes list of annotations for the XApp constructors",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "makeXAppsWithAnnots",
          "normalized": "Exp a b-\u003e[(Exp a b,a)]-\u003eExp a b",
          "package": "ddc-core",
          "partial": "XApps With Annots",
          "signature": "Exp a n-\u003e[(Exp a n,a)]-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:makeXAppsWithAnnots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake some nested lambda abstractions,\n   using a flag to indicate whether the lambda is a\n   level-1 (True), or level-0 (False) binder.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "makeXLamFlags",
          "package": "ddc-core",
          "signature": "a -\u003e [(Bool, Bind n)] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#makeXLamFlags",
          "type": "function"
        },
        "index": {
          "description": "Make some nested lambda abstractions using flag to indicate whether the lambda is level-1 True or level-0 False binder",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "makeXLamFlags",
          "normalized": "a-\u003e[(Bool,Bind b)]-\u003eExp a b-\u003eExp a b",
          "package": "ddc-core",
          "partial": "XLam Flags",
          "signature": "a-\u003e[(Bool,Bind n)]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:makeXLamFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake an algebraic data constructor.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Compounds.Annot\",\"DDC.Core.Compounds.Simple\"]",
          "name": "mkDaConAlg",
          "package": "ddc-core",
          "signature": "n -\u003e Type n -\u003e DaCon n",
          "source": "src/DDC-Core-Exp-DaCon.html#mkDaConAlg",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:mkDaConAlg\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:mkDaConAlg\"]"
        },
        "index": {
          "description": "Make an algebraic data constructor",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "mkDaConAlg",
          "normalized": "a-\u003eType a-\u003eDaCon a",
          "package": "ddc-core",
          "partial": "Da Con Alg",
          "signature": "n-\u003eType n-\u003eDaCon n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:mkDaConAlg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a non-algebraic (solid) constructor.\n   These are used for location values in the interpreter,\n   and for floating point literals in the main compiler.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Compounds.Annot\",\"DDC.Core.Compounds.Simple\"]",
          "name": "mkDaConSolid",
          "package": "ddc-core",
          "signature": "n -\u003e Type n -\u003e DaCon n",
          "source": "src/DDC-Core-Exp-DaCon.html#mkDaConSolid",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:mkDaConSolid\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:mkDaConSolid\"]"
        },
        "index": {
          "description": "Make non-algebraic solid constructor These are used for location values in the interpreter and for floating point literals in the main compiler",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "mkDaConSolid",
          "normalized": "a-\u003eType a-\u003eDaCon a",
          "package": "ddc-core",
          "partial": "Da Con Solid",
          "signature": "n-\u003eType n-\u003eDaCon n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:mkDaConSolid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ebindsOfLets\u003c/a\u003e\u003c/code\u003e but only take the spec (level-1) binders.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "specBindsOfLets",
          "package": "ddc-core",
          "signature": "Lets a n -\u003e [Bind n]",
          "source": "src/DDC-Core-Compounds-Annot.html#specBindsOfLets",
          "type": "function"
        },
        "index": {
          "description": "Like bindsOfLets but only take the spec level-1 binders",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "specBindsOfLets",
          "normalized": "Lets a b-\u003e[Bind b]",
          "package": "ddc-core",
          "partial": "Binds Of Lets",
          "signature": "Lets a n-\u003e[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:specBindsOfLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit let-bindings from the front of an expression, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "splitXLets",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e ([Lets a n], Exp a n)",
          "source": "src/DDC-Core-Compounds-Annot.html#splitXLets",
          "type": "function"
        },
        "index": {
          "description": "Split let-bindings from the front of an expression if any",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "splitXLets",
          "normalized": "Exp a b-\u003e([Lets a b],Exp a b)",
          "package": "ddc-core",
          "partial": "XLets",
          "signature": "Exp a n-\u003e([Lets a n],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:splitXLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the outermost annotation from an expression,\n   or Nothing if this is an \u003ccode\u003e\u003ca\u003eXType\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eXWitness\u003c/a\u003e\u003c/code\u003e without an annotation.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeAnnotOfExp",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe a",
          "source": "src/DDC-Core-Compounds-Annot.html#takeAnnotOfExp",
          "type": "function"
        },
        "index": {
          "description": "Take the outermost annotation from an expression or Nothing if this is an XType or XWitness without an annotation",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeAnnotOfExp",
          "normalized": "Exp a b-\u003eMaybe a",
          "package": "ddc-core",
          "partial": "Annot Of Exp",
          "signature": "Exp a n-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeAnnotOfExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the constructor name of an alternative, if there is one.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeCtorNameOfAlt",
          "package": "ddc-core",
          "signature": "Alt a n -\u003e Maybe n",
          "source": "src/DDC-Core-Compounds-Annot.html#takeCtorNameOfAlt",
          "type": "function"
        },
        "index": {
          "description": "Take the constructor name of an alternative if there is one",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeCtorNameOfAlt",
          "normalized": "Alt a b-\u003eMaybe b",
          "package": "ddc-core",
          "partial": "Ctor Name Of Alt",
          "signature": "Alt a n-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeCtorNameOfAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the name of data constructor.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Compounds.Annot\",\"DDC.Core.Compounds.Simple\"]",
          "name": "takeNameOfDaCon",
          "package": "ddc-core",
          "signature": "DaCon n -\u003e Maybe n",
          "source": "src/DDC-Core-Exp-DaCon.html#takeNameOfDaCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeNameOfDaCon\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeNameOfDaCon\"]"
        },
        "index": {
          "description": "Take the name of data constructor",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeNameOfDaCon",
          "normalized": "DaCon a-\u003eMaybe a",
          "package": "ddc-core",
          "partial": "Name Of Da Con",
          "signature": "DaCon n-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeNameOfDaCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application of a witness into the witness constructor\n   name and its arguments.\n\u003c/p\u003e\u003cp\u003eReturns nothing if there is no witness constructor in head position.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takePrimWiConApps",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e Maybe (n, [Witness a n])",
          "source": "src/DDC-Core-Compounds-Annot.html#takePrimWiConApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application of witness into the witness constructor name and its arguments Returns nothing if there is no witness constructor in head position",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takePrimWiConApps",
          "normalized": "Witness a b-\u003eMaybe(b,[Witness a b])",
          "package": "ddc-core",
          "partial": "Prim Wi Con Apps",
          "signature": "Witness a n-\u003eMaybe(n,[Witness a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takePrimWiConApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function parts and arguments, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeWAppsAsList",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e [Witness a n]",
          "source": "src/DDC-Core-Compounds-Annot.html#takeWAppsAsList",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function parts and arguments if any",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeWAppsAsList",
          "normalized": "Witness a b-\u003e[Witness a b]",
          "package": "ddc-core",
          "partial": "WApps As List",
          "signature": "Witness a n-\u003e[Witness a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeWAppsAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function part and its arguments.\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no outer application.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXApps",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (Exp a n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function part and its arguments Returns Nothing if there is no outer application",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXApps",
          "normalized": "Exp a b-\u003eMaybe(Exp a b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XApps",
          "signature": "Exp a n-\u003eMaybe(Exp a n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function part and its arguments.\n\u003c/p\u003e\u003cp\u003eThis is like \u003ccode\u003e\u003ca\u003etakeXApps\u003c/a\u003e\u003c/code\u003e above, except we know there is at least one argument.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXApps1",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Exp a n -\u003e (Exp a n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXApps1",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function part and its arguments This is like takeXApps above except we know there is at least one argument",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXApps1",
          "normalized": "Exp a b-\u003eExp a b-\u003e(Exp a b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XApps",
          "signature": "Exp a n-\u003eExp a n-\u003e(Exp a n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXApps1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function parts and arguments, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXAppsAsList",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e [Exp a n]",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXAppsAsList",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function parts and arguments if any",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXAppsAsList",
          "normalized": "Exp a b-\u003e[Exp a b]",
          "package": "ddc-core",
          "partial": "XApps As List",
          "signature": "Exp a n-\u003e[Exp a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXAppsAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestruct sequence of applications.\n   Similar to \u003ccode\u003e\u003ca\u003etakeXAppsAsList\u003c/a\u003e\u003c/code\u003e but also keeps annotations for later.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXAppsWithAnnots",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e (Exp a n, [(Exp a n, a)])",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXAppsWithAnnots",
          "type": "function"
        },
        "index": {
          "description": "Destruct sequence of applications Similar to takeXAppsAsList but also keeps annotations for later",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXAppsWithAnnots",
          "normalized": "Exp a b-\u003e(Exp a b,[(Exp a b,a)])",
          "package": "ddc-core",
          "partial": "XApps With Annots",
          "signature": "Exp a n-\u003e(Exp a n,[(Exp a n,a)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXAppsWithAnnots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application of a data constructor into the constructor\n   and its arguments. \n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the expression isn't a constructor application.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXConApps",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (DaCon n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXConApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application of data constructor into the constructor and its arguments Returns Nothing if the expression isn constructor application",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXConApps",
          "normalized": "Exp a b-\u003eMaybe(DaCon b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XCon Apps",
          "signature": "Exp a n-\u003eMaybe(DaCon n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXConApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit type lambdas from the front of an expression,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there aren't any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXLAMs",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe ([Bind n], Exp a n)",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXLAMs",
          "type": "function"
        },
        "index": {
          "description": "Split type lambdas from the front of an expression or Nothing if there aren any",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXLAMs",
          "normalized": "Exp a b-\u003eMaybe([Bind b],Exp a b)",
          "package": "ddc-core",
          "partial": "XLAMs",
          "signature": "Exp a n-\u003eMaybe([Bind n],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXLAMs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit nested lambdas from the front of an expression, \n   with a flag indicating whether the lambda was a level-1 (True), \n   or level-0 (False) binder.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXLamFlags",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe ([(Bool, Bind n)], Exp a n)",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXLamFlags",
          "type": "function"
        },
        "index": {
          "description": "Split nested lambdas from the front of an expression with flag indicating whether the lambda was level-1 True or level-0 False binder",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXLamFlags",
          "normalized": "Exp a b-\u003eMaybe([(Bool,Bind b)],Exp a b)",
          "package": "ddc-core",
          "partial": "XLam Flags",
          "signature": "Exp a n-\u003eMaybe([(Bool,Bind n)],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXLamFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit nested value or witness lambdas from the front of an expression,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there aren't any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXLams",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe ([Bind n], Exp a n)",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXLams",
          "type": "function"
        },
        "index": {
          "description": "Split nested value or witness lambdas from the front of an expression or Nothing if there aren any",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXLams",
          "normalized": "Exp a b-\u003eMaybe([Bind b],Exp a b)",
          "package": "ddc-core",
          "partial": "XLams",
          "signature": "Exp a n-\u003eMaybe([Bind n],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXLams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application of a primop into the variable\n   and its arguments.\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the expression isn't a primop application.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXPrimApps",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXPrimApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application of primop into the variable and its arguments Returns Nothing if the expression isn primop application",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXPrimApps",
          "normalized": "Exp a b-\u003eMaybe(b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XPrim Apps",
          "signature": "Exp a n-\u003eMaybe(n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXPrimApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the type from an \u003ccode\u003e\u003ca\u003eXType\u003c/a\u003e\u003c/code\u003e argument, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXType",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (Type n)",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXType",
          "type": "function"
        },
        "index": {
          "description": "Take the type from an XType argument if any",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXType",
          "normalized": "Exp a b-\u003eMaybe(Type b)",
          "package": "ddc-core",
          "partial": "XType",
          "signature": "Exp a n-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the witness from an \u003ccode\u003e\u003ca\u003eXWitness\u003c/a\u003e\u003c/code\u003e argument, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXWitness",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (Witness a n)",
          "source": "src/DDC-Core-Compounds-Annot.html#takeXWitness",
          "type": "function"
        },
        "index": {
          "description": "Take the witness from an XWitness argument if any",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "takeXWitness",
          "normalized": "Exp a b-\u003eMaybe(Witness a b)",
          "package": "ddc-core",
          "partial": "XWitness",
          "signature": "Exp a n-\u003eMaybe(Witness a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:takeXWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the type annotation of a data constructor.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Compounds.Annot\",\"DDC.Core.Compounds.Simple\"]",
          "name": "typeOfDaCon",
          "package": "ddc-core",
          "signature": "DaCon n -\u003e Type n",
          "source": "src/DDC-Core-Exp-DaCon.html#typeOfDaCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:typeOfDaCon\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:typeOfDaCon\"]"
        },
        "index": {
          "description": "Take the type annotation of data constructor",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "typeOfDaCon",
          "normalized": "DaCon a-\u003eType a",
          "package": "ddc-core",
          "partial": "Of Da Con",
          "signature": "DaCon n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:typeOfDaCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ebindsOfLets\u003c/a\u003e\u003c/code\u003e but only take the value and witness (level-0) binders.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "valwitBindsOfLets",
          "package": "ddc-core",
          "signature": "Lets a n -\u003e [Bind n]",
          "source": "src/DDC-Core-Compounds-Annot.html#valwitBindsOfLets",
          "type": "function"
        },
        "index": {
          "description": "Like bindsOfLets but only take the value and witness level-0 binders",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "valwitBindsOfLets",
          "normalized": "Lets a b-\u003e[Bind b]",
          "package": "ddc-core",
          "partial": "Binds Of Lets",
          "signature": "Lets a n-\u003e[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:valwitBindsOfLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a witness application\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "wApp",
          "package": "ddc-core",
          "signature": "a -\u003e Witness a n -\u003e Witness a n -\u003e Witness a n",
          "source": "src/DDC-Core-Compounds-Annot.html#wApp",
          "type": "function"
        },
        "index": {
          "description": "Construct witness application",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "wApp",
          "normalized": "a-\u003eWitness a b-\u003eWitness a b-\u003eWitness a b",
          "package": "ddc-core",
          "partial": "App",
          "signature": "a-\u003eWitness a n-\u003eWitness a n-\u003eWitness a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:wApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a sequence of witness applications\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "wApps",
          "package": "ddc-core",
          "signature": "a -\u003e Witness a n -\u003e [Witness a n] -\u003e Witness a n",
          "source": "src/DDC-Core-Compounds-Annot.html#wApps",
          "type": "function"
        },
        "index": {
          "description": "Construct sequence of witness applications",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "wApps",
          "normalized": "a-\u003eWitness a b-\u003e[Witness a b]-\u003eWitness a b",
          "package": "ddc-core",
          "partial": "Apps",
          "signature": "a-\u003eWitness a n-\u003e[Witness a n]-\u003eWitness a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:wApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild sequence of value applications.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xApps",
          "package": "ddc-core",
          "signature": "a -\u003e Exp a n -\u003e [Exp a n] -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#xApps",
          "type": "function"
        },
        "index": {
          "description": "Build sequence of value applications",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xApps",
          "normalized": "a-\u003eExp a b-\u003e[Exp a b]-\u003eExp a b",
          "package": "ddc-core",
          "partial": "Apps",
          "signature": "a-\u003eExp a n-\u003e[Exp a n]-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:xApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake some nested type lambdas.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLAMs",
          "package": "ddc-core",
          "signature": "a -\u003e [Bind n] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#xLAMs",
          "type": "function"
        },
        "index": {
          "description": "Make some nested type lambdas",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLAMs",
          "normalized": "a-\u003e[Bind b]-\u003eExp a b-\u003eExp a b",
          "package": "ddc-core",
          "partial": "LAMs",
          "signature": "a-\u003e[Bind n]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:xLAMs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake some nested value or witness lambdas.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLams",
          "package": "ddc-core",
          "signature": "a -\u003e [Bind n] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#xLams",
          "type": "function"
        },
        "index": {
          "description": "Make some nested value or witness lambdas",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLams",
          "normalized": "a-\u003e[Bind b]-\u003eExp a b-\u003eExp a b",
          "package": "ddc-core",
          "partial": "Lams",
          "signature": "a-\u003e[Bind n]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:xLams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap some let-bindings around an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLets",
          "package": "ddc-core",
          "signature": "a -\u003e [Lets a n] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#xLets",
          "type": "function"
        },
        "index": {
          "description": "Wrap some let-bindings around an expression",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLets",
          "normalized": "a-\u003e[Lets a b]-\u003eExp a b-\u003eExp a b",
          "package": "ddc-core",
          "partial": "Lets",
          "signature": "a-\u003e[Lets a n]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:xLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap some let-bindings around an expression, with individual annotations.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLetsAnnot",
          "package": "ddc-core",
          "signature": "[(Lets a n, a)] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#xLetsAnnot",
          "type": "function"
        },
        "index": {
          "description": "Wrap some let-bindings around an expression with individual annotations",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xLetsAnnot",
          "normalized": "[(Lets a b,a)]-\u003eExp a b-\u003eExp a b",
          "package": "ddc-core",
          "partial": "Lets Annot",
          "signature": "[(Lets a n,a)]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:xLetsAnnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a value of unit type.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xUnit",
          "package": "ddc-core",
          "signature": "a -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Annot.html#xUnit",
          "type": "function"
        },
        "index": {
          "description": "Construct value of unit type",
          "hierarchy": "DDC Core Compounds Annot",
          "module": "DDC.Core.Compounds.Annot",
          "name": "xUnit",
          "normalized": "a-\u003eExp a b",
          "package": "ddc-core",
          "partial": "Unit",
          "signature": "a-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Annot.html#v:xUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for constructing and destructing compound expressions.\n\u003c/p\u003e\u003cp\u003eFor the Simple version of the AST.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "Simple",
          "package": "ddc-core",
          "source": "src/DDC-Core-Compounds-Simple.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for constructing and destructing compound expressions For the Simple version of the AST",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "Simple",
          "package": "ddc-core",
          "partial": "Simple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the binds of a \u003ccode\u003e\u003ca\u003eLets\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe level-1 and level-0 binders are returned separately.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "bindsOfLets",
          "package": "ddc-core",
          "signature": "Lets a n -\u003e ([Bind n], [Bind n])",
          "source": "src/DDC-Core-Compounds-Simple.html#bindsOfLets",
          "type": "function"
        },
        "index": {
          "description": "Take the binds of Lets The level-1 and level-0 binders are returned separately",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "bindsOfLets",
          "normalized": "Lets a b-\u003e([Bind b],[Bind b])",
          "package": "ddc-core",
          "partial": "Of Lets",
          "signature": "Lets a n-\u003e([Bind n],[Bind n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:bindsOfLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the binds of a \u003ccode\u003e\u003ca\u003ePat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "bindsOfPat",
          "package": "ddc-core",
          "signature": "Pat n -\u003e [Bind n]",
          "source": "src/DDC-Core-Compounds-Simple.html#bindsOfPat",
          "type": "function"
        },
        "index": {
          "description": "Take the binds of Pat",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "bindsOfPat",
          "normalized": "Pat a-\u003e[Bind a]",
          "package": "ddc-core",
          "partial": "Of Pat",
          "signature": "Pat n-\u003e[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:bindsOfPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake some nested lambda abstractions,\n   using a flag to indicate whether the lambda is a\n   level-1 (True), or level-0 (False) binder.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "makeXLamFlags",
          "package": "ddc-core",
          "signature": "[(Bool, Bind n)] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Simple.html#makeXLamFlags",
          "type": "function"
        },
        "index": {
          "description": "Make some nested lambda abstractions using flag to indicate whether the lambda is level-1 True or level-0 False binder",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "makeXLamFlags",
          "normalized": "[(Bool,Bind a)]-\u003eExp b a-\u003eExp b a",
          "package": "ddc-core",
          "partial": "XLam Flags",
          "signature": "[(Bool,Bind n)]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:makeXLamFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ebindsOfLets\u003c/a\u003e\u003c/code\u003e but only take the spec (level-1) binders.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "specBindsOfLets",
          "package": "ddc-core",
          "signature": "Lets a n -\u003e [Bind n]",
          "source": "src/DDC-Core-Compounds-Simple.html#specBindsOfLets",
          "type": "function"
        },
        "index": {
          "description": "Like bindsOfLets but only take the spec level-1 binders",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "specBindsOfLets",
          "normalized": "Lets a b-\u003e[Bind b]",
          "package": "ddc-core",
          "partial": "Binds Of Lets",
          "signature": "Lets a n-\u003e[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:specBindsOfLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit let-bindings from the front of an expression, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "splitXLets",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e ([Lets a n], Exp a n)",
          "source": "src/DDC-Core-Compounds-Simple.html#splitXLets",
          "type": "function"
        },
        "index": {
          "description": "Split let-bindings from the front of an expression if any",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "splitXLets",
          "normalized": "Exp a b-\u003e([Lets a b],Exp a b)",
          "package": "ddc-core",
          "partial": "XLets",
          "signature": "Exp a n-\u003e([Lets a n],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:splitXLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the constructor name of an alternative, if there is one.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeCtorNameOfAlt",
          "package": "ddc-core",
          "signature": "Alt a n -\u003e Maybe n",
          "source": "src/DDC-Core-Compounds-Simple.html#takeCtorNameOfAlt",
          "type": "function"
        },
        "index": {
          "description": "Take the constructor name of an alternative if there is one",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeCtorNameOfAlt",
          "normalized": "Alt a b-\u003eMaybe b",
          "package": "ddc-core",
          "partial": "Ctor Name Of Alt",
          "signature": "Alt a n-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeCtorNameOfAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application of a witness into the witness constructor\n   name and its arguments.\n\u003c/p\u003e\u003cp\u003eReturns nothing if there is no witness constructor in head position.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takePrimWiConApps",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e Maybe (n, [Witness a n])",
          "source": "src/DDC-Core-Compounds-Simple.html#takePrimWiConApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application of witness into the witness constructor name and its arguments Returns nothing if there is no witness constructor in head position",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takePrimWiConApps",
          "normalized": "Witness a b-\u003eMaybe(b,[Witness a b])",
          "package": "ddc-core",
          "partial": "Prim Wi Con Apps",
          "signature": "Witness a n-\u003eMaybe(n,[Witness a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takePrimWiConApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function parts and arguments, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeWAppsAsList",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e [Witness a n]",
          "source": "src/DDC-Core-Compounds-Simple.html#takeWAppsAsList",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function parts and arguments if any",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeWAppsAsList",
          "normalized": "Witness a b-\u003e[Witness a b]",
          "package": "ddc-core",
          "partial": "WApps As List",
          "signature": "Witness a n-\u003e[Witness a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeWAppsAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function part and its arguments.\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no outer application.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXApps",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (Exp a n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function part and its arguments Returns Nothing if there is no outer application",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXApps",
          "normalized": "Exp a b-\u003eMaybe(Exp a b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XApps",
          "signature": "Exp a n-\u003eMaybe(Exp a n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function part and its arguments.\n\u003c/p\u003e\u003cp\u003eThis is like \u003ccode\u003e\u003ca\u003etakeXApps\u003c/a\u003e\u003c/code\u003e above, except we know there is at least one argument.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXApps1",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Exp a n -\u003e (Exp a n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXApps1",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function part and its arguments This is like takeXApps above except we know there is at least one argument",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXApps1",
          "normalized": "Exp a b-\u003eExp a b-\u003e(Exp a b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XApps",
          "signature": "Exp a n-\u003eExp a n-\u003e(Exp a n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXApps1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application into the function parts and arguments, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXAppsAsList",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e [Exp a n]",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXAppsAsList",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application into the function parts and arguments if any",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXAppsAsList",
          "normalized": "Exp a b-\u003e[Exp a b]",
          "package": "ddc-core",
          "partial": "XApps As List",
          "signature": "Exp a n-\u003e[Exp a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXAppsAsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application of a data constructor into the constructor\n   and its arguments. \n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the expression isn't a constructor application.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXConApps",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (DaCon n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXConApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application of data constructor into the constructor and its arguments Returns Nothing if the expression isn constructor application",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXConApps",
          "normalized": "Exp a b-\u003eMaybe(DaCon b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XCon Apps",
          "signature": "Exp a n-\u003eMaybe(DaCon n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXConApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit type lambdas from the front of an expression,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there aren't any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXLAMs",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe ([Bind n], Exp a n)",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXLAMs",
          "type": "function"
        },
        "index": {
          "description": "Split type lambdas from the front of an expression or Nothing if there aren any",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXLAMs",
          "normalized": "Exp a b-\u003eMaybe([Bind b],Exp a b)",
          "package": "ddc-core",
          "partial": "XLAMs",
          "signature": "Exp a n-\u003eMaybe([Bind n],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXLAMs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit nested lambdas from the front of an expression, \n   with a flag indicating whether the lambda was a level-1 (True), \n   or level-0 (False) binder.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXLamFlags",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe ([(Bool, Bind n)], Exp a n)",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXLamFlags",
          "type": "function"
        },
        "index": {
          "description": "Split nested lambdas from the front of an expression with flag indicating whether the lambda was level-1 True or level-0 False binder",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXLamFlags",
          "normalized": "Exp a b-\u003eMaybe([(Bool,Bind b)],Exp a b)",
          "package": "ddc-core",
          "partial": "XLam Flags",
          "signature": "Exp a n-\u003eMaybe([(Bool,Bind n)],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXLamFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit nested value or witness lambdas from the front of an expression,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there aren't any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXLams",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe ([Bind n], Exp a n)",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXLams",
          "type": "function"
        },
        "index": {
          "description": "Split nested value or witness lambdas from the front of an expression or Nothing if there aren any",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXLams",
          "normalized": "Exp a b-\u003eMaybe([Bind b],Exp a b)",
          "package": "ddc-core",
          "partial": "XLams",
          "signature": "Exp a n-\u003eMaybe([Bind n],Exp a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXLams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten an application of a primop into the variable\n   and its arguments.\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the expression isn't a primop application.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXPrimApps",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (n, [Exp a n])",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXPrimApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten an application of primop into the variable and its arguments Returns Nothing if the expression isn primop application",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXPrimApps",
          "normalized": "Exp a b-\u003eMaybe(b,[Exp a b])",
          "package": "ddc-core",
          "partial": "XPrim Apps",
          "signature": "Exp a n-\u003eMaybe(n,[Exp a n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXPrimApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the type from an \u003ccode\u003e\u003ca\u003eXType\u003c/a\u003e\u003c/code\u003e argument, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXType",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (Type n)",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXType",
          "type": "function"
        },
        "index": {
          "description": "Take the type from an XType argument if any",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXType",
          "normalized": "Exp a b-\u003eMaybe(Type b)",
          "package": "ddc-core",
          "partial": "XType",
          "signature": "Exp a n-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the witness from an \u003ccode\u003e\u003ca\u003eXWitness\u003c/a\u003e\u003c/code\u003e argument, if any.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXWitness",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Maybe (Witness a n)",
          "source": "src/DDC-Core-Compounds-Simple.html#takeXWitness",
          "type": "function"
        },
        "index": {
          "description": "Take the witness from an XWitness argument if any",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "takeXWitness",
          "normalized": "Exp a b-\u003eMaybe(Witness a b)",
          "package": "ddc-core",
          "partial": "XWitness",
          "signature": "Exp a n-\u003eMaybe(Witness a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:takeXWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ebindsOfLets\u003c/a\u003e\u003c/code\u003e but only take the value and witness (level-0) binders.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "valwitBindsOfLets",
          "package": "ddc-core",
          "signature": "Lets a n -\u003e [Bind n]",
          "source": "src/DDC-Core-Compounds-Simple.html#valwitBindsOfLets",
          "type": "function"
        },
        "index": {
          "description": "Like bindsOfLets but only take the value and witness level-0 binders",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "valwitBindsOfLets",
          "normalized": "Lets a b-\u003e[Bind b]",
          "package": "ddc-core",
          "partial": "Binds Of Lets",
          "signature": "Lets a n-\u003e[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:valwitBindsOfLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a witness application\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "wApp",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e Witness a n -\u003e Witness a n",
          "source": "src/DDC-Core-Compounds-Simple.html#wApp",
          "type": "function"
        },
        "index": {
          "description": "Construct witness application",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "wApp",
          "normalized": "Witness a b-\u003eWitness a b-\u003eWitness a b",
          "package": "ddc-core",
          "partial": "App",
          "signature": "Witness a n-\u003eWitness a n-\u003eWitness a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:wApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a sequence of witness applications\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "wApps",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e [Witness a n] -\u003e Witness a n",
          "source": "src/DDC-Core-Compounds-Simple.html#wApps",
          "type": "function"
        },
        "index": {
          "description": "Construct sequence of witness applications",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "wApps",
          "normalized": "Witness a b-\u003e[Witness a b]-\u003eWitness a b",
          "package": "ddc-core",
          "partial": "Apps",
          "signature": "Witness a n-\u003e[Witness a n]-\u003eWitness a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:wApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild sequence of value applications.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xApps",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e [Exp a n] -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Simple.html#xApps",
          "type": "function"
        },
        "index": {
          "description": "Build sequence of value applications",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xApps",
          "normalized": "Exp a b-\u003e[Exp a b]-\u003eExp a b",
          "package": "ddc-core",
          "partial": "Apps",
          "signature": "Exp a n-\u003e[Exp a n]-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:xApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake some nested type lambdas.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xLAMs",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Simple.html#xLAMs",
          "type": "function"
        },
        "index": {
          "description": "Make some nested type lambdas",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xLAMs",
          "normalized": "[Bind a]-\u003eExp b a-\u003eExp b a",
          "package": "ddc-core",
          "partial": "LAMs",
          "signature": "[Bind n]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:xLAMs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake some nested value or witness lambdas.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xLams",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Simple.html#xLams",
          "type": "function"
        },
        "index": {
          "description": "Make some nested value or witness lambdas",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xLams",
          "normalized": "[Bind a]-\u003eExp b a-\u003eExp b a",
          "package": "ddc-core",
          "partial": "Lams",
          "signature": "[Bind n]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:xLams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap some let-bindings around an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xLets",
          "package": "ddc-core",
          "signature": "[Lets a n] -\u003e Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Compounds-Simple.html#xLets",
          "type": "function"
        },
        "index": {
          "description": "Wrap some let-bindings around an expression",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xLets",
          "normalized": "[Lets a b]-\u003eExp a b-\u003eExp a b",
          "package": "ddc-core",
          "partial": "Lets",
          "signature": "[Lets a n]-\u003eExp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:xLets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a value of unit type.\n\u003c/p\u003e",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xUnit",
          "package": "ddc-core",
          "signature": "Exp a n",
          "source": "src/DDC-Core-Compounds-Simple.html#xUnit",
          "type": "function"
        },
        "index": {
          "description": "Construct value of unit type",
          "hierarchy": "DDC Core Compounds Simple",
          "module": "DDC.Core.Compounds.Simple",
          "name": "xUnit",
          "package": "ddc-core",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds-Simple.html#v:xUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for constructing and destructing compound expressions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Compounds",
          "name": "Compounds",
          "package": "ddc-core",
          "source": "src/DDC-Core-Compounds.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for constructing and destructing compound expressions",
          "hierarchy": "DDC Core Compounds",
          "module": "DDC.Core.Compounds",
          "name": "Compounds",
          "package": "ddc-core",
          "partial": "Compounds",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Compounds.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCore language AST that includes an annotation on every node of \n   an expression.\n\u003c/p\u003e\u003cp\u003eThis is the default representation for Disciple Core, and should be preferred\n   over the \u003ccode\u003eSimple\u003c/code\u003e version of the AST in most cases. \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Local transformations on this AST should propagate the annotations in a way that\n   would make sense if they were source position identifiers that tracked the provenance\n   of each code snippet. If the specific annotations attached to the AST would not make\n   sense after such a transformation, then the client should erase them to \u003ccode\u003e()\u003c/code\u003e beforehand\n   using the \u003ccode\u003ereannotate\u003c/code\u003e transform.\n\u003c/li\u003e\u003cli\u003e Global transformations that drastically change the provenance of code snippets should\n     accept an AST with an arbitrary annotation type, but produce one with the annotations\n     set to \u003ccode\u003e()\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "Annot",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Annot.html",
          "type": "module"
        },
        "index": {
          "description": "Core language AST that includes an annotation on every node of an expression This is the default representation for Disciple Core and should be preferred over the Simple version of the AST in most cases Local transformations on this AST should propagate the annotations in way that would make sense if they were source position identifiers that tracked the provenance of each code snippet If the specific annotations attached to the AST would not make sense after such transformation then the client should erase them to beforehand using the reannotate transform Global transformations that drastically change the provenance of code snippets should accept an AST with an arbitrary annotation type but produce one with the annotations set to",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "Annot",
          "package": "ddc-core",
          "partial": "Annot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCase alternatives.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "Alt",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Annot.html#Alt",
          "type": "data"
        },
        "index": {
          "description": "Case alternatives",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "Alt",
          "package": "ddc-core",
          "partial": "Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:Alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType casts.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "Cast",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Annot.html#Cast",
          "type": "data"
        },
        "index": {
          "description": "Type casts",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "Cast",
          "package": "ddc-core",
          "partial": "Cast",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:Cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructors.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "DaCon",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-DaCon.html#DaCon",
          "type": "data"
        },
        "index": {
          "description": "Data constructors",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "DaCon",
          "package": "ddc-core",
          "partial": "Da Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:DaCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructor names.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "DaConName",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-DaCon.html#DaConName",
          "type": "data"
        },
        "index": {
          "description": "Data constructor names",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "DaConName",
          "package": "ddc-core",
          "partial": "Da Con Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:DaConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWell-typed expressions have types of kind \u003ccode\u003eData\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "Exp",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "data"
        },
        "index": {
          "description": "Well-typed expressions have types of kind Data",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "Exp",
          "package": "ddc-core",
          "partial": "Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:Exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly recursive bindings.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "Lets",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Annot.html#Lets",
          "type": "data"
        },
        "index": {
          "description": "Possibly recursive bindings",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "Lets",
          "package": "ddc-core",
          "partial": "Lets",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:Lets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePattern matching.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "Pat",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Pat.html#Pat",
          "type": "data"
        },
        "index": {
          "description": "Pattern matching",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "Pat",
          "package": "ddc-core",
          "partial": "Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:Pat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuilt-in witness constructors.\n\u003c/p\u003e\u003cp\u003eThese are used to convert a runtime capability into a witness that\n   the corresponding property is true.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "WbCon",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-WiCon.html#WbCon",
          "type": "data"
        },
        "index": {
          "description": "Built-in witness constructors These are used to convert runtime capability into witness that the corresponding property is true",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WbCon",
          "package": "ddc-core",
          "partial": "Wb Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:WbCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness constructors.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "WiCon",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-WiCon.html#WiCon",
          "type": "data"
        },
        "index": {
          "description": "Witness constructors",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WiCon",
          "package": "ddc-core",
          "partial": "Wi Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:WiCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen a witness exists in the program it guarantees that a\n   certain property of the program is true.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "Witness",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Annot.html#Witness",
          "type": "data"
        },
        "index": {
          "description": "When witness exists in the program it guarantees that certain property of the program is true",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "Witness",
          "package": "ddc-core",
          "partial": "Witness",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#t:Witness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Exp.Annot",
          "name": "AAlt",
          "package": "ddc-core",
          "signature": "AAlt !(Pat n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Alt",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "AAlt",
          "package": "ddc-core",
          "partial": "AAlt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:AAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForget about the closure (sharing) of an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastForget",
          "package": "ddc-core",
          "signature": "CastForget !(Witness a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Forget about the closure sharing of an expression",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastForget",
          "package": "ddc-core",
          "partial": "Cast Forget",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:CastForget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePurify the effect (action) of an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastPurify",
          "package": "ddc-core",
          "signature": "CastPurify !(Witness a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Purify the effect action of an expression",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastPurify",
          "package": "ddc-core",
          "partial": "Cast Purify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:CastPurify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a computation,\n   releasing its effects into the environment.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastRun",
          "package": "ddc-core",
          "signature": "CastRun",
          "source": "src/DDC-Core-Exp-Annot.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Run computation releasing its effects into the environment",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastRun",
          "package": "ddc-core",
          "partial": "Cast Run",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:CastRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuspend a computation, \n   capturing its effects in the S computation type.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastSuspend",
          "package": "ddc-core",
          "signature": "CastSuspend",
          "source": "src/DDC-Core-Exp-Annot.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Suspend computation capturing its effects in the computation type",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastSuspend",
          "package": "ddc-core",
          "partial": "Cast Suspend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:CastSuspend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeaken the closure of an expression.\n   The closures of these expressions are added to the closure\n   of the body.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastWeakenClosure",
          "package": "ddc-core",
          "signature": "CastWeakenClosure ![Exp a n]",
          "source": "src/DDC-Core-Exp-Annot.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Weaken the closure of an expression The closures of these expressions are added to the closure of the body",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastWeakenClosure",
          "normalized": "CastWeakenClosure[Exp a b]",
          "package": "ddc-core",
          "partial": "Cast Weaken Closure",
          "signature": "CastWeakenClosure[Exp a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:CastWeakenClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeaken the effect of an expression.\n   The given effect is added to the effect\n   of the body.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastWeakenEffect",
          "package": "ddc-core",
          "signature": "CastWeakenEffect !(Effect n)",
          "source": "src/DDC-Core-Exp-Annot.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Weaken the effect of an expression The given effect is added to the effect of the body",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "CastWeakenEffect",
          "package": "ddc-core",
          "partial": "Cast Weaken Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:CastWeakenEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "DaCon",
          "package": "ddc-core",
          "signature": "DaCon",
          "source": "src/DDC-Core-Exp-DaCon.html#DaCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:DaCon\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:DaCon\"]"
        },
        "index": {
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "DaCon",
          "package": "ddc-core",
          "partial": "Da Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:DaCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructor name defined by the client.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "DaConNamed",
          "package": "ddc-core",
          "signature": "DaConNamed n",
          "source": "src/DDC-Core-Exp-DaCon.html#DaConName",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:DaConNamed\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:DaConNamed\"]"
        },
        "index": {
          "description": "Data constructor name defined by the client",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "DaConNamed",
          "package": "ddc-core",
          "partial": "Da Con Named",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:DaConNamed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit data constructor is builtin.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "DaConUnit",
          "package": "ddc-core",
          "signature": "DaConUnit",
          "source": "src/DDC-Core-Exp-DaCon.html#DaConName",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:DaConUnit\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:DaConUnit\"]"
        },
        "index": {
          "description": "The unit data constructor is builtin",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "DaConUnit",
          "package": "ddc-core",
          "partial": "Da Con Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:DaConUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-recursive expression binding.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "LLet",
          "package": "ddc-core",
          "signature": "LLet !(Bind n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Non-recursive expression binding",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "LLet",
          "package": "ddc-core",
          "partial": "LLet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:LLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBind a local region variable,\n   and witnesses to its properties.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "LLetRegions",
          "package": "ddc-core",
          "signature": "LLetRegions ![Bind n] ![Bind n]",
          "source": "src/DDC-Core-Exp-Annot.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Bind local region variable and witnesses to its properties",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "LLetRegions",
          "normalized": "LLetRegions[Bind a][Bind a]",
          "package": "ddc-core",
          "partial": "LLet Regions",
          "signature": "LLetRegions[Bind n][Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:LLetRegions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecursive binding of lambda abstractions.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "LRec",
          "package": "ddc-core",
          "signature": "LRec ![(Bind n, Exp a n)]",
          "source": "src/DDC-Core-Exp-Annot.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Recursive binding of lambda abstractions",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "LRec",
          "normalized": "LRec[(Bind a,Exp b a)]",
          "package": "ddc-core",
          "partial": "LRec",
          "signature": "LRec[(Bind n,Exp a n)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:LRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHolds a region handle during evaluation.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "LWithRegion",
          "package": "ddc-core",
          "signature": "LWithRegion !(Bound n)",
          "source": "src/DDC-Core-Exp-Annot.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Holds region handle during evaluation",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "LWithRegion",
          "package": "ddc-core",
          "partial": "LWith Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:LWithRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a data constructor and bind its arguments.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "PData",
          "package": "ddc-core",
          "signature": "PData !(DaCon n) ![Bind n]",
          "source": "src/DDC-Core-Exp-Pat.html#Pat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:PData\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:PData\"]"
        },
        "index": {
          "description": "Match data constructor and bind its arguments",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "PData",
          "normalized": "PData(DaCon a)[Bind a]",
          "package": "ddc-core",
          "partial": "PData",
          "signature": "PData(DaCon n)[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:PData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default pattern always succeeds.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "PDefault",
          "package": "ddc-core",
          "signature": "PDefault",
          "source": "src/DDC-Core-Exp-Pat.html#Pat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:PDefault\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:PDefault\"]"
        },
        "index": {
          "description": "The default pattern always succeeds",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "PDefault",
          "package": "ddc-core",
          "partial": "PDefault",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:PDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "WApp",
          "package": "ddc-core",
          "signature": "WApp a !(Witness a n) !(Witness a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Witness application",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WApp",
          "package": "ddc-core",
          "partial": "WApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "WCon",
          "package": "ddc-core",
          "signature": "WCon a !(WiCon n)",
          "source": "src/DDC-Core-Exp-Annot.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Witness constructor",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WCon",
          "package": "ddc-core",
          "partial": "WCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoining of witnesses.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "WJoin",
          "package": "ddc-core",
          "signature": "WJoin a !(Witness a n) !(Witness a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Joining of witnesses",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WJoin",
          "package": "ddc-core",
          "partial": "WJoin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType can appear as the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "WType",
          "package": "ddc-core",
          "signature": "WType a !(Type n)",
          "source": "src/DDC-Core-Exp-Annot.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Type can appear as the argument of an application",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WType",
          "package": "ddc-core",
          "partial": "WType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness variable.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "WVar",
          "package": "ddc-core",
          "signature": "WVar a !(Bound n)",
          "source": "src/DDC-Core-Exp-Annot.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Witness variable",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WVar",
          "package": "ddc-core",
          "partial": "WVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a capability guaranteeing the constancy of a region, into\n   a witness that allocation into that region is pure.\n   This lets us increase the sharing of constant objects,\n   because we can't tell constant objects of the same value apart.\n\u003c/p\u003e\u003cpre\u003ealloc    :: [r : %]. Const r  =\u003e Pure (Alloc r)\u003c/pre\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "WbConAlloc",
          "package": "ddc-core",
          "signature": "WbConAlloc",
          "source": "src/DDC-Core-Exp-WiCon.html#WbCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConAlloc\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WbConAlloc\"]"
        },
        "index": {
          "description": "Convert capability guaranteeing the constancy of region into witness that allocation into that region is pure This lets us increase the sharing of constant objects because we can tell constant objects of the same value apart alloc Const Pure Alloc",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WbConAlloc",
          "package": "ddc-core",
          "partial": "Wb Con Alloc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConAlloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(axiom) The empty closure is empty.\n\u003c/p\u003e\u003cpre\u003eempty    :: Empty $0\u003c/pre\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "WbConEmpty",
          "package": "ddc-core",
          "signature": "WbConEmpty",
          "source": "src/DDC-Core-Exp-WiCon.html#WbCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConEmpty\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WbConEmpty\"]"
        },
        "index": {
          "description": "axiom The empty closure is empty empty Empty",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WbConEmpty",
          "package": "ddc-core",
          "partial": "Wb Con Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(axiom) The pure effect is pure.\n\u003c/p\u003e\u003cpre\u003epure     :: Pure !0\u003c/pre\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "WbConPure",
          "package": "ddc-core",
          "signature": "WbConPure",
          "source": "src/DDC-Core-Exp-WiCon.html#WbCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConPure\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WbConPure\"]"
        },
        "index": {
          "description": "axiom The pure effect is pure pure Pure",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WbConPure",
          "package": "ddc-core",
          "partial": "Wb Con Pure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a capability guaranteeing the constancy of a region, into\n   a witness that a read from that region is pure.\n   This lets us suspend applications that read constant objects,\n   because it doesn't matter if the read is delayed, we'll always\n   get the same result.\n\u003c/p\u003e\u003cpre\u003eread     :: [r : %]. Const r  =\u003e Pure (Read r)\u003c/pre\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "WbConRead",
          "package": "ddc-core",
          "signature": "WbConRead",
          "source": "src/DDC-Core-Exp-WiCon.html#WbCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConRead\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WbConRead\"]"
        },
        "index": {
          "description": "Convert capability guaranteeing the constancy of region into witness that read from that region is pure This lets us suspend applications that read constant objects because it doesn matter if the read is delayed we ll always get the same result read Const Pure Read",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WbConRead",
          "package": "ddc-core",
          "partial": "Wb Con Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a capability guaranteeing that a region is in the global\n   heap, into a witness that a closure using this region is empty.\n   This lets us rely on the garbage collector to reclaim objects\n   in the region. It is needed when we suspend the evaluation of \n   expressions that have a region in their closure, because the\n   type of the returned thunk may not reveal that it references\n   objects in that region.\n\u003c/p\u003e\u003cpre\u003euse      :: [r : %]. Global r =\u003e Empty (Use r)\u003c/pre\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "WbConUse",
          "package": "ddc-core",
          "signature": "WbConUse",
          "source": "src/DDC-Core-Exp-WiCon.html#WbCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConUse\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WbConUse\"]"
        },
        "index": {
          "description": "Convert capability guaranteeing that region is in the global heap into witness that closure using this region is empty This lets us rely on the garbage collector to reclaim objects in the region It is needed when we suspend the evaluation of expressions that have region in their closure because the type of the returned thunk may not reveal that it references objects in that region use Global Empty Use",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WbConUse",
          "package": "ddc-core",
          "partial": "Wb Con Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WbConUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness constructors defined in the environment.\n   In the interpreter we use this to hold runtime capabilities.\n   The attached type must be closed.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "WiConBound",
          "package": "ddc-core",
          "signature": "WiConBound !(Bound n) !(Type n)",
          "source": "src/DDC-Core-Exp-WiCon.html#WiCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WiConBound\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WiConBound\"]"
        },
        "index": {
          "description": "Witness constructors defined in the environment In the interpreter we use this to hold runtime capabilities The attached type must be closed",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WiConBound",
          "package": "ddc-core",
          "partial": "Wi Con Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WiConBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness constructors baked into the language.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "WiConBuiltin",
          "package": "ddc-core",
          "signature": "WiConBuiltin !WbCon",
          "source": "src/DDC-Core-Exp-WiCon.html#WiCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WiConBuiltin\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WiConBuiltin\"]"
        },
        "index": {
          "description": "Witness constructors baked into the language",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "WiConBuiltin",
          "package": "ddc-core",
          "partial": "Wi Con Builtin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:WiConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XApp",
          "package": "ddc-core",
          "signature": "XApp !a !(Exp a n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Application",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XApp",
          "package": "ddc-core",
          "partial": "XApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCase branching.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XCase",
          "package": "ddc-core",
          "signature": "XCase !a !(Exp a n) ![Alt a n]",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Case branching",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XCase",
          "normalized": "XCase a(Exp a b)[Alt a b]",
          "package": "ddc-core",
          "partial": "XCase",
          "signature": "XCase a(Exp a n)[Alt a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType cast.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XCast",
          "package": "ddc-core",
          "signature": "XCast !a !(Cast a n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type cast",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XCast",
          "package": "ddc-core",
          "partial": "XCast",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructor or literal.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XCon",
          "package": "ddc-core",
          "signature": "XCon !a !(DaCon n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Data constructor or literal",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XCon",
          "package": "ddc-core",
          "partial": "XCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType abstraction (level-1).\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XLAM",
          "package": "ddc-core",
          "signature": "XLAM !a !(Bind n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type abstraction level-1",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XLAM",
          "package": "ddc-core",
          "partial": "XLAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XLAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue and Witness abstraction (level-0).\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XLam",
          "package": "ddc-core",
          "signature": "XLam !a !(Bind n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Value and Witness abstraction level-0",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XLam",
          "package": "ddc-core",
          "partial": "XLam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XLam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly recursive bindings.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XLet",
          "package": "ddc-core",
          "signature": "XLet !a !(Lets a n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Possibly recursive bindings",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XLet",
          "package": "ddc-core",
          "partial": "XLet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType can appear as the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XType",
          "package": "ddc-core",
          "signature": "XType !(Type n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type can appear as the argument of an application",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XType",
          "package": "ddc-core",
          "partial": "XType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue variable   or primitive operation.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XVar",
          "package": "ddc-core",
          "signature": "XVar !a !(Bound n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Value variable or primitive operation",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XVar",
          "package": "ddc-core",
          "partial": "XVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness can appear as the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Annot",
          "name": "XWitness",
          "package": "ddc-core",
          "signature": "XWitness !(Witness a n)",
          "source": "src/DDC-Core-Exp-Annot.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Witness can appear as the argument of an application",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "XWitness",
          "package": "ddc-core",
          "partial": "XWitness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:XWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlgebraic constructors can be deconstructed with case-expressions,\n   and must have a data type declaration.\n\u003c/p\u003e\u003cp\u003eNon-algebraic types like \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e can't be inspected with\n   case-expressions.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "daConIsAlgebraic",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Exp-DaCon.html#DaCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:daConIsAlgebraic\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:daConIsAlgebraic\"]"
        },
        "index": {
          "description": "Algebraic constructors can be deconstructed with case-expressions and must have data type declaration Non-algebraic types like Float can be inspected with case-expressions",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "daConIsAlgebraic",
          "package": "ddc-core",
          "partial": "Con Is Algebraic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:daConIsAlgebraic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of the data constructor.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "daConName",
          "package": "ddc-core",
          "signature": "(DaConName n)",
          "source": "src/DDC-Core-Exp-DaCon.html#DaCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:daConName\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:daConName\"]"
        },
        "index": {
          "description": "Name of the data constructor",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "daConName",
          "package": "ddc-core",
          "partial": "Con Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:daConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of the data constructor.\n   The type must be closed.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Exp.Annot\",\"DDC.Core.Exp.Simple\"]",
          "name": "daConType",
          "package": "ddc-core",
          "signature": "(Type n)",
          "source": "src/DDC-Core-Exp-DaCon.html#DaCon",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:daConType\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:daConType\"]"
        },
        "index": {
          "description": "Type of the data constructor The type must be closed",
          "hierarchy": "DDC Core Exp Annot",
          "module": "DDC.Core.Exp.Annot",
          "name": "daConType",
          "package": "ddc-core",
          "partial": "Con Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Annot.html#v:daConType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCore language AST with a separate node to hold annotations.\n\u003c/p\u003e\u003cp\u003eThis version of the AST is used when generating code where most or all\n   of the annotations would be empty. General purpose transformations should\n   deal with the fully annotated version of the AST instead.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "Simple",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Simple.html",
          "type": "module"
        },
        "index": {
          "description": "Core language AST with separate node to hold annotations This version of the AST is used when generating code where most or all of the annotations would be empty General purpose transformations should deal with the fully annotated version of the AST instead",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "Simple",
          "package": "ddc-core",
          "partial": "Simple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCase alternatives.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "Alt",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Simple.html#Alt",
          "type": "data"
        },
        "index": {
          "description": "Case alternatives",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "Alt",
          "package": "ddc-core",
          "partial": "Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:Alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType casts.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "Cast",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Simple.html#Cast",
          "type": "data"
        },
        "index": {
          "description": "Type casts",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "Cast",
          "package": "ddc-core",
          "partial": "Cast",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:Cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructors.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "DaCon",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-DaCon.html#DaCon",
          "type": "data"
        },
        "index": {
          "description": "Data constructors",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "DaCon",
          "package": "ddc-core",
          "partial": "Da Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:DaCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructor names.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "DaConName",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-DaCon.html#DaConName",
          "type": "data"
        },
        "index": {
          "description": "Data constructor names",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "DaConName",
          "package": "ddc-core",
          "partial": "Da Con Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:DaConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWell-typed expressions have types of kind \u003ccode\u003eData\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "Exp",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "data"
        },
        "index": {
          "description": "Well-typed expressions have types of kind Data",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "Exp",
          "package": "ddc-core",
          "partial": "Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:Exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly recursive bindings.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "Lets",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Simple.html#Lets",
          "type": "data"
        },
        "index": {
          "description": "Possibly recursive bindings",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "Lets",
          "package": "ddc-core",
          "partial": "Lets",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:Lets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePattern matching.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "Pat",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Pat.html#Pat",
          "type": "data"
        },
        "index": {
          "description": "Pattern matching",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "Pat",
          "package": "ddc-core",
          "partial": "Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:Pat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuilt-in witness constructors.\n\u003c/p\u003e\u003cp\u003eThese are used to convert a runtime capability into a witness that\n   the corresponding property is true.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "WbCon",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-WiCon.html#WbCon",
          "type": "data"
        },
        "index": {
          "description": "Built-in witness constructors These are used to convert runtime capability into witness that the corresponding property is true",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WbCon",
          "package": "ddc-core",
          "partial": "Wb Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:WbCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness constructors.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "WiCon",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-WiCon.html#WiCon",
          "type": "data"
        },
        "index": {
          "description": "Witness constructors",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WiCon",
          "package": "ddc-core",
          "partial": "Wi Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:WiCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen a witness exists in the program it guarantees that a\n   certain property of the program is true.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "Witness",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp-Simple.html#Witness",
          "type": "data"
        },
        "index": {
          "description": "When witness exists in the program it guarantees that certain property of the program is true",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "Witness",
          "package": "ddc-core",
          "partial": "Witness",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#t:Witness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Exp.Simple",
          "name": "AAlt",
          "package": "ddc-core",
          "signature": "AAlt !(Pat n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Alt",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "AAlt",
          "package": "ddc-core",
          "partial": "AAlt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:AAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForget about the closure (sharing) of an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastForget",
          "package": "ddc-core",
          "signature": "CastForget !(Witness a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Forget about the closure sharing of an expression",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastForget",
          "package": "ddc-core",
          "partial": "Cast Forget",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:CastForget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePurify the effect (action) of an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastPurify",
          "package": "ddc-core",
          "signature": "CastPurify !(Witness a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Purify the effect action of an expression",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastPurify",
          "package": "ddc-core",
          "partial": "Cast Purify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:CastPurify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a computation,\n   releasing its effects into the environment.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastRun",
          "package": "ddc-core",
          "signature": "CastRun",
          "source": "src/DDC-Core-Exp-Simple.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Run computation releasing its effects into the environment",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastRun",
          "package": "ddc-core",
          "partial": "Cast Run",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:CastRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuspend a computation, \n   capturing its effects in the S computation type.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastSuspend",
          "package": "ddc-core",
          "signature": "CastSuspend",
          "source": "src/DDC-Core-Exp-Simple.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Suspend computation capturing its effects in the computation type",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastSuspend",
          "package": "ddc-core",
          "partial": "Cast Suspend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:CastSuspend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeaken the closure of an expression.\n   The closures of these expressions are added to the closure\n   of the body.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastWeakenClosure",
          "package": "ddc-core",
          "signature": "CastWeakenClosure ![Exp a n]",
          "source": "src/DDC-Core-Exp-Simple.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Weaken the closure of an expression The closures of these expressions are added to the closure of the body",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastWeakenClosure",
          "normalized": "CastWeakenClosure[Exp a b]",
          "package": "ddc-core",
          "partial": "Cast Weaken Closure",
          "signature": "CastWeakenClosure[Exp a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:CastWeakenClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeaken the effect of an expression.\n   The given effect is added to the effect\n   of the body.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastWeakenEffect",
          "package": "ddc-core",
          "signature": "CastWeakenEffect !(Effect n)",
          "source": "src/DDC-Core-Exp-Simple.html#Cast",
          "type": "function"
        },
        "index": {
          "description": "Weaken the effect of an expression The given effect is added to the effect of the body",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "CastWeakenEffect",
          "package": "ddc-core",
          "partial": "Cast Weaken Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:CastWeakenEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-recursive expression binding.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "LLet",
          "package": "ddc-core",
          "signature": "LLet !(Bind n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Non-recursive expression binding",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "LLet",
          "package": "ddc-core",
          "partial": "LLet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:LLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBind a local region variable,\n   and witnesses to its properties.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "LLetRegions",
          "package": "ddc-core",
          "signature": "LLetRegions ![Bind n] ![Bind n]",
          "source": "src/DDC-Core-Exp-Simple.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Bind local region variable and witnesses to its properties",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "LLetRegions",
          "normalized": "LLetRegions[Bind a][Bind a]",
          "package": "ddc-core",
          "partial": "LLet Regions",
          "signature": "LLetRegions[Bind n][Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:LLetRegions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecursive binding of lambda abstractions.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "LRec",
          "package": "ddc-core",
          "signature": "LRec ![(Bind n, Exp a n)]",
          "source": "src/DDC-Core-Exp-Simple.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Recursive binding of lambda abstractions",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "LRec",
          "normalized": "LRec[(Bind a,Exp b a)]",
          "package": "ddc-core",
          "partial": "LRec",
          "signature": "LRec[(Bind n,Exp a n)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:LRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHolds a region handle during evaluation.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "LWithRegion",
          "package": "ddc-core",
          "signature": "LWithRegion !(Bound n)",
          "source": "src/DDC-Core-Exp-Simple.html#Lets",
          "type": "function"
        },
        "index": {
          "description": "Holds region handle during evaluation",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "LWithRegion",
          "package": "ddc-core",
          "partial": "LWith Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:LWithRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Exp.Simple",
          "name": "WAnnot",
          "package": "ddc-core",
          "signature": "WAnnot a (Witness a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Witness",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WAnnot",
          "package": "ddc-core",
          "partial": "WAnnot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WAnnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "WApp",
          "package": "ddc-core",
          "signature": "WApp !(Witness a n) !(Witness a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Witness application",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WApp",
          "package": "ddc-core",
          "partial": "WApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "WCon",
          "package": "ddc-core",
          "signature": "WCon !(WiCon n)",
          "source": "src/DDC-Core-Exp-Simple.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Witness constructor",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WCon",
          "package": "ddc-core",
          "partial": "WCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoining of witnesses.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "WJoin",
          "package": "ddc-core",
          "signature": "WJoin !(Witness a n) !(Witness a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Joining of witnesses",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WJoin",
          "package": "ddc-core",
          "partial": "WJoin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WJoin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType can appear as the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "WType",
          "package": "ddc-core",
          "signature": "WType !(Type n)",
          "source": "src/DDC-Core-Exp-Simple.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Type can appear as the argument of an application",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WType",
          "package": "ddc-core",
          "partial": "WType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness variable.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "WVar",
          "package": "ddc-core",
          "signature": "WVar !(Bound n)",
          "source": "src/DDC-Core-Exp-Simple.html#Witness",
          "type": "function"
        },
        "index": {
          "description": "Witness variable",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "WVar",
          "package": "ddc-core",
          "partial": "WVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:WVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnnotation.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XAnnot",
          "package": "ddc-core",
          "signature": "XAnnot a (Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Annotation",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XAnnot",
          "package": "ddc-core",
          "partial": "XAnnot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XAnnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XApp",
          "package": "ddc-core",
          "signature": "XApp !(Exp a n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Application",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XApp",
          "package": "ddc-core",
          "partial": "XApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCase branching.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XCase",
          "package": "ddc-core",
          "signature": "XCase !(Exp a n) ![Alt a n]",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Case branching",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XCase",
          "normalized": "XCase(Exp a b)[Alt a b]",
          "package": "ddc-core",
          "partial": "XCase",
          "signature": "XCase(Exp a n)[Alt a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType cast.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XCast",
          "package": "ddc-core",
          "signature": "XCast !(Cast a n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type cast",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XCast",
          "package": "ddc-core",
          "partial": "XCast",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XCast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructor or literal.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XCon",
          "package": "ddc-core",
          "signature": "XCon !(DaCon n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Data constructor or literal",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XCon",
          "package": "ddc-core",
          "partial": "XCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType abstraction (level-1).\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XLAM",
          "package": "ddc-core",
          "signature": "XLAM !(Bind n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type abstraction level-1",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XLAM",
          "package": "ddc-core",
          "partial": "XLAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XLAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue and Witness abstraction (level-0).\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XLam",
          "package": "ddc-core",
          "signature": "XLam !(Bind n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Value and Witness abstraction level-0",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XLam",
          "package": "ddc-core",
          "partial": "XLam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XLam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly recursive bindings.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XLet",
          "package": "ddc-core",
          "signature": "XLet !(Lets a n) !(Exp a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Possibly recursive bindings",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XLet",
          "package": "ddc-core",
          "partial": "XLet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType can appear as the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XType",
          "package": "ddc-core",
          "signature": "XType !(Type n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type can appear as the argument of an application",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XType",
          "package": "ddc-core",
          "partial": "XType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValue variable   or primitive operation.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XVar",
          "package": "ddc-core",
          "signature": "XVar !(Bound n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Value variable or primitive operation",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XVar",
          "package": "ddc-core",
          "partial": "XVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness can appear as the argument of an application.\n\u003c/p\u003e",
          "module": "DDC.Core.Exp.Simple",
          "name": "XWitness",
          "package": "ddc-core",
          "signature": "XWitness !(Witness a n)",
          "source": "src/DDC-Core-Exp-Simple.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Witness can appear as the argument of an application",
          "hierarchy": "DDC Core Exp Simple",
          "module": "DDC.Core.Exp.Simple",
          "name": "XWitness",
          "package": "ddc-core",
          "partial": "XWitness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp-Simple.html#v:XWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAbstract syntax for the Disciple core language.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Exp",
          "name": "Exp",
          "package": "ddc-core",
          "source": "src/DDC-Core-Exp.html",
          "type": "module"
        },
        "index": {
          "description": "Abstract syntax for the Disciple core language",
          "hierarchy": "DDC Core Exp",
          "module": "DDC.Core.Exp",
          "name": "Exp",
          "package": "ddc-core",
          "partial": "Exp",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Exp.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe ambient Disciple Core language is specialised to concrete languages\n   by adding primitive operations and optionally restricting the set of \n   available language features. This specialisation results in user-facing\n   language fragments such as \u003ccode\u003eDisciple Core Lite\u003c/code\u003e and \u003ccode\u003eDisciple Core Salt\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Fragment",
          "name": "Fragment",
          "package": "ddc-core",
          "source": "src/DDC-Core-Fragment.html",
          "type": "module"
        },
        "index": {
          "description": "The ambient Disciple Core language is specialised to concrete languages by adding primitive operations and optionally restricting the set of available language features This specialisation results in user-facing language fragments such as Disciple Core Lite and Disciple Core Salt",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Fragment",
          "package": "ddc-core",
          "partial": "Fragment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of things we can check language fragment compliance for.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "Complies",
          "package": "ddc-core",
          "source": "src/DDC-Core-Fragment-Compliance.html#Complies",
          "type": "class"
        },
        "index": {
          "description": "Class of things we can check language fragment compliance for",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Complies",
          "package": "ddc-core",
          "partial": "Complies",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#t:Complies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLanguage fragment compliance violations.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "Error",
          "package": "ddc-core",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "data"
        },
        "index": {
          "description": "Language fragment compliance violations",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Error",
          "package": "ddc-core",
          "partial": "Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#t:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLanguage feature supported by a fragment.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "Feature",
          "package": "ddc-core",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "data"
        },
        "index": {
          "description": "Language feature supported by fragment",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Feature",
          "package": "ddc-core",
          "partial": "Feature",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#t:Feature"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA flattened set of features, for easy lookup.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "Features",
          "package": "ddc-core",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "data"
        },
        "index": {
          "description": "flattened set of features for easy lookup",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Features",
          "package": "ddc-core",
          "partial": "Features",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#t:Features"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCarries all the information we need to work on a particular \n   fragment of the Disciple Core language.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "Fragment",
          "package": "ddc-core",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "data"
        },
        "index": {
          "description": "Carries all the information we need to work on particular fragment of the Disciple Core language",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Fragment",
          "package": "ddc-core",
          "partial": "Fragment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#t:Fragment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fragment profile describes the language features and \n   primitive operators available in the language.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "Profile",
          "package": "ddc-core",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "data"
        },
        "index": {
          "description": "The fragment profile describes the language features and primitive operators available in the language",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Profile",
          "package": "ddc-core",
          "partial": "Profile",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#t:Profile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDebruijn binders.\n   Most backends will want to use real names, instead of indexed\n   binders.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "DebruijnBinders",
          "package": "ddc-core",
          "signature": "DebruijnBinders",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Debruijn binders Most backends will want to use real names instead of indexed binders",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "DebruijnBinders",
          "package": "ddc-core",
          "partial": "Debruijn Binders",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:DebruijnBinders"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a naked type that isn't used as a function argument.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "ErrorNakedType",
          "package": "ddc-core",
          "signature": "ErrorNakedType !(Type n)",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found naked type that isn used as function argument",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "ErrorNakedType",
          "package": "ddc-core",
          "partial": "Error Naked Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:ErrorNakedType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a naked witness that isn't used as a function argument.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "ErrorNakedWitness",
          "package": "ddc-core",
          "signature": "ErrorNakedWitness !(Witness a n)",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found naked witness that isn used as function argument",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "ErrorNakedWitness",
          "package": "ddc-core",
          "partial": "Error Naked Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:ErrorNakedWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a variable binder that shadows another one at a higher scope,\n   but the profile doesn't permit this.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "ErrorShadowedBind",
          "package": "ddc-core",
          "signature": "ErrorShadowedBind !n",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found variable binder that shadows another one at higher scope but the profile doesn permit this",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "ErrorShadowedBind",
          "package": "ddc-core",
          "partial": "Error Shadowed Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:ErrorShadowedBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound an undefined primitive operator.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUndefinedPrim",
          "package": "ddc-core",
          "signature": "ErrorUndefinedPrim !n",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found an undefined primitive operator",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUndefinedPrim",
          "package": "ddc-core",
          "partial": "Error Undefined Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:ErrorUndefinedPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound an unbound variable.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUndefinedVar",
          "package": "ddc-core",
          "signature": "ErrorUndefinedVar !n",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found an unbound variable",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUndefinedVar",
          "package": "ddc-core",
          "partial": "Error Undefined Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:ErrorUndefinedVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound an unsupported language feature.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUnsupported",
          "package": "ddc-core",
          "signature": "ErrorUnsupported !Feature",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found an unsupported language feature",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUnsupported",
          "package": "ddc-core",
          "partial": "Error Unsupported",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:ErrorUnsupported"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a bound variable with no uses,\n   but the profile doesn't permit this.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUnusedBind",
          "package": "ddc-core",
          "signature": "ErrorUnusedBind !n",
          "source": "src/DDC-Core-Fragment-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found bound variable with no uses but the profile doesn permit this",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "ErrorUnusedBind",
          "package": "ddc-core",
          "partial": "Error Unused Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:ErrorUnusedBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "Features",
          "package": "ddc-core",
          "signature": "Features",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Features",
          "package": "ddc-core",
          "partial": "Features",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:Features"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "Fragment",
          "package": "ddc-core",
          "signature": "Fragment",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Fragment",
          "package": "ddc-core",
          "partial": "Fragment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:Fragment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach latent closures to function types.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "FunctionalClosures",
          "package": "ddc-core",
          "signature": "FunctionalClosures",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Attach latent closures to function types",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "FunctionalClosures",
          "package": "ddc-core",
          "partial": "Functional Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:FunctionalClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach latent effects to function types.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "FunctionalEffects",
          "package": "ddc-core",
          "signature": "FunctionalEffects",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Attach latent effects to function types",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "FunctionalEffects",
          "package": "ddc-core",
          "partial": "Functional Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:FunctionalEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction application where the thing being applied\n   is not a variable.\n   Most backend languages (like LLVM) don't support this.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "GeneralApplication",
          "package": "ddc-core",
          "signature": "GeneralApplication",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Function application where the thing being applied is not variable Most backend languages like LLVM don support this",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "GeneralApplication",
          "package": "ddc-core",
          "partial": "General Application",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:GeneralApplication"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow name shadowing.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "NameShadowing",
          "package": "ddc-core",
          "signature": "NameShadowing",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Allow name shadowing",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "NameShadowing",
          "package": "ddc-core",
          "partial": "Name Shadowing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:NameShadowing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNested function bindings.\n   The output of the lambda-lifter should not contain these.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "NestedFunctions",
          "package": "ddc-core",
          "signature": "NestedFunctions",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Nested function bindings The output of the lambda-lifter should not contain these",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "NestedFunctions",
          "package": "ddc-core",
          "partial": "Nested Functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:NestedFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartially applied functions\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "PartialApplication",
          "package": "ddc-core",
          "signature": "PartialApplication",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Partially applied functions",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "PartialApplication",
          "package": "ddc-core",
          "partial": "Partial Application",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:PartialApplication"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartially applied primitive operators.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "PartialPrims",
          "package": "ddc-core",
          "signature": "PartialPrims",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Partially applied primitive operators",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "PartialPrims",
          "package": "ddc-core",
          "partial": "Partial Prims",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:PartialPrims"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "Profile",
          "package": "ddc-core",
          "signature": "Profile",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "Profile",
          "package": "ddc-core",
          "partial": "Profile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:Profile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrack closure type information.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "TrackedClosures",
          "package": "ddc-core",
          "signature": "TrackedClosures",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Track closure type information",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "TrackedClosures",
          "package": "ddc-core",
          "partial": "Tracked Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:TrackedClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrack effect type information.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "TrackedEffects",
          "package": "ddc-core",
          "signature": "TrackedEffects",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Track effect type information",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "TrackedEffects",
          "package": "ddc-core",
          "partial": "Tracked Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:TrackedEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow data and witness vars without binding occurrences if\n   they are annotated directly with their types. This lets\n   us work with open terms.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "UnboundLevel0Vars",
          "package": "ddc-core",
          "signature": "UnboundLevel0Vars",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Allow data and witness vars without binding occurrences if they are annotated directly with their types This lets us work with open terms",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "UnboundLevel0Vars",
          "package": "ddc-core",
          "partial": "Unbound Level Vars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:UnboundLevel0Vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow non-primitive functions to be instantiated at unboxed types.\n   Our existing backends can't handle this, because boxed and unboxed\n   objects have different representations.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "UnboxedInstantiation",
          "package": "ddc-core",
          "signature": "UnboxedInstantiation",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Allow non-primitive functions to be instantiated at unboxed types Our existing backends can handle this because boxed and unboxed objects have different representations",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "UnboxedInstantiation",
          "package": "ddc-core",
          "partial": "Unboxed Instantiation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:UnboxedInstantiation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow unused named data and witness bindings.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "UnusedBindings",
          "package": "ddc-core",
          "signature": "UnusedBindings",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Allow unused named data and witness bindings",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "UnusedBindings",
          "package": "ddc-core",
          "partial": "Unused Bindings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:UnusedBindings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow unused named matches.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "UnusedMatches",
          "package": "ddc-core",
          "signature": "UnusedMatches",
          "source": "src/DDC-Core-Fragment-Feature.html#Feature",
          "type": "function"
        },
        "index": {
          "description": "Allow unused named matches",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "UnusedMatches",
          "package": "ddc-core",
          "partial": "Unused Matches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:UnusedMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a core thing complies with a language fragment profile.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "complies",
          "package": "ddc-core",
          "signature": "Profile n-\u003e c a n-\u003e Maybe (Error a n)",
          "type": "function"
        },
        "index": {
          "description": "Check whether core thing complies with language fragment profile",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "complies",
          "normalized": "Profile a-\u003eb c a-\u003eMaybe(Error c a)",
          "package": "ddc-core",
          "signature": "Profile n-\u003ec a n-\u003eMaybe(Error a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:complies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ecomplies\u003c/a\u003e\u003c/code\u003e but with some starting environments.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "compliesWithEnvs",
          "package": "ddc-core",
          "signature": "Profile n-\u003e KindEnv n-\u003e TypeEnv n-\u003e c a n-\u003e Maybe (Error a n)",
          "type": "function"
        },
        "index": {
          "description": "Like complies but with some starting environments",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "compliesWithEnvs",
          "normalized": "Profile a-\u003eKindEnv a-\u003eTypeEnv a-\u003eb c a-\u003eMaybe(Error c a)",
          "package": "ddc-core",
          "partial": "With Envs",
          "signature": "Profile n-\u003eKindEnv n-\u003eTypeEnv n-\u003ec a n-\u003eMaybe(Error a n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:compliesWithEnvs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresDebruijnBinders",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresDebruijnBinders",
          "package": "ddc-core",
          "partial": "Debruijn Binders",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresDebruijnBinders"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresFunctionalClosures",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresFunctionalClosures",
          "package": "ddc-core",
          "partial": "Functional Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresFunctionalClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresFunctionalEffects",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresFunctionalEffects",
          "package": "ddc-core",
          "partial": "Functional Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresFunctionalEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresGeneralApplication",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresGeneralApplication",
          "package": "ddc-core",
          "partial": "General Application",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresGeneralApplication"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresNameShadowing",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresNameShadowing",
          "package": "ddc-core",
          "partial": "Name Shadowing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresNameShadowing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresNestedFunctions",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresNestedFunctions",
          "package": "ddc-core",
          "partial": "Nested Functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresNestedFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresPartialApplication",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresPartialApplication",
          "package": "ddc-core",
          "partial": "Partial Application",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresPartialApplication"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresPartialPrims",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresPartialPrims",
          "package": "ddc-core",
          "partial": "Partial Prims",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresPartialPrims"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresTrackedClosures",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresTrackedClosures",
          "package": "ddc-core",
          "partial": "Tracked Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresTrackedClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresTrackedEffects",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresTrackedEffects",
          "package": "ddc-core",
          "partial": "Tracked Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresTrackedEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresUnboundLevel0Vars",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresUnboundLevel0Vars",
          "package": "ddc-core",
          "partial": "Unbound Level Vars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresUnboundLevel0Vars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresUnboxedInstantiation",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresUnboxedInstantiation",
          "package": "ddc-core",
          "partial": "Unboxed Instantiation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresUnboxedInstantiation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresUnusedBindings",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresUnusedBindings",
          "package": "ddc-core",
          "partial": "Unused Bindings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresUnusedBindings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Fragment",
          "name": "featuresUnusedMatches",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Fragment-Profile.html#Features",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "featuresUnusedMatches",
          "package": "ddc-core",
          "partial": "Unused Matches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:featuresUnusedMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform language fragment specific checks on an expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "fragmentCheckExp",
          "package": "ddc-core",
          "signature": "forall a.  Exp a n -\u003e Maybe (err a)",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "description": "Perform language fragment specific checks on an expression",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "fragmentCheckExp",
          "normalized": "a b Exp c d-\u003eMaybe(e c)",
          "package": "ddc-core",
          "partial": "Check Exp",
          "signature": "forall a. Exp a n-\u003eMaybe(err a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:fragmentCheckExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform language fragment specific checks on a module.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "fragmentCheckModule",
          "package": "ddc-core",
          "signature": "forall a.  Module a n -\u003e Maybe (err a)",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "description": "Perform language fragment specific checks on module",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "fragmentCheckModule",
          "normalized": "a b Module c d-\u003eMaybe(e c)",
          "package": "ddc-core",
          "partial": "Check Module",
          "signature": "forall a. Module a n-\u003eMaybe(err a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:fragmentCheckModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFile extension to use when dumping modules in this fragment.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "fragmentExtension",
          "package": "ddc-core",
          "signature": "String",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "description": "File extension to use when dumping modules in this fragment",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "fragmentExtension",
          "package": "ddc-core",
          "partial": "Extension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:fragmentExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLex expression source into tokens,\n   given the source name and starting line number.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "fragmentLexExp",
          "package": "ddc-core",
          "signature": "String -\u003e Int -\u003e String -\u003e [Token (Tok n)]",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "description": "Lex expression source into tokens given the source name and starting line number",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "fragmentLexExp",
          "normalized": "String-\u003eInt-\u003eString-\u003e[Token(Tok a)]",
          "package": "ddc-core",
          "partial": "Lex Exp",
          "signature": "String-\u003eInt-\u003eString-\u003e[Token(Tok n)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:fragmentLexExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLex module source into tokens,\n   given the source name and starting line number. \n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "fragmentLexModule",
          "package": "ddc-core",
          "signature": "String -\u003e Int -\u003e String -\u003e [Token (Tok n)]",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "description": "Lex module source into tokens given the source name and starting line number",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "fragmentLexModule",
          "normalized": "String-\u003eInt-\u003eString-\u003e[Token(Tok a)]",
          "package": "ddc-core",
          "partial": "Lex Module",
          "signature": "String-\u003eInt-\u003eString-\u003e[Token(Tok n)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:fragmentLexModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLanguage profile for this fragment.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "fragmentProfile",
          "package": "ddc-core",
          "signature": "Profile n",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "description": "Language profile for this fragment",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "fragmentProfile",
          "package": "ddc-core",
          "partial": "Profile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:fragmentProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a name.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "fragmentReadName",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe n",
          "source": "src/DDC-Core-Fragment.html#Fragment",
          "type": "function"
        },
        "index": {
          "description": "Read name",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "fragmentReadName",
          "normalized": "String-\u003eMaybe a",
          "package": "ddc-core",
          "partial": "Read Name",
          "signature": "String-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:fragmentReadName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePermitted language features.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "profileFeatures",
          "package": "ddc-core",
          "signature": "Features",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "description": "Permitted language features",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "profileFeatures",
          "package": "ddc-core",
          "partial": "Features",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:profileFeatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of this profile.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "profileName",
          "package": "ddc-core",
          "signature": "String",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "description": "The name of this profile",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "profileName",
          "package": "ddc-core",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:profileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitive data type declarations.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimDataDefs",
          "package": "ddc-core",
          "signature": "(DataDefs n)",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "description": "Primitive data type declarations",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimDataDefs",
          "package": "ddc-core",
          "partial": "Prim Data Defs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:profilePrimDataDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKinds of primitive types.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimKinds",
          "package": "ddc-core",
          "signature": "(KindEnv n)",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "description": "Kinds of primitive types",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimKinds",
          "package": "ddc-core",
          "partial": "Prim Kinds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:profilePrimKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupers of primitive kinds.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimSupers",
          "package": "ddc-core",
          "signature": "(SuperEnv n)",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "description": "Supers of primitive kinds",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimSupers",
          "package": "ddc-core",
          "partial": "Prim Supers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:profilePrimSupers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of primitive operators.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimTypes",
          "package": "ddc-core",
          "signature": "(TypeEnv n)",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "description": "Types of primitive operators",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "profilePrimTypes",
          "package": "ddc-core",
          "partial": "Prim Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:profilePrimTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a type is an unboxed type.\n   Some fragments limit how these can be used.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "profileTypeIsUnboxed",
          "package": "ddc-core",
          "signature": "(Type n -\u003e Bool)",
          "source": "src/DDC-Core-Fragment-Profile.html#Profile",
          "type": "function"
        },
        "index": {
          "description": "Check whether type is an unboxed type Some fragments limit how these can be used",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "profileTypeIsUnboxed",
          "normalized": "(Type a-\u003eBool)",
          "package": "ddc-core",
          "partial": "Type Is Unboxed",
          "signature": "(Type n-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:profileTypeIsUnboxed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn emtpy feature set, with all flags set to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "zeroFeatures",
          "package": "ddc-core",
          "signature": "Features",
          "source": "src/DDC-Core-Fragment-Profile.html#zeroFeatures",
          "type": "function"
        },
        "index": {
          "description": "An emtpy feature set with all flags set to False",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "zeroFeatures",
          "package": "ddc-core",
          "partial": "Features",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:zeroFeatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA language profile with no features or primitive operators.\n\u003c/p\u003e\u003cp\u003eThis provides a simple first-order language.\n\u003c/p\u003e",
          "module": "DDC.Core.Fragment",
          "name": "zeroProfile",
          "package": "ddc-core",
          "signature": "Profile n",
          "source": "src/DDC-Core-Fragment-Profile.html#zeroProfile",
          "type": "function"
        },
        "index": {
          "description": "language profile with no features or primitive operators This provides simple first-order language",
          "hierarchy": "DDC Core Fragment",
          "module": "DDC.Core.Fragment",
          "name": "zeroProfile",
          "package": "ddc-core",
          "partial": "Profile",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Fragment.html#v:zeroProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Names",
          "name": "Names",
          "package": "ddc-core",
          "source": "src/DDC-Core-Lexer-Names.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "Names",
          "package": "ddc-core",
          "partial": "Names",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCharater can be part of a constructor body.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isConBody",
          "package": "ddc-core",
          "signature": "Char -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isConBody",
          "type": "function"
        },
        "index": {
          "description": "Charater can be part of constructor body",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isConBody",
          "normalized": "Char-\u003eBool",
          "package": "ddc-core",
          "partial": "Con Body",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isConBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eString is a constructor name.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isConName",
          "package": "ddc-core",
          "signature": "String -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isConName",
          "type": "function"
        },
        "index": {
          "description": "String is constructor name",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isConName",
          "normalized": "String-\u003eBool",
          "package": "ddc-core",
          "partial": "Con Name",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCharacter can start a constructor name.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isConStart",
          "package": "ddc-core",
          "signature": "Char -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isConStart",
          "type": "function"
        },
        "index": {
          "description": "Character can start constructor name",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isConStart",
          "normalized": "Char-\u003eBool",
          "package": "ddc-core",
          "partial": "Con Start",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isConStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCharacter can be part of a literal body.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isLitBody",
          "package": "ddc-core",
          "signature": "Char -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isLitBody",
          "type": "function"
        },
        "index": {
          "description": "Character can be part of literal body",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isLitBody",
          "normalized": "Char-\u003eBool",
          "package": "ddc-core",
          "partial": "Lit Body",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isLitBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eString is the name of a literal.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isLitName",
          "package": "ddc-core",
          "signature": "String -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isLitName",
          "type": "function"
        },
        "index": {
          "description": "String is the name of literal",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isLitName",
          "normalized": "String-\u003eBool",
          "package": "ddc-core",
          "partial": "Lit Name",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isLitName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCharacter can start a literal.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isLitStart",
          "package": "ddc-core",
          "signature": "Char -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isLitStart",
          "type": "function"
        },
        "index": {
          "description": "Character can start literal",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isLitStart",
          "normalized": "Char-\u003eBool",
          "package": "ddc-core",
          "partial": "Lit Start",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isLitStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCharacter can be part of a variable body.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isVarBody",
          "package": "ddc-core",
          "signature": "Char -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isVarBody",
          "type": "function"
        },
        "index": {
          "description": "Character can be part of variable body",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isVarBody",
          "normalized": "Char-\u003eBool",
          "package": "ddc-core",
          "partial": "Var Body",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isVarBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eString is a variable name\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isVarName",
          "package": "ddc-core",
          "signature": "String -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isVarName",
          "type": "function"
        },
        "index": {
          "description": "String is variable name",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isVarName",
          "normalized": "String-\u003eBool",
          "package": "ddc-core",
          "partial": "Var Name",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isVarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCharater can start a variable name.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "isVarStart",
          "package": "ddc-core",
          "signature": "Char -\u003e Bool",
          "source": "src/DDC-Core-Lexer-Names.html#isVarStart",
          "type": "function"
        },
        "index": {
          "description": "Charater can start variable name",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "isVarStart",
          "normalized": "Char-\u003eBool",
          "package": "ddc-core",
          "partial": "Var Start",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:isVarStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTextual keywords in the core language.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "keywords",
          "package": "ddc-core",
          "signature": "[(String, Tok n)]",
          "source": "src/DDC-Core-Lexer-Names.html#keywords",
          "type": "function"
        },
        "index": {
          "description": "Textual keywords in the core language",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "keywords",
          "normalized": "[(String,Tok a)]",
          "package": "ddc-core",
          "signature": "[(String,Tok n)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:keywords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a named, user defined \u003ccode\u003e\u003ca\u003eTcCon\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "readCon",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe String",
          "source": "src/DDC-Core-Lexer-Names.html#readCon",
          "type": "function"
        },
        "index": {
          "description": "Read named user defined TcCon",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "readCon",
          "normalized": "String-\u003eMaybe String",
          "package": "ddc-core",
          "partial": "Con",
          "signature": "String-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:readCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a named kind constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "readKiConBuiltin",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe KiCon",
          "source": "src/DDC-Core-Lexer-Names.html#readKiConBuiltin",
          "type": "function"
        },
        "index": {
          "description": "Read named kind constructor",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "readKiConBuiltin",
          "normalized": "String-\u003eMaybe KiCon",
          "package": "ddc-core",
          "partial": "Ki Con Builtin",
          "signature": "String-\u003eMaybe KiCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:readKiConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a named sort constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "readSoConBuiltin",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe SoCon",
          "source": "src/DDC-Core-Lexer-Names.html#readSoConBuiltin",
          "type": "function"
        },
        "index": {
          "description": "Read named sort constructor",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "readSoConBuiltin",
          "normalized": "String-\u003eMaybe SoCon",
          "package": "ddc-core",
          "partial": "So Con Builtin",
          "signature": "String-\u003eMaybe SoCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:readSoConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a builtin type constructor with a non-symbolic name.\n   ie not '-\u003e'.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "readTcConBuiltin",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe TcCon",
          "source": "src/DDC-Core-Lexer-Names.html#readTcConBuiltin",
          "type": "function"
        },
        "index": {
          "description": "Read builtin type constructor with non-symbolic name ie not",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "readTcConBuiltin",
          "normalized": "String-\u003eMaybe TcCon",
          "package": "ddc-core",
          "partial": "Tc Con Builtin",
          "signature": "String-\u003eMaybe TcCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:readTcConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a named witness type constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "readTwConBuiltin",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe TwCon",
          "source": "src/DDC-Core-Lexer-Names.html#readTwConBuiltin",
          "type": "function"
        },
        "index": {
          "description": "Read named witness type constructor",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "readTwConBuiltin",
          "normalized": "String-\u003eMaybe TwCon",
          "package": "ddc-core",
          "partial": "Tw Con Builtin",
          "signature": "String-\u003eMaybe TwCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:readTwConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a named, user defined variable.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "readVar",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe String",
          "source": "src/DDC-Core-Lexer-Names.html#readVar",
          "type": "function"
        },
        "index": {
          "description": "Read named user defined variable",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "readVar",
          "normalized": "String-\u003eMaybe String",
          "package": "ddc-core",
          "partial": "Var",
          "signature": "String-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:readVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead a witness constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Names",
          "name": "readWbConBuiltin",
          "package": "ddc-core",
          "signature": "String -\u003e Maybe WbCon",
          "source": "src/DDC-Core-Lexer-Names.html#readWbConBuiltin",
          "type": "function"
        },
        "index": {
          "description": "Read witness constructor",
          "hierarchy": "DDC Core Lexer Names",
          "module": "DDC.Core.Lexer.Names",
          "name": "readWbConBuiltin",
          "normalized": "String-\u003eMaybe WbCon",
          "package": "ddc-core",
          "partial": "Wb Con Builtin",
          "signature": "String-\u003eMaybe WbCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Names.html#v:readWbConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "Tokens",
          "package": "ddc-core",
          "source": "src/DDC-Core-Lexer-Tokens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "Tokens",
          "package": "ddc-core",
          "partial": "Tokens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTokens accepted by the core language parser.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "Tok",
          "package": "ddc-core",
          "source": "src/DDC-Core-Lexer-Tokens.html#Tok",
          "type": "data"
        },
        "index": {
          "description": "Tokens accepted by the core language parser",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "Tok",
          "package": "ddc-core",
          "partial": "Tok",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#t:Tok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic tokens are keywords, punctuation and baked-in constructor names.\n   They don't contain user-defined names or primops specific to the \n   language fragment.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "TokAtom",
          "package": "ddc-core",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "data"
        },
        "index": {
          "description": "Atomic tokens are keywords punctuation and baked-in constructor names They don contain user-defined names or primops specific to the language fragment",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "TokAtom",
          "package": "ddc-core",
          "partial": "Tok Atom",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#t:TokAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMeta tokens contain out-of-band information that is \n   eliminated before parsing proper.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "TokMeta",
          "package": "ddc-core",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokMeta",
          "type": "data"
        },
        "index": {
          "description": "Meta tokens contain out-of-band information that is eliminated before parsing proper",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "TokMeta",
          "package": "ddc-core",
          "partial": "Tok Meta",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#t:TokMeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA token with a user-defined name.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "TokNamed",
          "package": "ddc-core",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokNamed",
          "type": "data"
        },
        "index": {
          "description": "token with user-defined name",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "TokNamed",
          "package": "ddc-core",
          "partial": "Tok Named",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#t:TokNamed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAtomic tokens are keywords, punctuation and baked-in \n   constructor names.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KA",
          "package": "ddc-core",
          "signature": "KA !TokAtom",
          "source": "src/DDC-Core-Lexer-Tokens.html#Tok",
          "type": "function"
        },
        "index": {
          "description": "Atomic tokens are keywords punctuation and baked-in constructor names",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KA",
          "package": "ddc-core",
          "partial": "KA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAmpersand",
          "package": "ddc-core",
          "signature": "KAmpersand",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAmpersand",
          "package": "ddc-core",
          "partial": "KAmpersand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KAmpersand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleBra",
          "package": "ddc-core",
          "signature": "KAngleBra",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleBra",
          "package": "ddc-core",
          "partial": "KAngle Bra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KAngleBra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleColonBra",
          "package": "ddc-core",
          "signature": "KAngleColonBra",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleColonBra",
          "package": "ddc-core",
          "partial": "KAngle Colon Bra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KAngleColonBra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleColonKet",
          "package": "ddc-core",
          "signature": "KAngleColonKet",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleColonKet",
          "package": "ddc-core",
          "partial": "KAngle Colon Ket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KAngleColonKet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleKet",
          "package": "ddc-core",
          "signature": "KAngleKet",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KAngleKet",
          "package": "ddc-core",
          "partial": "KAngle Ket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KAngleKet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowDash",
          "package": "ddc-core",
          "signature": "KArrowDash",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowDash",
          "package": "ddc-core",
          "partial": "KArrow Dash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KArrowDash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowDashLeft",
          "package": "ddc-core",
          "signature": "KArrowDashLeft",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowDashLeft",
          "package": "ddc-core",
          "partial": "KArrow Dash Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KArrowDashLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowEquals",
          "package": "ddc-core",
          "signature": "KArrowEquals",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowEquals",
          "package": "ddc-core",
          "partial": "KArrow Equals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KArrowEquals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowTilde",
          "package": "ddc-core",
          "signature": "KArrowTilde",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KArrowTilde",
          "package": "ddc-core",
          "partial": "KArrow Tilde",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KArrowTilde"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBackSlash",
          "package": "ddc-core",
          "signature": "KBackSlash",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBackSlash",
          "package": "ddc-core",
          "partial": "KBack Slash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KBackSlash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBar",
          "package": "ddc-core",
          "signature": "KBar",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBar",
          "package": "ddc-core",
          "partial": "KBar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBigLambda",
          "package": "ddc-core",
          "signature": "KBigLambda",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBigLambda",
          "package": "ddc-core",
          "partial": "KBig Lambda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KBigLambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBotClosure",
          "package": "ddc-core",
          "signature": "KBotClosure",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBotClosure",
          "package": "ddc-core",
          "partial": "KBot Closure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KBotClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBotEffect",
          "package": "ddc-core",
          "signature": "KBotEffect",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBotEffect",
          "package": "ddc-core",
          "partial": "KBot Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KBotEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBraceBra",
          "package": "ddc-core",
          "signature": "KBraceBra",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBraceBra",
          "package": "ddc-core",
          "partial": "KBrace Bra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KBraceBra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBraceKet",
          "package": "ddc-core",
          "signature": "KBraceKet",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KBraceKet",
          "package": "ddc-core",
          "partial": "KBrace Ket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KBraceKet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCase",
          "package": "ddc-core",
          "signature": "KCase",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCase",
          "package": "ddc-core",
          "partial": "KCase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KColon",
          "package": "ddc-core",
          "signature": "KColon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KColon",
          "package": "ddc-core",
          "partial": "KColon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KColonColon",
          "package": "ddc-core",
          "signature": "KColonColon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KColonColon",
          "package": "ddc-core",
          "partial": "KColon Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KColonColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KComma",
          "package": "ddc-core",
          "signature": "KComma",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KComma",
          "package": "ddc-core",
          "partial": "KComma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KComma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentBlockEnd",
          "package": "ddc-core",
          "signature": "KCommentBlockEnd",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokMeta",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentBlockEnd",
          "package": "ddc-core",
          "partial": "KComment Block End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KCommentBlockEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentBlockStart",
          "package": "ddc-core",
          "signature": "KCommentBlockStart",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokMeta",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentBlockStart",
          "package": "ddc-core",
          "partial": "KComment Block Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KCommentBlockStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentLineStart",
          "package": "ddc-core",
          "signature": "KCommentLineStart",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokMeta",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentLineStart",
          "package": "ddc-core",
          "partial": "KComment Line Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KCommentLineStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is injected by \u003ccode\u003edropCommentBlock\u003c/code\u003e when it finds\n   an unterminated block comment.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentUnterminated",
          "package": "ddc-core",
          "signature": "KCommentUnterminated",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokMeta",
          "type": "function"
        },
        "index": {
          "description": "This is injected by dropCommentBlock when it finds an unterminated block comment",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCommentUnterminated",
          "package": "ddc-core",
          "partial": "KComment Unterminated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KCommentUnterminated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCon",
          "package": "ddc-core",
          "signature": "KCon n",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokNamed",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KCon",
          "package": "ddc-core",
          "partial": "KCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDaConUnit",
          "package": "ddc-core",
          "signature": "KDaConUnit",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDaConUnit",
          "package": "ddc-core",
          "partial": "KDa Con Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KDaConUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDash",
          "package": "ddc-core",
          "signature": "KDash",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDash",
          "package": "ddc-core",
          "partial": "KDash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KDash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDo",
          "package": "ddc-core",
          "signature": "KDo",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDo",
          "package": "ddc-core",
          "partial": "KDo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDot",
          "package": "ddc-core",
          "signature": "KDot",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KDot",
          "package": "ddc-core",
          "partial": "KDot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KElse",
          "package": "ddc-core",
          "signature": "KElse",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KElse",
          "package": "ddc-core",
          "partial": "KElse",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KEquals",
          "package": "ddc-core",
          "signature": "KEquals",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KEquals",
          "package": "ddc-core",
          "partial": "KEquals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KEquals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KExports",
          "package": "ddc-core",
          "signature": "KExports",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KExports",
          "package": "ddc-core",
          "partial": "KExports",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KExports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KForget",
          "package": "ddc-core",
          "signature": "KForget",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KForget",
          "package": "ddc-core",
          "partial": "KForget",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KForget"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KHat",
          "package": "ddc-core",
          "signature": "KHat",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KHat",
          "package": "ddc-core",
          "partial": "KHat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KHat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KImports",
          "package": "ddc-core",
          "signature": "KImports",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KImports",
          "package": "ddc-core",
          "partial": "KImports",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KImports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KIn",
          "package": "ddc-core",
          "signature": "KIn",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KIn",
          "package": "ddc-core",
          "partial": "KIn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KIndex",
          "package": "ddc-core",
          "signature": "KIndex Int",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KIndex",
          "package": "ddc-core",
          "partial": "KIndex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSome junk symbol that isn't part of the language.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KJunk",
          "package": "ddc-core",
          "signature": "KJunk String",
          "source": "src/DDC-Core-Lexer-Tokens.html#Tok",
          "type": "function"
        },
        "index": {
          "description": "Some junk symbol that isn part of the language",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KJunk",
          "package": "ddc-core",
          "partial": "KJunk",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KJunk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KKiConBuiltin",
          "package": "ddc-core",
          "signature": "KKiConBuiltin KiCon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KKiConBuiltin",
          "package": "ddc-core",
          "partial": "KKi Con Builtin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KKiConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLazy",
          "package": "ddc-core",
          "signature": "KLazy",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLazy",
          "package": "ddc-core",
          "partial": "KLazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLet",
          "package": "ddc-core",
          "signature": "KLet",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLet",
          "package": "ddc-core",
          "partial": "KLet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLetRec",
          "package": "ddc-core",
          "signature": "KLetRec",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLetRec",
          "package": "ddc-core",
          "partial": "KLet Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KLetRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLetRegion",
          "package": "ddc-core",
          "signature": "KLetRegion",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLetRegion",
          "package": "ddc-core",
          "partial": "KLet Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KLetRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLetRegions",
          "package": "ddc-core",
          "signature": "KLetRegions",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLetRegions",
          "package": "ddc-core",
          "partial": "KLet Regions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KLetRegions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLit",
          "package": "ddc-core",
          "signature": "KLit n",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokNamed",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KLit",
          "package": "ddc-core",
          "partial": "KLit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMeta tokens contain out-of-band information that is eliminated\n   before parsing proper.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KM",
          "package": "ddc-core",
          "signature": "KM !TokMeta",
          "source": "src/DDC-Core-Lexer-Tokens.html#Tok",
          "type": "function"
        },
        "index": {
          "description": "Meta tokens contain out-of-band information that is eliminated before parsing proper",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KM",
          "package": "ddc-core",
          "partial": "KM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KMatch",
          "package": "ddc-core",
          "signature": "KMatch",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KMatch",
          "package": "ddc-core",
          "partial": "KMatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KModule",
          "package": "ddc-core",
          "signature": "KModule",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KModule",
          "package": "ddc-core",
          "partial": "KModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA named token that is specific to the language fragment \n   (maybe it's a primop), or a user defined name.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KN",
          "package": "ddc-core",
          "signature": "KN !(TokNamed n)",
          "source": "src/DDC-Core-Lexer-Tokens.html#Tok",
          "type": "function"
        },
        "index": {
          "description": "named token that is specific to the language fragment maybe it primop or user defined name",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KN",
          "package": "ddc-core",
          "partial": "KN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KNewLine",
          "package": "ddc-core",
          "signature": "KNewLine",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokMeta",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KNewLine",
          "package": "ddc-core",
          "partial": "KNew Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KNewLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KOf",
          "package": "ddc-core",
          "signature": "KOf",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KOf",
          "package": "ddc-core",
          "partial": "KOf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is injected by \u003ccode\u003eapplyOffside\u003c/code\u003e when it finds an explit close\n   brace in a position where it would close a synthetic one.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KOffsideClosingBrace",
          "package": "ddc-core",
          "signature": "KOffsideClosingBrace",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokMeta",
          "type": "function"
        },
        "index": {
          "description": "This is injected by applyOffside when it finds an explit close brace in position where it would close synthetic one",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KOffsideClosingBrace",
          "package": "ddc-core",
          "partial": "KOffside Closing Brace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KOffsideClosingBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KPlus",
          "package": "ddc-core",
          "signature": "KPlus",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KPlus",
          "package": "ddc-core",
          "partial": "KPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KPurify",
          "package": "ddc-core",
          "signature": "KPurify",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KPurify",
          "package": "ddc-core",
          "partial": "KPurify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KPurify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KRoundBra",
          "package": "ddc-core",
          "signature": "KRoundBra",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KRoundBra",
          "package": "ddc-core",
          "partial": "KRound Bra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KRoundBra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KRoundKet",
          "package": "ddc-core",
          "signature": "KRoundKet",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KRoundKet",
          "package": "ddc-core",
          "partial": "KRound Ket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KRoundKet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KRun",
          "package": "ddc-core",
          "signature": "KRun",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KRun",
          "package": "ddc-core",
          "partial": "KRun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSemiColon",
          "package": "ddc-core",
          "signature": "KSemiColon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSemiColon",
          "package": "ddc-core",
          "partial": "KSemi Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KSemiColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSoConBuiltin",
          "package": "ddc-core",
          "signature": "KSoConBuiltin SoCon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSoConBuiltin",
          "package": "ddc-core",
          "partial": "KSo Con Builtin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KSoConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareBra",
          "package": "ddc-core",
          "signature": "KSquareBra",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareBra",
          "package": "ddc-core",
          "partial": "KSquare Bra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KSquareBra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareColonBra",
          "package": "ddc-core",
          "signature": "KSquareColonBra",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareColonBra",
          "package": "ddc-core",
          "partial": "KSquare Colon Bra",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KSquareColonBra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareColonKet",
          "package": "ddc-core",
          "signature": "KSquareColonKet",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareColonKet",
          "package": "ddc-core",
          "partial": "KSquare Colon Ket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KSquareColonKet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareKet",
          "package": "ddc-core",
          "signature": "KSquareKet",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSquareKet",
          "package": "ddc-core",
          "partial": "KSquare Ket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KSquareKet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSuspend",
          "package": "ddc-core",
          "signature": "KSuspend",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KSuspend",
          "package": "ddc-core",
          "partial": "KSuspend",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KSuspend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KTcConBuiltin",
          "package": "ddc-core",
          "signature": "KTcConBuiltin TcCon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KTcConBuiltin",
          "package": "ddc-core",
          "partial": "KTc Con Builtin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KTcConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KTwConBuiltin",
          "package": "ddc-core",
          "signature": "KTwConBuiltin TwCon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KTwConBuiltin",
          "package": "ddc-core",
          "partial": "KTw Con Builtin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KTwConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KType",
          "package": "ddc-core",
          "signature": "KType",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KType",
          "package": "ddc-core",
          "partial": "KType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KUnderscore",
          "package": "ddc-core",
          "signature": "KUnderscore",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KUnderscore",
          "package": "ddc-core",
          "partial": "KUnderscore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KUnderscore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KVar",
          "package": "ddc-core",
          "signature": "KVar n",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokNamed",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KVar",
          "package": "ddc-core",
          "partial": "KVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWbConBuiltin",
          "package": "ddc-core",
          "signature": "KWbConBuiltin WbCon",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWbConBuiltin",
          "package": "ddc-core",
          "partial": "KWb Con Builtin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KWbConBuiltin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWeakClo",
          "package": "ddc-core",
          "signature": "KWeakClo",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWeakClo",
          "package": "ddc-core",
          "partial": "KWeak Clo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KWeakClo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWeakEff",
          "package": "ddc-core",
          "signature": "KWeakEff",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWeakEff",
          "package": "ddc-core",
          "partial": "KWeak Eff",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KWeakEff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWhere",
          "package": "ddc-core",
          "signature": "KWhere",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWhere",
          "package": "ddc-core",
          "partial": "KWhere",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KWhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWith",
          "package": "ddc-core",
          "signature": "KWith",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWith",
          "package": "ddc-core",
          "partial": "KWith",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWithRegion",
          "package": "ddc-core",
          "signature": "KWithRegion",
          "source": "src/DDC-Core-Lexer-Tokens.html#TokAtom",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "KWithRegion",
          "package": "ddc-core",
          "partial": "KWith Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:KWithRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribe a token for parser error messages.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTok",
          "package": "ddc-core",
          "signature": "Tok n -\u003e String",
          "source": "src/DDC-Core-Lexer-Tokens.html#describeTok",
          "type": "function"
        },
        "index": {
          "description": "Describe token for parser error messages",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTok",
          "normalized": "Tok a-\u003eString",
          "package": "ddc-core",
          "partial": "Tok",
          "signature": "Tok n-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:describeTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribe a \u003ccode\u003e\u003ca\u003eTokAtom\u003c/a\u003e\u003c/code\u003e, for parser error messages.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTokAtom",
          "package": "ddc-core",
          "signature": "TokAtom -\u003e String",
          "source": "src/DDC-Core-Lexer-Tokens.html#describeTokAtom",
          "type": "function"
        },
        "index": {
          "description": "Describe TokAtom for parser error messages",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTokAtom",
          "normalized": "TokAtom-\u003eString",
          "package": "ddc-core",
          "partial": "Tok Atom",
          "signature": "TokAtom-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:describeTokAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribe a TokMeta, for lexer error messages.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTokMeta",
          "package": "ddc-core",
          "signature": "TokMeta -\u003e String",
          "source": "src/DDC-Core-Lexer-Tokens.html#describeTokMeta",
          "type": "function"
        },
        "index": {
          "description": "Describe TokMeta for lexer error messages",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTokMeta",
          "normalized": "TokMeta-\u003eString",
          "package": "ddc-core",
          "partial": "Tok Meta",
          "signature": "TokMeta-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:describeTokMeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribe a \u003ccode\u003e\u003ca\u003eTokNamed\u003c/a\u003e\u003c/code\u003e, for parser error messages.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTokNamed",
          "package": "ddc-core",
          "signature": "TokNamed n -\u003e String",
          "source": "src/DDC-Core-Lexer-Tokens.html#describeTokNamed",
          "type": "function"
        },
        "index": {
          "description": "Describe TokNamed for parser error messages",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "describeTokNamed",
          "normalized": "TokNamed a-\u003eString",
          "package": "ddc-core",
          "partial": "Tok Named",
          "signature": "TokNamed n-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:describeTokNamed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to all the names in a \u003ccode\u003e\u003ca\u003eTok\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "renameTok",
          "package": "ddc-core",
          "signature": "(n1 -\u003e Maybe n2) -\u003e Tok n1 -\u003e Maybe (Tok n2)",
          "source": "src/DDC-Core-Lexer-Tokens.html#renameTok",
          "type": "function"
        },
        "index": {
          "description": "Apply function to all the names in Tok",
          "hierarchy": "DDC Core Lexer Tokens",
          "module": "DDC.Core.Lexer.Tokens",
          "name": "renameTok",
          "normalized": "(a-\u003eMaybe a)-\u003eTok a-\u003eMaybe(Tok a)",
          "package": "ddc-core",
          "partial": "Tok",
          "signature": "(n-\u003eMaybe n)-\u003eTok n-\u003eMaybe(Tok n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer-Tokens.html#v:renameTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReference lexer for core langauge parser. Slow but Simple.\n\u003c/p\u003e\u003cp\u003eThe lexers here all use \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e in place of a real name type.\n   After applying these functions to the program text, we need\n   to use \u003ccode\u003e\u003ca\u003erenameTok\u003c/a\u003e\u003c/code\u003e tok convert the strings in \u003ccode\u003e\u003ca\u003eTokNamed\u003c/a\u003e\u003c/code\u003e tokens\n   into the name type specific to the langauge fragment to be parsed.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Lexer",
          "name": "Lexer",
          "package": "ddc-core",
          "source": "src/DDC-Core-Lexer.html",
          "type": "module"
        },
        "index": {
          "description": "Reference lexer for core langauge parser Slow but Simple The lexers here all use String in place of real name type After applying these functions to the program text we need to use renameTok tok convert the strings in TokNamed tokens into the name type specific to the langauge fragment to be parsed",
          "hierarchy": "DDC Core Lexer",
          "module": "DDC.Core.Lexer",
          "name": "Lexer",
          "package": "ddc-core",
          "partial": "Lexer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLex a string into tokens.\n\u003c/p\u003e\u003cp\u003eAutomatically drop comments from the token stream along the way.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer",
          "name": "lexExp",
          "package": "ddc-core",
          "signature": "FilePath-\u003e Int-\u003e String-\u003e [Token (Tok String)]",
          "type": "function"
        },
        "index": {
          "description": "Lex string into tokens Automatically drop comments from the token stream along the way",
          "hierarchy": "DDC Core Lexer",
          "module": "DDC.Core.Lexer",
          "name": "lexExp",
          "normalized": "FilePath-\u003eInt-\u003eString-\u003e[Token(Tok String)]",
          "package": "ddc-core",
          "partial": "Exp",
          "signature": "FilePath-\u003eInt-\u003eString-\u003e[Token(Tok String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer.html#v:lexExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLex a module and apply the offside rule.\n\u003c/p\u003e\u003cp\u003eAutomatically drop comments from the token stream along the way.\n\u003c/p\u003e",
          "module": "DDC.Core.Lexer",
          "name": "lexModuleWithOffside",
          "package": "ddc-core",
          "signature": "FilePath-\u003e Int-\u003e String-\u003e [Token (Tok String)]",
          "type": "function"
        },
        "index": {
          "description": "Lex module and apply the offside rule Automatically drop comments from the token stream along the way",
          "hierarchy": "DDC Core Lexer",
          "module": "DDC.Core.Lexer",
          "name": "lexModuleWithOffside",
          "normalized": "FilePath-\u003eInt-\u003eString-\u003e[Token(Tok String)]",
          "package": "ddc-core",
          "partial": "Module With Offside",
          "signature": "FilePath-\u003eInt-\u003eString-\u003e[Token(Tok String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Lexer.html#v:lexModuleWithOffside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\"Loading\" refers to the combination of parsing and type checking.\n   This is the easiest way to turn source tokens into a type-checked \n   abstract syntax tree.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Load",
          "name": "Load",
          "package": "ddc-core",
          "source": "src/DDC-Core-Load.html",
          "type": "module"
        },
        "index": {
          "description": "Loading refers to the combination of parsing and type checking This is the easiest way to turn source tokens into type-checked abstract syntax tree",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "Load",
          "package": "ddc-core",
          "partial": "Load",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type checker adds this annotation to every node in the AST, \n   giving its type, effect and closure.\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "AnTEC",
          "package": "ddc-core",
          "source": "src/DDC-Core-Annot-AnTEC.html#AnTEC",
          "type": "data"
        },
        "index": {
          "description": "The type checker adds this annotation to every node in the AST giving its type effect and closure",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "AnTEC",
          "package": "ddc-core",
          "partial": "An TEC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#t:AnTEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThings that can go wrong when loading a core thing.\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "Error",
          "package": "ddc-core",
          "source": "src/DDC-Core-Load.html#Error",
          "type": "data"
        },
        "index": {
          "description": "Things that can go wrong when loading core thing",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "Error",
          "package": "ddc-core",
          "partial": "Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#t:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Load",
          "name": "ErrorCheckExp",
          "package": "ddc-core",
          "signature": "ErrorCheckExp !(Error SourcePos n)",
          "source": "src/DDC-Core-Load.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "ErrorCheckExp",
          "package": "ddc-core",
          "partial": "Error Check Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:ErrorCheckExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Load",
          "name": "ErrorCheckType",
          "package": "ddc-core",
          "signature": "ErrorCheckType !(Error n)",
          "source": "src/DDC-Core-Load.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "ErrorCheckType",
          "package": "ddc-core",
          "partial": "Error Check Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:ErrorCheckType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Load",
          "name": "ErrorCompliance",
          "package": "ddc-core",
          "signature": "ErrorCompliance !(Error (AnTEC SourcePos n) n)",
          "source": "src/DDC-Core-Load.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "ErrorCompliance",
          "package": "ddc-core",
          "partial": "Error Compliance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:ErrorCompliance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Load",
          "name": "ErrorParser",
          "package": "ddc-core",
          "signature": "ErrorParser !ParseError",
          "source": "src/DDC-Core-Load.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "ErrorParser",
          "package": "ddc-core",
          "partial": "Error Parser",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:ErrorParser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Load",
          "name": "ErrorRead",
          "package": "ddc-core",
          "signature": "ErrorRead !String",
          "source": "src/DDC-Core-Load.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "ErrorRead",
          "package": "ddc-core",
          "partial": "Error Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:ErrorRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse and check an expression\n   returning it along with its spec, effect and closure\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "loadExp",
          "package": "ddc-core",
          "signature": "Profile n-\u003e Map ModuleName (Module (AnTEC () n) n)-\u003e FilePath-\u003e [Token (Tok n)]-\u003e Either (Error n) (Exp (AnTEC SourcePos n) n)",
          "type": "function"
        },
        "index": {
          "description": "Parse and check an expression returning it along with its spec effect and closure",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "loadExp",
          "normalized": "Profile a-\u003eMap ModuleName(Module(AnTEC()a)a)-\u003eFilePath-\u003e[Token(Tok a)]-\u003eEither(Error a)(Exp(AnTEC SourcePos a)a)",
          "package": "ddc-core",
          "partial": "Exp",
          "signature": "Profile n-\u003eMap ModuleName(Module(AnTEC()n)n)-\u003eFilePath-\u003e[Token(Tok n)]-\u003eEither(Error n)(Exp(AnTEC SourcePos n)n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:loadExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse and type check a core module from a file.\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "loadModuleFromFile",
          "package": "ddc-core",
          "signature": "Profile n-\u003e (String -\u003e [Token (Tok n)])-\u003e FilePath-\u003e IO (Either (Error n) (Module (AnTEC SourcePos n) n))",
          "type": "function"
        },
        "index": {
          "description": "Parse and type check core module from file",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "loadModuleFromFile",
          "normalized": "Profile a-\u003e(String-\u003e[Token(Tok a)])-\u003eFilePath-\u003eIO(Either(Error a)(Module(AnTEC SourcePos a)a))",
          "package": "ddc-core",
          "partial": "Module From File",
          "signature": "Profile n-\u003e(String-\u003e[Token(Tok n)])-\u003eFilePath-\u003eIO(Either(Error n)(Module(AnTEC SourcePos n)n))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:loadModuleFromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse and type check a core module from a string.\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "loadModuleFromString",
          "package": "ddc-core",
          "signature": "Profile n-\u003e (String -\u003e [Token (Tok n)])-\u003e FilePath-\u003e String-\u003e Either (Error n) (Module (AnTEC SourcePos n) n)",
          "type": "function"
        },
        "index": {
          "description": "Parse and type check core module from string",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "loadModuleFromString",
          "normalized": "Profile a-\u003e(String-\u003e[Token(Tok a)])-\u003eFilePath-\u003eString-\u003eEither(Error a)(Module(AnTEC SourcePos a)a)",
          "package": "ddc-core",
          "partial": "Module From String",
          "signature": "Profile n-\u003e(String-\u003e[Token(Tok n)])-\u003eFilePath-\u003eString-\u003eEither(Error n)(Module(AnTEC SourcePos n)n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:loadModuleFromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse and type check a core module.\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "loadModuleFromTokens",
          "package": "ddc-core",
          "signature": "Profile n-\u003e FilePath-\u003e [Token (Tok n)]-\u003e Either (Error n) (Module (AnTEC SourcePos n) n)",
          "type": "function"
        },
        "index": {
          "description": "Parse and type check core module",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "loadModuleFromTokens",
          "normalized": "Profile a-\u003eFilePath-\u003e[Token(Tok a)]-\u003eEither(Error a)(Module(AnTEC SourcePos a)a)",
          "package": "ddc-core",
          "partial": "Module From Tokens",
          "signature": "Profile n-\u003eFilePath-\u003e[Token(Tok n)]-\u003eEither(Error n)(Module(AnTEC SourcePos n)n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:loadModuleFromTokens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse and check a type,\n   returning it along with its kind.\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "loadType",
          "package": "ddc-core",
          "signature": "Profile n-\u003e FilePath-\u003e [Token (Tok n)]-\u003e Either (Error n) (Type n, Kind n)",
          "type": "function"
        },
        "index": {
          "description": "Parse and check type returning it along with its kind",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "loadType",
          "normalized": "Profile a-\u003eFilePath-\u003e[Token(Tok a)]-\u003eEither(Error a)(Type a,Kind a)",
          "package": "ddc-core",
          "partial": "Type",
          "signature": "Profile n-\u003eFilePath-\u003e[Token(Tok n)]-\u003eEither(Error n)(Type n,Kind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:loadType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse and check a witness,\n   returning it along with its type.\n\u003c/p\u003e",
          "module": "DDC.Core.Load",
          "name": "loadWitness",
          "package": "ddc-core",
          "signature": "Profile n-\u003e FilePath-\u003e [Token (Tok n)]-\u003e Either (Error n) (Witness (AnT SourcePos n) n, Type n)",
          "type": "function"
        },
        "index": {
          "description": "Parse and check witness returning it along with its type",
          "hierarchy": "DDC Core Load",
          "module": "DDC.Core.Load",
          "name": "loadWitness",
          "normalized": "Profile a-\u003eFilePath-\u003e[Token(Tok a)]-\u003eEither(Error a)(Witness(AnT SourcePos a)a,Type a)",
          "package": "ddc-core",
          "partial": "Witness",
          "signature": "Profile n-\u003eFilePath-\u003e[Token(Tok n)]-\u003eEither(Error n)(Witness(AnT SourcePos n)n,Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Load.html#v:loadWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Module",
          "name": "Module",
          "package": "ddc-core",
          "source": "src/DDC-Core-Module.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "Module",
          "package": "ddc-core",
          "partial": "Module",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA module can be mutually recursive with other modules.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "Module",
          "package": "ddc-core",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "data"
        },
        "index": {
          "description": "module can be mutually recursive with other modules",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "Module",
          "package": "ddc-core",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap of module names to modules.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "ModuleMap",
          "package": "ddc-core",
          "source": "src/DDC-Core-Module.html#ModuleMap",
          "type": "type"
        },
        "index": {
          "description": "Map of module names to modules",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "ModuleMap",
          "package": "ddc-core",
          "partial": "Module Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#t:ModuleMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA hierarchical module name.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "ModuleName",
          "package": "ddc-core",
          "source": "src/DDC-Core-Module.html#ModuleName",
          "type": "data"
        },
        "index": {
          "description": "hierarchical module name",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "ModuleName",
          "package": "ddc-core",
          "partial": "Module Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#t:ModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA fully qualified name, \n   including the name of the module it is from.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "QualName",
          "package": "ddc-core",
          "source": "src/DDC-Core-Module.html#QualName",
          "type": "data"
        },
        "index": {
          "description": "fully qualified name including the name of the module it is from",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "QualName",
          "package": "ddc-core",
          "partial": "Qual Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#t:QualName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Module",
          "name": "ModuleCore",
          "package": "ddc-core",
          "signature": "ModuleCore",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "ModuleCore",
          "package": "ddc-core",
          "partial": "Module Core",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:ModuleCore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Module",
          "name": "ModuleName",
          "package": "ddc-core",
          "signature": "ModuleName [String]",
          "source": "src/DDC-Core-Module.html#ModuleName",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "ModuleName",
          "normalized": "ModuleName[String]",
          "package": "ddc-core",
          "partial": "Module Name",
          "signature": "ModuleName[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:ModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Module",
          "name": "QualName",
          "package": "ddc-core",
          "signature": "QualName ModuleName n",
          "source": "src/DDC-Core-Module.html#QualName",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "QualName",
          "package": "ddc-core",
          "partial": "Qual Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:QualName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if this is the \u003ccode\u003eMain\u003c/code\u003e module.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "isMainModule",
          "package": "ddc-core",
          "signature": "Module a n -\u003e Bool",
          "source": "src/DDC-Core-Module.html#isMainModule",
          "type": "function"
        },
        "index": {
          "description": "Check if this is the Main module",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "isMainModule",
          "normalized": "Module a b-\u003eBool",
          "package": "ddc-core",
          "partial": "Main Module",
          "signature": "Module a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:isMainModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this is the name of the \"Main\" module.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "isMainModuleName",
          "package": "ddc-core",
          "signature": "ModuleName -\u003e Bool",
          "source": "src/DDC-Core-Module.html#isMainModuleName",
          "type": "function"
        },
        "index": {
          "description": "Check whether this is the name of the Main module",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "isMainModuleName",
          "normalized": "ModuleName-\u003eBool",
          "package": "ddc-core",
          "partial": "Main Module Name",
          "signature": "ModuleName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:isMainModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe module body consists of some let-bindings\n   wrapping a unit data constructor.\n\u003c/p\u003e\u003cp\u003eWe're only interested in the bindings, \n  with the unit being just a place-holder.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleBody",
          "package": "ddc-core",
          "signature": "(Exp a n)",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "function"
        },
        "index": {
          "description": "The module body consists of some let-bindings wrapping unit data constructor We re only interested in the bindings with the unit being just place-holder",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleBody",
          "package": "ddc-core",
          "partial": "Body",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKinds of exported types.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleExportKinds",
          "package": "ddc-core",
          "signature": "(Map n (Kind n))",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "function"
        },
        "index": {
          "description": "Kinds of exported types",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleExportKinds",
          "package": "ddc-core",
          "partial": "Export Kinds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleExportKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of exported values.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleExportTypes",
          "package": "ddc-core",
          "signature": "(Map n (Type n))",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "function"
        },
        "index": {
          "description": "Types of exported values",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleExportTypes",
          "package": "ddc-core",
          "partial": "Export Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleExportTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKinds of imported types,\n   along with the name of the module they are from.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleImportKinds",
          "package": "ddc-core",
          "signature": "(Map n (QualName n, Kind n))",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "function"
        },
        "index": {
          "description": "Kinds of imported types along with the name of the module they are from",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleImportKinds",
          "normalized": "(Map a(QualName a,Kind a))",
          "package": "ddc-core",
          "partial": "Import Kinds",
          "signature": "(Map n(QualName n,Kind n))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleImportKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of imported values,\n   along with the name of the module they are from.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleImportTypes",
          "package": "ddc-core",
          "signature": "(Map n (QualName n, Type n))",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "function"
        },
        "index": {
          "description": "Types of imported values along with the name of the module they are from",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleImportTypes",
          "normalized": "(Map a(QualName a,Type a))",
          "package": "ddc-core",
          "partial": "Import Types",
          "signature": "(Map n(QualName n,Type n))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleImportTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the top-level kind environment of a module,\n   from its imported types.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleKindEnv",
          "package": "ddc-core",
          "signature": "Module a n -\u003e KindEnv n",
          "source": "src/DDC-Core-Module.html#moduleKindEnv",
          "type": "function"
        },
        "index": {
          "description": "Get the top-level kind environment of module from its imported types",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleKindEnv",
          "normalized": "Module a b-\u003eKindEnv b",
          "package": "ddc-core",
          "partial": "Kind Env",
          "signature": "Module a n-\u003eKindEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleKindEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of this module.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleName",
          "package": "ddc-core",
          "signature": "ModuleName",
          "source": "src/DDC-Core-Module.html#Module",
          "type": "function"
        },
        "index": {
          "description": "Name of this module",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleName",
          "package": "ddc-core",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the top-level type environment of a module,\n   from its imported values.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "moduleTypeEnv",
          "package": "ddc-core",
          "signature": "Module a n -\u003e TypeEnv n",
          "source": "src/DDC-Core-Module.html#moduleTypeEnv",
          "type": "function"
        },
        "index": {
          "description": "Get the top-level type environment of module from its imported values",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "moduleTypeEnv",
          "normalized": "Module a b-\u003eTypeEnv b",
          "package": "ddc-core",
          "partial": "Type Env",
          "signature": "Module a n-\u003eTypeEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:moduleTypeEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd the kind environment exported by all these modules to the given one.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "modulesExportKinds",
          "package": "ddc-core",
          "signature": "ModuleMap a n -\u003e KindEnv n -\u003e KindEnv n",
          "source": "src/DDC-Core-Module.html#modulesExportKinds",
          "type": "function"
        },
        "index": {
          "description": "Add the kind environment exported by all these modules to the given one",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "modulesExportKinds",
          "normalized": "ModuleMap a b-\u003eKindEnv b-\u003eKindEnv b",
          "package": "ddc-core",
          "partial": "Export Kinds",
          "signature": "ModuleMap a n-\u003eKindEnv n-\u003eKindEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:modulesExportKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd the type environment exported by all these modules to the given one.\n\u003c/p\u003e",
          "module": "DDC.Core.Module",
          "name": "modulesExportTypes",
          "package": "ddc-core",
          "signature": "ModuleMap a n -\u003e TypeEnv n -\u003e TypeEnv n",
          "source": "src/DDC-Core-Module.html#modulesExportTypes",
          "type": "function"
        },
        "index": {
          "description": "Add the type environment exported by all these modules to the given one",
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "modulesExportTypes",
          "normalized": "ModuleMap a b-\u003eTypeEnv b-\u003eTypeEnv b",
          "package": "ddc-core",
          "partial": "Export Types",
          "signature": "ModuleMap a n-\u003eTypeEnv n-\u003eTypeEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:modulesExportTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Module",
          "name": "modulesGetBinds",
          "package": "ddc-core",
          "signature": "Map n (Type n) -\u003e Env n",
          "source": "src/DDC-Core-Module.html#modulesGetBinds",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Module",
          "module": "DDC.Core.Module",
          "name": "modulesGetBinds",
          "normalized": "Map a(Type a)-\u003eEnv a",
          "package": "ddc-core",
          "partial": "Get Binds",
          "signature": "Map n(Type n)-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Module.html#v:modulesGetBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCore language parser.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Parser",
          "name": "Parser",
          "package": "ddc-core",
          "source": "src/DDC-Core-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "Core language parser",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "Parser",
          "package": "ddc-core",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConfiguration and information from the context. \n   Used for context sensitive parsing.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "Context",
          "package": "ddc-core",
          "source": "src/DDC-Core-Parser-Context.html#Context",
          "type": "data"
        },
        "index": {
          "description": "Configuration and information from the context Used for context sensitive parsing",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "Context",
          "package": "ddc-core",
          "partial": "Context",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA parser of core language tokens.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "Parser",
          "package": "ddc-core",
          "source": "src/DDC-Core-Parser-Base.html#Parser",
          "type": "type"
        },
        "index": {
          "description": "parser of core language tokens",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "Parser",
          "package": "ddc-core",
          "partial": "Parser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Parser",
          "name": "Context",
          "package": "ddc-core",
          "signature": "Context",
          "source": "src/DDC-Core-Parser-Context.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "Context",
          "package": "ddc-core",
          "partial": "Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Parser",
          "name": "contextFunctionalClosures",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Parser-Context.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "contextFunctionalClosures",
          "package": "ddc-core",
          "partial": "Functional Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:contextFunctionalClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Parser",
          "name": "contextFunctionalEffects",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Parser-Context.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "contextFunctionalEffects",
          "package": "ddc-core",
          "partial": "Functional Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:contextFunctionalEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSlurp an initital Context from a Profile\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "contextOfProfile",
          "package": "ddc-core",
          "signature": "Profile n -\u003e Context",
          "source": "src/DDC-Core-Parser-Context.html#contextOfProfile",
          "type": "function"
        },
        "index": {
          "description": "Slurp an initital Context from Profile",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "contextOfProfile",
          "normalized": "Profile a-\u003eContext",
          "package": "ddc-core",
          "partial": "Of Profile",
          "signature": "Profile n-\u003eContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:contextOfProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Parser",
          "name": "contextTrackedClosures",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Parser-Context.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "contextTrackedClosures",
          "package": "ddc-core",
          "partial": "Tracked Closures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:contextTrackedClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Parser",
          "name": "contextTrackedEffects",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Core-Parser-Context.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "contextTrackedEffects",
          "package": "ddc-core",
          "partial": "Tracked Effects",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:contextTrackedEffects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a binder.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pBinder",
          "package": "ddc-core",
          "signature": "Parser n (Binder n)",
          "source": "src/DDC-Core-Parser-Type.html#pBinder",
          "type": "function"
        },
        "index": {
          "description": "Parse binder",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pBinder",
          "package": "ddc-core",
          "partial": "Binder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a constructor name.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pCon",
          "package": "ddc-core",
          "signature": "Parser n n",
          "source": "src/DDC-Core-Parser-Base.html#pCon",
          "type": "function"
        },
        "index": {
          "description": "Parse constructor name",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pCon",
          "package": "ddc-core",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a core language expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pExp",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Exp SourcePos n)",
          "source": "src/DDC-Core-Parser-Exp.html#pExp",
          "type": "function"
        },
        "index": {
          "description": "Parse core language expression",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pExp",
          "normalized": "Context-\u003eParser a(Exp SourcePos a)",
          "package": "ddc-core",
          "partial": "Exp",
          "signature": "Context-\u003eParser n(Exp SourcePos n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Parser",
          "name": "pExpApp",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Exp SourcePos n)",
          "source": "src/DDC-Core-Parser-Exp.html#pExpApp",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pExpApp",
          "normalized": "Context-\u003eParser a(Exp SourcePos a)",
          "package": "ddc-core",
          "partial": "Exp App",
          "signature": "Context-\u003eParser n(Exp SourcePos n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pExpApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a variable, constructor or parenthesised expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pExpAtom",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Exp SourcePos n)",
          "source": "src/DDC-Core-Parser-Exp.html#pExpAtom",
          "type": "function"
        },
        "index": {
          "description": "Parse variable constructor or parenthesised expression",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pExpAtom",
          "normalized": "Context-\u003eParser a(Exp SourcePos a)",
          "package": "ddc-core",
          "partial": "Exp Atom",
          "signature": "Context-\u003eParser n(Exp SourcePos n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pExpAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a deBruijn index\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pIndex",
          "package": "ddc-core",
          "signature": "Parser n Int",
          "source": "src/DDC-Core-Parser-Base.html#pIndex",
          "type": "function"
        },
        "index": {
          "description": "Parse deBruijn index",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pIndex",
          "package": "ddc-core",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a literal\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pLit",
          "package": "ddc-core",
          "signature": "Parser n n",
          "source": "src/DDC-Core-Parser-Base.html#pLit",
          "type": "function"
        },
        "index": {
          "description": "Parse literal",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pLit",
          "package": "ddc-core",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a core module.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pModule",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Module SourcePos n)",
          "source": "src/DDC-Core-Parser-Module.html#pModule",
          "type": "function"
        },
        "index": {
          "description": "Parse core module",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pModule",
          "normalized": "Context-\u003eParser a(Module SourcePos a)",
          "package": "ddc-core",
          "partial": "Module",
          "signature": "Context-\u003eParser n(Module SourcePos n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a constructor or variable name.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pName",
          "package": "ddc-core",
          "signature": "Parser n n",
          "source": "src/DDC-Core-Parser-Base.html#pName",
          "type": "function"
        },
        "index": {
          "description": "Parse constructor or variable name",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pName",
          "package": "ddc-core",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse an atomic token.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pTok",
          "package": "ddc-core",
          "signature": "TokAtom -\u003e Parser n ()",
          "source": "src/DDC-Core-Parser-Base.html#pTok",
          "type": "function"
        },
        "index": {
          "description": "Parse an atomic token",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pTok",
          "normalized": "TokAtom-\u003eParser a()",
          "package": "ddc-core",
          "partial": "Tok",
          "signature": "TokAtom-\u003eParser n()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse an atomic token and return some value.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pTokAs",
          "package": "ddc-core",
          "signature": "TokAtom -\u003e a -\u003e Parser n a",
          "source": "src/DDC-Core-Parser-Base.html#pTokAs",
          "type": "function"
        },
        "index": {
          "description": "Parse an atomic token and return some value",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pTokAs",
          "normalized": "TokAtom-\u003ea-\u003eParser b a",
          "package": "ddc-core",
          "partial": "Tok As",
          "signature": "TokAtom-\u003ea-\u003eParser n a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pTokAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a type.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pType",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Type n)",
          "source": "src/DDC-Core-Parser-Type.html#pType",
          "type": "function"
        },
        "index": {
          "description": "Parse type",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pType",
          "normalized": "Context-\u003eParser a(Type a)",
          "package": "ddc-core",
          "partial": "Type",
          "signature": "Context-\u003eParser n(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a type application.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pTypeApp",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Type n)",
          "source": "src/DDC-Core-Parser-Type.html#pTypeApp",
          "type": "function"
        },
        "index": {
          "description": "Parse type application",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pTypeApp",
          "normalized": "Context-\u003eParser a(Type a)",
          "package": "ddc-core",
          "partial": "Type App",
          "signature": "Context-\u003eParser n(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pTypeApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a variable, constructor or parenthesised type.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pTypeAtom",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Type n)",
          "source": "src/DDC-Core-Parser-Type.html#pTypeAtom",
          "type": "function"
        },
        "index": {
          "description": "Parse variable constructor or parenthesised type",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pTypeAtom",
          "normalized": "Context-\u003eParser a(Type a)",
          "package": "ddc-core",
          "partial": "Type Atom",
          "signature": "Context-\u003eParser n(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pTypeAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a variable.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pVar",
          "package": "ddc-core",
          "signature": "Parser n n",
          "source": "src/DDC-Core-Parser-Base.html#pVar",
          "type": "function"
        },
        "index": {
          "description": "Parse variable",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pVar",
          "package": "ddc-core",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a witness expression.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pWitness",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Witness SourcePos n)",
          "source": "src/DDC-Core-Parser-Witness.html#pWitness",
          "type": "function"
        },
        "index": {
          "description": "Parse witness expression",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pWitness",
          "normalized": "Context-\u003eParser a(Witness SourcePos a)",
          "package": "ddc-core",
          "partial": "Witness",
          "signature": "Context-\u003eParser n(Witness SourcePos n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a witness application.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pWitnessApp",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Witness SourcePos n)",
          "source": "src/DDC-Core-Parser-Witness.html#pWitnessApp",
          "type": "function"
        },
        "index": {
          "description": "Parse witness application",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pWitnessApp",
          "normalized": "Context-\u003eParser a(Witness SourcePos a)",
          "package": "ddc-core",
          "partial": "Witness App",
          "signature": "Context-\u003eParser n(Witness SourcePos n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pWitnessApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a variable, constructor or parenthesised witness.\n\u003c/p\u003e",
          "module": "DDC.Core.Parser",
          "name": "pWitnessAtom",
          "package": "ddc-core",
          "signature": "Context -\u003e Parser n (Witness SourcePos n)",
          "source": "src/DDC-Core-Parser-Witness.html#pWitnessAtom",
          "type": "function"
        },
        "index": {
          "description": "Parse variable constructor or parenthesised witness",
          "hierarchy": "DDC Core Parser",
          "module": "DDC.Core.Parser",
          "name": "pWitnessAtom",
          "normalized": "Context-\u003eParser a(Witness SourcePos a)",
          "package": "ddc-core",
          "partial": "Witness Atom",
          "signature": "Context-\u003eParser n(Witness SourcePos n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Parser.html#v:pWitnessAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSimple predicates on core expressions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Predicates",
          "name": "Predicates",
          "package": "ddc-core",
          "source": "src/DDC-Core-Predicates.html",
          "type": "module"
        },
        "index": {
          "description": "Simple predicates on core expressions",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "Predicates",
          "package": "ddc-core",
          "partial": "Predicates",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a witness is a \u003ccode\u003e\u003ca\u003eWVar\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eWCon\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isAtomW",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isAtomW",
          "type": "function"
        },
        "index": {
          "description": "Check whether witness is WVar or WCon",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isAtomW",
          "normalized": "Witness a b-\u003eBool",
          "package": "ddc-core",
          "partial": "Atom",
          "signature": "Witness a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isAtomW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is a \u003ccode\u003e\u003ca\u003eXVar\u003c/a\u003e\u003c/code\u003e or an \u003ccode\u003e\u003ca\u003eXCon\u003c/a\u003e\u003c/code\u003e, \n   or some type or witness atom.\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isAtomX",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isAtomX",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is XVar or an XCon or some type or witness atom",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isAtomX",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "Atom",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isAtomX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is a spec, value, or witness abstraction.\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isLambdaX",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isLambdaX",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is spec value or witness abstraction",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isLambdaX",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "Lambda",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isLambdaX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an alternative is a \u003ccode\u003e\u003ca\u003ePDefault\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isPDefault",
          "package": "ddc-core",
          "signature": "Pat n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isPDefault",
          "type": "function"
        },
        "index": {
          "description": "Check whether an alternative is PDefault",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isPDefault",
          "normalized": "Pat a-\u003eBool",
          "package": "ddc-core",
          "partial": "PDefault",
          "signature": "Pat n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isPDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is an \u003ccode\u003e\u003ca\u003eXApp\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isXApp",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXApp",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is an XApp",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXApp",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XApp",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is a constructor.\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isXCon",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXCon",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is constructor",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXCon",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XCon",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is a spec abstraction (level-1).\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isXLAM",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXLAM",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is spec abstraction level-1",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXLAM",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XLAM",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXLAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is a value or witness abstraction (level-0).\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isXLam",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXLam",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is value or witness abstraction level-0",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXLam",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XLam",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXLam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Predicates",
          "name": "isXLet",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXLet",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXLet",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XLet",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is an \u003ccode\u003e\u003ca\u003eXType\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isXType",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXType",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is an XType",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXType",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XType",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is a variable.\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isXVar",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXVar",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is variable",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXVar",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XVar",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an expression is an \u003ccode\u003e\u003ca\u003eXWitness\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Core.Predicates",
          "name": "isXWitness",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Bool",
          "source": "src/DDC-Core-Predicates.html#isXWitness",
          "type": "function"
        },
        "index": {
          "description": "Check whether an expression is an XWitness",
          "hierarchy": "DDC Core Predicates",
          "module": "DDC.Core.Predicates",
          "name": "isXWitness",
          "normalized": "Exp a b-\u003eBool",
          "package": "ddc-core",
          "partial": "XWitness",
          "signature": "Exp a n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Predicates.html#v:isXWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvides pretty printing for core modules and expressions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Pretty",
          "name": "Pretty",
          "package": "ddc-core",
          "source": "src/DDC-Core-Pretty.html",
          "type": "module"
        },
        "index": {
          "description": "Provides pretty printing for core modules and expressions",
          "hierarchy": "DDC Core Pretty",
          "module": "DDC.Core.Pretty",
          "name": "Pretty",
          "package": "ddc-core",
          "partial": "Pretty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Pretty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Annotate",
          "name": "Annotate",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Annotate.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Transform Annotate",
          "module": "DDC.Core.Transform.Annotate",
          "name": "Annotate",
          "package": "ddc-core",
          "partial": "Annotate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Annotate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the \u003ccode\u003eSimple\u003c/code\u003e version of the AST to the \u003ccode\u003eAnnot\u003c/code\u003e version,\n   using a the provided default annotation value.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Annotate",
          "name": "Annotate",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Annotate.html#Annotate",
          "type": "class"
        },
        "index": {
          "description": "Convert the Simple version of the AST to the Annot version using the provided default annotation value",
          "hierarchy": "DDC Core Transform Annotate",
          "module": "DDC.Core.Transform.Annotate",
          "name": "Annotate",
          "package": "ddc-core",
          "partial": "Annotate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Annotate.html#t:Annotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Annotate",
          "name": "annotate",
          "package": "ddc-core",
          "signature": "a -\u003e c1 a n -\u003e c2 a n",
          "source": "src/DDC-Core-Transform-Annotate.html#annotate",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Core Transform Annotate",
          "module": "DDC.Core.Transform.Annotate",
          "name": "annotate",
          "normalized": "a-\u003eb a c-\u003eb a c",
          "package": "ddc-core",
          "signature": "a-\u003ec a n-\u003ec a n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Annotate.html#v:annotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Deannotate",
          "name": "Deannotate",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Deannotate.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Transform Deannotate",
          "module": "DDC.Core.Transform.Deannotate",
          "name": "Deannotate",
          "package": "ddc-core",
          "partial": "Deannotate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Deannotate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the \u003ccode\u003eAnnot\u003c/code\u003e version of the AST to the \u003ccode\u003eSimple\u003c/code\u003e version,\n   using the provided function to decide when to keep the annotation.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Deannotate",
          "name": "Deannotate",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Deannotate.html#Deannotate",
          "type": "class"
        },
        "index": {
          "description": "Convert the Annot version of the AST to the Simple version using the provided function to decide when to keep the annotation",
          "hierarchy": "DDC Core Transform Deannotate",
          "module": "DDC.Core.Transform.Deannotate",
          "name": "Deannotate",
          "package": "ddc-core",
          "partial": "Deannotate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Deannotate.html#t:Deannotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Deannotate",
          "name": "deannotate",
          "package": "ddc-core",
          "signature": "(a -\u003e Maybe a) -\u003e c1 a n -\u003e c2 a n",
          "source": "src/DDC-Core-Transform-Deannotate.html#deannotate",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Core Transform Deannotate",
          "module": "DDC.Core.Transform.Deannotate",
          "name": "deannotate",
          "normalized": "(a-\u003eMaybe a)-\u003eb a c-\u003eb a c",
          "package": "ddc-core",
          "signature": "(a-\u003eMaybe a)-\u003ec a n-\u003ec a n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Deannotate.html#v:deannotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.LiftT",
          "name": "LiftT",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-LiftT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Transform LiftT",
          "module": "DDC.Core.Transform.LiftT",
          "name": "LiftT",
          "package": "ddc-core",
          "partial": "Lift",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.LiftT",
          "name": "MapBoundT",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-LiftT.html#MapBoundT",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Transform LiftT",
          "module": "DDC.Core.Transform.LiftT",
          "name": "MapBoundT",
          "package": "ddc-core",
          "partial": "Map Bound",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftT.html#t:MapBoundT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift debruijn indices less than or equal to the given depth.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.LiftT\",\"DDC.Type.Transform.LiftT\"]",
          "name": "liftAtDepthT",
          "package": "ddc-core",
          "signature": "Int-\u003e Int-\u003e c n-\u003e c n",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftT.html#v:liftAtDepthT\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-LiftT.html#v:liftAtDepthT\"]"
        },
        "index": {
          "description": "Lift debruijn indices less than or equal to the given depth",
          "hierarchy": "DDC Core Transform LiftT",
          "module": "DDC.Core.Transform.LiftT",
          "name": "liftAtDepthT",
          "normalized": "Int-\u003eInt-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "partial": "At Depth",
          "signature": "Int-\u003eInt-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftT.html#v:liftAtDepthT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003eliftAtDepthX\u003c/code\u003e that starts at depth 0.       \n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.LiftT\",\"DDC.Type.Transform.LiftT\"]",
          "name": "liftT",
          "package": "ddc-core",
          "signature": "Int -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-LiftT.html#liftT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftT.html#v:liftT\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-LiftT.html#v:liftT\"]"
        },
        "index": {
          "description": "Wrapper for liftAtDepthX that starts at depth",
          "hierarchy": "DDC Core Transform LiftT",
          "module": "DDC.Core.Transform.LiftT",
          "name": "liftT",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "signature": "Int-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftT.html#v:liftT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to all bound variables in the program.\n   The function is passed the current binding depth.\n   This is used to defined both \u003ccode\u003e\u003ca\u003eliftT\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elowerT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.LiftT",
          "name": "mapBoundAtDepthT",
          "package": "ddc-core",
          "signature": "mapBoundAtDepthT",
          "source": "src/DDC-Type-Transform-LiftT.html#mapBoundAtDepthT",
          "type": "method"
        },
        "index": {
          "description": "Apply function to all bound variables in the program The function is passed the current binding depth This is used to defined both liftT and lowerT",
          "hierarchy": "DDC Core Transform LiftT",
          "module": "DDC.Core.Transform.LiftT",
          "name": "mapBoundAtDepthT",
          "package": "ddc-core",
          "partial": "Bound At Depth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftT.html#v:mapBoundAtDepthT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLifting and lowering level-0 deBruijn indices in core things.\n\u003c/p\u003e\u003cp\u003eLevel-0 indices are used for both value and witness variables.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Transform.LiftX",
          "name": "LiftX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-LiftX.html",
          "type": "module"
        },
        "index": {
          "description": "Lifting and lowering level-0 deBruijn indices in core things Level-0 indices are used for both value and witness variables",
          "hierarchy": "DDC Core Transform LiftX",
          "module": "DDC.Core.Transform.LiftX",
          "name": "LiftX",
          "package": "ddc-core",
          "partial": "Lift",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftX.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.LiftX",
          "name": "MapBoundX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-LiftX.html#MapBoundX",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Transform LiftX",
          "module": "DDC.Core.Transform.LiftX",
          "name": "MapBoundX",
          "package": "ddc-core",
          "partial": "Map Bound",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftX.html#t:MapBoundX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift debruijn indices less than or equal to the given depth.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.LiftX",
          "name": "liftAtDepthX",
          "package": "ddc-core",
          "signature": "Int-\u003e Int-\u003e c n-\u003e c n",
          "type": "function"
        },
        "index": {
          "description": "Lift debruijn indices less than or equal to the given depth",
          "hierarchy": "DDC Core Transform LiftX",
          "module": "DDC.Core.Transform.LiftX",
          "name": "liftAtDepthX",
          "normalized": "Int-\u003eInt-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "partial": "At Depth",
          "signature": "Int-\u003eInt-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftX.html#v:liftAtDepthX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003eliftAtDepthX\u003c/a\u003e\u003c/code\u003e that starts at depth 0.       \n\u003c/p\u003e",
          "module": "DDC.Core.Transform.LiftX",
          "name": "liftX",
          "package": "ddc-core",
          "signature": "Int -\u003e c n -\u003e c n",
          "source": "src/DDC-Core-Transform-LiftX.html#liftX",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for liftAtDepthX that starts at depth",
          "hierarchy": "DDC Core Transform LiftX",
          "module": "DDC.Core.Transform.LiftX",
          "name": "liftX",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "signature": "Int-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftX.html#v:liftX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLower debruijn indices less than or equal to the given depth.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.LiftX",
          "name": "lowerAtDepthX",
          "package": "ddc-core",
          "signature": "Int-\u003e Int-\u003e c n-\u003e c n",
          "type": "function"
        },
        "index": {
          "description": "Lower debruijn indices less than or equal to the given depth",
          "hierarchy": "DDC Core Transform LiftX",
          "module": "DDC.Core.Transform.LiftX",
          "name": "lowerAtDepthX",
          "normalized": "Int-\u003eInt-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "partial": "At Depth",
          "signature": "Int-\u003eInt-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftX.html#v:lowerAtDepthX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003elowerAtDepthX\u003c/a\u003e\u003c/code\u003e that starts at depth 0.       \n\u003c/p\u003e",
          "module": "DDC.Core.Transform.LiftX",
          "name": "lowerX",
          "package": "ddc-core",
          "signature": "Int -\u003e c n -\u003e c n",
          "source": "src/DDC-Core-Transform-LiftX.html#lowerX",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for lowerAtDepthX that starts at depth",
          "hierarchy": "DDC Core Transform LiftX",
          "module": "DDC.Core.Transform.LiftX",
          "name": "lowerX",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "signature": "Int-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftX.html#v:lowerX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to all bound variables in the program.\n   The function is passed the current binding depth.\n   This is used to defined both \u003ccode\u003e\u003ca\u003eliftX\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elowerX\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.LiftX",
          "name": "mapBoundAtDepthX",
          "package": "ddc-core",
          "signature": "mapBoundAtDepthX",
          "source": "src/DDC-Core-Transform-LiftX.html#mapBoundAtDepthX",
          "type": "method"
        },
        "index": {
          "description": "Apply function to all bound variables in the program The function is passed the current binding depth This is used to defined both liftX and lowerX",
          "hierarchy": "DDC Core Transform LiftX",
          "module": "DDC.Core.Transform.LiftX",
          "name": "mapBoundAtDepthX",
          "package": "ddc-core",
          "partial": "Bound At Depth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-LiftX.html#v:mapBoundAtDepthX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Reannotate",
          "name": "Reannotate",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Reannotate.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Transform Reannotate",
          "module": "DDC.Core.Transform.Reannotate",
          "name": "Reannotate",
          "package": "ddc-core",
          "partial": "Reannotate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Reannotate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the given function to every annotation in a core thing.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Reannotate",
          "name": "Reannotate",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Reannotate.html#Reannotate",
          "type": "class"
        },
        "index": {
          "description": "Apply the given function to every annotation in core thing",
          "hierarchy": "DDC Core Transform Reannotate",
          "module": "DDC.Core.Transform.Reannotate",
          "name": "Reannotate",
          "package": "ddc-core",
          "partial": "Reannotate",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Reannotate.html#t:Reannotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Reannotate",
          "name": "reannotate",
          "package": "ddc-core",
          "signature": "(a -\u003e b) -\u003e c a n -\u003e c b n",
          "source": "src/DDC-Core-Transform-Reannotate.html#reannotate",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Core Transform Reannotate",
          "module": "DDC.Core.Transform.Reannotate",
          "name": "reannotate",
          "normalized": "(a-\u003eb)-\u003ec a d-\u003ec b d",
          "package": "ddc-core",
          "signature": "(a-\u003eb)-\u003ec a n-\u003ec b n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Reannotate.html#v:reannotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Rename.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "partial": "Rename",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStack of anonymous binders that we've entered under during substitution. \n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Rename",
          "name": "BindStack",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "data"
        },
        "index": {
          "description": "Stack of anonymous binders that we ve entered under during substitution",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "BindStack",
          "package": "ddc-core",
          "partial": "Bind Stack",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#t:BindStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html#Rename",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "partial": "Rename",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#t:Rename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitution state.\n   Keeps track of the binders in the environment that have been rewrittten\n   to avoid variable capture or spec binder shadowing.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Rename",
          "name": "Sub",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "data"
        },
        "index": {
          "description": "Substitution state Keeps track of the binders in the environment that have been rewrittten to avoid variable capture or spec binder shadowing",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "Sub",
          "package": "ddc-core",
          "partial": "Sub",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#t:Sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "BindStack",
          "package": "ddc-core",
          "signature": "BindStack",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:BindStack\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:BindStack\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:BindStack\"]"
        },
        "index": {
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "BindStack",
          "package": "ddc-core",
          "partial": "Bind Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:BindStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "Sub",
          "package": "ddc-core",
          "signature": "Sub",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:Sub\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:Sub\"]"
        },
        "index": {
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "Sub",
          "package": "ddc-core",
          "partial": "Sub",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:Sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush a level-0 binder on the rewrite stack.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "bind0",
          "package": "ddc-core",
          "signature": "Sub n -\u003e Bind n -\u003e (Sub n, Bind n)",
          "source": "src/DDC-Type-Transform-Rename.html#bind0",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind0\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:bind0\"]"
        },
        "index": {
          "description": "Push level-0 binder on the rewrite stack",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "bind0",
          "normalized": "Sub a-\u003eBind a-\u003e(Sub a,Bind a)",
          "package": "ddc-core",
          "signature": "Sub n-\u003eBind n-\u003e(Sub n,Bind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush some level-0 binders on the rewrite stack.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "bind0s",
          "package": "ddc-core",
          "signature": "Sub n -\u003e [Bind n] -\u003e (Sub n, [Bind n])",
          "source": "src/DDC-Type-Transform-Rename.html#bind0s",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind0s\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:bind0s\"]"
        },
        "index": {
          "description": "Push some level-0 binders on the rewrite stack",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "bind0s",
          "normalized": "Sub a-\u003e[Bind a]-\u003e(Sub a,[Bind a])",
          "package": "ddc-core",
          "signature": "Sub n-\u003e[Bind n]-\u003e(Sub n,[Bind n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind0s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush a level-1 binder on the rewrite stack.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "bind1",
          "package": "ddc-core",
          "signature": "Sub n -\u003e Bind n -\u003e (Sub n, Bind n)",
          "source": "src/DDC-Type-Transform-Rename.html#bind1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind1\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:bind1\"]"
        },
        "index": {
          "description": "Push level-1 binder on the rewrite stack",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "bind1",
          "normalized": "Sub a-\u003eBind a-\u003e(Sub a,Bind a)",
          "package": "ddc-core",
          "signature": "Sub n-\u003eBind n-\u003e(Sub n,Bind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush some level-1 binders on the rewrite stack.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "bind1s",
          "package": "ddc-core",
          "signature": "Sub n -\u003e [Bind n] -\u003e (Sub n, [Bind n])",
          "source": "src/DDC-Type-Transform-Rename.html#bind1s",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind1s\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:bind1s\"]"
        },
        "index": {
          "description": "Push some level-1 binders on the rewrite stack",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "bind1s",
          "normalized": "Sub a-\u003e[Bind a]-\u003e(Sub a,[Bind a])",
          "package": "ddc-core",
          "signature": "Sub n-\u003e[Bind n]-\u003e(Sub n,[Bind n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:bind1s"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush a bind onto a bind stack, \n   anonymizing it if need be to avoid variable capture.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "pushBind",
          "package": "ddc-core",
          "signature": "Set n-\u003e BindStack n-\u003e Bind n-\u003e (BindStack n, Bind n)",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:pushBind\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:pushBind\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:pushBind\"]"
        },
        "index": {
          "description": "Push bind onto bind stack anonymizing it if need be to avoid variable capture",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "pushBind",
          "normalized": "Set a-\u003eBindStack a-\u003eBind a-\u003e(BindStack a,Bind a)",
          "package": "ddc-core",
          "partial": "Bind",
          "signature": "Set n-\u003eBindStack n-\u003eBind n-\u003e(BindStack n,Bind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:pushBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePush several binds onto the bind stack,\n   anonymyzing them if need be to avoid variable capture.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "pushBinds",
          "package": "ddc-core",
          "signature": "Set n -\u003e BindStack n -\u003e [Bind n] -\u003e (BindStack n, [Bind n])",
          "source": "src/DDC-Type-Transform-Rename.html#pushBinds",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:pushBinds\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:pushBinds\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:pushBinds\"]"
        },
        "index": {
          "description": "Push several binds onto the bind stack anonymyzing them if need be to avoid variable capture",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "pushBinds",
          "normalized": "Set a-\u003eBindStack a-\u003e[Bind a]-\u003e(BindStack a,[Bind a])",
          "package": "ddc-core",
          "partial": "Binds",
          "signature": "Set n-\u003eBindStack n-\u003e[Bind n]-\u003e(BindStack n,[Bind n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:pushBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite names in some thing to anonymous form if they conflict with\n    any names in the \u003ccode\u003e\u003ca\u003eSub\u003c/a\u003e\u003c/code\u003e state. We use this to avoid variable capture\n    during substitution.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Rename",
          "name": "renameWith",
          "package": "ddc-core",
          "signature": "Sub n -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-Rename.html#renameWith",
          "type": "method"
        },
        "index": {
          "description": "Rewrite names in some thing to anonymous form if they conflict with any names in the Sub state We use this to avoid variable capture during substitution",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "renameWith",
          "normalized": "Sub a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "With",
          "signature": "Sub n-\u003ec n-\u003ec n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:renameWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHolds all binders, independent of whether they are being rewritten or not.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "stackAll",
          "package": "ddc-core",
          "signature": "[Bind n]",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackAll\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:stackAll\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:stackAll\"]"
        },
        "index": {
          "description": "Holds all binders independent of whether they are being rewritten or not",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "stackAll",
          "normalized": "[Bind a]",
          "package": "ddc-core",
          "partial": "All",
          "signature": "[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of \u003ccode\u003e\u003ca\u003eBAnon\u003c/a\u003e\u003c/code\u003e in \u003ccode\u003e\u003ca\u003estackBinds\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "stackAnons",
          "package": "ddc-core",
          "signature": "Int",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackAnons\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:stackAnons\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:stackAnons\"]"
        },
        "index": {
          "description": "Number of BAnon in stackBinds",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "stackAnons",
          "package": "ddc-core",
          "partial": "Anons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackAnons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHolds anonymous binders that were already in the program,\n   as well as named binders that are being rewritten to anonymous ones.\n   In the resulting expression all these binders will be anonymous.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "stackBinds",
          "package": "ddc-core",
          "signature": "[Bind n]",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackBinds\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:stackBinds\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:stackBinds\"]"
        },
        "index": {
          "description": "Holds anonymous binders that were already in the program as well as named binders that are being rewritten to anonymous ones In the resulting expression all these binders will be anonymous",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "stackBinds",
          "normalized": "[Bind a]",
          "package": "ddc-core",
          "partial": "Binds",
          "signature": "[Bind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of \u003ccode\u003e\u003ca\u003eBName\u003c/a\u003e\u003c/code\u003e in \u003ccode\u003e\u003ca\u003estackBinds\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "stackNamed",
          "package": "ddc-core",
          "signature": "Int",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackNamed\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:stackNamed\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:stackNamed\"]"
        },
        "index": {
          "description": "Number of BName in stackBinds",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "stackNamed",
          "package": "ddc-core",
          "partial": "Named",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:stackNamed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBound variable that we're substituting for.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "subBound",
          "package": "ddc-core",
          "signature": "(Bound n)",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subBound\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:subBound\"]"
        },
        "index": {
          "description": "Bound variable that we re substituting for",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "subBound",
          "package": "ddc-core",
          "partial": "Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLevel-0 names that need to be rewritten to avoid capture.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "subConflict0",
          "package": "ddc-core",
          "signature": "(Set n)",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subConflict0\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:subConflict0\"]"
        },
        "index": {
          "description": "Level-0 names that need to be rewritten to avoid capture",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "subConflict0",
          "package": "ddc-core",
          "partial": "Conflict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subConflict0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLevel-1 names that need to be rewritten to avoid capture.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "subConflict1",
          "package": "ddc-core",
          "signature": "(Set n)",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subConflict1\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:subConflict1\"]"
        },
        "index": {
          "description": "Level-1 names that need to be rewritten to avoid capture",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "subConflict1",
          "package": "ddc-core",
          "partial": "Conflict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subConflict1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe've decended past a binder that shadows the one that we're\n   substituting for. We're no longer substituting, but still may\n   need to anonymise variables in types. \n   This can only happen for level-0 named binders.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "subShadow0",
          "package": "ddc-core",
          "signature": "Bool",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subShadow0\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:subShadow0\"]"
        },
        "index": {
          "description": "We ve decended past binder that shadows the one that we re substituting for We re no longer substituting but still may need to anonymise variables in types This can only happen for level-0 named binders",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "subShadow0",
          "package": "ddc-core",
          "partial": "Shadow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subShadow0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewriting stack for level-0 names.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "subStack0",
          "package": "ddc-core",
          "signature": "(BindStack n)",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subStack0\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:subStack0\"]"
        },
        "index": {
          "description": "Rewriting stack for level-0 names",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "subStack0",
          "package": "ddc-core",
          "partial": "Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subStack0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewriting stack for level-1 names.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "subStack1",
          "package": "ddc-core",
          "signature": "(BindStack n)",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subStack1\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:subStack1\"]"
        },
        "index": {
          "description": "Rewriting stack for level-1 names",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "subStack1",
          "package": "ddc-core",
          "partial": "Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:subStack1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare a \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003e against the one we're substituting for.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\",\"DDC.Type.Transform.SubstituteT\"]",
          "name": "substBound",
          "package": "ddc-core",
          "signature": "BindStack n-\u003e Bound n-\u003e Bound n-\u003e Either (Bound n) Int",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:substBound\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:substBound\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:substBound\"]"
        },
        "index": {
          "description": "Compare Bound against the one we re substituting for",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "substBound",
          "normalized": "BindStack a-\u003eBound a-\u003eBound a-\u003eEither(Bound a)Int",
          "package": "ddc-core",
          "partial": "Bound",
          "signature": "BindStack n-\u003eBound n-\u003eBound n-\u003eEither(Bound n)Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:substBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite the use of a level-0 binder if need be.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "use0",
          "package": "ddc-core",
          "signature": "Sub n -\u003e Bound n -\u003e Bound n",
          "source": "src/DDC-Type-Transform-Rename.html#use0",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:use0\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:use0\"]"
        },
        "index": {
          "description": "Rewrite the use of level-0 binder if need be",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "use0",
          "normalized": "Sub a-\u003eBound a-\u003eBound a",
          "package": "ddc-core",
          "signature": "Sub n-\u003eBound n-\u003eBound n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:use0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite the use of a level-1 binder if need be.\n\u003c/p\u003e",
          "module": "[\"DDC.Core.Transform.Rename\",\"DDC.Type.Transform.Rename\"]",
          "name": "use1",
          "package": "ddc-core",
          "signature": "Sub n -\u003e Bound n -\u003e Bound n",
          "source": "src/DDC-Type-Transform-Rename.html#use1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:use1\",\"http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:use1\"]"
        },
        "index": {
          "description": "Rewrite the use of level-1 binder if need be",
          "hierarchy": "DDC Core Transform Rename",
          "module": "DDC.Core.Transform.Rename",
          "name": "use1",
          "normalized": "Sub a-\u003eBound a-\u003eBound a",
          "package": "ddc-core",
          "signature": "Sub n-\u003eBound n-\u003eBound n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Rename.html#v:use1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SpreadX",
          "name": "SpreadX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SpreadX.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Core Transform SpreadX",
          "module": "DDC.Core.Transform.SpreadX",
          "name": "SpreadX",
          "package": "ddc-core",
          "partial": "Spread",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SpreadX.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SpreadX",
          "name": "SpreadX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SpreadX.html#SpreadX",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Transform SpreadX",
          "module": "DDC.Core.Transform.SpreadX",
          "name": "SpreadX",
          "package": "ddc-core",
          "partial": "Spread",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SpreadX.html#t:SpreadX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpread type annotations from binders and the environment into bound\n   occurrences of variables and constructors.\n\u003c/p\u003e\u003cp\u003eAlso convert \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003e\u003ca\u003eUPrim\u003c/a\u003e\u003c/code\u003e form if the environment says that\n   they are primitive.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SpreadX",
          "name": "spreadX",
          "package": "ddc-core",
          "signature": "Env n -\u003e Env n -\u003e c n -\u003e c n",
          "source": "src/DDC-Core-Transform-SpreadX.html#spreadX",
          "type": "method"
        },
        "index": {
          "description": "Spread type annotations from binders and the environment into bound occurrences of variables and constructors Also convert Bound to UPrim form if the environment says that they are primitive",
          "hierarchy": "DDC Core Transform SpreadX",
          "module": "DDC.Core.Transform.SpreadX",
          "name": "spreadX",
          "normalized": "Env a-\u003eEnv a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "signature": "Env n-\u003eEnv n-\u003ec n-\u003ec n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SpreadX.html#v:spreadX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCapture avoiding substitution of types in expressions. \n\u003c/p\u003e\u003cp\u003eIf a binder would capture a variable then it is anonymized\n   to deBruijn form.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "SubstituteTX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SubstituteTX.html",
          "type": "module"
        },
        "index": {
          "description": "Capture avoiding substitution of types in expressions If binder would capture variable then it is anonymized to deBruijn form",
          "hierarchy": "DDC Core Transform SubstituteTX",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "SubstituteTX",
          "package": "ddc-core",
          "partial": "Substitute TX",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteTX.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "SubstituteTX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SubstituteTX.html#SubstituteTX",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Transform SubstituteTX",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "SubstituteTX",
          "package": "ddc-core",
          "partial": "Substitute TX",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteTX.html#t:SubstituteTX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute a \u003ccode\u003e\u003ca\u003eType\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003e in some thing.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteBoundTX",
          "package": "ddc-core",
          "signature": "Bound n -\u003e Type n -\u003e c n -\u003e c n",
          "source": "src/DDC-Core-Transform-SubstituteTX.html#substituteBoundTX",
          "type": "function"
        },
        "index": {
          "description": "Substitute Type for Bound in some thing",
          "hierarchy": "DDC Core Transform SubstituteTX",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteBoundTX",
          "normalized": "Bound a-\u003eType a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "Bound TX",
          "signature": "Bound n-\u003eType n-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteTX.html#v:substituteBoundTX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute a \u003ccode\u003e\u003ca\u003eType\u003c/a\u003e\u003c/code\u003e for the \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003e corresponding to some \u003ccode\u003e\u003ca\u003eBind\u003c/a\u003e\u003c/code\u003e in a thing.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteTX",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Type n -\u003e c n -\u003e c n",
          "source": "src/DDC-Core-Transform-SubstituteTX.html#substituteTX",
          "type": "function"
        },
        "index": {
          "description": "Substitute Type for the Bound corresponding to some Bind in thing",
          "hierarchy": "DDC Core Transform SubstituteTX",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteTX",
          "normalized": "Bind a-\u003eType a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "TX",
          "signature": "Bind n-\u003eType n-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteTX.html#v:substituteTX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003esubstituteT\u003c/a\u003e\u003c/code\u003e to substitute multiple types.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteTXs",
          "package": "ddc-core",
          "signature": "[(Bind n, Type n)] -\u003e c n -\u003e c n",
          "source": "src/DDC-Core-Transform-SubstituteTX.html#substituteTXs",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for substituteT to substitute multiple types",
          "hierarchy": "DDC Core Transform SubstituteTX",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteTXs",
          "normalized": "[(Bind a,Type a)]-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "TXs",
          "signature": "[(Bind n,Type n)]-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteTX.html#v:substituteTXs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteWithTX",
          "package": "ddc-core",
          "signature": "Type n -\u003e Sub n -\u003e c n -\u003e c n",
          "source": "src/DDC-Core-Transform-SubstituteTX.html#substituteWithTX",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Core Transform SubstituteTX",
          "module": "DDC.Core.Transform.SubstituteTX",
          "name": "substituteWithTX",
          "normalized": "Type a-\u003eSub a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "With TX",
          "signature": "Type n-\u003eSub n-\u003ec n-\u003ec n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteTX.html#v:substituteWithTX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCapture avoiding substitution of witnesses in expressions.\n\u003c/p\u003e\u003cp\u003eIf a binder would capture a variable then it is anonymized\n   to deBruijn form.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "SubstituteWX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SubstituteWX.html",
          "type": "module"
        },
        "index": {
          "description": "Capture avoiding substitution of witnesses in expressions If binder would capture variable then it is anonymized to deBruijn form",
          "hierarchy": "DDC Core Transform SubstituteWX",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "SubstituteWX",
          "package": "ddc-core",
          "partial": "Substitute WX",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteWX.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "SubstituteWX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SubstituteWX.html#SubstituteWX",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Transform SubstituteWX",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "SubstituteWX",
          "package": "ddc-core",
          "partial": "Substitute WX",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteWX.html#t:SubstituteWX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003esubstituteWithWX\u003c/a\u003e\u003c/code\u003e that determines the set of free names in the\n   type being substituted, and starts with an empty binder stack.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "substituteWX",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Witness a n -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteWX.html#substituteWX",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for substituteWithWX that determines the set of free names in the type being substituted and starts with an empty binder stack",
          "hierarchy": "DDC Core Transform SubstituteWX",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "substituteWX",
          "normalized": "Bind a-\u003eWitness b a-\u003ec b a-\u003ec b a",
          "package": "ddc-core",
          "partial": "WX",
          "signature": "Bind n-\u003eWitness a n-\u003ec a n-\u003ec a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteWX.html#v:substituteWX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003esubstituteWithWX\u003c/a\u003e\u003c/code\u003e to substitute multiple things.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "substituteWXs",
          "package": "ddc-core",
          "signature": "[(Bind n, Witness a n)] -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteWX.html#substituteWXs",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for substituteWithWX to substitute multiple things",
          "hierarchy": "DDC Core Transform SubstituteWX",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "substituteWXs",
          "normalized": "[(Bind a,Witness b a)]-\u003ec b a-\u003ec b a",
          "package": "ddc-core",
          "partial": "WXs",
          "signature": "[(Bind n,Witness a n)]-\u003ec a n-\u003ec a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteWX.html#v:substituteWXs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "substituteWithWX",
          "package": "ddc-core",
          "signature": "Witness a n -\u003e Sub n -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteWX.html#substituteWithWX",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Core Transform SubstituteWX",
          "module": "DDC.Core.Transform.SubstituteWX",
          "name": "substituteWithWX",
          "normalized": "Witness a b-\u003eSub b-\u003ec a b-\u003ec a b",
          "package": "ddc-core",
          "partial": "With WX",
          "signature": "Witness a n-\u003eSub n-\u003ec a n-\u003ec a n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteWX.html#v:substituteWithWX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCapture avoiding substitution of expressions in expressions.\n\u003c/p\u003e\u003cp\u003eIf a binder would capture a variable then it is anonymized\n   to deBruijn form.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "SubstituteXX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SubstituteXX.html",
          "type": "module"
        },
        "index": {
          "description": "Capture avoiding substitution of expressions in expressions If binder would capture variable then it is anonymized to deBruijn form",
          "hierarchy": "DDC Core Transform SubstituteXX",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "SubstituteXX",
          "package": "ddc-core",
          "partial": "Substitute XX",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteXX.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "SubstituteXX",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-SubstituteXX.html#SubstituteXX",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Core Transform SubstituteXX",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "SubstituteXX",
          "package": "ddc-core",
          "partial": "Substitute XX",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteXX.html#t:SubstituteXX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteWithXX",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Sub n -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteXX.html#substituteWithXX",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Core Transform SubstituteXX",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteWithXX",
          "normalized": "Exp a b-\u003eSub b-\u003ec a b-\u003ec a b",
          "package": "ddc-core",
          "partial": "With XX",
          "signature": "Exp a n-\u003eSub n-\u003ec a n-\u003ec a n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteXX.html#v:substituteWithXX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute the argument of an application into an expression.\n   Perform type substitution for an \u003ccode\u003e\u003ca\u003eXType\u003c/a\u003e\u003c/code\u003e \n    and witness substitution for an \u003ccode\u003e\u003ca\u003eXWitness\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXArg",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Exp a n -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteXX.html#substituteXArg",
          "type": "function"
        },
        "index": {
          "description": "Substitute the argument of an application into an expression Perform type substitution for an XType and witness substitution for an XWitness",
          "hierarchy": "DDC Core Transform SubstituteXX",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXArg",
          "normalized": "Bind a-\u003eExp b a-\u003ec b a-\u003ec b a",
          "package": "ddc-core",
          "partial": "XArg",
          "signature": "Bind n-\u003eExp a n-\u003ec a n-\u003ec a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteXX.html#v:substituteXArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003esubstituteXArgs\u003c/a\u003e\u003c/code\u003e to substitute multiple arguments.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXArgs",
          "package": "ddc-core",
          "signature": "[(Bind n, Exp a n)] -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteXX.html#substituteXArgs",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for substituteXArgs to substitute multiple arguments",
          "hierarchy": "DDC Core Transform SubstituteXX",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXArgs",
          "normalized": "[(Bind a,Exp b a)]-\u003ec b a-\u003ec b a",
          "package": "ddc-core",
          "partial": "XArgs",
          "signature": "[(Bind n,Exp a n)]-\u003ec a n-\u003ec a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteXX.html#v:substituteXArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003esubstituteWithX\u003c/code\u003e that determines the set of free names in the\n   expression being substituted, and starts with an empty binder stack.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXX",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Exp a n -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteXX.html#substituteXX",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for substituteWithX that determines the set of free names in the expression being substituted and starts with an empty binder stack",
          "hierarchy": "DDC Core Transform SubstituteXX",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXX",
          "normalized": "Bind a-\u003eExp b a-\u003ec b a-\u003ec b a",
          "package": "ddc-core",
          "partial": "XX",
          "signature": "Bind n-\u003eExp a n-\u003ec a n-\u003ec a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteXX.html#v:substituteXX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003esubstituteX\u003c/code\u003e to substitute multiple expressions.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXXs",
          "package": "ddc-core",
          "signature": "[(Bind n, Exp a n)] -\u003e c a n -\u003e c a n",
          "source": "src/DDC-Core-Transform-SubstituteXX.html#substituteXXs",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for substituteX to substitute multiple expressions",
          "hierarchy": "DDC Core Transform SubstituteXX",
          "module": "DDC.Core.Transform.SubstituteXX",
          "name": "substituteXXs",
          "normalized": "[(Bind a,Exp b a)]-\u003ec b a-\u003ec b a",
          "package": "ddc-core",
          "partial": "XXs",
          "signature": "[(Bind n,Exp a n)]-\u003ec a n-\u003ec a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-SubstituteXX.html#v:substituteXXs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTrim the expressions passed to \u003ccode\u003eweakclo\u003c/code\u003e casts to just those terms\n   that can affect the closure of the body. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Core.Transform.Trim",
          "name": "Trim",
          "package": "ddc-core",
          "source": "src/DDC-Core-Transform-Trim.html",
          "type": "module"
        },
        "index": {
          "description": "Trim the expressions passed to weakclo casts to just those terms that can affect the closure of the body",
          "hierarchy": "DDC Core Transform Trim",
          "module": "DDC.Core.Transform.Trim",
          "name": "Trim",
          "package": "ddc-core",
          "partial": "Trim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Trim.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrim the expressions of a weaken closure \u003ccode\u003e(XCast CastWeakenClosure)\u003c/code\u003e\n   into only the free variables.\n\u003c/p\u003e\u003cp\u003eFor example,\n    \u003ccode\u003etrimClosures [build (k z. something k), else]\n       = [build, something, else]\n    \u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Trim",
          "name": "trimClosures",
          "package": "ddc-core",
          "signature": "a -\u003e [Exp a n] -\u003e [Exp a n]",
          "source": "src/DDC-Core-Transform-Trim.html#trimClosures",
          "type": "function"
        },
        "index": {
          "description": "Trim the expressions of weaken closure XCast CastWeakenClosure into only the free variables For example trimClosures build something else build something else",
          "hierarchy": "DDC Core Transform Trim",
          "module": "DDC.Core.Transform.Trim",
          "name": "trimClosures",
          "normalized": "a-\u003e[Exp a b]-\u003e[Exp a b]",
          "package": "ddc-core",
          "partial": "Closures",
          "signature": "a-\u003e[Exp a n]-\u003e[Exp a n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Trim.html#v:trimClosures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrim an expression if it is a \u003ccode\u003eweakclo\u003c/code\u003e cast. \n\u003c/p\u003e\u003cp\u003eNon-recursive version. If you want to recursively trim closures,\n   use \u003ccode\u003etransformUpX' (const trimX)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Core.Transform.Trim",
          "name": "trimX",
          "package": "ddc-core",
          "signature": "Exp a n -\u003e Exp a n",
          "source": "src/DDC-Core-Transform-Trim.html#trimX",
          "type": "function"
        },
        "index": {
          "description": "Trim an expression if it is weakclo cast Non-recursive version If you want to recursively trim closures use transformUpX const trimX",
          "hierarchy": "DDC Core Transform Trim",
          "module": "DDC.Core.Transform.Trim",
          "name": "trimX",
          "normalized": "Exp a b-\u003eExp a b",
          "package": "ddc-core",
          "signature": "Exp a n-\u003eExp a n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Core-Transform-Trim.html#v:trimX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Bind",
          "name": "Bind",
          "package": "ddc-core",
          "source": "src/DDC-Type-Bind.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Bind",
          "module": "DDC.Type.Bind",
          "name": "Bind",
          "package": "ddc-core",
          "partial": "Bind",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Bind.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup the type of a bound thing from the binder stack.\n   The binder stack contains the binders of all the \u003ccode\u003e\u003ca\u003eTForall\u003c/a\u003e\u003c/code\u003es we've\n   entered under so far.\n\u003c/p\u003e",
          "module": "DDC.Type.Bind",
          "name": "getBindType",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e Bound n -\u003e Maybe (Int, Type n)",
          "source": "src/DDC-Type-Bind.html#getBindType",
          "type": "function"
        },
        "index": {
          "description": "Lookup the type of bound thing from the binder stack The binder stack contains the binders of all the TForall we ve entered under so far",
          "hierarchy": "DDC Type Bind",
          "module": "DDC.Type.Bind",
          "name": "getBindType",
          "normalized": "[Bind a]-\u003eBound a-\u003eMaybe(Int,Type a)",
          "package": "ddc-core",
          "partial": "Bind Type",
          "signature": "[Bind n]-\u003eBound n-\u003eMaybe(Int,Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Bind.html#v:getBindType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCheck the kind of a type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Check",
          "name": "Check",
          "package": "ddc-core",
          "source": "src/DDC-Type-Check.html",
          "type": "module"
        },
        "index": {
          "description": "Check the kind of type",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "Check",
          "package": "ddc-core",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatic configuration for the type checker.\n   These fields don't change as we decend into the tree.\n\u003c/p\u003e\u003cp\u003eThe starting configuration should be converted from the profile that\n   defines the language fragment you are checking. \n   See \u003ca\u003eDDC.Core.Fragment\u003c/a\u003e and use \u003ccode\u003e\u003ca\u003econfigOfProfile\u003c/a\u003e\u003c/code\u003e below.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "Config",
          "package": "ddc-core",
          "source": "src/DDC-Type-Check-Config.html#Config",
          "type": "data"
        },
        "index": {
          "description": "Static configuration for the type checker These fields don change as we decend into the tree The starting configuration should be converted from the profile that defines the language fragment you are checking See DDC.Core.Fragment and use configOfProfile below",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "Config",
          "package": "ddc-core",
          "partial": "Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#t:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThings that can go wrong when checking the kind of at type.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "Error",
          "package": "ddc-core",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "data"
        },
        "index": {
          "description": "Things that can go wrong when checking the kind of at type",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "Error",
          "package": "ddc-core",
          "partial": "Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#t:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type application where the parameter and argument kinds don't match.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorAppArgMismatch",
          "package": "ddc-core",
          "signature": "ErrorAppArgMismatch",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "type application where the parameter and argument kinds don match",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorAppArgMismatch",
          "package": "ddc-core",
          "partial": "Error App Arg Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorAppArgMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type application where the thing being applied is not a function.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorAppNotFun",
          "package": "ddc-core",
          "signature": "ErrorAppNotFun",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "type application where the thing being applied is not function",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorAppNotFun",
          "package": "ddc-core",
          "partial": "Error App Not Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorAppNotFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA forall where the body does not have data or witness kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorForallKindInvalid",
          "package": "ddc-core",
          "signature": "ErrorForallKindInvalid",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "forall where the body does not have data or witness kind",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorForallKindInvalid",
          "package": "ddc-core",
          "partial": "Error Forall Kind Invalid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorForallKindInvalid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound a naked sort constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorNakedSort",
          "package": "ddc-core",
          "signature": "ErrorNakedSort",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found naked sort constructor",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorNakedSort",
          "package": "ddc-core",
          "partial": "Error Naked Sort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorNakedSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type sum that does not have effect or closure kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorSumKindInvalid",
          "package": "ddc-core",
          "signature": "ErrorSumKindInvalid",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "type sum that does not have effect or closure kind",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorSumKindInvalid",
          "package": "ddc-core",
          "partial": "Error Sum Kind Invalid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorSumKindInvalid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type sum where the components have differing kinds.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorSumKindMismatch",
          "package": "ddc-core",
          "signature": "ErrorSumKindMismatch",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "type sum where the components have differing kinds",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorSumKindMismatch",
          "package": "ddc-core",
          "partial": "Error Sum Kind Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorSumKindMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFound an unapplied kind function constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorUnappliedKindFun",
          "package": "ddc-core",
          "signature": "ErrorUnappliedKindFun",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "Found an unapplied kind function constructor",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorUnappliedKindFun",
          "package": "ddc-core",
          "partial": "Error Unapplied Kind Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorUnappliedKindFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn undefined type variable.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorUndefined",
          "package": "ddc-core",
          "signature": "ErrorUndefined",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "An undefined type variable",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorUndefined",
          "package": "ddc-core",
          "partial": "Error Undefined",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorUndefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn undefined type constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorUndefinedCtor",
          "package": "ddc-core",
          "signature": "ErrorUndefinedCtor",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "An undefined type constructor",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorUndefinedCtor",
          "package": "ddc-core",
          "partial": "Error Undefined Ctor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorUndefinedCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe kind annotation on the variables does not match the one in the environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorVarAnnotMismatch",
          "package": "ddc-core",
          "signature": "ErrorVarAnnotMismatch",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "The kind annotation on the variables does not match the one in the environment",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorVarAnnotMismatch",
          "package": "ddc-core",
          "partial": "Error Var Annot Mismatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorVarAnnotMismatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA witness implication where the premise or conclusion has an invalid kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "ErrorWitnessImplInvalid",
          "package": "ddc-core",
          "signature": "ErrorWitnessImplInvalid",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "description": "witness implication where the premise or conclusion has an invalid kind",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "ErrorWitnessImplInvalid",
          "package": "ddc-core",
          "partial": "Error Witness Impl Invalid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:ErrorWitnessImplInvalid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck a type in the given environment, returning an error or its kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "checkType",
          "package": "ddc-core",
          "signature": "Config n -\u003e KindEnv n -\u003e Type n -\u003e Either (Error n) (Kind n)",
          "source": "src/DDC-Type-Check.html#checkType",
          "type": "function"
        },
        "index": {
          "description": "Check type in the given environment returning an error or its kind",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "checkType",
          "normalized": "Config a-\u003eKindEnv a-\u003eType a-\u003eEither(Error a)(Kind a)",
          "package": "ddc-core",
          "partial": "Type",
          "signature": "Config n-\u003eKindEnv n-\u003eType n-\u003eEither(Error n)(Kind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:checkType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorArgKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorArgKind",
          "package": "ddc-core",
          "partial": "Arg Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorArgKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorArgType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorArgType",
          "package": "ddc-core",
          "partial": "Arg Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorArgType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorArgTypeKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorArgTypeKind",
          "package": "ddc-core",
          "partial": "Arg Type Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorArgTypeKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorBody",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorBody",
          "package": "ddc-core",
          "partial": "Body",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorBound",
          "package": "ddc-core",
          "signature": "Bound n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorBound",
          "package": "ddc-core",
          "partial": "Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorChecking",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorChecking",
          "package": "ddc-core",
          "partial": "Checking",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorChecking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorCheckingSum",
          "package": "ddc-core",
          "signature": "TypeSum n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorCheckingSum",
          "package": "ddc-core",
          "partial": "Checking Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorCheckingSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorFunType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorFunType",
          "package": "ddc-core",
          "partial": "Fun Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorFunType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorFunTypeKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorFunTypeKind",
          "package": "ddc-core",
          "partial": "Fun Type Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorFunTypeKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorKind",
          "package": "ddc-core",
          "partial": "Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorKindExpected",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorKindExpected",
          "package": "ddc-core",
          "partial": "Kind Expected",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorKindExpected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorKinds",
          "package": "ddc-core",
          "signature": "[Kind n]",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorKinds",
          "normalized": "[Kind a]",
          "package": "ddc-core",
          "partial": "Kinds",
          "signature": "[Kind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorLeftKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorLeftKind",
          "package": "ddc-core",
          "partial": "Left Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorLeftKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorLeftType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorLeftType",
          "package": "ddc-core",
          "partial": "Left Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorLeftType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorParamKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorParamKind",
          "package": "ddc-core",
          "partial": "Param Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorParamKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorRightKind",
          "package": "ddc-core",
          "signature": "Kind n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorRightKind",
          "package": "ddc-core",
          "partial": "Right Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorRightKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorRightType",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorRightType",
          "package": "ddc-core",
          "partial": "Right Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorRightType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorSort",
          "package": "ddc-core",
          "signature": "Sort n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorSort",
          "package": "ddc-core",
          "partial": "Sort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorTypeEnv",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorTypeEnv",
          "package": "ddc-core",
          "partial": "Type Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorTypeEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Check",
          "name": "errorTypeSum",
          "package": "ddc-core",
          "signature": "TypeSum n",
          "source": "src/DDC-Type-Check-Error.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "errorTypeSum",
          "package": "ddc-core",
          "partial": "Type Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:errorTypeSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the kind of a computation type constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "kindOfTcCon",
          "package": "ddc-core",
          "signature": "TcCon -\u003e Kind n",
          "source": "src/DDC-Type-Check-CheckCon.html#kindOfTcCon",
          "type": "function"
        },
        "index": {
          "description": "Take the kind of computation type constructor",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "kindOfTcCon",
          "normalized": "TcCon-\u003eKind a",
          "package": "ddc-core",
          "partial": "Of Tc Con",
          "signature": "TcCon-\u003eKind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:kindOfTcCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the kind of a witness type constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "kindOfTwCon",
          "package": "ddc-core",
          "signature": "TwCon -\u003e Kind n",
          "source": "src/DDC-Type-Check-CheckCon.html#kindOfTwCon",
          "type": "function"
        },
        "index": {
          "description": "Take the kind of witness type constructor",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "kindOfTwCon",
          "normalized": "TwCon-\u003eKind a",
          "package": "ddc-core",
          "partial": "Of Tw Con",
          "signature": "TwCon-\u003eKind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:kindOfTwCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck a type in an empty environment, returning an error or its kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "kindOfType",
          "package": "ddc-core",
          "signature": "Config n -\u003e Type n -\u003e Either (Error n) (Kind n)",
          "source": "src/DDC-Type-Check.html#kindOfType",
          "type": "function"
        },
        "index": {
          "description": "Check type in an empty environment returning an error or its kind",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "kindOfType",
          "normalized": "Config a-\u003eType a-\u003eEither(Error a)(Kind a)",
          "package": "ddc-core",
          "partial": "Of Type",
          "signature": "Config n-\u003eType n-\u003eEither(Error n)(Kind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:kindOfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the superkind of an atomic kind constructor.\n\u003c/p\u003e\u003cp\u003eYields \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for the kind function (~\u003e) as it doesn't have a sort\n   without being fully applied.\n\u003c/p\u003e",
          "module": "DDC.Type.Check",
          "name": "takeSortOfKiCon",
          "package": "ddc-core",
          "signature": "KiCon -\u003e Maybe (Sort n)",
          "source": "src/DDC-Type-Check-CheckCon.html#takeSortOfKiCon",
          "type": "function"
        },
        "index": {
          "description": "Take the superkind of an atomic kind constructor Yields Nothing for the kind function as it doesn have sort without being fully applied",
          "hierarchy": "DDC Type Check",
          "module": "DDC.Type.Check",
          "name": "takeSortOfKiCon",
          "normalized": "KiCon-\u003eMaybe(Sort a)",
          "package": "ddc-core",
          "partial": "Sort Of Ki Con",
          "signature": "KiCon-\u003eMaybe(Sort n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Check.html#v:takeSortOfKiCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCollecting sets of variables and constructors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Collect",
          "name": "Collect",
          "package": "ddc-core",
          "source": "src/DDC-Type-Collect.html",
          "type": "module"
        },
        "index": {
          "description": "Collecting sets of variables and constructors",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "Collect",
          "package": "ddc-core",
          "partial": "Collect",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindStruct",
          "package": "ddc-core",
          "source": "src/DDC-Type-Collect.html#BindStruct",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindStruct",
          "package": "ddc-core",
          "partial": "Bind Struct",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#t:BindStruct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA description of the binding structure of some type or expression.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "BindTree",
          "package": "ddc-core",
          "source": "src/DDC-Type-Collect.html#BindTree",
          "type": "data"
        },
        "index": {
          "description": "description of the binding structure of some type or expression",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindTree",
          "package": "ddc-core",
          "partial": "Bind Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#t:BindTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes how a variable was bound.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "BindWay",
          "package": "ddc-core",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "data"
        },
        "index": {
          "description": "Describes how variable was bound",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindWay",
          "package": "ddc-core",
          "partial": "Bind Way",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#t:BindWay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat level this binder is at.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "BoundLevel",
          "package": "ddc-core",
          "source": "src/DDC-Type-Collect.html#BoundLevel",
          "type": "data"
        },
        "index": {
          "description": "What level this binder is at",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BoundLevel",
          "package": "ddc-core",
          "partial": "Bound Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#t:BoundLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindCasePat",
          "package": "ddc-core",
          "signature": "BindCasePat",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindCasePat",
          "package": "ddc-core",
          "partial": "Bind Case Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindCasePat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse of a constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "BindCon",
          "package": "ddc-core",
          "signature": "BindCon BoundLevel (Bound n) (Maybe (Kind n))",
          "source": "src/DDC-Type-Collect.html#BindTree",
          "type": "function"
        },
        "index": {
          "description": "Use of constructor",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindCon",
          "package": "ddc-core",
          "partial": "Bind Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn abstract binding expression.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "BindDef",
          "package": "ddc-core",
          "signature": "BindDef BindWay [Bind n] [BindTree n]",
          "source": "src/DDC-Type-Collect.html#BindTree",
          "type": "function"
        },
        "index": {
          "description": "An abstract binding expression",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindDef",
          "normalized": "BindDef BindWay[Bind a][BindTree a]",
          "package": "ddc-core",
          "partial": "Bind Def",
          "signature": "BindDef BindWay[Bind n][BindTree n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindForall",
          "package": "ddc-core",
          "signature": "BindForall",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindForall",
          "package": "ddc-core",
          "partial": "Bind Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindForall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindLAM",
          "package": "ddc-core",
          "signature": "BindLAM",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindLAM",
          "package": "ddc-core",
          "partial": "Bind LAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindLAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindLam",
          "package": "ddc-core",
          "signature": "BindLam",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindLam",
          "package": "ddc-core",
          "partial": "Bind Lam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindLam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindLet",
          "package": "ddc-core",
          "signature": "BindLet",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindLet",
          "package": "ddc-core",
          "partial": "Bind Let",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindLetRec",
          "package": "ddc-core",
          "signature": "BindLetRec",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindLetRec",
          "package": "ddc-core",
          "partial": "Bind Let Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindLetRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindLetRegionWith",
          "package": "ddc-core",
          "signature": "BindLetRegionWith",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindLetRegionWith",
          "package": "ddc-core",
          "partial": "Bind Let Region With",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindLetRegionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BindLetRegions",
          "package": "ddc-core",
          "signature": "BindLetRegions",
          "source": "src/DDC-Type-Collect.html#BindWay",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindLetRegions",
          "package": "ddc-core",
          "partial": "Bind Let Regions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindLetRegions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse of a variable.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "BindUse",
          "package": "ddc-core",
          "signature": "BindUse BoundLevel (Bound n)",
          "source": "src/DDC-Type-Collect.html#BindTree",
          "type": "function"
        },
        "index": {
          "description": "Use of variable",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BindUse",
          "package": "ddc-core",
          "partial": "Bind Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BindUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BoundExp",
          "package": "ddc-core",
          "signature": "BoundExp",
          "source": "src/DDC-Type-Collect.html#BoundLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BoundExp",
          "package": "ddc-core",
          "partial": "Bound Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BoundExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BoundSpec",
          "package": "ddc-core",
          "signature": "BoundSpec",
          "source": "src/DDC-Type-Collect.html#BoundLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BoundSpec",
          "package": "ddc-core",
          "partial": "Bound Spec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BoundSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "BoundWit",
          "package": "ddc-core",
          "signature": "BoundWit",
          "source": "src/DDC-Type-Collect.html#BoundLevel",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "BoundWit",
          "package": "ddc-core",
          "partial": "Bound Wit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:BoundWit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper for constructing the \u003ccode\u003e\u003ca\u003eBindTree\u003c/a\u003e\u003c/code\u003e for a type binder.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "bindDefT",
          "package": "ddc-core",
          "signature": "BindWay -\u003e [Bind n] -\u003e [c n] -\u003e BindTree n",
          "source": "src/DDC-Type-Collect.html#bindDefT",
          "type": "function"
        },
        "index": {
          "description": "Helper for constructing the BindTree for type binder",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "bindDefT",
          "normalized": "BindWay-\u003e[Bind a]-\u003e[b a]-\u003eBindTree a",
          "package": "ddc-core",
          "partial": "Def",
          "signature": "BindWay-\u003e[Bind n]-\u003e[c n]-\u003eBindTree n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:bindDefT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the \u003ccode\u003e\u003ca\u003eBoundLevel\u003c/a\u003e\u003c/code\u003e corresponding to a \u003ccode\u003e\u003ca\u003eBindWay\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "boundLevelOfBindWay",
          "package": "ddc-core",
          "signature": "BindWay -\u003e BoundLevel",
          "source": "src/DDC-Type-Collect.html#boundLevelOfBindWay",
          "type": "function"
        },
        "index": {
          "description": "Get the BoundLevel corresponding to BindWay",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "boundLevelOfBindWay",
          "normalized": "BindWay-\u003eBoundLevel",
          "package": "ddc-core",
          "partial": "Level Of Bind Way",
          "signature": "BindWay-\u003eBoundLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:boundLevelOfBindWay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if a boundlevel is expression or witness\n\u003c/p\u003e",
          "module": "DDC.Type.Collect",
          "name": "isBoundExpWit",
          "package": "ddc-core",
          "signature": "BoundLevel -\u003e Bool",
          "source": "src/DDC-Type-Collect.html#isBoundExpWit",
          "type": "function"
        },
        "index": {
          "description": "Check if boundlevel is expression or witness",
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "isBoundExpWit",
          "normalized": "BoundLevel-\u003eBool",
          "package": "ddc-core",
          "partial": "Bound Exp Wit",
          "signature": "BoundLevel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:isBoundExpWit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Collect",
          "name": "slurpBindTree",
          "package": "ddc-core",
          "signature": "c n -\u003e [BindTree n]",
          "source": "src/DDC-Type-Collect.html#slurpBindTree",
          "type": "method"
        },
        "index": {
          "hierarchy": "DDC Type Collect",
          "module": "DDC.Type.Collect",
          "name": "slurpBindTree",
          "normalized": "a b-\u003e[BindTree b]",
          "package": "ddc-core",
          "partial": "Bind Tree",
          "signature": "c n-\u003e[BindTree n]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Collect.html#v:slurpBindTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "Compounds",
          "package": "ddc-core",
          "source": "src/DDC-Type-Compounds.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "Compounds",
          "package": "ddc-core",
          "partial": "Compounds",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a type application.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "($:)",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#%24%3A",
          "type": "function"
        },
        "index": {
          "description": "Construct type application",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "($:) $:",
          "normalized": "Type a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "signature": "Type n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:-36-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine the arity of an expression by looking at its type.\n   Count all the function arrows, and foralls.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "arityOfType",
          "package": "ddc-core",
          "signature": "Type n -\u003e Int",
          "source": "src/DDC-Type-Compounds.html#arityOfType",
          "type": "function"
        },
        "index": {
          "description": "Determine the arity of an expression by looking at its type Count all the function arrows and foralls",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "arityOfType",
          "normalized": "Type a-\u003eInt",
          "package": "ddc-core",
          "partial": "Of Type",
          "signature": "Type n-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:arityOfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the binder of a bind.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "binderOfBind",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Binder n",
          "source": "src/DDC-Type-Compounds.html#binderOfBind",
          "type": "function"
        },
        "index": {
          "description": "Take the binder of bind",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "binderOfBind",
          "normalized": "Bind a-\u003eBinder a",
          "package": "ddc-core",
          "partial": "Of Bind",
          "signature": "Bind n-\u003eBinder n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:binderOfBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a bound maches a bind.\n    \u003ccode\u003e\u003ca\u003eUName\u003c/a\u003e\u003c/code\u003e    and \u003ccode\u003e\u003ca\u003eBName\u003c/a\u003e\u003c/code\u003e match if they have the same name.\n    \u003ccode\u003eUIx 0 _\u003c/code\u003e  and \u003ccode\u003eBAnon _\u003c/code\u003e always match.\n   Yields \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e for other combinations of bounds and binds.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "boundMatchesBind",
          "package": "ddc-core",
          "signature": "Bound n -\u003e Bind n -\u003e Bool",
          "source": "src/DDC-Type-Compounds.html#boundMatchesBind",
          "type": "function"
        },
        "index": {
          "description": "Check whether bound maches bind UName and BName match if they have the same name UIx and BAnon always match Yields False for other combinations of bounds and binds",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "boundMatchesBind",
          "normalized": "Bound a-\u003eBind a-\u003eBool",
          "package": "ddc-core",
          "partial": "Matches Bind",
          "signature": "Bound n-\u003eBind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:boundMatchesBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eErase all \u003ccode\u003e\u003ca\u003eTForall\u003c/a\u003e\u003c/code\u003e quantifiers from a type.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "eraseTForalls",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#eraseTForalls",
          "type": "function"
        },
        "index": {
          "description": "Erase all TForall quantifiers from type",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "eraseTForalls",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "TForalls",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:eraseTForalls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "kClosure",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#kClosure",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "kClosure",
          "package": "ddc-core",
          "partial": "Closure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:kClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "kData",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#kData",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "kData",
          "package": "ddc-core",
          "partial": "Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:kData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "kEffect",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#kEffect",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "kEffect",
          "package": "ddc-core",
          "partial": "Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:kEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a kind function.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "kFun",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Kind n -\u003e Kind n",
          "source": "src/DDC-Type-Compounds.html#kFun",
          "type": "function"
        },
        "index": {
          "description": "Construct kind function",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "kFun",
          "normalized": "Kind a-\u003eKind a-\u003eKind a",
          "package": "ddc-core",
          "partial": "Fun",
          "signature": "Kind n-\u003eKind n-\u003eKind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:kFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct some kind functions.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "kFuns",
          "package": "ddc-core",
          "signature": "[Kind n] -\u003e Kind n -\u003e Kind n",
          "source": "src/DDC-Type-Compounds.html#kFuns",
          "type": "function"
        },
        "index": {
          "description": "Construct some kind functions",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "kFuns",
          "normalized": "[Kind a]-\u003eKind a-\u003eKind a",
          "package": "ddc-core",
          "partial": "Funs",
          "signature": "[Kind n]-\u003eKind n-\u003eKind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:kFuns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "kRegion",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#kRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "kRegion",
          "package": "ddc-core",
          "partial": "Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:kRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "kWitness",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#kWitness",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "kWitness",
          "package": "ddc-core",
          "partial": "Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:kWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a bind from a binder and its type.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "makeBindFromBinder",
          "package": "ddc-core",
          "signature": "Binder n -\u003e Type n -\u003e Bind n",
          "source": "src/DDC-Type-Compounds.html#makeBindFromBinder",
          "type": "function"
        },
        "index": {
          "description": "Make bind from binder and its type",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "makeBindFromBinder",
          "normalized": "Binder a-\u003eType a-\u003eBind a",
          "package": "ddc-core",
          "partial": "Bind From Binder",
          "signature": "Binder n-\u003eType n-\u003eBind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:makeBindFromBinder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a named bound matches a named bind. \n   Yields \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if they are not named or have different names.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "namedBoundMatchesBind",
          "package": "ddc-core",
          "signature": "Bound n -\u003e Bind n -\u003e Bool",
          "source": "src/DDC-Type-Compounds.html#namedBoundMatchesBind",
          "type": "function"
        },
        "index": {
          "description": "Check whether named bound matches named bind Yields False if they are not named or have different names",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "namedBoundMatchesBind",
          "normalized": "Bound a-\u003eBind a-\u003eBool",
          "package": "ddc-core",
          "partial": "Bound Matches Bind",
          "signature": "Bound n-\u003eBind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:namedBoundMatchesBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake lists of binds that have the same type.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "partitionBindsByType",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e [([Binder n], Type n)]",
          "source": "src/DDC-Type-Compounds.html#partitionBindsByType",
          "type": "function"
        },
        "index": {
          "description": "Make lists of binds that have the same type",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "partitionBindsByType",
          "normalized": "[Bind a]-\u003e[([Binder a],Type a)]",
          "package": "ddc-core",
          "partial": "Binds By Type",
          "signature": "[Bind n]-\u003e[([Binder n],Type n)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:partitionBindsByType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the type of a bind with a new one.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "replaceTypeOfBind",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bind n -\u003e Bind n",
          "source": "src/DDC-Type-Compounds.html#replaceTypeOfBind",
          "type": "function"
        },
        "index": {
          "description": "Replace the type of bind with new one",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "replaceTypeOfBind",
          "normalized": "Type a-\u003eBind a-\u003eBind a",
          "package": "ddc-core",
          "partial": "Type Of Bind",
          "signature": "Type n-\u003eBind n-\u003eBind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:replaceTypeOfBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf this \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eUPrim\u003c/a\u003e\u003c/code\u003e then replace it's embedded type with a new\n   one, otherwise return it unharmed.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "replaceTypeOfBound",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bound n -\u003e Bound n",
          "source": "src/DDC-Type-Compounds.html#replaceTypeOfBound",
          "type": "function"
        },
        "index": {
          "description": "If this Bound is UPrim then replace it embedded type with new one otherwise return it unharmed",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "replaceTypeOfBound",
          "normalized": "Type a-\u003eBound a-\u003eBound a",
          "package": "ddc-core",
          "partial": "Type Of Bound",
          "signature": "Type n-\u003eBound n-\u003eBound n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:replaceTypeOfBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "sComp",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#sComp",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "sComp",
          "package": "ddc-core",
          "partial": "Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:sComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "sProp",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#sProp",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "sProp",
          "package": "ddc-core",
          "partial": "Prop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:sProp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tAlloc",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tAlloc",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tAlloc",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Alloc",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tAlloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a type application.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tApp",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tApp",
          "type": "function"
        },
        "index": {
          "description": "Construct type application",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tApp",
          "normalized": "Type a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "App",
          "signature": "Type n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a sequence of type applications.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tApps",
          "package": "ddc-core",
          "signature": "Type n -\u003e [Type n] -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tApps",
          "type": "function"
        },
        "index": {
          "description": "Construct sequence of type applications",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tApps",
          "normalized": "Type a-\u003e[Type a]-\u003eType a",
          "package": "ddc-core",
          "partial": "Apps",
          "signature": "Type n-\u003e[Type n]-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an empty type sum.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tBot",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tBot",
          "type": "function"
        },
        "index": {
          "description": "Construct an empty type sum",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tBot",
          "normalized": "Kind a-\u003eType a",
          "package": "ddc-core",
          "partial": "Bot",
          "signature": "Kind n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tBot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a nullary type constructor of the given kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tConData0",
          "package": "ddc-core",
          "signature": "n -\u003e Kind n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tConData0",
          "type": "function"
        },
        "index": {
          "description": "Build nullary type constructor of the given kind",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tConData0",
          "normalized": "a-\u003eKind a-\u003eType a",
          "package": "ddc-core",
          "partial": "Con Data",
          "signature": "n-\u003eKind n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tConData0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a type constructor application of one argumnet.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tConData1",
          "package": "ddc-core",
          "signature": "n -\u003e Kind n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tConData1",
          "type": "function"
        },
        "index": {
          "description": "Build type constructor application of one argumnet",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tConData1",
          "normalized": "a-\u003eKind a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "Con Data",
          "signature": "n-\u003eKind n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tConData1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tConst",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tConst",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Const",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDeepAlloc",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDeepAlloc",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDeepAlloc",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Deep Alloc",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDeepAlloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDeepConst",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDeepConst",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDeepConst",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Deep Const",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDeepConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDeepGlobal",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDeepGlobal",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDeepGlobal",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Deep Global",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDeepGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDeepMutable",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDeepMutable",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDeepMutable",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Deep Mutable",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDeepMutable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDeepRead",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDeepRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDeepRead",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Deep Read",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDeepRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDeepUse",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDeepUse",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDeepUse",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Deep Use",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDeepUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDeepWrite",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDeepWrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDeepWrite",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Deep Write",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDeepWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tDistinct",
          "package": "ddc-core",
          "signature": "Int -\u003e [Type n] -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tDistinct",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tDistinct",
          "normalized": "Int-\u003e[Type a]-\u003eType a",
          "package": "ddc-core",
          "partial": "Distinct",
          "signature": "Int-\u003e[Type n]-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tDistinct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tEmpty",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tEmpty",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Empty",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an anonymous type abstraction, with a single parameter.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tForall",
          "package": "ddc-core",
          "signature": "Kind n -\u003e (Type n -\u003e Type n) -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tForall",
          "type": "function"
        },
        "index": {
          "description": "Build an anonymous type abstraction with single parameter",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tForall",
          "normalized": "Kind a-\u003e(Type a-\u003eType a)-\u003eType a",
          "package": "ddc-core",
          "partial": "Forall",
          "signature": "Kind n-\u003e(Type n-\u003eType n)-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tForall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an anonymous type abstraction, with a single parameter.\n   Starting the next index from the given value.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tForall'",
          "package": "ddc-core",
          "signature": "Int -\u003e Kind n -\u003e (Type n -\u003e Type n) -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tForall%27",
          "type": "function"
        },
        "index": {
          "description": "Build an anonymous type abstraction with single parameter Starting the next index from the given value",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tForall'",
          "normalized": "Int-\u003eKind a-\u003e(Type a-\u003eType a)-\u003eType a",
          "package": "ddc-core",
          "partial": "Forall'",
          "signature": "Int-\u003eKind n-\u003e(Type n-\u003eType n)-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tForall-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an anonymous type abstraction, with several parameters.\n   Starting the next index from the given value.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tForalls",
          "package": "ddc-core",
          "signature": "[Kind n] -\u003e ([Type n] -\u003e Type n) -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tForalls",
          "type": "function"
        },
        "index": {
          "description": "Build an anonymous type abstraction with several parameters Starting the next index from the given value",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tForalls",
          "normalized": "[Kind a]-\u003e([Type a]-\u003eType a)-\u003eType a",
          "package": "ddc-core",
          "partial": "Foralls",
          "signature": "[Kind n]-\u003e([Type n]-\u003eType n)-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tForalls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an anonymous type abstraction, with several parameters.\n   Starting the next index from the given value.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tForalls'",
          "package": "ddc-core",
          "signature": "Int -\u003e [Kind n] -\u003e ([Type n] -\u003e Type n) -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tForalls%27",
          "type": "function"
        },
        "index": {
          "description": "Build an anonymous type abstraction with several parameters Starting the next index from the given value",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tForalls'",
          "normalized": "Int-\u003e[Kind a]-\u003e([Type a]-\u003eType a)-\u003eType a",
          "package": "ddc-core",
          "partial": "Foralls'",
          "signature": "Int-\u003e[Kind n]-\u003e([Type n]-\u003eType n)-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tForalls-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a pure function type.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tFun",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tFun",
          "type": "function"
        },
        "index": {
          "description": "Construct pure function type",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tFun",
          "normalized": "Type a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "Fun",
          "signature": "Type n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a value type function, \n   with the provided effect and closure.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tFunEC",
          "package": "ddc-core",
          "signature": "Type n -\u003e Effect n -\u003e Closure n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tFunEC",
          "type": "function"
        },
        "index": {
          "description": "Construct value type function with the provided effect and closure",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tFunEC",
          "normalized": "Type a-\u003eEffect a-\u003eClosure a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "Fun EC",
          "signature": "Type n-\u003eEffect n-\u003eClosure n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tFunEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a pure and empty function from a list containing the \n   parameter and return type. Yields \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the list is empty.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tFunOfList",
          "package": "ddc-core",
          "signature": "[Type n] -\u003e Maybe (Type n)",
          "source": "src/DDC-Type-Compounds.html#tFunOfList",
          "type": "function"
        },
        "index": {
          "description": "Construct pure and empty function from list containing the parameter and return type Yields Nothing if the list is empty",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tFunOfList",
          "normalized": "[Type a]-\u003eMaybe(Type a)",
          "package": "ddc-core",
          "partial": "Fun Of List",
          "signature": "[Type n]-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tFunOfList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a pure and empty function from a list containing the \n   parameter and return type. Yields \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the list is empty.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tFunOfListPE",
          "package": "ddc-core",
          "signature": "[Type n] -\u003e Maybe (Type n)",
          "source": "src/DDC-Type-Compounds.html#tFunOfListPE",
          "type": "function"
        },
        "index": {
          "description": "Construct pure and empty function from list containing the parameter and return type Yields Nothing if the list is empty",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tFunOfListPE",
          "normalized": "[Type a]-\u003eMaybe(Type a)",
          "package": "ddc-core",
          "partial": "Fun Of List PE",
          "signature": "[Type n]-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tFunOfListPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a pure and empty value type function.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tFunPE",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tFunPE",
          "type": "function"
        },
        "index": {
          "description": "Construct pure and empty value type function",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tFunPE",
          "normalized": "Type a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "Fun PE",
          "signature": "Type n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tFunPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tGlobal",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tGlobal",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tGlobal",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Global",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tHeadLazy",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tHeadLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tHeadLazy",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Head Lazy",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tHeadLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tHeadRead",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tHeadRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tHeadRead",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Head Read",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tHeadRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a witness implication type.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tImpl",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tImpl",
          "type": "function"
        },
        "index": {
          "description": "Construct witness implication type",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tImpl",
          "normalized": "Type a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "Impl",
          "signature": "Type n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tImpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a deBruijn index.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "tIx",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Int -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tIx",
          "type": "function"
        },
        "index": {
          "description": "Construct deBruijn index",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tIx",
          "normalized": "Kind a-\u003eInt-\u003eType a",
          "package": "ddc-core",
          "partial": "Ix",
          "signature": "Kind n-\u003eInt-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tIx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tLazy",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tLazy",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Lazy",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tManifest",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tManifest",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tManifest",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Manifest",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tManifest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tMutable",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tMutable",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tMutable",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Mutable",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tMutable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tPure",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tPure",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tPure",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Pure",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tRead",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tRead",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Read",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tSum",
          "package": "ddc-core",
          "signature": "Kind n -\u003e [Type n] -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tSum",
          "normalized": "Kind a-\u003e[Type a]-\u003eType a",
          "package": "ddc-core",
          "partial": "Sum",
          "signature": "Kind n-\u003e[Type n]-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tSusp",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tSusp",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tSusp",
          "normalized": "Effect a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "Susp",
          "signature": "Effect n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tSusp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tUnit",
          "package": "ddc-core",
          "signature": "Type n",
          "source": "src/DDC-Type-Compounds.html#tUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tUnit",
          "package": "ddc-core",
          "partial": "Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tUse",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tUse",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tUse",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Use",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Compounds",
          "name": "tWrite",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#tWrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "tWrite",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Write",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:tWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a sequence of type applications, returning the type constructor\n   and arguments, if there is one. Only accept data type constructors.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeDataTyConApps",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe (TyCon n, [Type n])",
          "source": "src/DDC-Type-Compounds.html#takeDataTyConApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten sequence of type applications returning the type constructor and arguments if there is one Only accept data type constructors",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeDataTyConApps",
          "normalized": "Type a-\u003eMaybe(TyCon a,[Type a])",
          "package": "ddc-core",
          "partial": "Data Ty Con Apps",
          "signature": "Type n-\u003eMaybe(TyCon n,[Type n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeDataTyConApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestruct a kind function\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeKFun",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Maybe (Kind n, Kind n)",
          "source": "src/DDC-Type-Compounds.html#takeKFun",
          "type": "function"
        },
        "index": {
          "description": "Destruct kind function",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeKFun",
          "normalized": "Kind a-\u003eMaybe(Kind a,Kind a)",
          "package": "ddc-core",
          "partial": "KFun",
          "signature": "Kind n-\u003eMaybe(Kind n,Kind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeKFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestruct a chain of kind functions into the arguments\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeKFuns",
          "package": "ddc-core",
          "signature": "Kind n -\u003e ([Kind n], Kind n)",
          "source": "src/DDC-Type-Compounds.html#takeKFuns",
          "type": "function"
        },
        "index": {
          "description": "Destruct chain of kind functions into the arguments",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeKFuns",
          "normalized": "Kind a-\u003e([Kind a],Kind a)",
          "package": "ddc-core",
          "partial": "KFuns",
          "signature": "Kind n-\u003e([Kind n],Kind n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeKFuns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003etakeKFuns\u003c/a\u003e\u003c/code\u003e, but return argument and return kinds in the same list.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeKFuns'",
          "package": "ddc-core",
          "signature": "Kind n -\u003e [Kind n]",
          "source": "src/DDC-Type-Compounds.html#takeKFuns%27",
          "type": "function"
        },
        "index": {
          "description": "Like takeKFuns but return argument and return kinds in the same list",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeKFuns'",
          "normalized": "Kind a-\u003e[Kind a]",
          "package": "ddc-core",
          "partial": "KFuns'",
          "signature": "Kind n-\u003e[Kind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeKFuns-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the variable name of a bind.\n   If this is an anonymous binder then there won't be a name.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeNameOfBind",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Maybe n",
          "source": "src/DDC-Type-Compounds.html#takeNameOfBind",
          "type": "function"
        },
        "index": {
          "description": "Take the variable name of bind If this is an anonymous binder then there won be name",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeNameOfBind",
          "normalized": "Bind a-\u003eMaybe a",
          "package": "ddc-core",
          "partial": "Name Of Bind",
          "signature": "Bind n-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeNameOfBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the name of bound variable.\n   If this is a deBruijn index then there won't be a name.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeNameOfBound",
          "package": "ddc-core",
          "signature": "Bound n -\u003e Maybe n",
          "source": "src/DDC-Type-Compounds.html#takeNameOfBound",
          "type": "function"
        },
        "index": {
          "description": "Take the name of bound variable If this is deBruijn index then there won be name",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeNameOfBound",
          "normalized": "Bound a-\u003eMaybe a",
          "package": "ddc-core",
          "partial": "Name Of Bound",
          "signature": "Bound n-\u003eMaybe n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeNameOfBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a sequence of type applications, returning the type constructor\n   and arguments, if there is one. Only accept primitive type constructors.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takePrimTyConApps",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe (n, [Type n])",
          "source": "src/DDC-Type-Compounds.html#takePrimTyConApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten sequence of type applications returning the type constructor and arguments if there is one Only accept primitive type constructors",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takePrimTyConApps",
          "normalized": "Type a-\u003eMaybe(a,[Type a])",
          "package": "ddc-core",
          "partial": "Prim Ty Con Apps",
          "signature": "Type n-\u003eMaybe(n,[Type n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takePrimTyConApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the prime region variable of a data type.\n   This corresponds to the region the outermost constructor is allocated into.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takePrimeRegion",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe (Type n)",
          "source": "src/DDC-Type-Compounds.html#takePrimeRegion",
          "type": "function"
        },
        "index": {
          "description": "Take the prime region variable of data type This corresponds to the region the outermost constructor is allocated into",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takePrimeRegion",
          "normalized": "Type a-\u003eMaybe(Type a)",
          "package": "ddc-core",
          "partial": "Prime Region",
          "signature": "Type n-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takePrimeRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the result kind of a kind function, or return the same kind\n   unharmed if it's not a kind function.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeResultKind",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Kind n",
          "source": "src/DDC-Type-Compounds.html#takeResultKind",
          "type": "function"
        },
        "index": {
          "description": "Take the result kind of kind function or return the same kind unharmed if it not kind function",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeResultKind",
          "normalized": "Kind a-\u003eKind a",
          "package": "ddc-core",
          "partial": "Result Kind",
          "signature": "Kind n-\u003eKind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeResultKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eBind\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003e, ready for substitution.\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eUName\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eBName\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003eUIx 0\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eBAnon\u003c/a\u003e\u003c/code\u003e \n   and \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eBNone\u003c/a\u003e\u003c/code\u003e, because there's nothing to substitute.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeSubstBoundOfBind",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Maybe (Bound n)",
          "source": "src/DDC-Type-Compounds.html#takeSubstBoundOfBind",
          "type": "function"
        },
        "index": {
          "description": "Convert Bind to Bound ready for substitution Returns UName for BName UIx for BAnon and Nothing for BNone because there nothing to substitute",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeSubstBoundOfBind",
          "normalized": "Bind a-\u003eMaybe(Bound a)",
          "package": "ddc-core",
          "partial": "Subst Bound Of Bind",
          "signature": "Bind n-\u003eMaybe(Bound n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeSubstBoundOfBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert some \u003ccode\u003e\u003ca\u003eBind\u003c/a\u003e\u003c/code\u003es to \u003ccode\u003eBounds\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeSubstBoundsOfBinds",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e [Bound n]",
          "source": "src/DDC-Type-Compounds.html#takeSubstBoundsOfBinds",
          "type": "function"
        },
        "index": {
          "description": "Convert some Bind to Bounds",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeSubstBoundsOfBinds",
          "normalized": "[Bind a]-\u003e[Bound a]",
          "package": "ddc-core",
          "partial": "Subst Bounds Of Binds",
          "signature": "[Bind n]-\u003e[Bound n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeSubstBoundsOfBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a sequence ot type applications into the function part and\n   arguments, if any.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTApps",
          "package": "ddc-core",
          "signature": "Type n -\u003e [Type n]",
          "source": "src/DDC-Type-Compounds.html#takeTApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten sequence ot type applications into the function part and arguments if any",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTApps",
          "normalized": "Type a-\u003e[Type a]",
          "package": "ddc-core",
          "partial": "TApps",
          "signature": "Type n-\u003e[Type n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit nested foralls from the front of a type, \n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there was no outer forall.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTForalls",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe ([Bind n], Type n)",
          "source": "src/DDC-Type-Compounds.html#takeTForalls",
          "type": "function"
        },
        "index": {
          "description": "Split nested foralls from the front of type or Nothing if there was no outer forall",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTForalls",
          "normalized": "Type a-\u003eMaybe([Bind a],Type a)",
          "package": "ddc-core",
          "partial": "TForalls",
          "signature": "Type n-\u003eMaybe([Bind n],Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTForalls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the argument and result type of a function type.\n\u003c/p\u003e\u003cp\u003eWorks for both \u003ccode\u003e\u003ca\u003eTcConFun\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eTcConFunEC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTFun",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe (Type n, Type n)",
          "source": "src/DDC-Type-Compounds.html#takeTFun",
          "type": "function"
        },
        "index": {
          "description": "Yield the argument and result type of function type Works for both TcConFun and TcConFunEC",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTFun",
          "normalized": "Type a-\u003eMaybe(Type a,Type a)",
          "package": "ddc-core",
          "partial": "TFun",
          "signature": "Type n-\u003eMaybe(Type n,Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestruct the type of a possibly polymorphic function\n   returning all kinds of quantifiers, witness arguments, \n   and value arguments in the order they appear, along with \n   the type of the result.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunAllArgResult",
          "package": "ddc-core",
          "signature": "Type n -\u003e ([Type n], Type n)",
          "source": "src/DDC-Type-Compounds.html#takeTFunAllArgResult",
          "type": "function"
        },
        "index": {
          "description": "Destruct the type of possibly polymorphic function returning all kinds of quantifiers witness arguments and value arguments in the order they appear along with the type of the result",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunAllArgResult",
          "normalized": "Type a-\u003e([Type a],Type a)",
          "package": "ddc-core",
          "partial": "TFun All Arg Result",
          "signature": "Type n-\u003e([Type n],Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTFunAllArgResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestruct the type of a function, returning just the argument and result types.\n\u003c/p\u003e\u003cp\u003eWorks for both \u003ccode\u003e\u003ca\u003eTcConFun\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eTcConFunEC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunArgResult",
          "package": "ddc-core",
          "signature": "Type n -\u003e ([Type n], Type n)",
          "source": "src/DDC-Type-Compounds.html#takeTFunArgResult",
          "type": "function"
        },
        "index": {
          "description": "Destruct the type of function returning just the argument and result types Works for both TcConFun and TcConFunEC",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunArgResult",
          "normalized": "Type a-\u003e([Type a],Type a)",
          "package": "ddc-core",
          "partial": "TFun Arg Result",
          "signature": "Type n-\u003e([Type n],Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTFunArgResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the argument and result type of a function type.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunEC",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe (Type n, Effect n, Closure n, Type n)",
          "source": "src/DDC-Type-Compounds.html#takeTFunEC",
          "type": "function"
        },
        "index": {
          "description": "Yield the argument and result type of function type",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunEC",
          "normalized": "Type a-\u003eMaybe(Type a,Effect a,Closure a,Type a)",
          "package": "ddc-core",
          "partial": "TFun EC",
          "signature": "Type n-\u003eMaybe(Type n,Effect n,Closure n,Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTFunEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestruct the type of a function,\n   returning the witness argument, value argument and result types.\n   The function type must have the witness implications before \n   the value arguments, eg  \u003ccode\u003eT1 =\u003e T2 -\u003e T3 -\u003e T4 -\u003e T5\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWorks for both \u003ccode\u003e\u003ca\u003eTcConFun\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eTcConFunEC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunWitArgResult",
          "package": "ddc-core",
          "signature": "Type n -\u003e ([Type n], [Type n], Type n)",
          "source": "src/DDC-Type-Compounds.html#takeTFunWitArgResult",
          "type": "function"
        },
        "index": {
          "description": "Destruct the type of function returning the witness argument value argument and result types The function type must have the witness implications before the value arguments eg T1 T2 T3 T4 T5 Works for both TcConFun and TcConFunEC",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTFunWitArgResult",
          "normalized": "Type a-\u003e([Type a],[Type a],Type a)",
          "package": "ddc-core",
          "partial": "TFun Wit Arg Result",
          "signature": "Type n-\u003e([Type n],[Type n],Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTFunWitArgResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a sequence of type applications, returning the type constructor\n   and arguments, if there is one.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "takeTyConApps",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe (TyCon n, [Type n])",
          "source": "src/DDC-Type-Compounds.html#takeTyConApps",
          "type": "function"
        },
        "index": {
          "description": "Flatten sequence of type applications returning the type constructor and arguments if there is one",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "takeTyConApps",
          "normalized": "Type a-\u003eMaybe(TyCon a,[Type a])",
          "package": "ddc-core",
          "partial": "Ty Con Apps",
          "signature": "Type n-\u003eMaybe(TyCon n,[Type n])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:takeTyConApps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the type of a bind.\n\u003c/p\u003e",
          "module": "DDC.Type.Compounds",
          "name": "typeOfBind",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Type n",
          "source": "src/DDC-Type-Compounds.html#typeOfBind",
          "type": "function"
        },
        "index": {
          "description": "Take the type of bind",
          "hierarchy": "DDC Type Compounds",
          "module": "DDC.Type.Compounds",
          "name": "typeOfBind",
          "normalized": "Bind a-\u003eType a",
          "package": "ddc-core",
          "partial": "Of Bind",
          "signature": "Bind n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Compounds.html#v:typeOfBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAlgebraic data type definitions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.DataDef",
          "name": "DataDef",
          "package": "ddc-core",
          "source": "src/DDC-Type-DataDef.html",
          "type": "module"
        },
        "index": {
          "description": "Algebraic data type definitions",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataDef",
          "package": "ddc-core",
          "partial": "Data Def",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes a data constructor, used in the \u003ccode\u003e\u003ca\u003eDataDefs\u003c/a\u003e\u003c/code\u003e table.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "DataCtor",
          "package": "ddc-core",
          "source": "src/DDC-Type-DataDef.html#DataCtor",
          "type": "data"
        },
        "index": {
          "description": "Describes data constructor used in the DataDefs table",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataCtor",
          "package": "ddc-core",
          "partial": "Data Ctor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#t:DataCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe definition of a single data type.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "DataDef",
          "package": "ddc-core",
          "source": "src/DDC-Type-DataDef.html#DataDef",
          "type": "data"
        },
        "index": {
          "description": "The definition of single data type",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataDef",
          "package": "ddc-core",
          "partial": "Data Def",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#t:DataDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA table of data type definitions,\n   unpacked into type and data constructors so we can find them easily.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "DataDefs",
          "package": "ddc-core",
          "source": "src/DDC-Type-DataDef.html#DataDefs",
          "type": "data"
        },
        "index": {
          "description": "table of data type definitions unpacked into type and data constructors so we can find them easily",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataDefs",
          "package": "ddc-core",
          "partial": "Data Defs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#t:DataDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe mode of a data type records how many data constructors there are.\n   This can be set to \u003ccode\u003eLarge\u003c/code\u003e for large primitive types like Int and Float.\n   In this case we don't ever expect them all to be enumerated\n   as case alternatives.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "DataMode",
          "package": "ddc-core",
          "source": "src/DDC-Type-DataDef.html#DataMode",
          "type": "data"
        },
        "index": {
          "description": "The mode of data type records how many data constructors there are This can be set to Large for large primitive types like Int and Float In this case we don ever expect them all to be enumerated as case alternatives",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataMode",
          "package": "ddc-core",
          "partial": "Data Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#t:DataMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes a data type constructor, used in the \u003ccode\u003e\u003ca\u003eDataDefs\u003c/a\u003e\u003c/code\u003e table.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "DataType",
          "package": "ddc-core",
          "source": "src/DDC-Type-DataDef.html#DataType",
          "type": "data"
        },
        "index": {
          "description": "Describes data type constructor used in the DataDefs table",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataType",
          "package": "ddc-core",
          "partial": "Data Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#t:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "DataCtor",
          "package": "ddc-core",
          "signature": "DataCtor",
          "source": "src/DDC-Type-DataDef.html#DataCtor",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataCtor",
          "package": "ddc-core",
          "partial": "Data Ctor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:DataCtor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "DataDef",
          "package": "ddc-core",
          "signature": "DataDef",
          "source": "src/DDC-Type-DataDef.html#DataDef",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataDef",
          "package": "ddc-core",
          "partial": "Data Def",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:DataDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "DataDefs",
          "package": "ddc-core",
          "signature": "DataDefs",
          "source": "src/DDC-Type-DataDef.html#DataDefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataDefs",
          "package": "ddc-core",
          "partial": "Data Defs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:DataDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "DataModeLarge",
          "package": "ddc-core",
          "signature": "DataModeLarge",
          "source": "src/DDC-Type-DataDef.html#DataMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataModeLarge",
          "package": "ddc-core",
          "partial": "Data Mode Large",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:DataModeLarge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "DataModeSmall",
          "package": "ddc-core",
          "signature": "DataModeSmall ![n]",
          "source": "src/DDC-Type-DataDef.html#DataMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataModeSmall",
          "normalized": "DataModeSmall[a]",
          "package": "ddc-core",
          "partial": "Data Mode Small",
          "signature": "DataModeSmall[n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:DataModeSmall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "DataType",
          "package": "ddc-core",
          "signature": "DataType",
          "source": "src/DDC-Type-DataDef.html#DataType",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "DataType",
          "package": "ddc-core",
          "partial": "Data Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField types of constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorFieldTypes",
          "package": "ddc-core",
          "signature": "[Type n]",
          "source": "src/DDC-Type-DataDef.html#DataCtor",
          "type": "function"
        },
        "index": {
          "description": "Field types of constructor",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorFieldTypes",
          "normalized": "[Type a]",
          "package": "ddc-core",
          "partial": "Ctor Field Types",
          "signature": "[Type n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataCtorFieldTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of data constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorName",
          "package": "ddc-core",
          "signature": "n",
          "source": "src/DDC-Type-DataDef.html#DataCtor",
          "type": "function"
        },
        "index": {
          "description": "Name of data constructor",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorName",
          "package": "ddc-core",
          "partial": "Ctor Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataCtorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTag of constructor (order in data type declaration)\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorTag",
          "package": "ddc-core",
          "signature": "Integer",
          "source": "src/DDC-Type-DataDef.html#DataCtor",
          "type": "function"
        },
        "index": {
          "description": "Tag of constructor order in data type declaration",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorTag",
          "package": "ddc-core",
          "partial": "Ctor Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataCtorTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of result type of constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorTypeName",
          "package": "ddc-core",
          "signature": "n",
          "source": "src/DDC-Type-DataDef.html#DataCtor",
          "type": "function"
        },
        "index": {
          "description": "Name of result type of constructor",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataCtorTypeName",
          "package": "ddc-core",
          "partial": "Ctor Type Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataCtorTypeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructors of the data type, or Nothing if there are\n   too many to list (like with \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataDefCtors",
          "package": "ddc-core",
          "signature": "(Maybe [(n, [Type n])])",
          "source": "src/DDC-Type-DataDef.html#DataDef",
          "type": "function"
        },
        "index": {
          "description": "Constructors of the data type or Nothing if there are too many to list like with Int",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataDefCtors",
          "normalized": "(Maybe[(a,[Type a])])",
          "package": "ddc-core",
          "partial": "Def Ctors",
          "signature": "(Maybe[(n,[Type n])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataDefCtors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKinds of type parameters.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataDefParamKinds",
          "package": "ddc-core",
          "signature": "[Kind n]",
          "source": "src/DDC-Type-DataDef.html#DataDef",
          "type": "function"
        },
        "index": {
          "description": "Kinds of type parameters",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataDefParamKinds",
          "normalized": "[Kind a]",
          "package": "ddc-core",
          "partial": "Def Param Kinds",
          "signature": "[Kind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataDefParamKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of the data type.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataDefTypeName",
          "package": "ddc-core",
          "signature": "n",
          "source": "src/DDC-Type-DataDef.html#DataDef",
          "type": "function"
        },
        "index": {
          "description": "Name of the data type",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataDefTypeName",
          "package": "ddc-core",
          "partial": "Def Type Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataDefTypeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "dataDefsCtors",
          "package": "ddc-core",
          "signature": "(Map n (DataCtor n))",
          "source": "src/DDC-Type-DataDef.html#DataDefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataDefsCtors",
          "package": "ddc-core",
          "partial": "Defs Ctors",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataDefsCtors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.DataDef",
          "name": "dataDefsTypes",
          "package": "ddc-core",
          "signature": "(Map n (DataType n))",
          "source": "src/DDC-Type-DataDef.html#DataDefs",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataDefsTypes",
          "package": "ddc-core",
          "partial": "Defs Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataDefsTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNames of data constructors of this data type,\n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it has infinitely many constructors.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataTypeMode",
          "package": "ddc-core",
          "signature": "(DataMode n)",
          "source": "src/DDC-Type-DataDef.html#DataType",
          "type": "function"
        },
        "index": {
          "description": "Names of data constructors of this data type or Nothing if it has infinitely many constructors",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataTypeMode",
          "package": "ddc-core",
          "partial": "Type Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataTypeMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of data type constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataTypeName",
          "package": "ddc-core",
          "signature": "n",
          "source": "src/DDC-Type-DataDef.html#DataType",
          "type": "function"
        },
        "index": {
          "description": "Name of data type constructor",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataTypeName",
          "package": "ddc-core",
          "partial": "Type Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataTypeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKinds of type parameters to constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "dataTypeParamKinds",
          "package": "ddc-core",
          "signature": "[Kind n]",
          "source": "src/DDC-Type-DataDef.html#DataType",
          "type": "function"
        },
        "index": {
          "description": "Kinds of type parameters to constructor",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "dataTypeParamKinds",
          "normalized": "[Kind a]",
          "package": "ddc-core",
          "partial": "Type Param Kinds",
          "signature": "[Kind n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:dataTypeParamKinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty table of data type definitions.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "emptyDataDefs",
          "package": "ddc-core",
          "signature": "DataDefs n",
          "source": "src/DDC-Type-DataDef.html#emptyDataDefs",
          "type": "function"
        },
        "index": {
          "description": "An empty table of data type definitions",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "emptyDataDefs",
          "package": "ddc-core",
          "partial": "Data Defs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:emptyDataDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eDataDefs\u003c/a\u003e\u003c/code\u003e table from a list of \u003ccode\u003e\u003ca\u003eDataDef\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "fromListDataDefs",
          "package": "ddc-core",
          "signature": "[DataDef n] -\u003e DataDefs n",
          "source": "src/DDC-Type-DataDef.html#fromListDataDefs",
          "type": "function"
        },
        "index": {
          "description": "Build DataDefs table from list of DataDef",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "fromListDataDefs",
          "normalized": "[DataDef a]-\u003eDataDefs a",
          "package": "ddc-core",
          "partial": "List Data Defs",
          "signature": "[DataDef n]-\u003eDataDefs n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:fromListDataDefs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert a data type definition into some DataDefs.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "insertDataDef",
          "package": "ddc-core",
          "signature": "DataDef n -\u003e DataDefs n -\u003e DataDefs n",
          "source": "src/DDC-Type-DataDef.html#insertDataDef",
          "type": "function"
        },
        "index": {
          "description": "Insert data type definition into some DataDefs",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "insertDataDef",
          "normalized": "DataDef a-\u003eDataDefs a-\u003eDataDefs a",
          "package": "ddc-core",
          "partial": "Data Def",
          "signature": "DataDef n-\u003eDataDefs n-\u003eDataDefs n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:insertDataDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the list of data constructor names for some data type, \n   or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for large types with too many constructors to list.\n\u003c/p\u003e",
          "module": "DDC.Type.DataDef",
          "name": "lookupModeOfDataType",
          "package": "ddc-core",
          "signature": "n -\u003e DataDefs n -\u003e Maybe (DataMode n)",
          "source": "src/DDC-Type-DataDef.html#lookupModeOfDataType",
          "type": "function"
        },
        "index": {
          "description": "Yield the list of data constructor names for some data type or Nothing for large types with too many constructors to list",
          "hierarchy": "DDC Type DataDef",
          "module": "DDC.Type.DataDef",
          "name": "lookupModeOfDataType",
          "normalized": "a-\u003eDataDefs a-\u003eMaybe(DataMode a)",
          "package": "ddc-core",
          "partial": "Mode Of Data Type",
          "signature": "n-\u003eDataDefs n-\u003eMaybe(DataMode n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-DataDef.html#v:lookupModeOfDataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eType environments.\n\u003c/p\u003e\u003cp\u003eAn environment contains the types \n     named bound variables,\n     named primitives, \n     and a deBruijn stack for anonymous variables.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Env",
          "name": "Env",
          "package": "ddc-core",
          "source": "src/DDC-Type-Env.html",
          "type": "module"
        },
        "index": {
          "description": "Type environments An environment contains the types named bound variables named primitives and deBruijn stack for anonymous variables",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "Env",
          "package": "ddc-core",
          "partial": "Env",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "Env",
          "package": "ddc-core",
          "source": "src/DDC-Type-Env.html#Env",
          "type": "data"
        },
        "index": {
          "description": "type environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "Env",
          "package": "ddc-core",
          "partial": "Env",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#t:Env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym to improve readability.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "KindEnv",
          "package": "ddc-core",
          "source": "src/DDC-Type-Env.html#KindEnv",
          "type": "type"
        },
        "index": {
          "description": "Type synonym to improve readability",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "KindEnv",
          "package": "ddc-core",
          "partial": "Kind Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#t:KindEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym to improve readability.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "SuperEnv",
          "package": "ddc-core",
          "source": "src/DDC-Type-Env.html#SuperEnv",
          "type": "type"
        },
        "index": {
          "description": "Type synonym to improve readability",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "SuperEnv",
          "package": "ddc-core",
          "partial": "Super Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#t:SuperEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType synonym to improve readability.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "TypeEnv",
          "package": "ddc-core",
          "source": "src/DDC-Type-Env.html#TypeEnv",
          "type": "type"
        },
        "index": {
          "description": "Type synonym to improve readability",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "TypeEnv",
          "package": "ddc-core",
          "partial": "Type Env",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#t:TypeEnv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Env",
          "name": "Env",
          "package": "ddc-core",
          "signature": "Env",
          "source": "src/DDC-Type-Env.html#Env",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "Env",
          "package": "ddc-core",
          "partial": "Env",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:Env"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the total depth of the deBruijn stack.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "depth",
          "package": "ddc-core",
          "signature": "Env n -\u003e Int",
          "source": "src/DDC-Type-Env.html#depth",
          "type": "function"
        },
        "index": {
          "description": "Yield the total depth of the deBruijn stack",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "depth",
          "normalized": "Env a-\u003eInt",
          "package": "ddc-core",
          "signature": "Env n-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:depth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "empty",
          "package": "ddc-core",
          "signature": "Env n",
          "source": "src/DDC-Type-Env.html#empty",
          "type": "function"
        },
        "index": {
          "description": "An empty environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "empty",
          "package": "ddc-core",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of named binders.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "envMap",
          "package": "ddc-core",
          "signature": "(Map n (Type n))",
          "source": "src/DDC-Type-Env.html#Env",
          "type": "function"
        },
        "index": {
          "description": "Types of named binders",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "envMap",
          "package": "ddc-core",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:envMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of baked in, primitive names.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "envPrimFun",
          "package": "ddc-core",
          "signature": "(n -\u003e Maybe (Type n))",
          "source": "src/DDC-Type-Env.html#Env",
          "type": "function"
        },
        "index": {
          "description": "Types of baked in primitive names",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "envPrimFun",
          "normalized": "(a-\u003eMaybe(Type a))",
          "package": "ddc-core",
          "partial": "Prim Fun",
          "signature": "(n-\u003eMaybe(Type n))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:envPrimFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes of anonymous deBruijn binders.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "envStack",
          "package": "ddc-core",
          "signature": "[Type n]",
          "source": "src/DDC-Type-Env.html#Env",
          "type": "function"
        },
        "index": {
          "description": "Types of anonymous deBruijn binders",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "envStack",
          "normalized": "[Type a]",
          "package": "ddc-core",
          "partial": "Stack",
          "signature": "[Type n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:envStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe length of the above stack.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "envStackLength",
          "package": "ddc-core",
          "signature": "Int",
          "source": "src/DDC-Type-Env.html#Env",
          "type": "function"
        },
        "index": {
          "description": "The length of the above stack",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "envStackLength",
          "package": "ddc-core",
          "partial": "Stack Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:envStackLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend an environment with a new binding.\n   Replaces bindings with the same name already in the environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "extend",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Env n -\u003e Env n",
          "source": "src/DDC-Type-Env.html#extend",
          "type": "function"
        },
        "index": {
          "description": "Extend an environment with new binding Replaces bindings with the same name already in the environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "extend",
          "normalized": "Bind a-\u003eEnv a-\u003eEnv a",
          "package": "ddc-core",
          "signature": "Bind n-\u003eEnv n-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:extend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend an environment with a list of new bindings.\n   Replaces bindings with the same name already in the environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "extends",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e Env n -\u003e Env n",
          "source": "src/DDC-Type-Env.html#extends",
          "type": "function"
        },
        "index": {
          "description": "Extend an environment with list of new bindings Replaces bindings with the same name already in the environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "extends",
          "normalized": "[Bind a]-\u003eEnv a-\u003eEnv a",
          "package": "ddc-core",
          "signature": "[Bind n]-\u003eEnv n-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:extends"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of \u003ccode\u003e\u003ca\u003eBind\u003c/a\u003e\u003c/code\u003es to an environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "fromList",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e Env n",
          "source": "src/DDC-Type-Env.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Convert list of Bind to an environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "fromList",
          "normalized": "[Bind a]-\u003eEnv a",
          "package": "ddc-core",
          "partial": "List",
          "signature": "[Bind n]-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a map of names to types to a environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "fromTypeMap",
          "package": "ddc-core",
          "signature": "Map n (Type n) -\u003e Env n",
          "source": "src/DDC-Type-Env.html#fromTypeMap",
          "type": "function"
        },
        "index": {
          "description": "Convert map of names to types to environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "fromTypeMap",
          "normalized": "Map a(Type a)-\u003eEnv a",
          "package": "ddc-core",
          "partial": "Type Map",
          "signature": "Map n(Type n)-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:fromTypeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if the type of a name is defined by the \u003ccode\u003e\u003ca\u003eenvPrimFun\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "isPrim",
          "package": "ddc-core",
          "signature": "Env n -\u003e n -\u003e Bool",
          "source": "src/DDC-Type-Env.html#isPrim",
          "type": "function"
        },
        "index": {
          "description": "Check if the type of name is defined by the envPrimFun",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "isPrim",
          "normalized": "Env a-\u003ea-\u003eBool",
          "package": "ddc-core",
          "partial": "Prim",
          "signature": "Env n-\u003en-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:isPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift all free deBruijn indices in the environment by the given number of steps.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "lift",
          "package": "ddc-core",
          "signature": "Int -\u003e Env n -\u003e Env n",
          "source": "src/DDC-Type-Env.html#lift",
          "type": "function"
        },
        "index": {
          "description": "Lift all free deBruijn indices in the environment by the given number of steps",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "lift",
          "normalized": "Int-\u003eEnv a-\u003eEnv a",
          "package": "ddc-core",
          "signature": "Int-\u003eEnv n-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a bound variable from an environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "lookup",
          "package": "ddc-core",
          "signature": "Bound n -\u003e Env n -\u003e Maybe (Type n)",
          "source": "src/DDC-Type-Env.html#lookup",
          "type": "function"
        },
        "index": {
          "description": "Lookup bound variable from an environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "lookup",
          "normalized": "Bound a-\u003eEnv a-\u003eMaybe(Type a)",
          "package": "ddc-core",
          "signature": "Bound n-\u003eEnv n-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookup a bound name from an environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "lookupName",
          "package": "ddc-core",
          "signature": "n -\u003e Env n -\u003e Maybe (Type n)",
          "source": "src/DDC-Type-Env.html#lookupName",
          "type": "function"
        },
        "index": {
          "description": "Lookup bound name from an environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "lookupName",
          "normalized": "a-\u003eEnv a-\u003eMaybe(Type a)",
          "package": "ddc-core",
          "partial": "Name",
          "signature": "n-\u003eEnv n-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:lookupName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a bound variable is present in an environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "member",
          "package": "ddc-core",
          "signature": "Bound n -\u003e Env n -\u003e Bool",
          "source": "src/DDC-Type-Env.html#member",
          "type": "function"
        },
        "index": {
          "description": "Check whether bound variable is present in an environment",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "member",
          "normalized": "Bound a-\u003eEnv a-\u003eBool",
          "package": "ddc-core",
          "signature": "Bound n-\u003eEnv n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a binder is already present in the an environment.\n   This can only return True for named binders, not anonymous or primitive ones.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "memberBind",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Env n -\u003e Bool",
          "source": "src/DDC-Type-Env.html#memberBind",
          "type": "function"
        },
        "index": {
          "description": "Check whether binder is already present in the an environment This can only return True for named binders not anonymous or primitive ones",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "memberBind",
          "normalized": "Bind a-\u003eEnv a-\u003eBool",
          "package": "ddc-core",
          "partial": "Bind",
          "signature": "Bind n-\u003eEnv n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:memberBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the function that knows the types of primitive things.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "setPrimFun",
          "package": "ddc-core",
          "signature": "(n -\u003e Maybe (Type n)) -\u003e Env n -\u003e Env n",
          "source": "src/DDC-Type-Env.html#setPrimFun",
          "type": "function"
        },
        "index": {
          "description": "Set the function that knows the types of primitive things",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "setPrimFun",
          "normalized": "(a-\u003eMaybe(Type a))-\u003eEnv a-\u003eEnv a",
          "package": "ddc-core",
          "partial": "Prim Fun",
          "signature": "(n-\u003eMaybe(Type n))-\u003eEnv n-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:setPrimFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two environments.\n   If both environments have a binding with the same name,\n   then the one in the second environment takes preference.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "union",
          "package": "ddc-core",
          "signature": "Env n -\u003e Env n -\u003e Env n",
          "source": "src/DDC-Type-Env.html#union",
          "type": "function"
        },
        "index": {
          "description": "Combine two environments If both environments have binding with the same name then the one in the second environment takes preference",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "union",
          "normalized": "Env a-\u003eEnv a-\u003eEnv a",
          "package": "ddc-core",
          "signature": "Env n-\u003eEnv n-\u003eEnv n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap locally bound (non primitive) variables defined in an environment\n   around a type as new foralls.\n\u003c/p\u003e",
          "module": "DDC.Type.Env",
          "name": "wrapTForalls",
          "package": "ddc-core",
          "signature": "Env n -\u003e Type n -\u003e Type n",
          "source": "src/DDC-Type-Env.html#wrapTForalls",
          "type": "function"
        },
        "index": {
          "description": "Wrap locally bound non primitive variables defined in an environment around type as new foralls",
          "hierarchy": "DDC Type Env",
          "module": "DDC.Type.Env",
          "name": "wrapTForalls",
          "normalized": "Env a-\u003eType a-\u003eType a",
          "package": "ddc-core",
          "partial": "TForalls",
          "signature": "Env n-\u003eType n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Env.html#v:wrapTForalls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Equiv",
          "name": "Equiv",
          "package": "ddc-core",
          "source": "src/DDC-Type-Equiv.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Equiv",
          "module": "DDC.Type.Equiv",
          "name": "Equiv",
          "package": "ddc-core",
          "partial": "Equiv",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Equiv.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck equivalence of types.\n\u003c/p\u003e\u003cp\u003eChecks equivalence up to alpha-renaming, as well as crushing of effects\n   and trimming of closures.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if we find any free variables.\n\u003c/li\u003e\u003cli\u003e We assume the types are well-kinded, so that the type annotations on\n     bound variables match the binders. If this is not the case then you get\n     an indeterminate result.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "DDC.Type.Equiv",
          "name": "equivT",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n -\u003e Bool",
          "source": "src/DDC-Type-Equiv.html#equivT",
          "type": "function"
        },
        "index": {
          "description": "Check equivalence of types Checks equivalence up to alpha-renaming as well as crushing of effects and trimming of closures Return False if we find any free variables We assume the types are well-kinded so that the type annotations on bound variables match the binders If this is not the case then you get an indeterminate result",
          "hierarchy": "DDC Type Equiv",
          "module": "DDC.Type.Equiv",
          "name": "equivT",
          "normalized": "Type a-\u003eType a-\u003eBool",
          "package": "ddc-core",
          "signature": "Type n-\u003eType n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Equiv.html#v:equivT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eequivT\u003c/a\u003e\u003c/code\u003e but take the initial stacks of type binders.\n\u003c/p\u003e",
          "module": "DDC.Type.Equiv",
          "name": "equivWithBindsT",
          "package": "ddc-core",
          "signature": "[Bind n] -\u003e [Bind n] -\u003e Type n -\u003e Type n -\u003e Bool",
          "source": "src/DDC-Type-Equiv.html#equivWithBindsT",
          "type": "function"
        },
        "index": {
          "description": "Like equivT but take the initial stacks of type binders",
          "hierarchy": "DDC Type Equiv",
          "module": "DDC.Type.Equiv",
          "name": "equivWithBindsT",
          "normalized": "[Bind a]-\u003e[Bind a]-\u003eType a-\u003eType a-\u003eBool",
          "package": "ddc-core",
          "partial": "With Binds",
          "signature": "[Bind n]-\u003e[Bind n]-\u003eType n-\u003eType n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Equiv.html#v:equivWithBindsT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "Exp",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Exp",
          "package": "ddc-core",
          "partial": "Exp",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable binder with its type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "Bind",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Bind",
          "type": "data"
        },
        "index": {
          "description": "variable binder with its type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Bind",
          "package": "ddc-core",
          "partial": "Bind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Bind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable binder.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "Binder",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Binder",
          "type": "data"
        },
        "index": {
          "description": "variable binder",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Binder",
          "package": "ddc-core",
          "partial": "Binder",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Binder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA bound occurrence of a variable, with its type.\n\u003c/p\u003e\u003cp\u003eIf variable hasn't been annotated with its real type then this \n   can be \u003ccode\u003etBot\u003c/code\u003e (an empty sum).\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "Bound",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Bound",
          "type": "data"
        },
        "index": {
          "description": "bound occurrence of variable with its type If variable hasn been annotated with its real type then this can be tBot an empty sum",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Bound",
          "package": "ddc-core",
          "partial": "Bound",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Bound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "Closure",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Closure",
          "type": "type"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Closure",
          "package": "ddc-core",
          "partial": "Closure",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Closure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "Effect",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Effect",
          "type": "type"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Effect",
          "package": "ddc-core",
          "partial": "Effect",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Effect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "KiCon",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#KiCon",
          "type": "data"
        },
        "index": {
          "description": "Kind constructor",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "KiCon",
          "package": "ddc-core",
          "partial": "Ki Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:KiCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "Kind",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Kind",
          "type": "type"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Kind",
          "package": "ddc-core",
          "partial": "Kind",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Kind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "Region",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Region",
          "type": "type"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Region",
          "package": "ddc-core",
          "partial": "Region",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Region"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort constructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "SoCon",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#SoCon",
          "type": "data"
        },
        "index": {
          "description": "Sort constructor",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "SoCon",
          "package": "ddc-core",
          "partial": "So Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:SoCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "Sort",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Sort",
          "type": "type"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Sort",
          "package": "ddc-core",
          "partial": "Sort",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOther constructors at the spec level.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcCon",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "data"
        },
        "index": {
          "description": "Other constructors at the spec level",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcCon",
          "package": "ddc-core",
          "partial": "Tc Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:TcCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWitness type constructors.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwCon",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "data"
        },
        "index": {
          "description": "Witness type constructors",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwCon",
          "package": "ddc-core",
          "partial": "Tw Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:TwCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind, type and witness constructors.\n\u003c/p\u003e\u003cp\u003eThese are grouped to make it easy to determine the universe that they\n   belong to.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TyCon",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#TyCon",
          "type": "data"
        },
        "index": {
          "description": "Kind type and witness constructors These are grouped to make it easy to determine the universe that they belong to",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyCon",
          "package": "ddc-core",
          "partial": "Ty Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:TyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHash value used to insert types into the \u003ccode\u003e\u003ca\u003etypeSumElems\u003c/a\u003e\u003c/code\u003e array of a \u003ccode\u003e\u003ca\u003eTypeSum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TyConHash",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#TyConHash",
          "type": "data"
        },
        "index": {
          "description": "Hash value used to insert types into the typeSumElems array of TypeSum",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyConHash",
          "package": "ddc-core",
          "partial": "Ty Con Hash",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:TyConHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value type, kind, or sort.\n\u003c/p\u003e\u003cp\u003eWe use the same data type to represent all three universes, as they have\n  a similar algebraic structure.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "Type",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#Type",
          "type": "data"
        },
        "index": {
          "description": "value type kind or sort We use the same data type to represent all three universes as they have similar algebraic structure",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "Type",
          "package": "ddc-core",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA least upper bound of several types.\n\u003c/p\u003e\u003cp\u003eWe keep type sums in this normalised format instead of joining them\n   together with a binary operator (like \u003ccode\u003e(+)\u003c/code\u003e). This makes sums easier to work\n   with, as a given sum type often only has a single physical representation.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TypeSum",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "data"
        },
        "index": {
          "description": "least upper bound of several types We keep type sums in this normalised format instead of joining them together with binary operator like This makes sums easier to work with as given sum type often only has single physical representation",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TypeSum",
          "package": "ddc-core",
          "partial": "Type Sum",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:TypeSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps a variable or constructor that can be added the \u003ccode\u003e\u003ca\u003etypeSumElems\u003c/a\u003e\u003c/code\u003e array.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TypeSumVarCon",
          "package": "ddc-core",
          "source": "src/DDC-Type-Exp-Base.html#TypeSumVarCon",
          "type": "data"
        },
        "index": {
          "description": "Wraps variable or constructor that can be added the typeSumElems array",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TypeSumVarCon",
          "package": "ddc-core",
          "partial": "Type Sum Var Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#t:TypeSumVarCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNameless variable on the deBruijn stack.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "BAnon",
          "package": "ddc-core",
          "signature": "BAnon !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#Bind",
          "type": "function"
        },
        "index": {
          "description": "Nameless variable on the deBruijn stack",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "BAnon",
          "package": "ddc-core",
          "partial": "BAnon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:BAnon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamed variable in the environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "BName",
          "package": "ddc-core",
          "signature": "BName n !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#Bind",
          "type": "function"
        },
        "index": {
          "description": "Named variable in the environment",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "BName",
          "package": "ddc-core",
          "partial": "BName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:BName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable with no uses in the body doesn't need a name.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "BNone",
          "package": "ddc-core",
          "signature": "BNone !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#Bind",
          "type": "function"
        },
        "index": {
          "description": "variable with no uses in the body doesn need name",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "BNone",
          "package": "ddc-core",
          "partial": "BNone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:BNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind of closures.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "KiConClosure",
          "package": "ddc-core",
          "signature": "KiConClosure",
          "source": "src/DDC-Type-Exp-Base.html#KiCon",
          "type": "function"
        },
        "index": {
          "description": "Kind of closures",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "KiConClosure",
          "package": "ddc-core",
          "partial": "Ki Con Closure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:KiConClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind of data values.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "KiConData",
          "package": "ddc-core",
          "signature": "KiConData",
          "source": "src/DDC-Type-Exp-Base.html#KiCon",
          "type": "function"
        },
        "index": {
          "description": "Kind of data values",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "KiConData",
          "package": "ddc-core",
          "partial": "Ki Con Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:KiConData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind of effects.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "KiConEffect",
          "package": "ddc-core",
          "signature": "KiConEffect",
          "source": "src/DDC-Type-Exp-Base.html#KiCon",
          "type": "function"
        },
        "index": {
          "description": "Kind of effects",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "KiConEffect",
          "package": "ddc-core",
          "partial": "Ki Con Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:KiConEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction kind constructor.\n   This is only well formed when it is fully applied.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "KiConFun",
          "package": "ddc-core",
          "signature": "KiConFun",
          "source": "src/DDC-Type-Exp-Base.html#KiCon",
          "type": "function"
        },
        "index": {
          "description": "Function kind constructor This is only well formed when it is fully applied",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "KiConFun",
          "package": "ddc-core",
          "partial": "Ki Con Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:KiConFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind of regions.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "KiConRegion",
          "package": "ddc-core",
          "signature": "KiConRegion",
          "source": "src/DDC-Type-Exp-Base.html#KiCon",
          "type": "function"
        },
        "index": {
          "description": "Kind of regions",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "KiConRegion",
          "package": "ddc-core",
          "partial": "Ki Con Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:KiConRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKind of witnesses.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "KiConWitness",
          "package": "ddc-core",
          "signature": "KiConWitness",
          "source": "src/DDC-Type-Exp-Base.html#KiCon",
          "type": "function"
        },
        "index": {
          "description": "Kind of witnesses",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "KiConWitness",
          "package": "ddc-core",
          "partial": "Ki Con Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:KiConWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "RAnon",
          "package": "ddc-core",
          "signature": "RAnon",
          "source": "src/DDC-Type-Exp-Base.html#Binder",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "RAnon",
          "package": "ddc-core",
          "partial": "RAnon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:RAnon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "RName",
          "package": "ddc-core",
          "signature": "RName !n",
          "source": "src/DDC-Type-Exp-Base.html#Binder",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "RName",
          "package": "ddc-core",
          "partial": "RName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:RName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "RNone",
          "package": "ddc-core",
          "signature": "RNone",
          "source": "src/DDC-Type-Exp-Base.html#Binder",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "RNone",
          "package": "ddc-core",
          "partial": "RNone",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:RNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort of computation kinds.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "SoConComp",
          "package": "ddc-core",
          "signature": "SoConComp",
          "source": "src/DDC-Type-Exp-Base.html#SoCon",
          "type": "function"
        },
        "index": {
          "description": "Sort of computation kinds",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "SoConComp",
          "package": "ddc-core",
          "partial": "So Con Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:SoConComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort of witness kinds.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "SoConProp",
          "package": "ddc-core",
          "signature": "SoConProp",
          "source": "src/DDC-Type-Exp-Base.html#SoCon",
          "type": "function"
        },
        "index": {
          "description": "Sort of witness kinds",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "SoConProp",
          "package": "ddc-core",
          "partial": "So Con Prop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:SoConProp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TApp",
          "package": "ddc-core",
          "signature": "TApp !(Type n) !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#Type",
          "type": "function"
        },
        "index": {
          "description": "Application",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TApp",
          "package": "ddc-core",
          "partial": "TApp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructor.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TCon",
          "package": "ddc-core",
          "signature": "TCon !(TyCon n)",
          "source": "src/DDC-Type-Exp-Base.html#Type",
          "type": "function"
        },
        "index": {
          "description": "Constructor",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TCon",
          "package": "ddc-core",
          "partial": "TCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstraction.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TForall",
          "package": "ddc-core",
          "signature": "TForall !(Bind n) !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#Type",
          "type": "function"
        },
        "index": {
          "description": "Abstraction",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TForall",
          "package": "ddc-core",
          "partial": "TForall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TForall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast upper bound.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TSum",
          "package": "ddc-core",
          "signature": "TSum !(TypeSum n)",
          "source": "src/DDC-Type-Exp-Base.html#Type",
          "type": "function"
        },
        "index": {
          "description": "Least upper bound",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TSum",
          "package": "ddc-core",
          "partial": "TSum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TVar",
          "package": "ddc-core",
          "signature": "TVar !(Bound n)",
          "source": "src/DDC-Type-Exp-Base.html#Type",
          "type": "function"
        },
        "index": {
          "description": "Variable",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TVar",
          "package": "ddc-core",
          "partial": "TVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocation into some region.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConAlloc",
          "package": "ddc-core",
          "signature": "TcConAlloc",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Allocation into some region",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConAlloc",
          "package": "ddc-core",
          "partial": "Tc Con Alloc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConAlloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllocation into all material regions in some data type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepAlloc",
          "package": "ddc-core",
          "signature": "TcConDeepAlloc",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Allocation into all material regions in some data type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepAlloc",
          "package": "ddc-core",
          "partial": "Tc Con Deep Alloc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConDeepAlloc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead of all material regions in a data type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepRead",
          "package": "ddc-core",
          "signature": "TcConDeepRead",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Read of all material regions in data type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepRead",
          "package": "ddc-core",
          "partial": "Tc Con Deep Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConDeepRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll material regions in a data type are captured in a closure.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepUse",
          "package": "ddc-core",
          "signature": "TcConDeepUse",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "All material regions in data type are captured in closure",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepUse",
          "package": "ddc-core",
          "partial": "Tc Con Deep Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConDeepUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite to all material regions in some data type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepWrite",
          "package": "ddc-core",
          "signature": "TcConDeepWrite",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Write to all material regions in some data type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConDeepWrite",
          "package": "ddc-core",
          "partial": "Tc Con Deep Write",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConDeepWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePure function.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConFun",
          "package": "ddc-core",
          "signature": "TcConFun",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Pure function",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConFun",
          "package": "ddc-core",
          "partial": "Tc Con Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction with a latent effect and closure.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConFunEC",
          "package": "ddc-core",
          "signature": "TcConFunEC",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Function with latent effect and closure",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConFunEC",
          "package": "ddc-core",
          "partial": "Tc Con Fun EC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConFunEC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the head region in a data type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConHeadRead",
          "package": "ddc-core",
          "signature": "TcConHeadRead",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Read the head region in data type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConHeadRead",
          "package": "ddc-core",
          "partial": "Tc Con Head Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConHeadRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead of some region.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConRead",
          "package": "ddc-core",
          "signature": "TcConRead",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Read of some region",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConRead",
          "package": "ddc-core",
          "partial": "Tc Con Read",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA suspended computation.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConSusp",
          "package": "ddc-core",
          "signature": "TcConSusp",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "suspended computation",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConSusp",
          "package": "ddc-core",
          "partial": "Tc Con Susp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConSusp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe unit data type constructor is baked in.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConUnit",
          "package": "ddc-core",
          "signature": "TcConUnit",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "The unit data type constructor is baked in",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConUnit",
          "package": "ddc-core",
          "partial": "Tc Con Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegion is captured in a closure.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConUse",
          "package": "ddc-core",
          "signature": "TcConUse",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Region is captured in closure",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConUse",
          "package": "ddc-core",
          "partial": "Tc Con Use",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConUse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite of some region.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TcConWrite",
          "package": "ddc-core",
          "signature": "TcConWrite",
          "source": "src/DDC-Type-Exp-Base.html#TcCon",
          "type": "function"
        },
        "index": {
          "description": "Write of some region",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TcConWrite",
          "package": "ddc-core",
          "partial": "Tc Con Write",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TcConWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstancy of some region.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConConst",
          "package": "ddc-core",
          "signature": "TwConConst",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Constancy of some region",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConConst",
          "package": "ddc-core",
          "partial": "Tw Con Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstancy of material regions in some type\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConDeepConst",
          "package": "ddc-core",
          "signature": "TwConDeepConst",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Constancy of material regions in some type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConDeepConst",
          "package": "ddc-core",
          "partial": "Tw Con Deep Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConDeepConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlobalness of material regions in some type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConDeepGlobal",
          "package": "ddc-core",
          "signature": "TwConDeepGlobal",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Globalness of material regions in some type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConDeepGlobal",
          "package": "ddc-core",
          "partial": "Tw Con Deep Global",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConDeepGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutability of material regions in some type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConDeepMutable",
          "package": "ddc-core",
          "signature": "TwConDeepMutable",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Mutability of material regions in some type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConDeepMutable",
          "package": "ddc-core",
          "partial": "Tw Con Deep Mutable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConDeepMutable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-interfering effects are disjoint. Used for rewrite rules.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConDisjoint",
          "package": "ddc-core",
          "signature": "TwConDisjoint",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Non-interfering effects are disjoint Used for rewrite rules",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConDisjoint",
          "package": "ddc-core",
          "partial": "Tw Con Disjoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConDisjoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDistinctness of some n regions\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConDistinct",
          "package": "ddc-core",
          "signature": "TwConDistinct Int",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Distinctness of some regions",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConDistinct",
          "package": "ddc-core",
          "partial": "Tw Con Distinct",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConDistinct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmptiness of some closure.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConEmpty",
          "package": "ddc-core",
          "signature": "TwConEmpty",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Emptiness of some closure",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConEmpty",
          "package": "ddc-core",
          "partial": "Tw Con Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlobalness of some region.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConGlobal",
          "package": "ddc-core",
          "signature": "TwConGlobal",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Globalness of some region",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConGlobal",
          "package": "ddc-core",
          "partial": "Tw Con Global",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConGlobal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLaziness of the primary region in some type.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConHeadLazy",
          "package": "ddc-core",
          "signature": "TwConHeadLazy",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Laziness of the primary region in some type",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConHeadLazy",
          "package": "ddc-core",
          "partial": "Tw Con Head Lazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConHeadLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "TwConImpl",
          "package": "ddc-core",
          "signature": "TwConImpl",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConImpl",
          "package": "ddc-core",
          "partial": "Tw Con Impl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConImpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLaziness of some region.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConLazy",
          "package": "ddc-core",
          "signature": "TwConLazy",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Laziness of some region",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConLazy",
          "package": "ddc-core",
          "partial": "Tw Con Lazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eManifestness of some region (not lazy).\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConManifest",
          "package": "ddc-core",
          "signature": "TwConManifest",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Manifestness of some region not lazy",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConManifest",
          "package": "ddc-core",
          "partial": "Tw Con Manifest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConManifest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutability of some region.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConMutable",
          "package": "ddc-core",
          "signature": "TwConMutable",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Mutability of some region",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConMutable",
          "package": "ddc-core",
          "partial": "Tw Con Mutable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConMutable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePurity of some effect.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TwConPure",
          "package": "ddc-core",
          "signature": "TwConPure",
          "source": "src/DDC-Type-Exp-Base.html#TwCon",
          "type": "function"
        },
        "index": {
          "description": "Purity of some effect",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TwConPure",
          "package": "ddc-core",
          "partial": "Tw Con Pure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TwConPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUser defined and primitive constructors.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TyConBound",
          "package": "ddc-core",
          "signature": "TyConBound !(Bound n) !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#TyCon",
          "type": "function"
        },
        "index": {
          "description": "User defined and primitive constructors",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyConBound",
          "package": "ddc-core",
          "partial": "Ty Con Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TyConBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "TyConHash",
          "package": "ddc-core",
          "signature": "TyConHash !Int",
          "source": "src/DDC-Type-Exp-Base.html#TyConHash",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyConHash",
          "package": "ddc-core",
          "partial": "Ty Con Hash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TyConHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 2) Builtin Kind constructors.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TyConKind",
          "package": "ddc-core",
          "signature": "TyConKind !KiCon",
          "source": "src/DDC-Type-Exp-Base.html#TyCon",
          "type": "function"
        },
        "index": {
          "description": "level Builtin Kind constructors",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyConKind",
          "package": "ddc-core",
          "partial": "Ty Con Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TyConKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 3) Builtin Sort constructors.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TyConSort",
          "package": "ddc-core",
          "signature": "TyConSort !SoCon",
          "source": "src/DDC-Type-Exp-Base.html#TyCon",
          "type": "function"
        },
        "index": {
          "description": "level Builtin Sort constructors",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyConSort",
          "package": "ddc-core",
          "partial": "Ty Con Sort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TyConSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 1) Builtin Spec constructors for types of other kinds.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TyConSpec",
          "package": "ddc-core",
          "signature": "TyConSpec !TcCon",
          "source": "src/DDC-Type-Exp-Base.html#TyCon",
          "type": "function"
        },
        "index": {
          "description": "level Builtin Spec constructors for types of other kinds",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyConSpec",
          "package": "ddc-core",
          "partial": "Ty Con Spec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TyConSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 1) Builtin Spec constructors for the types of witnesses.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "TyConWitness",
          "package": "ddc-core",
          "signature": "TyConWitness !TwCon",
          "source": "src/DDC-Type-Exp-Base.html#TyCon",
          "type": "function"
        },
        "index": {
          "description": "level Builtin Spec constructors for the types of witnesses",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TyConWitness",
          "package": "ddc-core",
          "partial": "Ty Con Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TyConWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "TypeSumBot",
          "package": "ddc-core",
          "signature": "TypeSumBot",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TypeSumBot",
          "package": "ddc-core",
          "partial": "Type Sum Bot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TypeSumBot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "TypeSumCon",
          "package": "ddc-core",
          "signature": "TypeSumCon !(Bound n) !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#TypeSumVarCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TypeSumCon",
          "package": "ddc-core",
          "partial": "Type Sum Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TypeSumCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "TypeSumSet",
          "package": "ddc-core",
          "signature": "TypeSumSet",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TypeSumSet",
          "package": "ddc-core",
          "partial": "Type Sum Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TypeSumSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Exp",
          "name": "TypeSumVar",
          "package": "ddc-core",
          "signature": "TypeSumVar !(Bound n)",
          "source": "src/DDC-Type-Exp-Base.html#TypeSumVarCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "TypeSumVar",
          "package": "ddc-core",
          "partial": "Type Sum Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:TypeSumVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNameless variable that should be on the deBruijn stack.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "UIx",
          "package": "ddc-core",
          "signature": "UIx !Int",
          "source": "src/DDC-Type-Exp-Base.html#Bound",
          "type": "function"
        },
        "index": {
          "description": "Nameless variable that should be on the deBruijn stack",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "UIx",
          "package": "ddc-core",
          "partial": "UIx",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:UIx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamed variable that should be in the environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "UName",
          "package": "ddc-core",
          "signature": "UName !n",
          "source": "src/DDC-Type-Exp-Base.html#Bound",
          "type": "function"
        },
        "index": {
          "description": "Named variable that should be in the environment",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "UName",
          "package": "ddc-core",
          "partial": "UName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:UName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamed primitive that has its type attached to it.\n   The types of primitives must be closed.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "UPrim",
          "package": "ddc-core",
          "signature": "UPrim !n !(Type n)",
          "source": "src/DDC-Type-Exp-Base.html#Bound",
          "type": "function"
        },
        "index": {
          "description": "Named primitive that has its type attached to it The types of primitives must be closed",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "UPrim",
          "package": "ddc-core",
          "partial": "UPrim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:UPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA map for anonymous type variables.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "typeSumBoundAnon",
          "package": "ddc-core",
          "signature": "(Map Int (Kind n))",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "function"
        },
        "index": {
          "description": "map for anonymous type variables",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "typeSumBoundAnon",
          "package": "ddc-core",
          "partial": "Sum Bound Anon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:typeSumBoundAnon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA map for named type variables.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "typeSumBoundNamed",
          "package": "ddc-core",
          "signature": "(Map n (Kind n))",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "function"
        },
        "index": {
          "description": "map for named type variables",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "typeSumBoundNamed",
          "package": "ddc-core",
          "partial": "Sum Bound Named",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:typeSumBoundNamed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhere we can see the outer constructor of a type, its argument\n   is inserted into this array. This handles common cases like\n   Read, Write, Alloc effects.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "typeSumElems",
          "package": "ddc-core",
          "signature": "(Array TyConHash (Set (TypeSumVarCon n)))",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "function"
        },
        "index": {
          "description": "Where we can see the outer constructor of type its argument is inserted into this array This handles common cases like Read Write Alloc effects",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "typeSumElems",
          "package": "ddc-core",
          "partial": "Sum Elems",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:typeSumElems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe kind of the elements in this sum.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "typeSumKind",
          "package": "ddc-core",
          "signature": "(Kind n)",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "function"
        },
        "index": {
          "description": "The kind of the elements in this sum",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "typeSumKind",
          "package": "ddc-core",
          "partial": "Sum Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:typeSumKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes that can't be placed in the other fields go here.\n\u003c/p\u003e\u003cp\u003eINVARIANT: this list doesn't contain more \u003ccode\u003e\u003ca\u003eTSum\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "DDC.Type.Exp",
          "name": "typeSumSpill",
          "package": "ddc-core",
          "signature": "[Type n]",
          "source": "src/DDC-Type-Exp-Base.html#TypeSum",
          "type": "function"
        },
        "index": {
          "description": "Types that can be placed in the other fields go here INVARIANT this list doesn contain more TSum",
          "hierarchy": "DDC Type Exp",
          "module": "DDC.Type.Exp",
          "name": "typeSumSpill",
          "normalized": "[Type a]",
          "package": "ddc-core",
          "partial": "Sum Spill",
          "signature": "[Type n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Exp.html#v:typeSumSpill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePredicates on type expressions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Predicates",
          "name": "Predicates",
          "package": "ddc-core",
          "source": "src/DDC-Type-Predicates.html",
          "type": "module"
        },
        "index": {
          "description": "Predicates on type expressions",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "Predicates",
          "package": "ddc-core",
          "partial": "Predicates",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this type is that of algebraic data.\n\u003c/p\u003e\u003cp\u003eIt needs to have an explicit data constructor out the front,\n   and not a type variable. The constructor must not be the function\n   constructor, and must return a value of kind \u003ccode\u003e\u003ca\u003e*\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isAlgDataType",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isAlgDataType",
          "type": "function"
        },
        "index": {
          "description": "Check whether this type is that of algebraic data It needs to have an explicit data constructor out the front and not type variable The constructor must not be the function constructor and must return value of kind",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isAlgDataType",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "Alg Data Type",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isAlgDataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this is an atomic alloc effect.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isAllocEffect",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isAllocEffect",
          "type": "function"
        },
        "index": {
          "description": "Check whether this is an atomic alloc effect",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isAllocEffect",
          "normalized": "Effect a-\u003eBool",
          "package": "ddc-core",
          "partial": "Alloc Effect",
          "signature": "Effect n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isAllocEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a type is a \u003ccode\u003e\u003ca\u003eTVar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTCon\u003c/a\u003e\u003c/code\u003e or is Bottom.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isAtomT",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isAtomT",
          "type": "function"
        },
        "index": {
          "description": "Check whether type is TVar TCon or is Bottom",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isAtomT",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "Atom",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isAtomT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Predicates",
          "name": "isBAnon",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isBAnon",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isBAnon",
          "normalized": "Bind a-\u003eBool",
          "package": "ddc-core",
          "partial": "BAnon",
          "signature": "Bind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isBAnon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Predicates",
          "name": "isBName",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isBName",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isBName",
          "normalized": "Bind a-\u003eBool",
          "package": "ddc-core",
          "partial": "BName",
          "signature": "Bind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isBName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Predicates",
          "name": "isBNone",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isBNone",
          "type": "function"
        },
        "index": {
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isBNone",
          "normalized": "Bind a-\u003eBool",
          "package": "ddc-core",
          "partial": "BNone",
          "signature": "Bind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isBNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if some type is an empty TSum\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isBot",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isBot",
          "type": "function"
        },
        "index": {
          "description": "Test if some type is an empty TSum",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isBot",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "Bot",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isBot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if some kind is the closure kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isClosureKind",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isClosureKind",
          "type": "function"
        },
        "index": {
          "description": "Check if some kind is the closure kind",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isClosureKind",
          "normalized": "Kind a-\u003eBool",
          "package": "ddc-core",
          "partial": "Closure Kind",
          "signature": "Kind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isClosureKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this is the type of a \u003ccode\u003eConst\u003c/code\u003e witness.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isConstWitType",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isConstWitType",
          "type": "function"
        },
        "index": {
          "description": "Check whether this is the type of Const witness",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isConstWitType",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "Const Wit Type",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isConstWitType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if some kind is the data kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isDataKind",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isDataKind",
          "type": "function"
        },
        "index": {
          "description": "Check if some kind is the data kind",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isDataKind",
          "normalized": "Kind a-\u003eBool",
          "package": "ddc-core",
          "partial": "Data Kind",
          "signature": "Kind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isDataKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this is the type of a \u003ccode\u003eDistinct\u003c/code\u003e witness.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isDistinctWitType",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isDistinctWitType",
          "type": "function"
        },
        "index": {
          "description": "Check whether this is the type of Distinct witness",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isDistinctWitType",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "Distinct Wit Type",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isDistinctWitType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if some kind is the effect kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isEffectKind",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isEffectKind",
          "type": "function"
        },
        "index": {
          "description": "Check if some kind is the effect kind",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isEffectKind",
          "normalized": "Kind a-\u003eBool",
          "package": "ddc-core",
          "partial": "Effect Kind",
          "signature": "Kind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isEffectKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this is the type of a \u003ccode\u003eMutable\u003c/code\u003e witness.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isMutableWitType",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isMutableWitType",
          "type": "function"
        },
        "index": {
          "description": "Check whether this is the type of Mutable witness",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isMutableWitType",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "Mutable Wit Type",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isMutableWitType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this is an atomic read effect.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isReadEffect",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isReadEffect",
          "type": "function"
        },
        "index": {
          "description": "Check whether this is an atomic read effect",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isReadEffect",
          "normalized": "Effect a-\u003eBool",
          "package": "ddc-core",
          "partial": "Read Effect",
          "signature": "Effect n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isReadEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if some kind is the region kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isRegionKind",
          "package": "ddc-core",
          "signature": "Region n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isRegionKind",
          "type": "function"
        },
        "index": {
          "description": "Check if some kind is the region kind",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isRegionKind",
          "normalized": "Region a-\u003eBool",
          "package": "ddc-core",
          "partial": "Region Kind",
          "signature": "Region n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isRegionKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an effect is some sort of allocation effect.\n   Matches \u003ccode\u003eAlloc\u003c/code\u003e and \u003ccode\u003eDeepAlloc\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isSomeAllocEffect",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isSomeAllocEffect",
          "type": "function"
        },
        "index": {
          "description": "Check whether an effect is some sort of allocation effect Matches Alloc and DeepAlloc",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isSomeAllocEffect",
          "normalized": "Effect a-\u003eBool",
          "package": "ddc-core",
          "partial": "Some Alloc Effect",
          "signature": "Effect n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isSomeAllocEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an effect is some sort of read effect.\n   Matches \u003ccode\u003eRead\u003c/code\u003e \u003ccode\u003eHeadRead\u003c/code\u003e and \u003ccode\u003eDeepRead\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isSomeReadEffect",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isSomeReadEffect",
          "type": "function"
        },
        "index": {
          "description": "Check whether an effect is some sort of read effect Matches Read HeadRead and DeepRead",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isSomeReadEffect",
          "normalized": "Effect a-\u003eBool",
          "package": "ddc-core",
          "partial": "Some Read Effect",
          "signature": "Effect n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isSomeReadEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an effect is some sort of allocation effect.\n   Matches \u003ccode\u003eAlloc\u003c/code\u003e and \u003ccode\u003eDeepAlloc\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isSomeWriteEffect",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isSomeWriteEffect",
          "type": "function"
        },
        "index": {
          "description": "Check whether an effect is some sort of allocation effect Matches Alloc and DeepAlloc",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isSomeWriteEffect",
          "normalized": "Effect a-\u003eBool",
          "package": "ddc-core",
          "partial": "Some Write Effect",
          "signature": "Effect n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isSomeWriteEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a type is a \u003ccode\u003e\u003ca\u003eTVar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isTVar",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isTVar",
          "type": "function"
        },
        "index": {
          "description": "Check whether type is TVar",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isTVar",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "TVar",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isTVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck if some kind is the witness kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isWitnessKind",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isWitnessKind",
          "type": "function"
        },
        "index": {
          "description": "Check if some kind is the witness kind",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isWitnessKind",
          "normalized": "Kind a-\u003eBool",
          "package": "ddc-core",
          "partial": "Witness Kind",
          "signature": "Kind n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isWitnessKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether type is a witness constructor\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isWitnessType",
          "package": "ddc-core",
          "signature": "Type n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isWitnessType",
          "type": "function"
        },
        "index": {
          "description": "Check whether type is witness constructor",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isWitnessType",
          "normalized": "Type a-\u003eBool",
          "package": "ddc-core",
          "partial": "Witness Type",
          "signature": "Type n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isWitnessType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether this is an atomic write effect.\n\u003c/p\u003e",
          "module": "DDC.Type.Predicates",
          "name": "isWriteEffect",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Bool",
          "source": "src/DDC-Type-Predicates.html#isWriteEffect",
          "type": "function"
        },
        "index": {
          "description": "Check whether this is an atomic write effect",
          "hierarchy": "DDC Type Predicates",
          "module": "DDC.Type.Predicates",
          "name": "isWriteEffect",
          "normalized": "Effect a-\u003eBool",
          "package": "ddc-core",
          "partial": "Write Effect",
          "signature": "Effect n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Predicates.html#v:isWriteEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Subsumes",
          "name": "Subsumes",
          "package": "ddc-core",
          "source": "src/DDC-Type-Subsumes.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Subsumes",
          "module": "DDC.Type.Subsumes",
          "name": "Subsumes",
          "package": "ddc-core",
          "partial": "Subsumes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Subsumes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether the first type subsumes the second.\n\u003c/p\u003e\u003cp\u003eBoth arguments are converted to sums, and we check that every\n   element of the second sum is equivalent to an element in the first.\n\u003c/p\u003e\u003cp\u003eThis only works for well formed types of effect and closure kind.\n   Other types will yield \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Subsumes",
          "name": "subsumesT",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Type n -\u003e Type n -\u003e Bool",
          "source": "src/DDC-Type-Subsumes.html#subsumesT",
          "type": "function"
        },
        "index": {
          "description": "Check whether the first type subsumes the second Both arguments are converted to sums and we check that every element of the second sum is equivalent to an element in the first This only works for well formed types of effect and closure kind Other types will yield False",
          "hierarchy": "DDC Type Subsumes",
          "module": "DDC.Type.Subsumes",
          "name": "subsumesT",
          "normalized": "Kind a-\u003eType a-\u003eType a-\u003eBool",
          "package": "ddc-core",
          "signature": "Kind n-\u003eType n-\u003eType n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Subsumes.html#v:subsumesT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities for working with \u003ccode\u003e\u003ca\u003eTypeSum\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Sum",
          "name": "Sum",
          "package": "ddc-core",
          "source": "src/DDC-Type-Sum.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities for working with TypeSum",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "Sum",
          "package": "ddc-core",
          "partial": "Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete an element from a sum.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "delete",
          "package": "ddc-core",
          "signature": "Type n -\u003e TypeSum n -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#delete",
          "type": "function"
        },
        "index": {
          "description": "Delete an element from sum",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "delete",
          "normalized": "Type a-\u003eTypeSum a-\u003eTypeSum a",
          "package": "ddc-core",
          "signature": "Type n-\u003eTypeSum n-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete all members of the second sum from the first one.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "difference",
          "package": "ddc-core",
          "signature": "TypeSum n -\u003e TypeSum n -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#difference",
          "type": "function"
        },
        "index": {
          "description": "Delete all members of the second sum from the first one",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "difference",
          "normalized": "TypeSum a-\u003eTypeSum a-\u003eTypeSum a",
          "package": "ddc-core",
          "signature": "TypeSum n-\u003eTypeSum n-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether an element is a member of a sum.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Returns True when the first argument is $0 or !0.\n\u003c/li\u003e\u003cli\u003e Returns False when the first argument is another sum.\n\u003c/li\u003e\u003cli\u003e May return False if the first argument is miskinded but still\n     alpha-equivalent to some component of the sum.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "DDC.Type.Sum",
          "name": "elem",
          "package": "ddc-core",
          "signature": "Type n -\u003e TypeSum n -\u003e Bool",
          "source": "src/DDC-Type-Sum.html#elem",
          "type": "function"
        },
        "index": {
          "description": "Check whether an element is member of sum Returns True when the first argument is or Returns False when the first argument is another sum May return False if the first argument is miskinded but still alpha-equivalent to some component of the sum",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "elem",
          "normalized": "Type a-\u003eTypeSum a-\u003eBool",
          "package": "ddc-core",
          "signature": "Type n-\u003eTypeSum n-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:elem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an empty type sum of the given kind.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "empty",
          "package": "ddc-core",
          "signature": "Kind n -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#empty",
          "type": "function"
        },
        "index": {
          "description": "Construct an empty type sum of the given kind",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "empty",
          "normalized": "Kind a-\u003eTypeSum a",
          "package": "ddc-core",
          "signature": "Kind n-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of types to a \u003ccode\u003e\u003ca\u003eTypeSum\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "fromList",
          "package": "ddc-core",
          "signature": "Kind n -\u003e [Type n] -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Convert list of types to TypeSum",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "fromList",
          "normalized": "Kind a-\u003e[Type a]-\u003eTypeSum a",
          "package": "ddc-core",
          "partial": "List",
          "signature": "Kind n-\u003e[Type n]-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the \u003ccode\u003e\u003ca\u003eTyConHash\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eTyCon\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there isn't one.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "hashTyCon",
          "package": "ddc-core",
          "signature": "TyCon n -\u003e Maybe TyConHash",
          "source": "src/DDC-Type-Sum.html#hashTyCon",
          "type": "function"
        },
        "index": {
          "description": "Yield the TyConHash of TyCon or Nothing if there isn one",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "hashTyCon",
          "normalized": "TyCon a-\u003eMaybe TyConHash",
          "package": "ddc-core",
          "partial": "Ty Con",
          "signature": "TyCon n-\u003eMaybe TyConHash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:hashTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe range of hashes that can be produced by \u003ccode\u003e\u003ca\u003ehashTyCon\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "hashTyConRange",
          "package": "ddc-core",
          "signature": "(TyConHash, TyConHash)",
          "source": "src/DDC-Type-Sum.html#hashTyConRange",
          "type": "function"
        },
        "index": {
          "description": "The range of hashes that can be produced by hashTyCon",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "hashTyConRange",
          "normalized": "(TyConHash,TyConHash)",
          "package": "ddc-core",
          "partial": "Ty Con Range",
          "signature": "(TyConHash,TyConHash)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:hashTyConRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert a new element into a sum.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "insert",
          "package": "ddc-core",
          "signature": "Type n -\u003e TypeSum n -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#insert",
          "type": "function"
        },
        "index": {
          "description": "Insert new element into sum",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "insert",
          "normalized": "Type a-\u003eTypeSum a-\u003eTypeSum a",
          "package": "ddc-core",
          "signature": "Type n-\u003eTypeSum n-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the kind of a sum.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "kindOfSum",
          "package": "ddc-core",
          "signature": "TypeSum n -\u003e Kind n",
          "source": "src/DDC-Type-Sum.html#kindOfSum",
          "type": "function"
        },
        "index": {
          "description": "Take the kind of sum",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "kindOfSum",
          "normalized": "TypeSum a-\u003eKind a",
          "package": "ddc-core",
          "partial": "Of Sum",
          "signature": "TypeSum n-\u003eKind n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:kindOfSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a type sum containing a single element.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "singleton",
          "package": "ddc-core",
          "signature": "Kind n -\u003e Type n -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "Construct type sum containing single element",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "singleton",
          "normalized": "Kind a-\u003eType a-\u003eTypeSum a",
          "package": "ddc-core",
          "signature": "Kind n-\u003eType n-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten out a sum, yielding a list of individual terms.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "toList",
          "package": "ddc-core",
          "signature": "TypeSum n -\u003e [Type n]",
          "source": "src/DDC-Type-Sum.html#toList",
          "type": "function"
        },
        "index": {
          "description": "Flatten out sum yielding list of individual terms",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "toList",
          "normalized": "TypeSum a-\u003e[Type a]",
          "package": "ddc-core",
          "partial": "List",
          "signature": "TypeSum n-\u003e[Type n]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the \u003ccode\u003e\u003ca\u003eTyCon\u003c/a\u003e\u003c/code\u003e corresponding to a \u003ccode\u003e\u003ca\u003eTyConHash\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e if there isn't one.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "unhashTyCon",
          "package": "ddc-core",
          "signature": "TyConHash -\u003e TyCon n",
          "source": "src/DDC-Type-Sum.html#unhashTyCon",
          "type": "function"
        },
        "index": {
          "description": "Yield the TyCon corresponding to TyConHash or error if there isn one",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "unhashTyCon",
          "normalized": "TyConHash-\u003eTyCon a",
          "package": "ddc-core",
          "partial": "Ty Con",
          "signature": "TyConHash-\u003eTyCon n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:unhashTyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd two type sums.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "union",
          "package": "ddc-core",
          "signature": "TypeSum n -\u003e TypeSum n -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#union",
          "type": "function"
        },
        "index": {
          "description": "Add two type sums",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "union",
          "normalized": "TypeSum a-\u003eTypeSum a-\u003eTypeSum a",
          "package": "ddc-core",
          "signature": "TypeSum n-\u003eTypeSum n-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnion a list of \u003ccode\u003e\u003ca\u003eTypeSum\u003c/a\u003e\u003c/code\u003es together.\n\u003c/p\u003e",
          "module": "DDC.Type.Sum",
          "name": "unions",
          "package": "ddc-core",
          "signature": "Kind n -\u003e [TypeSum n] -\u003e TypeSum n",
          "source": "src/DDC-Type-Sum.html#unions",
          "type": "function"
        },
        "index": {
          "description": "Union list of TypeSum together",
          "hierarchy": "DDC Type Sum",
          "module": "DDC.Type.Sum",
          "name": "unions",
          "normalized": "Kind a-\u003e[TypeSum a]-\u003eTypeSum a",
          "package": "ddc-core",
          "signature": "Kind n-\u003e[TypeSum n]-\u003eTypeSum n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Sum.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.Crush",
          "name": "Crush",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Crush.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Transform Crush",
          "module": "DDC.Type.Transform.Crush",
          "name": "Crush",
          "package": "ddc-core",
          "partial": "Crush",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Crush.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCrush compound effect terms into their components.\n\u003c/p\u003e\u003cp\u003eThis is like \u003ccode\u003e\u003ca\u003etrimClosure\u003c/a\u003e\u003c/code\u003e but for effects instead of closures.\n\u003c/p\u003e\u003cp\u003eFor example, crushing \u003ccode\u003eDeepRead (List r1 (Int r2))\u003c/code\u003e yields \u003ccode\u003e(Read r1 + Read r2)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Crush",
          "name": "crushEffect",
          "package": "ddc-core",
          "signature": "Effect n -\u003e Effect n",
          "source": "src/DDC-Type-Transform-Crush.html#crushEffect",
          "type": "function"
        },
        "index": {
          "description": "Crush compound effect terms into their components This is like trimClosure but for effects instead of closures For example crushing DeepRead List r1 Int r2 yields Read r1 Read r2",
          "hierarchy": "DDC Type Transform Crush",
          "module": "DDC.Type.Transform.Crush",
          "name": "crushEffect",
          "normalized": "Effect a-\u003eEffect a",
          "package": "ddc-core",
          "partial": "Effect",
          "signature": "Effect n-\u003eEffect n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Crush.html#v:crushEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCrush compound effects and closure terms.\n   We check for a crushable term before calling crushT because that function\n   will recursively crush the components. \n   As equivT is already recursive, we don't want a doubly-recursive function\n   that tries to re-crush the same non-crushable type over and over.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Crush",
          "name": "crushSomeT",
          "package": "ddc-core",
          "signature": "Type n -\u003e Type n",
          "source": "src/DDC-Type-Transform-Crush.html#crushSomeT",
          "type": "function"
        },
        "index": {
          "description": "Crush compound effects and closure terms We check for crushable term before calling crushT because that function will recursively crush the components As equivT is already recursive we don want doubly-recursive function that tries to re-crush the same non-crushable type over and over",
          "hierarchy": "DDC Type Transform Crush",
          "module": "DDC.Type.Transform.Crush",
          "name": "crushSomeT",
          "normalized": "Type a-\u003eType a",
          "package": "ddc-core",
          "partial": "Some",
          "signature": "Type n-\u003eType n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Crush.html#v:crushSomeT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.Instantiate",
          "name": "Instantiate",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Instantiate.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Transform Instantiate",
          "module": "DDC.Type.Transform.Instantiate",
          "name": "Instantiate",
          "package": "ddc-core",
          "partial": "Instantiate",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Instantiate.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstantiate a type with an argument.\n   The type to be instantiated must have an outer forall, else \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Instantiate",
          "name": "instantiateT",
          "package": "ddc-core",
          "signature": "Type n-\u003e Type n-\u003e Maybe (Type n)",
          "type": "function"
        },
        "index": {
          "description": "Instantiate type with an argument The type to be instantiated must have an outer forall else Nothing",
          "hierarchy": "DDC Type Transform Instantiate",
          "module": "DDC.Type.Transform.Instantiate",
          "name": "instantiateT",
          "normalized": "Type a-\u003eType a-\u003eMaybe(Type a)",
          "package": "ddc-core",
          "signature": "Type n-\u003eType n-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Instantiate.html#v:instantiateT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstantiate a type with several arguments.\n   The type to be instantiated must have at least as many outer foralls \n   as provided type arguments, else \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Instantiate",
          "name": "instantiateTs",
          "package": "ddc-core",
          "signature": "Type n-\u003e [Type n]-\u003e Maybe (Type n)",
          "type": "function"
        },
        "index": {
          "description": "Instantiate type with several arguments The type to be instantiated must have at least as many outer foralls as provided type arguments else Nothing",
          "hierarchy": "DDC Type Transform Instantiate",
          "module": "DDC.Type.Transform.Instantiate",
          "name": "instantiateTs",
          "normalized": "Type a-\u003e[Type a]-\u003eMaybe(Type a)",
          "package": "ddc-core",
          "partial": "Ts",
          "signature": "Type n-\u003e[Type n]-\u003eMaybe(Type n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Instantiate.html#v:instantiateTs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLifting of deBruijn indices in a type.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Transform.LiftT",
          "name": "LiftT",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-LiftT.html",
          "type": "module"
        },
        "index": {
          "description": "Lifting of deBruijn indices in type",
          "hierarchy": "DDC Type Transform LiftT",
          "module": "DDC.Type.Transform.LiftT",
          "name": "LiftT",
          "package": "ddc-core",
          "partial": "Lift",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-LiftT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.LiftT",
          "name": "MapBoundT",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-LiftT.html#MapBoundT",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Type Transform LiftT",
          "module": "DDC.Type.Transform.LiftT",
          "name": "MapBoundT",
          "package": "ddc-core",
          "partial": "Map Bound",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-LiftT.html#t:MapBoundT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLower debruijn indices less than or equal to the given depth.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.LiftT",
          "name": "lowerAtDepthT",
          "package": "ddc-core",
          "signature": "Int-\u003e Int-\u003e c n-\u003e c n",
          "type": "function"
        },
        "index": {
          "description": "Lower debruijn indices less than or equal to the given depth",
          "hierarchy": "DDC Type Transform LiftT",
          "module": "DDC.Type.Transform.LiftT",
          "name": "lowerAtDepthT",
          "normalized": "Int-\u003eInt-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "partial": "At Depth",
          "signature": "Int-\u003eInt-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-LiftT.html#v:lowerAtDepthT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003elowerAtDepthX\u003c/code\u003e that starts at depth 0.       \n\u003c/p\u003e",
          "module": "DDC.Type.Transform.LiftT",
          "name": "lowerT",
          "package": "ddc-core",
          "signature": "Int -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-LiftT.html#lowerT",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for lowerAtDepthX that starts at depth",
          "hierarchy": "DDC Type Transform LiftT",
          "module": "DDC.Type.Transform.LiftT",
          "name": "lowerT",
          "normalized": "Int-\u003ea b-\u003ea b",
          "package": "ddc-core",
          "signature": "Int-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-LiftT.html#v:lowerT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to all bound variables in the program.\n   The function is passed the current binding depth.\n   This is used to defined both \u003ccode\u003e\u003ca\u003eliftT\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elowerT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.LiftT",
          "name": "mapBoundAtDepthT",
          "package": "ddc-core",
          "signature": "mapBoundAtDepthT",
          "source": "src/DDC-Type-Transform-LiftT.html#mapBoundAtDepthT",
          "type": "method"
        },
        "index": {
          "description": "Apply function to all bound variables in the program The function is passed the current binding depth This is used to defined both liftT and lowerT",
          "hierarchy": "DDC Type Transform LiftT",
          "module": "DDC.Type.Transform.LiftT",
          "name": "mapBoundAtDepthT",
          "package": "ddc-core",
          "partial": "Bound At Depth",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-LiftT.html#v:mapBoundAtDepthT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eRenaming of variable binders to anonymous form to avoid capture.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html",
          "type": "module"
        },
        "index": {
          "description": "Renaming of variable binders to anonymous form to avoid capture",
          "hierarchy": "DDC Type Transform Rename",
          "module": "DDC.Type.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "partial": "Rename",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStack of anonymous binders that we've entered under during substitution. \n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Rename",
          "name": "BindStack",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "data"
        },
        "index": {
          "description": "Stack of anonymous binders that we ve entered under during substitution",
          "hierarchy": "DDC Type Transform Rename",
          "module": "DDC.Type.Transform.Rename",
          "name": "BindStack",
          "package": "ddc-core",
          "partial": "Bind Stack",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#t:BindStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html#Rename",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Type Transform Rename",
          "module": "DDC.Type.Transform.Rename",
          "name": "Rename",
          "package": "ddc-core",
          "partial": "Rename",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#t:Rename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitution state.\n   Keeps track of the binders in the environment that have been rewrittten\n   to avoid variable capture or spec binder shadowing.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Rename",
          "name": "Sub",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html#Sub",
          "type": "data"
        },
        "index": {
          "description": "Substitution state Keeps track of the binders in the environment that have been rewrittten to avoid variable capture or spec binder shadowing",
          "hierarchy": "DDC Type Transform Rename",
          "module": "DDC.Type.Transform.Rename",
          "name": "Sub",
          "package": "ddc-core",
          "partial": "Sub",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#t:Sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite names in some thing to anonymous form if they conflict with\n    any names in the \u003ccode\u003e\u003ca\u003eSub\u003c/a\u003e\u003c/code\u003e state. We use this to avoid variable capture\n    during substitution.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Rename",
          "name": "renameWith",
          "package": "ddc-core",
          "signature": "Sub n -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-Rename.html#renameWith",
          "type": "method"
        },
        "index": {
          "description": "Rewrite names in some thing to anonymous form if they conflict with any names in the Sub state We use this to avoid variable capture during substitution",
          "hierarchy": "DDC Type Transform Rename",
          "module": "DDC.Type.Transform.Rename",
          "name": "renameWith",
          "normalized": "Sub a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "With",
          "signature": "Sub n-\u003ec n-\u003ec n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Rename.html#v:renameWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.SpreadT",
          "name": "SpreadT",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-SpreadT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Transform SpreadT",
          "module": "DDC.Type.Transform.SpreadT",
          "name": "SpreadT",
          "package": "ddc-core",
          "partial": "Spread",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SpreadT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.SpreadT",
          "name": "SpreadT",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-SpreadT.html#SpreadT",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Type Transform SpreadT",
          "module": "DDC.Type.Transform.SpreadT",
          "name": "SpreadT",
          "package": "ddc-core",
          "partial": "Spread",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SpreadT.html#t:SpreadT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite \u003ccode\u003e\u003ca\u003eUName\u003c/a\u003e\u003c/code\u003e bounds to \u003ccode\u003e\u003ca\u003eUPrim\u003c/a\u003e\u003c/code\u003e bounds and attach their types.\n   Primitives have their types attached because they are so common in the\n   language, their types are closed, and we don't want to keep having to\n   look them up from the environment.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.SpreadT",
          "name": "spreadT",
          "package": "ddc-core",
          "signature": "TypeEnv n -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-SpreadT.html#spreadT",
          "type": "method"
        },
        "index": {
          "description": "Rewrite UName bounds to UPrim bounds and attach their types Primitives have their types attached because they are so common in the language their types are closed and we don want to keep having to look them up from the environment",
          "hierarchy": "DDC Type Transform SpreadT",
          "module": "DDC.Type.Transform.SpreadT",
          "name": "spreadT",
          "normalized": "TypeEnv a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "signature": "TypeEnv n-\u003ec n-\u003ec n",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SpreadT.html#v:spreadT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCapture avoiding substitution of types in types.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "SubstituteT",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-SubstituteT.html",
          "type": "module"
        },
        "index": {
          "description": "Capture avoiding substitution of types in types",
          "hierarchy": "DDC Type Transform SubstituteT",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "SubstituteT",
          "package": "ddc-core",
          "partial": "Substitute",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStack of anonymous binders that we've entered under during substitution. \n\u003c/p\u003e",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "BindStack",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Rename.html#BindStack",
          "type": "data"
        },
        "index": {
          "description": "Stack of anonymous binders that we ve entered under during substitution",
          "hierarchy": "DDC Type Transform SubstituteT",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "BindStack",
          "package": "ddc-core",
          "partial": "Bind Stack",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#t:BindStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "SubstituteT",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-SubstituteT.html#SubstituteT",
          "type": "class"
        },
        "index": {
          "hierarchy": "DDC Type Transform SubstituteT",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "SubstituteT",
          "package": "ddc-core",
          "partial": "Substitute",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#t:SubstituteT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute a \u003ccode\u003e\u003ca\u003eType\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003e in some thing.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteBoundT",
          "package": "ddc-core",
          "signature": "Bound n -\u003e Type n -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-SubstituteT.html#substituteBoundT",
          "type": "function"
        },
        "index": {
          "description": "Substitute Type for Bound in some thing",
          "hierarchy": "DDC Type Transform SubstituteT",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteBoundT",
          "normalized": "Bound a-\u003eType a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "Bound",
          "signature": "Bound n-\u003eType n-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:substituteBoundT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute a \u003ccode\u003e\u003ca\u003eType\u003c/a\u003e\u003c/code\u003e for the \u003ccode\u003e\u003ca\u003eBound\u003c/a\u003e\u003c/code\u003e corresponding to some \u003ccode\u003e\u003ca\u003eBind\u003c/a\u003e\u003c/code\u003e in a thing.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteT",
          "package": "ddc-core",
          "signature": "Bind n -\u003e Type n -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-SubstituteT.html#substituteT",
          "type": "function"
        },
        "index": {
          "description": "Substitute Type for the Bound corresponding to some Bind in thing",
          "hierarchy": "DDC Type Transform SubstituteT",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteT",
          "normalized": "Bind a-\u003eType a-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "signature": "Bind n-\u003eType n-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:substituteT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for \u003ccode\u003e\u003ca\u003esubstituteT\u003c/a\u003e\u003c/code\u003e to substitute multiple things.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteTs",
          "package": "ddc-core",
          "signature": "[(Bind n, Type n)] -\u003e c n -\u003e c n",
          "source": "src/DDC-Type-Transform-SubstituteT.html#substituteTs",
          "type": "function"
        },
        "index": {
          "description": "Wrapper for substituteT to substitute multiple things",
          "hierarchy": "DDC Type Transform SubstituteT",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteTs",
          "normalized": "[(Bind a,Type a)]-\u003eb a-\u003eb a",
          "package": "ddc-core",
          "partial": "Ts",
          "signature": "[(Bind n,Type n)]-\u003ec n-\u003ec n",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:substituteTs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute a type into some thing.\n   In the target, if we find a named binder that would capture a free variable\n   in the type to substitute, then we rewrite that binder to anonymous form,\n   avoiding the capture.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteWithT",
          "package": "ddc-core",
          "signature": "substituteWithT",
          "source": "src/DDC-Type-Transform-SubstituteT.html#substituteWithT",
          "type": "method"
        },
        "index": {
          "description": "Substitute type into some thing In the target if we find named binder that would capture free variable in the type to substitute then we rewrite that binder to anonymous form avoiding the capture",
          "hierarchy": "DDC Type Transform SubstituteT",
          "module": "DDC.Type.Transform.SubstituteT",
          "name": "substituteWithT",
          "package": "ddc-core",
          "partial": "With",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-SubstituteT.html#v:substituteWithT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Transform.Trim",
          "name": "Trim",
          "package": "ddc-core",
          "source": "src/DDC-Type-Transform-Trim.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Transform Trim",
          "module": "DDC.Type.Transform.Trim",
          "name": "Trim",
          "package": "ddc-core",
          "partial": "Trim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Trim.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrim compound closures into their components. \n\u003c/p\u003e\u003cp\u003eThis is like \u003ccode\u003ecrushEffect\u003c/code\u003e, but for closures instead of effects.\n\u003c/p\u003e\u003cp\u003eFor example, trimming \u003ccode\u003eDeepUse (Int r2 -(Read r1 | Use r1)\u003e Int r2)\u003c/code\u003e yields\n   just \u003ccode\u003eUse r1\u003c/code\u003e. \n   Only \u003ccode\u003er1\u003c/code\u003e might contain an actual store object that is reachable from a function\n   closure with such a type.\n\u003c/p\u003e\u003cp\u003eThis function assumes the closure is well-kinded, and may return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if\n   this is not the case.\n\u003c/p\u003e",
          "module": "DDC.Type.Transform.Trim",
          "name": "trimClosure",
          "package": "ddc-core",
          "signature": "Closure n -\u003e Maybe (Closure n)",
          "source": "src/DDC-Type-Transform-Trim.html#trimClosure",
          "type": "function"
        },
        "index": {
          "description": "Trim compound closures into their components This is like crushEffect but for closures instead of effects For example trimming DeepUse Int r2 Read r1 Use r1 Int r2 yields just Use r1 Only r1 might contain an actual store object that is reachable from function closure with such type This function assumes the closure is well-kinded and may return Nothing if this is not the case",
          "hierarchy": "DDC Type Transform Trim",
          "module": "DDC.Type.Transform.Trim",
          "name": "trimClosure",
          "normalized": "Closure a-\u003eMaybe(Closure a)",
          "package": "ddc-core",
          "partial": "Closure",
          "signature": "Closure n-\u003eMaybe(Closure n)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Transform-Trim.html#v:trimClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "DDC.Type.Universe",
          "name": "Universe",
          "package": "ddc-core",
          "source": "src/DDC-Type-Universe.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "Universe",
          "package": "ddc-core",
          "partial": "Universe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUniverses of the Disciple Core language.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "Universe",
          "package": "ddc-core",
          "source": "src/DDC-Type-Universe.html#Universe",
          "type": "data"
        },
        "index": {
          "description": "Universes of the Disciple Core language",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "Universe",
          "package": "ddc-core",
          "partial": "Universe",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#t:Universe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 0). The universe of data values.\n   These are physical data objects that take up space at runtime.\n   This is like the \u003ccode\u003eSet\u003c/code\u003e universe in constructive logic, but the \n   expressions may diverge or cause side effects.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "UniverseData",
          "package": "ddc-core",
          "signature": "UniverseData",
          "source": "src/DDC-Type-Universe.html#Universe",
          "type": "function"
        },
        "index": {
          "description": "level The universe of data values These are physical data objects that take up space at runtime This is like the Set universe in constructive logic but the expressions may diverge or cause side effects",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "UniverseData",
          "package": "ddc-core",
          "partial": "Universe Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:UniverseData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 2). The universe of kinds.\n   Kinds classify specifications.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "UniverseKind",
          "package": "ddc-core",
          "signature": "UniverseKind",
          "source": "src/DDC-Type-Universe.html#Universe",
          "type": "function"
        },
        "index": {
          "description": "level The universe of kinds Kinds classify specifications",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "UniverseKind",
          "package": "ddc-core",
          "partial": "Universe Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:UniverseKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 3). The universe of sorts.\n   Sorts classify kinds.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "UniverseSort",
          "package": "ddc-core",
          "signature": "UniverseSort",
          "source": "src/DDC-Type-Universe.html#Universe",
          "type": "function"
        },
        "index": {
          "description": "level The universe of sorts Sorts classify kinds",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "UniverseSort",
          "package": "ddc-core",
          "partial": "Universe Sort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:UniverseSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 1). The universe of specifications.\n   Specifications classify both witnesses and data values.\n   In the vanilla Haskell world \"specifications\" are known as\n   \"types\", but here we use the former term because we overload\n   the word \"type\" to refer to kinds and sorts as well.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "UniverseSpec",
          "package": "ddc-core",
          "signature": "UniverseSpec",
          "source": "src/DDC-Type-Universe.html#Universe",
          "type": "function"
        },
        "index": {
          "description": "level The universe of specifications Specifications classify both witnesses and data values In the vanilla Haskell world specifications are known as types but here we use the former term because we overload the word type to refer to kinds and sorts as well",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "UniverseSpec",
          "package": "ddc-core",
          "partial": "Universe Spec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:UniverseSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(level 0). The universe of witnesses.\n   The existence of a witness in the program guarantees that some\n   property about how it operates at runtime. For example, a witness\n   of constancy of some region guarantees objects in that region will\n   not be updated. This is like the \u003ccode\u003eProp\u003c/code\u003e universe in constructive\n   logic.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "UniverseWitness",
          "package": "ddc-core",
          "signature": "UniverseWitness",
          "source": "src/DDC-Type-Universe.html#Universe",
          "type": "function"
        },
        "index": {
          "description": "level The universe of witnesses The existence of witness in the program guarantees that some property about how it operates at runtime For example witness of constancy of some region guarantees objects in that region will not be updated This is like the Prop universe in constructive logic",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "UniverseWitness",
          "package": "ddc-core",
          "partial": "Universe Witness",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:UniverseWitness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the type of some thing (up one level),\n   yield the universe of the original thing, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it was badly formed.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "universeFromType1",
          "package": "ddc-core",
          "signature": "Env n -\u003e Type n -\u003e Maybe Universe",
          "source": "src/DDC-Type-Universe.html#universeFromType1",
          "type": "function"
        },
        "index": {
          "description": "Given the type of some thing up one level yield the universe of the original thing or Nothing if it was badly formed",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "universeFromType1",
          "normalized": "Env a-\u003eType a-\u003eMaybe Universe",
          "package": "ddc-core",
          "partial": "From Type",
          "signature": "Env n-\u003eType n-\u003eMaybe Universe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:universeFromType1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the type of the type of some thing (up two levels),\n   yield the universe of the original thing, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it was badly formed.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "universeFromType2",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe Universe",
          "source": "src/DDC-Type-Universe.html#universeFromType2",
          "type": "function"
        },
        "index": {
          "description": "Given the type of the type of some thing up two levels yield the universe of the original thing or Nothing if it was badly formed",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "universeFromType2",
          "normalized": "Type a-\u003eMaybe Universe",
          "package": "ddc-core",
          "partial": "From Type",
          "signature": "Type n-\u003eMaybe Universe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:universeFromType2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the type of the type of the type of some thing (up three levels),\n   yield the universe of the original thing, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e it was badly formed.\n\u003c/p\u003e",
          "module": "DDC.Type.Universe",
          "name": "universeFromType3",
          "package": "ddc-core",
          "signature": "Type n -\u003e Maybe Universe",
          "source": "src/DDC-Type-Universe.html#universeFromType3",
          "type": "function"
        },
        "index": {
          "description": "Given the type of the type of the type of some thing up three levels yield the universe of the original thing or Nothing it was badly formed",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "universeFromType3",
          "normalized": "Type a-\u003eMaybe Universe",
          "package": "ddc-core",
          "partial": "From Type",
          "signature": "Type n-\u003eMaybe Universe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:universeFromType3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the universe of some type.\n\u003c/p\u003e\u003cpre\u003e  universeOfType (tBot kEffect) = UniverseSpec\n  universeOfType kRegion        = UniverseKind\n\u003c/pre\u003e",
          "module": "DDC.Type.Universe",
          "name": "universeOfType",
          "package": "ddc-core",
          "signature": "Env n -\u003e Type n -\u003e Maybe Universe",
          "source": "src/DDC-Type-Universe.html#universeOfType",
          "type": "function"
        },
        "index": {
          "description": "Yield the universe of some type universeOfType tBot kEffect UniverseSpec universeOfType kRegion UniverseKind",
          "hierarchy": "DDC Type Universe",
          "module": "DDC.Type.Universe",
          "name": "universeOfType",
          "normalized": "Env a-\u003eType a-\u003eMaybe Universe",
          "package": "ddc-core",
          "partial": "Of Type",
          "signature": "Env n-\u003eType n-\u003eMaybe Universe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/ddc-core/docs/DDC-Type-Universe.html#v:universeOfType"
      }
    }
  ]
]