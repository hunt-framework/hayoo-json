[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "diagrams-builder"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools for creating standalone command-line diagram builder utilities.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Builder.CmdLine",
          "name": "CmdLine",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-CmdLine.html",
          "type": "module"
        },
        "index": {
          "description": "Tools for creating standalone command-line diagram builder utilities",
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "CmdLine",
          "package": "diagrams-builder",
          "partial": "Cmd Line",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecord of command-line options.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.CmdLine",
          "name": "Build",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "data"
        },
        "index": {
          "description": "Record of command-line options",
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "Build",
          "package": "diagrams-builder",
          "partial": "Build",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#t:Build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "Build",
          "package": "diagrams-builder",
          "signature": "Build",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:Build\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:Build\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "Build",
          "package": "diagrams-builder",
          "partial": "Build",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:Build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault command-line options record.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "defaultBuildOpts",
          "package": "diagrams-builder",
          "signature": "Build",
          "source": "src/Diagrams-Builder-CmdLine.html#defaultBuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:defaultBuildOpts\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:defaultBuildOpts\"]"
        },
        "index": {
          "description": "Default command-line options record",
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "defaultBuildOpts",
          "package": "diagrams-builder",
          "partial": "Build Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:defaultBuildOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "dir",
          "package": "diagrams-builder",
          "signature": "String",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:dir\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:dir\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "dir",
          "package": "diagrams-builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:dir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "expr",
          "package": "diagrams-builder",
          "signature": "String",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:expr\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:expr\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "expr",
          "package": "diagrams-builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "height",
          "package": "diagrams-builder",
          "signature": "Maybe Double",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:height\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:height\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "height",
          "package": "diagrams-builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "outFile",
          "package": "diagrams-builder",
          "signature": "String",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:outFile\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:outFile\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "outFile",
          "package": "diagrams-builder",
          "partial": "File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:outFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "srcFile",
          "package": "diagrams-builder",
          "signature": "String",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:srcFile\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:srcFile\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "srcFile",
          "package": "diagrams-builder",
          "partial": "File",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:srcFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.CmdLine\",\"Diagrams.Builder\"]",
          "name": "width",
          "package": "diagrams-builder",
          "signature": "Maybe Double",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:width\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:width\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder CmdLine",
          "module": "Diagrams.Builder.CmdLine",
          "name": "width",
          "package": "diagrams-builder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-CmdLine.html#v:width"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools used by diagrams-builder for manipulating Haskell modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "Modules",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-Modules.html",
          "type": "module"
        },
        "index": {
          "description": "Tools used by diagrams-builder for manipulating Haskell modules",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "Modules",
          "package": "diagrams-builder",
          "partial": "Modules",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd some imports to a module if necessary.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "addImports",
          "package": "diagrams-builder",
          "signature": "[String] -\u003e Module -\u003e Module",
          "source": "src/Diagrams-Builder-Modules.html#addImports",
          "type": "function"
        },
        "index": {
          "description": "Add some imports to module if necessary",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "addImports",
          "normalized": "[String]-\u003eModule-\u003eModule",
          "package": "diagrams-builder",
          "partial": "Imports",
          "signature": "[String]-\u003eModule-\u003eModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:addImports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd some \u003ccode\u003eLANGUAGE\u003c/code\u003e pragmas to a module if necessary.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "addPragmas",
          "package": "diagrams-builder",
          "signature": "[String] -\u003e Module -\u003e Module",
          "source": "src/Diagrams-Builder-Modules.html#addPragmas",
          "type": "function"
        },
        "index": {
          "description": "Add some LANGUAGE pragmas to module if necessary",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "addPragmas",
          "normalized": "[String]-\u003eModule-\u003eModule",
          "package": "diagrams-builder",
          "partial": "Pragmas",
          "signature": "[String]-\u003eModule-\u003eModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:addPragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two modules into one, with a left bias in the case of\n   things that can't be sensibly combined (\u003cem\u003ee.g.\u003c/em\u003e the module name).\n   Note that combining multiple imports of the same module with\n   different import specifications (qualification, hiding, explicit\n   import) is unlikely to work sensibly.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "combineModules",
          "package": "diagrams-builder",
          "signature": "Module -\u003e Module -\u003e Module",
          "source": "src/Diagrams-Builder-Modules.html#combineModules",
          "type": "function"
        },
        "index": {
          "description": "Combine two modules into one with left bias in the case of things that can be sensibly combined e.g the module name Note that combining multiple imports of the same module with different import specifications qualification hiding explicit import is unlikely to work sensibly",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "combineModules",
          "normalized": "Module-\u003eModule-\u003eModule",
          "package": "diagrams-builder",
          "partial": "Modules",
          "signature": "Module-\u003eModule-\u003eModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:combineModules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend some snippets of source code into a proper module, by\n   combining them intelligently (preserving imports, pragmas, \u003cem\u003eetc.\u003c/em\u003e),\n   (possibly) giving it a different name, and adding \u003ccode\u003eLANGUAGE\u003c/code\u003e pragmas\n   and imports if necessary.  Only those pragmas and imports which\n   are not already included in the code will be added.\n\u003c/p\u003e\u003cp\u003eReturns the updated module, or an error message if parsing\n   failed.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "createModule",
          "package": "diagrams-builder",
          "signature": "Maybe String-\u003e BuildOpts b v-\u003e Either String Module",
          "type": "function"
        },
        "index": {
          "description": "Extend some snippets of source code into proper module by combining them intelligently preserving imports pragmas etc possibly giving it different name and adding LANGUAGE pragmas and imports if necessary Only those pragmas and imports which are not already included in the code will be added Returns the updated module or an error message if parsing failed",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "createModule",
          "normalized": "Maybe String-\u003eBuildOpts a b-\u003eEither String Module",
          "package": "diagrams-builder",
          "partial": "Module",
          "signature": "Maybe String-\u003eBuildOpts b v-\u003eEither String Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:createModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete module exports.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "deleteExports",
          "package": "diagrams-builder",
          "signature": "Module -\u003e Module",
          "source": "src/Diagrams-Builder-Modules.html#deleteExports",
          "type": "function"
        },
        "index": {
          "description": "Delete module exports",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "deleteExports",
          "normalized": "Module-\u003eModule",
          "package": "diagrams-builder",
          "partial": "Exports",
          "signature": "Module-\u003eModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:deleteExports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the haskell-src-exts parser on a \u003ccode\u003eString\u003c/code\u003e representing some\n   Haskell code, producing a \u003ccode\u003eModule\u003c/code\u003e or an error message.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "doModuleParse",
          "package": "diagrams-builder",
          "signature": "String -\u003e Either String Module",
          "source": "src/Diagrams-Builder-Modules.html#doModuleParse",
          "type": "function"
        },
        "index": {
          "description": "Run the haskell-src-exts parser on String representing some Haskell code producing Module or an error message",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "doModuleParse",
          "normalized": "String-\u003eEither String Module",
          "package": "diagrams-builder",
          "partial": "Module Parse",
          "signature": "String-\u003eEither String Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:doModuleParse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Diagrams.Builder.Modules",
          "name": "emptyModule",
          "package": "diagrams-builder",
          "signature": "Module",
          "source": "src/Diagrams-Builder-Modules.html#emptyModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "emptyModule",
          "package": "diagrams-builder",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:emptyModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003eModuleName\u003c/code\u003e to a \u003ccode\u003eString\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "getModuleName",
          "package": "diagrams-builder",
          "signature": "ModuleName -\u003e String",
          "source": "src/Diagrams-Builder-Modules.html#getModuleName",
          "type": "function"
        },
        "index": {
          "description": "Convert ModuleName to String",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "getModuleName",
          "normalized": "ModuleName-\u003eString",
          "package": "diagrams-builder",
          "partial": "Module Name",
          "signature": "ModuleName-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:getModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the name of a module.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "replaceModuleName",
          "package": "diagrams-builder",
          "signature": "String -\u003e Module -\u003e Module",
          "source": "src/Diagrams-Builder-Modules.html#replaceModuleName",
          "type": "function"
        },
        "index": {
          "description": "Replace the name of module",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "replaceModuleName",
          "normalized": "String-\u003eModule-\u003eModule",
          "package": "diagrams-builder",
          "partial": "Module Name",
          "signature": "String-\u003eModule-\u003eModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:replaceModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all the literate comments and bird tracks from a literate\n   Haskell file.  Has no effect on non-literate source.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Modules",
          "name": "unLit",
          "package": "diagrams-builder",
          "signature": "String -\u003e String",
          "source": "src/Diagrams-Builder-Modules.html#unLit",
          "type": "function"
        },
        "index": {
          "description": "Remove all the literate comments and bird tracks from literate Haskell file Has no effect on non-literate source",
          "hierarchy": "Diagrams Builder Modules",
          "module": "Diagrams.Builder.Modules",
          "name": "unLit",
          "normalized": "String-\u003eString",
          "package": "diagrams-builder",
          "partial": "Lit",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Modules.html#v:unLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOptions for dynamic creation of diagrams.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Builder.Opts",
          "name": "Opts",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-Opts.html",
          "type": "module"
        },
        "index": {
          "description": "Options for dynamic creation of diagrams",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "Opts",
          "package": "diagrams-builder",
          "partial": "Opts",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions to control the behavior of \u003ccode\u003ebuildDiagram\u003c/code\u003e.  Create one\n   with \u003ccode\u003e\u003ca\u003emkBuildOpts\u003c/a\u003e\u003c/code\u003e followed by using the provided lenses to\n   override more fields; for example,\n\u003c/p\u003e\u003cpre\u003e\n   mkBuildOpts SVG zeroV (Options ...)\n     & imports .~ [\"Foo.Bar\", \"Baz.Quux\"]\n     & diaExpr .~ \"square 6 # fc green\"\n\u003c/pre\u003e",
          "module": "Diagrams.Builder.Opts",
          "name": "BuildOpts",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "data"
        },
        "index": {
          "description": "Options to control the behavior of buildDiagram Create one with mkBuildOpts followed by using the provided lenses to override more fields for example mkBuildOpts SVG zeroV Options imports Foo.Bar Baz.Quux diaExpr square fc green",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "BuildOpts",
          "package": "diagrams-builder",
          "partial": "Build Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#t:BuildOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSynonym for more perspicuous types.\n\u003c/p\u003e\u003cp\u003eWe use \u003ccode\u003eInt\u003c/code\u003e values for hashes because that's what the \u003ccode\u003eHashable\u003c/code\u003e\n   package uses.  Assuming diagram hashes are uniformly distributed,\n   on a 64-bit system one needs to build on the order of billions of\n   diagrams before the probability of a hash collision exceeds 1/2,\n   and for anything up to tens of millions of diagrams the\n   probability of a collision is under 0.1%.  On 32-bit systems\n   those become tens of thousands and thousands, respectively.\n\u003c/p\u003e",
          "module": "Diagrams.Builder.Opts",
          "name": "Hash",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-Opts.html#Hash",
          "type": "type"
        },
        "index": {
          "description": "Synonym for more perspicuous types We use Int values for hashes because that what the Hashable package uses Assuming diagram hashes are uniformly distributed on bit system one needs to build on the order of billions of diagrams before the probability of hash collision exceeds and for anything up to tens of millions of diagrams the probability of collision is under On bit systems those become tens of thousands and thousands respectively",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "Hash",
          "package": "diagrams-builder",
          "partial": "Hash",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#t:Hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "BuildOpts",
          "package": "diagrams-builder",
          "signature": "BuildOpts",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:BuildOpts\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:BuildOpts\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "BuildOpts",
          "package": "diagrams-builder",
          "partial": "Build Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:BuildOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "_backendOpts",
          "package": "diagrams-builder",
          "signature": "Options b v",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_backendOpts\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:_backendOpts\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "_backendOpts",
          "package": "diagrams-builder",
          "partial": "Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_backendOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "_decideRegen",
          "package": "diagrams-builder",
          "signature": "Hash -\u003e IO (Maybe (Options b v -\u003e Options b v))",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_decideRegen\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:_decideRegen\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "_decideRegen",
          "normalized": "Hash-\u003eIO(Maybe(Options a b-\u003eOptions a b))",
          "package": "diagrams-builder",
          "partial": "Regen",
          "signature": "Hash-\u003eIO(Maybe(Options b v-\u003eOptions b v))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_decideRegen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "_diaExpr",
          "package": "diagrams-builder",
          "signature": "String",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_diaExpr\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:_diaExpr\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "_diaExpr",
          "package": "diagrams-builder",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_diaExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "_imports",
          "package": "diagrams-builder",
          "signature": "[String]",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_imports\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:_imports\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "_imports",
          "normalized": "[String]",
          "package": "diagrams-builder",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_imports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "_postProcess",
          "package": "diagrams-builder",
          "signature": "Diagram b v -\u003e Diagram b v",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_postProcess\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:_postProcess\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "_postProcess",
          "normalized": "Diagram a b-\u003eDiagram a b",
          "package": "diagrams-builder",
          "partial": "Process",
          "signature": "Diagram b v-\u003eDiagram b v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_postProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "_pragmas",
          "package": "diagrams-builder",
          "signature": "[String]",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_pragmas\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:_pragmas\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "_pragmas",
          "normalized": "[String]",
          "package": "diagrams-builder",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_pragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "_snippets",
          "package": "diagrams-builder",
          "signature": "[String]",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_snippets\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:_snippets\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "_snippets",
          "normalized": "[String]",
          "package": "diagrams-builder",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:_snippets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenience function suitable to be given as the final argument\n   to \u003ccode\u003ebuildDiagram\u003c/code\u003e.  It implements the simple policy of always\n   rebuilding every diagram.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "alwaysRegenerate",
          "package": "diagrams-builder",
          "signature": "Hash -\u003e IO (Maybe (a -\u003e a))",
          "source": "src/Diagrams-Builder-Opts.html#alwaysRegenerate",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:alwaysRegenerate\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:alwaysRegenerate\"]"
        },
        "index": {
          "description": "Convenience function suitable to be given as the final argument to buildDiagram It implements the simple policy of always rebuilding every diagram",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "alwaysRegenerate",
          "normalized": "Hash-\u003eIO(Maybe(a-\u003ea))",
          "package": "diagrams-builder",
          "partial": "Regenerate",
          "signature": "Hash-\u003eIO(Maybe(a-\u003ea))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:alwaysRegenerate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBackend-specific options to use.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "backendOpts",
          "package": "diagrams-builder",
          "signature": "Lens' (BuildOpts b v) (Options b v)",
          "source": "src/Diagrams-Builder-Opts.html#backendOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:backendOpts\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:backendOpts\"]"
        },
        "index": {
          "description": "Backend-specific options to use",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "backendOpts",
          "package": "diagrams-builder",
          "partial": "Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:backendOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBackend token\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "backendToken",
          "package": "diagrams-builder",
          "signature": "b",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:backendToken\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:backendToken\"]"
        },
        "index": {
          "description": "Backend token",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "backendToken",
          "package": "diagrams-builder",
          "partial": "Token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:backendToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function to decide whether a particular diagram needs to be\n   regenerated.  It will be passed a hash of the final assembled\n   source for the diagram (but with the module name set to \u003ccode\u003eMain\u003c/code\u003e\n   instead of something auto-generated, so that hashing the source\n   will produce consistent results across runs), plus any options,\n   local imports, and other things which could affect the result of\n   rendering. It can return some information (such as a hash of the\n   source) via the \u003ccode\u003ex\u003c/code\u003e result, which will be passed through to the\n   result of \u003ccode\u003ebuildDiagram\u003c/code\u003e.  More importantly, it decides whether\n   the diagram should be built: a result of \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e means the diagram\n   \u003cem\u003eshould\u003c/em\u003e be built; \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e means it should not. In the case\n   that it should be built, it returns a function for updating the\n   rendering options.  This could be used, \u003cem\u003ee.g.\u003c/em\u003e, to request a\n   filename based on a hash of the source.\n\u003c/p\u003e\u003cp\u003eTwo standard decision functions are provided for\n   convenience: \u003ccode\u003e\u003ca\u003ealwaysRegenerate\u003c/a\u003e\u003c/code\u003e returns no extra information\n   and always decides to regenerate the diagram;\n   \u003ccode\u003e\u003ca\u003ehashedRegenerate\u003c/a\u003e\u003c/code\u003e creates a hash of the diagram source and\n   looks for a file with that name in a given directory.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "decideRegen",
          "package": "diagrams-builder",
          "signature": "Lens' (BuildOpts b v) (Hash -\u003e IO (Maybe (Options b v -\u003e Options b v)))",
          "source": "src/Diagrams-Builder-Opts.html#decideRegen",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:decideRegen\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:decideRegen\"]"
        },
        "index": {
          "description": "function to decide whether particular diagram needs to be regenerated It will be passed hash of the final assembled source for the diagram but with the module name set to Main instead of something auto-generated so that hashing the source will produce consistent results across runs plus any options local imports and other things which could affect the result of rendering It can return some information such as hash of the source via the result which will be passed through to the result of buildDiagram More importantly it decides whether the diagram should be built result of Just means the diagram should be built Nothing means it should not In the case that it should be built it returns function for updating the rendering options This could be used e.g to request filename based on hash of the source Two standard decision functions are provided for convenience alwaysRegenerate returns no extra information and always decides to regenerate the diagram hashedRegenerate creates hash of the diagram source and looks for file with that name in given directory",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "decideRegen",
          "normalized": "Lens'(BuildOpts a b)(Hash-\u003eIO(Maybe(Options a b-\u003eOptions a b)))",
          "package": "diagrams-builder",
          "partial": "Regen",
          "signature": "Lens'(BuildOpts b v)(Hash-\u003eIO(Maybe(Options b v-\u003eOptions b v)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:decideRegen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe diagram expression to interpret.  All the given import sand\n   snippets will be in scope, with the given LANGUAGE pragmas\n   enabled.  The expression may have either of the types \u003ccode\u003eDiagram b\n   v\u003c/code\u003e or \u003ccode\u003eIO (Diagram b v)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "diaExpr",
          "package": "diagrams-builder",
          "signature": "Lens' (BuildOpts b v) String",
          "source": "src/Diagrams-Builder-Opts.html#diaExpr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:diaExpr\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:diaExpr\"]"
        },
        "index": {
          "description": "The diagram expression to interpret All the given import sand snippets will be in scope with the given LANGUAGE pragmas enabled The expression may have either of the types Diagram or IO Diagram",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "diaExpr",
          "package": "diagrams-builder",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:diaExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "hashToHexStr",
          "package": "diagrams-builder",
          "signature": "Hash -\u003e String",
          "source": "src/Diagrams-Builder-Opts.html#hashToHexStr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:hashToHexStr\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:hashToHexStr\"]"
        },
        "index": {
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "hashToHexStr",
          "normalized": "Hash-\u003eString",
          "package": "diagrams-builder",
          "partial": "To Hex Str",
          "signature": "Hash-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:hashToHexStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenience function suitable to be given as the final argument\n   to \u003ccode\u003ebuildDiagram\u003c/code\u003e.  It works by converting the hash value to a\n   zero-padded hexadecimal string and looking in the specified\n   directory for any file whose base name is equal to the hash.  If\n   there is such a file, it specifies that the diagram should not be\n   rebuilt.  Otherwise, it specifies that the diagram should be\n   rebuilt, and uses the provided function to update the rendering\n   options based on the generated hash string.  (Most likely, one\n   would want to set the requested output file to the hash followed\n   by some extension.)\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "hashedRegenerate",
          "package": "diagrams-builder",
          "signature": "(String -\u003e a -\u003e a)-\u003e FilePath-\u003e Hash-\u003e IO (Maybe (a -\u003e a))",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:hashedRegenerate\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:hashedRegenerate\"]"
        },
        "index": {
          "description": "Convenience function suitable to be given as the final argument to buildDiagram It works by converting the hash value to zero-padded hexadecimal string and looking in the specified directory for any file whose base name is equal to the hash If there is such file it specifies that the diagram should not be rebuilt Otherwise it specifies that the diagram should be rebuilt and uses the provided function to update the rendering options based on the generated hash string Most likely one would want to set the requested output file to the hash followed by some extension",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "hashedRegenerate",
          "normalized": "(String-\u003ea-\u003ea)-\u003eFilePath-\u003eHash-\u003eIO(Maybe(a-\u003ea))",
          "package": "diagrams-builder",
          "partial": "Regenerate",
          "signature": "(String-\u003ea-\u003ea)-\u003eFilePath-\u003eHash-\u003eIO(Maybe(a-\u003ea))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:hashedRegenerate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdditional module imports (note that \u003ca\u003eDiagrams.Prelude\u003c/a\u003e is\n   automatically imported).\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "imports",
          "package": "diagrams-builder",
          "signature": "Lens' (BuildOpts b v) [String]",
          "source": "src/Diagrams-Builder-Opts.html#imports",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:imports\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:imports\"]"
        },
        "index": {
          "description": "Additional module imports note that Diagrams.Prelude is automatically imported",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "imports",
          "normalized": "Lens'(BuildOpts a b)[String]",
          "package": "diagrams-builder",
          "signature": "Lens'(BuildOpts b v)[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:imports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003eBuildOpts\u003c/code\u003e record with default options:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e no snippets\n\u003c/li\u003e\u003cli\u003e no pragmas\n\u003c/li\u003e\u003cli\u003e no imports\n\u003c/li\u003e\u003cli\u003e always regenerate\n\u003c/li\u003e\u003cli\u003e the diagram expression \u003ccode\u003ecircle 1\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e no postprocessing\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "mkBuildOpts",
          "package": "diagrams-builder",
          "signature": "b -\u003e v -\u003e Options b v -\u003e BuildOpts b v",
          "source": "src/Diagrams-Builder-Opts.html#mkBuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:mkBuildOpts\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:mkBuildOpts\"]"
        },
        "index": {
          "description": "Create BuildOpts record with default options no snippets no pragmas no imports always regenerate the diagram expression circle no postprocessing",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "mkBuildOpts",
          "normalized": "a-\u003eb-\u003eOptions a b-\u003eBuildOpts a b",
          "package": "diagrams-builder",
          "partial": "Build Opts",
          "signature": "b-\u003ev-\u003eOptions b v-\u003eBuildOpts b v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:mkBuildOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function to apply to the interpreted diagram prior to\n   rendering.  For example, you might wish to apply \u003ccode\u003epad 1.1\n   . centerXY\u003c/code\u003e.  This is preferred over directly modifying the\n   string expression to be interpreted, since it gives better\n   typechecking, and works no matter whether the expression\n   represents a diagram or an IO action.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "postProcess",
          "package": "diagrams-builder",
          "signature": "Lens' (BuildOpts b v) (Diagram b v -\u003e Diagram b v)",
          "source": "src/Diagrams-Builder-Opts.html#postProcess",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:postProcess\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:postProcess\"]"
        },
        "index": {
          "description": "function to apply to the interpreted diagram prior to rendering For example you might wish to apply pad centerXY This is preferred over directly modifying the string expression to be interpreted since it gives better typechecking and works no matter whether the expression represents diagram or an IO action",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "postProcess",
          "normalized": "Lens'(BuildOpts a b)(Diagram a b-\u003eDiagram a b)",
          "package": "diagrams-builder",
          "partial": "Process",
          "signature": "Lens'(BuildOpts b v)(Diagram b v-\u003eDiagram b v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:postProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtra \u003ccode\u003eLANGUAGE\u003c/code\u003e pragmas to use (\u003ccode\u003eNoMonomorphismRestriction\u003c/code\u003e\n   is automatically enabled.)\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "pragmas",
          "package": "diagrams-builder",
          "signature": "Lens' (BuildOpts b v) [String]",
          "source": "src/Diagrams-Builder-Opts.html#pragmas",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:pragmas\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:pragmas\"]"
        },
        "index": {
          "description": "Extra LANGUAGE pragmas to use NoMonomorphismRestriction is automatically enabled",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "pragmas",
          "normalized": "Lens'(BuildOpts a b)[String]",
          "package": "diagrams-builder",
          "signature": "Lens'(BuildOpts b v)[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:pragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSource code snippets.  Each should be a syntactically valid\n   Haskell module.  They will be combined intelligently, \u003cem\u003ei.e.\u003c/em\u003e\n   not just pasted together textually but combining pragmas,\n   imports, \u003cem\u003eetc.\u003c/em\u003e separately.\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "snippets",
          "package": "diagrams-builder",
          "signature": "Lens' (BuildOpts b v) [String]",
          "source": "src/Diagrams-Builder-Opts.html#snippets",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:snippets\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:snippets\"]"
        },
        "index": {
          "description": "Source code snippets Each should be syntactically valid Haskell module They will be combined intelligently i.e not just pasted together textually but combining pragmas imports etc separately",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "snippets",
          "normalized": "Lens'(BuildOpts a b)[String]",
          "package": "diagrams-builder",
          "signature": "Lens'(BuildOpts b v)[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:snippets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDummy vector argument to fix the vector space type\n\u003c/p\u003e",
          "module": "[\"Diagrams.Builder.Opts\",\"Diagrams.Builder\"]",
          "name": "vectorToken",
          "package": "diagrams-builder",
          "signature": "v",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:vectorToken\",\"http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:vectorToken\"]"
        },
        "index": {
          "description": "Dummy vector argument to fix the vector space type",
          "hierarchy": "Diagrams Builder Opts",
          "module": "Diagrams.Builder.Opts",
          "name": "vectorToken",
          "package": "diagrams-builder",
          "partial": "Token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder-Opts.html#v:vectorToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTools for dynamically building diagrams, for \u003cem\u003ee.g.\u003c/em\u003e creating\n preprocessors to interpret diagrams code embedded in documents.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Diagrams.Builder",
          "name": "Builder",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder.html",
          "type": "module"
        },
        "index": {
          "description": "Tools for dynamically building diagrams for e.g creating preprocessors to interpret diagrams code embedded in documents",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "Builder",
          "package": "diagrams-builder",
          "partial": "Builder",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecord of command-line options.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "Build",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-CmdLine.html#Build",
          "type": "data"
        },
        "index": {
          "description": "Record of command-line options",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "Build",
          "package": "diagrams-builder",
          "partial": "Build",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#t:Build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions to control the behavior of \u003ccode\u003ebuildDiagram\u003c/code\u003e.  Create one\n   with \u003ccode\u003e\u003ca\u003emkBuildOpts\u003c/a\u003e\u003c/code\u003e followed by using the provided lenses to\n   override more fields; for example,\n\u003c/p\u003e\u003cpre\u003e\n   mkBuildOpts SVG zeroV (Options ...)\n     & imports .~ [\"Foo.Bar\", \"Baz.Quux\"]\n     & diaExpr .~ \"square 6 # fc green\"\n\u003c/pre\u003e",
          "module": "Diagrams.Builder",
          "name": "BuildOpts",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder-Opts.html#BuildOpts",
          "type": "data"
        },
        "index": {
          "description": "Options to control the behavior of buildDiagram Create one with mkBuildOpts followed by using the provided lenses to override more fields for example mkBuildOpts SVG zeroV Options imports Foo.Bar Baz.Quux diaExpr square fc green",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "BuildOpts",
          "package": "diagrams-builder",
          "partial": "Build Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#t:BuildOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePotential results of a dynamic diagram building operation.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "BuildResult",
          "package": "diagrams-builder",
          "source": "src/Diagrams-Builder.html#BuildResult",
          "type": "data"
        },
        "index": {
          "description": "Potential results of dynamic diagram building operation",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "BuildResult",
          "package": "diagrams-builder",
          "partial": "Build Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#t:BuildResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpreting the code\n   failed. See \u003ccode\u003e\u003ca\u003eppInterpError\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "InterpErr",
          "package": "diagrams-builder",
          "signature": "InterpErr InterpreterError",
          "source": "src/Diagrams-Builder.html#BuildResult",
          "type": "function"
        },
        "index": {
          "description": "Interpreting the code failed See ppInterpError",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "InterpErr",
          "package": "diagrams-builder",
          "partial": "Interp Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:InterpErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA successful build, yielding the\n   hash and a backend-specific result.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "OK",
          "package": "diagrams-builder",
          "signature": "OK Hash (Result b v)",
          "source": "src/Diagrams-Builder.html#BuildResult",
          "type": "function"
        },
        "index": {
          "description": "successful build yielding the hash and backend-specific result",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "OK",
          "package": "diagrams-builder",
          "partial": "OK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:OK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParsing of the code failed.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "ParseErr",
          "package": "diagrams-builder",
          "signature": "ParseErr String",
          "source": "src/Diagrams-Builder.html#BuildResult",
          "type": "function"
        },
        "index": {
          "description": "Parsing of the code failed",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "ParseErr",
          "package": "diagrams-builder",
          "partial": "Parse Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:ParseErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis diagram did not need to be\n   regenerated; includes the hash.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "Skipped",
          "package": "diagrams-builder",
          "signature": "Skipped Hash",
          "source": "src/Diagrams-Builder.html#BuildResult",
          "type": "function"
        },
        "index": {
          "description": "This diagram did not need to be regenerated includes the hash",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "Skipped",
          "package": "diagrams-builder",
          "partial": "Skipped",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:Skipped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a diagram by writing the given source code to a temporary\n   module and interpreting the given expression, which can be of\n   type \u003ccode\u003eDiagram b v\u003c/code\u003e or \u003ccode\u003eIO (Diagram b v)\u003c/code\u003e.  Can return either a\n   parse error if the source does not parse, an interpreter error,\n   or the final result.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "buildDiagram",
          "package": "diagrams-builder",
          "signature": "BuildOpts b v -\u003e IO (BuildResult b v)",
          "source": "src/Diagrams-Builder.html#buildDiagram",
          "type": "function"
        },
        "index": {
          "description": "Build diagram by writing the given source code to temporary module and interpreting the given expression which can be of type Diagram or IO Diagram Can return either parse error if the source does not parse an interpreter error or the final result",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "buildDiagram",
          "normalized": "BuildOpts a b-\u003eIO(BuildResult a b)",
          "package": "diagrams-builder",
          "partial": "Diagram",
          "signature": "BuildOpts b v-\u003eIO(BuildResult b v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:buildDiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterpret a diagram expression based on the contents of a given\n   source file, using some backend to produce a result.  The\n   expression can be of type \u003ccode\u003eDiagram b v\u003c/code\u003e or \u003ccode\u003eIO (Diagram b v)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "interpretDiagram",
          "package": "diagrams-builder",
          "signature": "BuildOpts b v -\u003e FilePath -\u003e IO (Either InterpreterError (Result b v))",
          "source": "src/Diagrams-Builder.html#interpretDiagram",
          "type": "function"
        },
        "index": {
          "description": "Interpret diagram expression based on the contents of given source file using some backend to produce result The expression can be of type Diagram or IO Diagram",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "interpretDiagram",
          "normalized": "BuildOpts a b-\u003eFilePath-\u003eIO(Either InterpreterError(Result a b))",
          "package": "diagrams-builder",
          "partial": "Diagram",
          "signature": "BuildOpts b v-\u003eFilePath-\u003eIO(Either InterpreterError(Result b v))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:interpretDiagram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty-print an \u003ccode\u003eInterpreterError\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "ppInterpError",
          "package": "diagrams-builder",
          "signature": "InterpreterError -\u003e String",
          "source": "src/Diagrams-Builder.html#ppInterpError",
          "type": "function"
        },
        "index": {
          "description": "Pretty-print an InterpreterError",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "ppInterpError",
          "normalized": "InterpreterError-\u003eString",
          "package": "diagrams-builder",
          "partial": "Interp Error",
          "signature": "InterpreterError-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:ppInterpError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet up the module to be interpreted, in the context of the\n   necessary imports.\n\u003c/p\u003e",
          "module": "Diagrams.Builder",
          "name": "setDiagramImports",
          "package": "diagrams-builder",
          "signature": "String-\u003e [String]-\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Set up the module to be interpreted in the context of the necessary imports",
          "hierarchy": "Diagrams Builder",
          "module": "Diagrams.Builder",
          "name": "setDiagramImports",
          "normalized": "String-\u003e[String]-\u003ea()",
          "package": "diagrams-builder",
          "partial": "Diagram Imports",
          "signature": "String-\u003e[String]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/diagrams-builder/docs/Diagrams-Builder.html#v:setDiagramImports"
      }
    }
  ]
]