[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "cassette"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "Char",
          "package": "cassette",
          "source": "src/Text-Cassette-Char.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "Char",
          "package": "cassette",
          "partial": "Char",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "alphaNum",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "alphaNum",
          "package": "cassette",
          "partial": "Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:alphaNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "anyChar",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "anyChar",
          "package": "cassette",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:anyChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specific character.\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "char",
          "package": "cassette",
          "signature": "Char -\u003e PP0",
          "source": "src/Text-Cassette-Char.html#char",
          "type": "function"
        },
        "index": {
          "description": "specific character",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "char",
          "normalized": "Char-\u003ePP",
          "package": "cassette",
          "signature": "Char-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "digit",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "digit",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:digit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "hexDigit",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "hexDigit",
          "package": "cassette",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:hexDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "letter",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "letter",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:letter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "lower",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "lower",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a newline character ('\\n').\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "newline",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Char.html#newline",
          "type": "function"
        },
        "index": {
          "description": "Parses newline character",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "newline",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:newline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDual of \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "noneOf",
          "package": "cassette",
          "signature": "[Char] -\u003e PP Char",
          "source": "src/Text-Cassette-Char.html#noneOf",
          "type": "function"
        },
        "index": {
          "description": "Dual of oneOf",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "noneOf",
          "normalized": "[Char]-\u003ePP Char",
          "package": "cassette",
          "partial": "Of",
          "signature": "[Char]-\u003ePP Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:noneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "octDigit",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "octDigit",
          "package": "cassette",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:octDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceeds if the current character is in the supplied list of characters.\n See also \u003ccode\u003e\u003ca\u003esatisfy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e vowel = oneOf \"aeiou\"\n\u003c/pre\u003e",
          "module": "Text.Cassette.Char",
          "name": "oneOf",
          "package": "cassette",
          "signature": "[Char] -\u003e PP Char",
          "source": "src/Text-Cassette-Char.html#oneOf",
          "type": "function"
        },
        "index": {
          "description": "Succeeds if the current character is in the supplied list of characters See also satisfy vowel oneOf aeiou",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "oneOf",
          "normalized": "[Char]-\u003ePP Char",
          "package": "cassette",
          "partial": "Of",
          "signature": "[Char]-\u003ePP Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:oneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eoptSpace\u003c/a\u003e\u003c/code\u003e marks a position where whitespace is desired to occur.\n It accepts arbitrary space while parsing, and produces a\n single space character while printing.\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "optSpace",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Char.html#optSpace",
          "type": "function"
        },
        "index": {
          "description": "optSpace marks position where whitespace is desired to occur It accepts arbitrary space while parsing and produces single space character while printing",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "optSpace",
          "package": "cassette",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:optSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esepSpace\u003c/a\u003e\u003c/code\u003e marks a position where whitespace is required to\n occur. It requires one or more space characters while parsing,\n and produces a single space character while printing.\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "sepSpace",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Char.html#sepSpace",
          "type": "function"
        },
        "index": {
          "description": "sepSpace marks position where whitespace is required to occur It requires one or more space characters while parsing and produces single space character while printing",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "sepSpace",
          "package": "cassette",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:sepSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esatisfy\u003c/a\u003e\u003c/code\u003e combinator, unshifted.\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "skip",
          "package": "cassette",
          "signature": "(Char -\u003e Bool) -\u003e Char -\u003e PP0",
          "source": "src/Text-Cassette-Char.html#skip",
          "type": "function"
        },
        "index": {
          "description": "The satisfy combinator unshifted",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "skip",
          "normalized": "(Char-\u003eBool)-\u003eChar-\u003ePP",
          "package": "cassette",
          "signature": "(Char-\u003eBool)-\u003eChar-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:skip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eskipSpace\u003c/a\u003e\u003c/code\u003e marks a position where whitespace is allowed to\n occur. It accepts arbitrary space while parsing, and produces\n no space while printing.\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "skipSpace",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Char.html#skipSpace",
          "type": "function"
        },
        "index": {
          "description": "skipSpace marks position where whitespace is allowed to occur It accepts arbitrary space while parsing and produces no space while printing",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "skipSpace",
          "package": "cassette",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:skipSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a tab character ('\\t').\n\u003c/p\u003e",
          "module": "Text.Cassette.Char",
          "name": "tab",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Char.html#tab",
          "type": "function"
        },
        "index": {
          "description": "Parses tab character",
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "tab",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:tab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Char",
          "name": "upper",
          "package": "cassette",
          "signature": "PP Char",
          "source": "src/Text-Cassette-Char.html#upper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Char",
          "module": "Text.Cassette.Char",
          "name": "upper",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Char.html#v:upper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Combinator",
          "name": "Combinator",
          "package": "cassette",
          "source": "src/Text-Cassette-Combinator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "Combinator",
          "package": "cassette",
          "partial": "Combinator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echainl p op x\u003c/code\u003e matches zero or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated by\n \u003ccode\u003eop\u003c/code\u003e. Returns a value obtained by a \u003cem\u003eleft associative\u003c/em\u003e application of all\n functions returned by \u003ccode\u003eop\u003c/code\u003e to the values returned by \u003ccode\u003ep\u003c/code\u003e. If there are zero\n occurrences of \u003ccode\u003ep\u003c/code\u003e, the value \u003ccode\u003ex\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "chainl",
          "package": "cassette",
          "signature": "PP0 -\u003e BinL a a a -\u003e PP a -\u003e a -\u003e PP a",
          "source": "src/Text-Cassette-Combinator.html#chainl",
          "type": "function"
        },
        "index": {
          "description": "chainl op matches zero or more occurrences of separated by op Returns value obtained by left associative application of all functions returned by op to the values returned by If there are zero occurrences of the value is returned",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "chainl",
          "normalized": "PP-\u003eBinL a a a-\u003ePP a-\u003ea-\u003ePP a",
          "package": "cassette",
          "signature": "PP-\u003eBinL a a a-\u003ePP a-\u003ea-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:chainl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a a left-associative chain of infix operators.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "chainl1",
          "package": "cassette",
          "signature": "PP0 -\u003e BinL a a a -\u003e PP a -\u003e PP a",
          "source": "src/Text-Cassette-Combinator.html#chainl1",
          "type": "function"
        },
        "index": {
          "description": "Match left-associative chain of infix operators",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "chainl1",
          "normalized": "PP-\u003eBinL a a a-\u003ePP a-\u003ePP a",
          "package": "cassette",
          "signature": "PP-\u003eBinL a a a-\u003ePP a-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:chainl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echainr p op x\u003c/code\u003e matches zero or more occurrences of \u003ccode\u003ep\u003c/code\u003e, separated by\n \u003ccode\u003eop\u003c/code\u003e. Returns a value obtained by a \u003cem\u003eright associative\u003c/em\u003e application of all\n functions returned by \u003ccode\u003eop\u003c/code\u003e to the values returned by \u003ccode\u003ep\u003c/code\u003e. If there are zero\n occurrences of \u003ccode\u003ep\u003c/code\u003e, the value \u003ccode\u003ex\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "chainr",
          "package": "cassette",
          "signature": "PP0 -\u003e BinL a a a -\u003e PP a -\u003e a -\u003e PP a",
          "source": "src/Text-Cassette-Combinator.html#chainr",
          "type": "function"
        },
        "index": {
          "description": "chainr op matches zero or more occurrences of separated by op Returns value obtained by right associative application of all functions returned by op to the values returned by If there are zero occurrences of the value is returned",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "chainr",
          "normalized": "PP-\u003eBinL a a a-\u003ePP a-\u003ea-\u003ePP a",
          "package": "cassette",
          "signature": "PP-\u003eBinL a a a-\u003ePP a-\u003ea-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:chainr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a a right-associative chain of infix operators.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "chainr1",
          "package": "cassette",
          "signature": "PP0 -\u003e BinL a a a -\u003e PP a -\u003e PP a",
          "source": "src/Text-Cassette-Combinator.html#chainr1",
          "type": "function"
        },
        "index": {
          "description": "Match right-associative chain of infix operators",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "chainr1",
          "normalized": "PP-\u003eBinL a a a-\u003ePP a-\u003ePP a",
          "package": "cassette",
          "signature": "PP-\u003eBinL a a a-\u003ePP a-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:chainr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies each cassette in the supplied list in order, until one of them\n succeeds.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "choice",
          "package": "cassette",
          "signature": "[PP a] -\u003e PP a",
          "source": "src/Text-Cassette-Combinator.html#choice",
          "type": "function"
        },
        "index": {
          "description": "Applies each cassette in the supplied list in order until one of them succeeds",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "choice",
          "normalized": "[PP a]-\u003ePP a",
          "package": "cassette",
          "signature": "[PP a]-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecount n p\u003c/code\u003e matches \u003ccode\u003en\u003c/code\u003e occurrences of \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "count",
          "package": "cassette",
          "signature": "Int -\u003e PP a -\u003e PP [a]",
          "source": "src/Text-Cassette-Combinator.html#count",
          "type": "function"
        },
        "index": {
          "description": "count matches occurrences of",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "count",
          "normalized": "Int-\u003ePP a-\u003ePP[a]",
          "package": "cassette",
          "signature": "Int-\u003ePP a-\u003ePP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the given cassette zero or more times.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "many",
          "package": "cassette",
          "signature": "PP a -\u003e PP [a]",
          "source": "src/Text-Cassette-Combinator.html#many",
          "type": "function"
        },
        "index": {
          "description": "Apply the given cassette zero or more times",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "many",
          "normalized": "PP a-\u003ePP[a]",
          "package": "cassette",
          "signature": "PP a-\u003ePP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the given cassette one or more times.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "many1",
          "package": "cassette",
          "signature": "PP a -\u003e PP [a]",
          "source": "src/Text-Cassette-Combinator.html#many1",
          "type": "function"
        },
        "index": {
          "description": "Apply the given cassette one or more times",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "many1",
          "normalized": "PP a-\u003ePP[a]",
          "package": "cassette",
          "signature": "PP a-\u003ePP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:many1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplies first argument zero or more times until second argument succeeds.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "manyTill",
          "package": "cassette",
          "signature": "PP a -\u003e PP0 -\u003e PP [a]",
          "source": "src/Text-Cassette-Combinator.html#manyTill",
          "type": "function"
        },
        "index": {
          "description": "Applies first argument zero or more times until second argument succeeds",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "manyTill",
          "normalized": "PP a-\u003ePP-\u003ePP[a]",
          "package": "cassette",
          "partial": "Till",
          "signature": "PP a-\u003ePP-\u003ePP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:manyTill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enotFollowedBy p\u003c/code\u003e only succeeds when \u003ccode\u003ep\u003c/code\u003e fails. This combinator does\n not consume/produce any input.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "notFollowedBy",
          "package": "cassette",
          "signature": "PP0 -\u003e PP0",
          "source": "src/Text-Cassette-Combinator.html#notFollowedBy",
          "type": "function"
        },
        "index": {
          "description": "notFollowedBy only succeeds when fails This combinator does not consume produce any input",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "notFollowedBy",
          "normalized": "PP-\u003ePP",
          "package": "cassette",
          "partial": "Followed By",
          "signature": "PP-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:notFollowedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to apply the given cassette. It returns the value of the cassette\n on success, the first argument otherwise.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "option",
          "package": "cassette",
          "signature": "a -\u003e PP a -\u003e PP a",
          "source": "src/Text-Cassette-Combinator.html#option",
          "type": "function"
        },
        "index": {
          "description": "Tries to apply the given cassette It returns the value of the cassette on success the first argument otherwise",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "option",
          "normalized": "a-\u003ePP a-\u003ePP a",
          "package": "cassette",
          "signature": "a-\u003ePP a-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to apply the given cassette. It returns a value of the form \u003ccode\u003eJust\n x\u003c/code\u003e on success, \u003ccode\u003eNothing\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "optionMaybe",
          "package": "cassette",
          "signature": "PP a -\u003e PP (Maybe a)",
          "source": "src/Text-Cassette-Combinator.html#optionMaybe",
          "type": "function"
        },
        "index": {
          "description": "Tries to apply the given cassette It returns value of the form Just on success Nothing otherwise",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "optionMaybe",
          "normalized": "PP a-\u003ePP(Maybe a)",
          "package": "cassette",
          "partial": "Maybe",
          "signature": "PP a-\u003ePP(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:optionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTries to match the given cassette and discards the result, otherwise does\n nothing in case of failure.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "optional",
          "package": "cassette",
          "signature": "PP a -\u003e PP0",
          "source": "src/Text-Cassette-Combinator.html#optional",
          "type": "function"
        },
        "index": {
          "description": "Tries to match the given cassette and discards the result otherwise does nothing in case of failure",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "optional",
          "normalized": "PP a-\u003ePP",
          "package": "cassette",
          "signature": "PP a-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:optional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the first argument zero or more times, separated by the second\n argument.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "sepBy",
          "package": "cassette",
          "signature": "PP a -\u003e PP0 -\u003e PP [a]",
          "source": "src/Text-Cassette-Combinator.html#sepBy",
          "type": "function"
        },
        "index": {
          "description": "Apply the first argument zero or more times separated by the second argument",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "sepBy",
          "normalized": "PP a-\u003ePP-\u003ePP[a]",
          "package": "cassette",
          "partial": "By",
          "signature": "PP a-\u003ePP-\u003ePP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:sepBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the first argument one or more times, separated by the second\n argument.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "sepBy1",
          "package": "cassette",
          "signature": "PP a -\u003e PP0 -\u003e PP [a]",
          "source": "src/Text-Cassette-Combinator.html#sepBy1",
          "type": "function"
        },
        "index": {
          "description": "Apply the first argument one or more times separated by the second argument",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "sepBy1",
          "normalized": "PP a-\u003ePP-\u003ePP[a]",
          "package": "cassette",
          "partial": "By",
          "signature": "PP a-\u003ePP-\u003ePP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:sepBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the given cassette zero or more times, discarding the result.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "skipMany",
          "package": "cassette",
          "signature": "PP a -\u003e PP0",
          "source": "src/Text-Cassette-Combinator.html#skipMany",
          "type": "function"
        },
        "index": {
          "description": "Apply the given cassette zero or more times discarding the result",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "skipMany",
          "normalized": "PP a-\u003ePP",
          "package": "cassette",
          "partial": "Many",
          "signature": "PP a-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:skipMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply the given cassette one or more times, discarding the result.\n\u003c/p\u003e",
          "module": "Text.Cassette.Combinator",
          "name": "skipMany1",
          "package": "cassette",
          "signature": "PP a -\u003e PP0",
          "source": "src/Text-Cassette-Combinator.html#skipMany1",
          "type": "function"
        },
        "index": {
          "description": "Apply the given cassette one or more times discarding the result",
          "hierarchy": "Text Cassette Combinator",
          "module": "Text.Cassette.Combinator",
          "name": "skipMany1",
          "normalized": "PP a-\u003ePP",
          "package": "cassette",
          "partial": "Many",
          "signature": "PP a-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Combinator.html#v:skipMany1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "Lead",
          "package": "cassette",
          "source": "src/Text-Cassette-Lead.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "Lead",
          "package": "cassette",
          "partial": "Lead",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of binary leads, parameterized by the type of the left operand,\n the right operand, and the type of the result.\n\u003c/p\u003e",
          "module": "Text.Cassette.Lead",
          "name": "BinL",
          "package": "cassette",
          "source": "src/Text-Cassette-Lead.html#BinL",
          "type": "type"
        },
        "index": {
          "description": "The type of binary leads parameterized by the type of the left operand the right operand and the type of the result",
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "BinL",
          "package": "cassette",
          "partial": "Bin",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#t:BinL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of binary leads, parameterized by the type of the left operand,\n the right operand, and the type of the result.\n\u003c/p\u003e",
          "module": "Text.Cassette.Lead",
          "name": "UnL",
          "package": "cassette",
          "source": "src/Text-Cassette-Lead.html#UnL",
          "type": "type"
        },
        "index": {
          "description": "The type of binary leads parameterized by the type of the left operand the right operand and the type of the result",
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "UnL",
          "package": "cassette",
          "partial": "Un",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#t:UnL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIterates a one step construction function (resp. deconstruction)\n function, i.e. a lead, thus obtaining a left fold (resp. unfold). The\n resulting lead is a catamorphism on one side and an anamorpism on the\n other, hence the name. The type of this function is the same as that of\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, lifted to cassettes.\n\u003c/p\u003e",
          "module": "Text.Cassette.Lead",
          "name": "catanal",
          "package": "cassette",
          "signature": "BinL a b a -\u003e BinL a [b] a",
          "source": "src/Text-Cassette-Lead.html#catanal",
          "type": "function"
        },
        "index": {
          "description": "Iterates one step construction function resp deconstruction function i.e lead thus obtaining left fold resp unfold The resulting lead is catamorphism on one side and an anamorpism on the other hence the name The type of this function is the same as that of foldl lifted to cassettes",
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "catanal",
          "normalized": "BinL a b a-\u003eBinL a[b]a",
          "package": "cassette",
          "signature": "BinL a b a-\u003eBinL a[b]a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:catanal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIterates a one step construction function (resp. deconstruction)\n function, i.e. a lead, thus obtaining a right fold (resp. unfold). The\n resulting lead is a catamorphism on one side and an anamorpism on the\n other, hence the name. The type of this function is the same as that of\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e, lifted to cassettes.\n\u003c/p\u003e",
          "module": "Text.Cassette.Lead",
          "name": "catanar",
          "package": "cassette",
          "signature": "BinL a b b -\u003e BinL b [a] b",
          "source": "src/Text-Cassette-Lead.html#catanar",
          "type": "function"
        },
        "index": {
          "description": "Iterates one step construction function resp deconstruction function i.e lead thus obtaining right fold resp unfold The resulting lead is catamorphism on one side and an anamorpism on the other hence the name The type of this function is the same as that of foldr lifted to cassettes",
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "catanar",
          "normalized": "BinL a b b-\u003eBinL b[a]b",
          "package": "cassette",
          "signature": "BinL a b b-\u003eBinL b[a]b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:catanar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "consL",
          "package": "cassette",
          "signature": "BinL a [a] [a]",
          "source": "src/Text-Cassette-Lead.html#consL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "consL",
          "normalized": "BinL a[a][a]",
          "package": "cassette",
          "signature": "BinL a[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:consL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "justL",
          "package": "cassette",
          "signature": "UnL a (Maybe a)",
          "source": "src/Text-Cassette-Lead.html#justL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "justL",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:justL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a pair of symmetric functions to a lead.\n\u003c/p\u003e",
          "module": "Text.Cassette.Lead",
          "name": "liftL",
          "package": "cassette",
          "signature": "Sym a b -\u003e UnL a b",
          "source": "src/Text-Cassette-Lead.html#liftL",
          "type": "function"
        },
        "index": {
          "description": "Lift pair of symmetric functions to lead",
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "liftL",
          "normalized": "Sym a b-\u003eUnL a b",
          "package": "cassette",
          "signature": "Sym a b-\u003eUnL a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:liftL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "nilL",
          "package": "cassette",
          "signature": "PP [a]",
          "source": "src/Text-Cassette-Lead.html#nilL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "nilL",
          "normalized": "PP[a]",
          "package": "cassette",
          "signature": "PP[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:nilL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "nothingL",
          "package": "cassette",
          "signature": "PP (Maybe a)",
          "source": "src/Text-Cassette-Lead.html#nothingL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "nothingL",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:nothingL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "pairL",
          "package": "cassette",
          "signature": "BinL a b (a, b)",
          "source": "src/Text-Cassette-Lead.html#pairL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "pairL",
          "normalized": "BinL a b(a,b)",
          "package": "cassette",
          "signature": "BinL a b(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:pairL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "quadrupleL",
          "package": "cassette",
          "signature": "K7 (C ((a, b, c, d) -\u003e r)) (C (d -\u003e c -\u003e b -\u003e a -\u003e r)) (C ((a, b, c, d) -\u003e r')) (C (d -\u003e c -\u003e b -\u003e a -\u003e r'))",
          "source": "src/Text-Cassette-Lead.html#quadrupleL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "quadrupleL",
          "normalized": "K(C((a,b,c,d)-\u003ee))(C(d-\u003ec-\u003eb-\u003ea-\u003ee))(C((a,b,c,d)-\u003ef))(C(d-\u003ec-\u003eb-\u003ea-\u003ef))",
          "package": "cassette",
          "signature": "K(C((a,b,c,d)-\u003er))(C(d-\u003ec-\u003eb-\u003ea-\u003er))(C((a,b,c,d)-\u003er'))(C(d-\u003ec-\u003eb-\u003ea-\u003er'))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:quadrupleL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Lead",
          "name": "tripleL",
          "package": "cassette",
          "signature": "K7 (C ((a, b, c) -\u003e r)) (C (c -\u003e b -\u003e a -\u003e r)) (C ((a, b, c) -\u003e r')) (C (c -\u003e b -\u003e a -\u003e r'))",
          "source": "src/Text-Cassette-Lead.html#tripleL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Lead",
          "module": "Text.Cassette.Lead",
          "name": "tripleL",
          "normalized": "K(C((a,b,c)-\u003ed))(C(c-\u003eb-\u003ea-\u003ed))(C((a,b,c)-\u003ee))(C(c-\u003eb-\u003ea-\u003ee))",
          "package": "cassette",
          "signature": "K(C((a,b,c)-\u003er))(C(c-\u003eb-\u003ea-\u003er))(C((a,b,c)-\u003er'))(C(c-\u003eb-\u003ea-\u003er'))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Lead.html#v:tripleL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports combinators for parsing number literals.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Cassette.Number",
          "name": "Number",
          "package": "cassette",
          "source": "src/Text-Cassette-Number.html",
          "type": "module"
        },
        "index": {
          "description": "This module exports combinators for parsing number literals",
          "hierarchy": "Text Cassette Number",
          "module": "Text.Cassette.Number",
          "name": "Number",
          "package": "cassette",
          "partial": "Number",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Number.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn integer literal, positive or negative.\n\u003c/p\u003e",
          "module": "Text.Cassette.Number",
          "name": "int",
          "package": "cassette",
          "signature": "PP Int",
          "source": "src/Text-Cassette-Number.html#int",
          "type": "function"
        },
        "index": {
          "description": "An integer literal positive or negative",
          "hierarchy": "Text Cassette Number",
          "module": "Text.Cassette.Number",
          "name": "int",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Number.html#v:int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Prim",
          "name": "Prim",
          "package": "cassette",
          "source": "src/Text-Cassette-Prim.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "Prim",
          "package": "cassette",
          "partial": "Prim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of string transformers in CPS, \u003cem\u003ei.e.\u003c/em\u003e functions from strings to\n strings.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "C",
          "package": "cassette",
          "source": "src/Text-Cassette-Prim.html#C",
          "type": "type"
        },
        "index": {
          "description": "The type of string transformers in CPS i.e functions from strings to strings",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "C",
          "package": "cassette",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#t:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA cassette consists of two tracks, represented by functions. The\n functions on each track are not necessarily inverses of each other, and do\n not necessarily connect the same start and end types.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "K7",
          "package": "cassette",
          "source": "src/Text-Cassette-Prim.html#K7",
          "type": "data"
        },
        "index": {
          "description": "cassette consists of two tracks represented by functions The functions on each track are not necessarily inverses of each other and do not necessarily connect the same start and end types",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "K7",
          "package": "cassette",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#t:K7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of cassettes with a string transformer on each side. The A-side\n produces a value in addition to transforming the string, \u003cem\u003ei.e.\u003c/em\u003e it is a\n parser. The B-side consumes a value to transform the string, \u003cem\u003ei.e.\u003c/em\u003e it is a\n printer.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "PP",
          "package": "cassette",
          "source": "src/Text-Cassette-Prim.html#PP",
          "type": "type"
        },
        "index": {
          "description": "The type of cassettes with string transformer on each side The A-side produces value in addition to transforming the string i.e it is parser The B-side consumes value to transform the string i.e it is printer",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "PP",
          "package": "cassette",
          "partial": "PP",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#t:PP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Prim",
          "name": "PP0",
          "package": "cassette",
          "source": "src/Text-Cassette-Prim.html#PP0",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "PP0",
          "package": "cassette",
          "partial": "PP",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#t:PP0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSymmetric cassettes do have functions that are inverses of each other on\n each track. Symmetric cassettes form a category under splicing (see\n '(\u003ca/\u003e)').\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "Sym",
          "package": "cassette",
          "source": "src/Text-Cassette-Prim.html#Sym",
          "type": "newtype"
        },
        "index": {
          "description": "Symmetric cassettes do have functions that are inverses of each other on each track Symmetric cassettes form category under splicing see",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "Sym",
          "package": "cassette",
          "partial": "Sym",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#t:Sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA synonym to '(\u003ca/\u003e)' with its arguments flipped and with lower precedence.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "(--\u003e)",
          "package": "cassette",
          "signature": "K7 a b a' b' -\u003e K7 b c b' c' -\u003e K7 a c a' c'",
          "source": "src/Text-Cassette-Prim.html#--%3E",
          "type": "function"
        },
        "index": {
          "description": "synonym to with its arguments flipped and with lower precedence",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "(--\u003e) --\u003e",
          "normalized": "K a b c d-\u003eK b e d f-\u003eK a e c f",
          "package": "cassette",
          "signature": "K a b a' b'-\u003eK b c b' c'-\u003eK a c a' c'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:-45--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChoice operator. If the first cassette fails, then try the second parser.\n Note that this is an unrestricted backtracking operator: it never commits\n to any particular choice.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "(\u003c|\u003e)",
          "package": "cassette",
          "signature": "PP a -\u003e PP a -\u003e PP a",
          "source": "src/Text-Cassette-Prim.html#%3C%7C%3E",
          "type": "function"
        },
        "index": {
          "description": "Choice operator If the first cassette fails then try the second parser Note that this is an unrestricted backtracking operator it never commits to any particular choice",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "(\u003c|\u003e) \u003c|\u003e",
          "normalized": "PP a-\u003ePP a-\u003ePP a",
          "package": "cassette",
          "signature": "PP a-\u003ePP a-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:-60--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTape splicing operator. Functions on each track are composed pairwise.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "(\u003c\u003e)",
          "package": "cassette",
          "signature": "K7 b c b' c' -\u003e K7 a b a' b' -\u003e K7 a c a' c'",
          "source": "src/Text-Cassette-Prim.html#%3C%3E",
          "type": "function"
        },
        "index": {
          "description": "Tape splicing operator Functions on each track are composed pairwise",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "K a b c d-\u003eK e a f c-\u003eK e b f d",
          "package": "cassette",
          "signature": "K b c b' c'-\u003eK a b a' b'-\u003eK a c a' c'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Prim",
          "name": "K7",
          "package": "cassette",
          "signature": "K7",
          "source": "src/Text-Cassette-Prim.html#K7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "K7",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:K7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Prim",
          "name": "Sym",
          "package": "cassette",
          "signature": "Sym",
          "source": "src/Text-Cassette-Prim.html#Sym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "Sym",
          "package": "cassette",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:Sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlways fail.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "empty",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Prim.html#empty",
          "type": "function"
        },
        "index": {
          "description": "Always fail",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "empty",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceeds if input string is empty.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "eof",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Prim.html#eof",
          "type": "function"
        },
        "index": {
          "description": "Succeeds if input string is empty",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "eof",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch the A-side and B-side around.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "flip",
          "package": "cassette",
          "signature": "K7 a b c d -\u003e K7 d c b a",
          "source": "src/Text-Cassette-Prim.html#flip",
          "type": "function"
        },
        "index": {
          "description": "Switch the A-side and B-side around",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "flip",
          "normalized": "K a b c d-\u003eK d c b a",
          "package": "cassette",
          "signature": "K a b c d-\u003eK d c b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:flip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse\u003cem\u003eprint without consuming\u003c/em\u003eproducing any input.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "lookAhead",
          "package": "cassette",
          "signature": "PP a -\u003e PP a",
          "source": "src/Text-Cassette-Prim.html#lookAhead",
          "type": "function"
        },
        "index": {
          "description": "Parse print without consuming producing any input",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "lookAhead",
          "normalized": "PP a-\u003ePP a",
          "package": "cassette",
          "partial": "Ahead",
          "signature": "PP a-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:lookAhead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo nothing.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "nothing",
          "package": "cassette",
          "signature": "PP0",
          "source": "src/Text-Cassette-Prim.html#nothing",
          "type": "function"
        },
        "index": {
          "description": "Do nothing",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "nothing",
          "package": "cassette",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:nothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the parser from a cassette.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "parse",
          "package": "cassette",
          "signature": "PP a -\u003e String -\u003e Maybe a",
          "source": "src/Text-Cassette-Prim.html#parse",
          "type": "function"
        },
        "index": {
          "description": "Extract the parser from cassette",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "parse",
          "normalized": "PP a-\u003eString-\u003eMaybe a",
          "package": "cassette",
          "signature": "PP a-\u003eString-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect the A-side.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "play",
          "package": "cassette",
          "signature": "K7 a b c d -\u003e a -\u003e b",
          "source": "src/Text-Cassette-Prim.html#play",
          "type": "function"
        },
        "index": {
          "description": "Select the A-side",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "play",
          "normalized": "K a b c d-\u003ea-\u003eb",
          "package": "cassette",
          "signature": "K a b c d-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:play"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlip the cassette around to extract the pretty printer.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "pretty",
          "package": "cassette",
          "signature": "PP a -\u003e a -\u003e Maybe String",
          "source": "src/Text-Cassette-Prim.html#pretty",
          "type": "function"
        },
        "index": {
          "description": "Flip the cassette around to extract the pretty printer",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "pretty",
          "normalized": "PP a-\u003ea-\u003eMaybe String",
          "package": "cassette",
          "signature": "PP a-\u003ea-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuccessful only if predicate holds.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "satisfy",
          "package": "cassette",
          "signature": "(Char -\u003e Bool) -\u003e PP Char",
          "source": "src/Text-Cassette-Prim.html#satisfy",
          "type": "function"
        },
        "index": {
          "description": "Successful only if predicate holds",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "satisfy",
          "normalized": "(Char-\u003eBool)-\u003ePP Char",
          "package": "cassette",
          "signature": "(Char-\u003eBool)-\u003ePP Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:satisfy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn the given pure transformer into a parsing/printing pair. That is,\n return a cassette that produces and output on the one side, and consumes an\n input on the other, in addition to the string transformations of the given\n pure transformer. \u003ccode\u003eshift x p\u003c/code\u003e produces \u003ccode\u003ex\u003c/code\u003e as the output of \u003ccode\u003ep\u003c/code\u003e on the\n parsing side, and on the printing side accepts an input that is ignored.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "shift",
          "package": "cassette",
          "signature": "a -\u003e PP0 -\u003e PP a",
          "source": "src/Text-Cassette-Prim.html#shift",
          "type": "function"
        },
        "index": {
          "description": "Turn the given pure transformer into parsing printing pair That is return cassette that produces and output on the one side and consumes an input on the other in addition to the string transformations of the given pure transformer shift produces as the output of on the parsing side and on the printing side accepts an input that is ignored",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "shift",
          "normalized": "a-\u003ePP-\u003ePP a",
          "package": "cassette",
          "signature": "a-\u003ePP-\u003ePP a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Prim",
          "name": "sideA",
          "package": "cassette",
          "signature": "a -\u003e b",
          "source": "src/Text-Cassette-Prim.html#K7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "sideA",
          "normalized": "a-\u003eb",
          "package": "cassette",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:sideA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Prim",
          "name": "sideB",
          "package": "cassette",
          "signature": "d -\u003e c",
          "source": "src/Text-Cassette-Prim.html#K7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "sideB",
          "normalized": "a-\u003eb",
          "package": "cassette",
          "signature": "d-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:sideB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrip\u003cem\u003eadd the given string from\u003c/em\u003eto the output string.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "string",
          "package": "cassette",
          "signature": "String -\u003e PP0",
          "source": "src/Text-Cassette-Prim.html#string",
          "type": "function"
        },
        "index": {
          "description": "Strip add the given string from to the output string",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "string",
          "normalized": "String-\u003ePP",
          "package": "cassette",
          "signature": "String-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Cassette.Prim",
          "name": "unSym",
          "package": "cassette",
          "signature": "K7 a b a b",
          "source": "src/Text-Cassette-Prim.html#Sym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "unSym",
          "package": "cassette",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:unSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn the given cassette into a pure string transformer. That is, return a\n cassette that does not produce an output or consume an input. \u003ccode\u003eunshift x p\u003c/code\u003e\n throws away the output of \u003ccode\u003ep\u003c/code\u003e on the parsing side, and on the printing side\n sets the input to \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Cassette.Prim",
          "name": "unshift",
          "package": "cassette",
          "signature": "a -\u003e PP a -\u003e PP0",
          "source": "src/Text-Cassette-Prim.html#unshift",
          "type": "function"
        },
        "index": {
          "description": "Turn the given cassette into pure string transformer That is return cassette that does not produce an output or consume an input unshift throws away the output of on the parsing side and on the printing side sets the input to",
          "hierarchy": "Text Cassette Prim",
          "module": "Text.Cassette.Prim",
          "name": "unshift",
          "normalized": "a-\u003ePP a-\u003ePP",
          "package": "cassette",
          "signature": "a-\u003ePP a-\u003ePP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette-Prim.html#v:unshift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe combinators of this library are all pairs of functions going in\n opposite directions. These pairs are called \u003cem\u003ecassettes\u003c/em\u003e, sporting two\n tracks (the two functions), one of which is read is one direction, the\n other of which (accessed by flipping the cassette) is read in the opossite\n direction.\n\u003c/p\u003e\u003cp\u003eHere is an example specification for the lambda-calculus:\n\u003c/p\u003e\u003cpre\u003e varL = K7 leadout leadin where\n   leadout k k' s x = k (\\ s _ -\u003e k' s x) s (Var x)\n   leadin k k' s t@(Var x)  = k (\\ s _ -\u003e k' s t) s x\n   leadin k k' s t          = k' s t\n\n absL = K7 leadout leadin where\n   leadout k k' s t' x = k (\\ s _ -\u003e k' s t' x) s (Lam x t')\n   leadin k k' s t@(Lam x t)  = k (\\ s _ _ -\u003e k' s t) s t x\n   leadin k k' s t            = k' s t\n\n appL = K7 leadout leadin where\n   leadout k s t2 t1 = k (\\ s _ -\u003e k' s t2 t1) s (App t1 t2)\n   leadin k k' s t@(App t1 t2)  = k (\\ s _ _ -\u003e k' s t) s t2 t1\n   leadin k k' s t            = k' s t\n\n parens p = char '(' \u003c\u003e p \u003c\u003e char ')'\n\n term :: PP Term\n term  =   varL --\u003e ident\n       \u003c|\u003e absL --\u003e char '\\' \u003c\u003e ident \u003c\u003e term\n       \u003c|\u003e appL --\u003e parens (term \u003c\u003e sepSpace \u003c\u003e term)\n\u003c/pre\u003e\u003cp\u003eFrom this single specification, we can extract a parser,\n\u003c/p\u003e\u003cpre\u003e parse term :: PP Term -\u003e String -\u003e Maybe Term\n\u003c/pre\u003e\u003cp\u003eand also a pretty printer,\n\u003c/p\u003e\u003cpre\u003e pretty term :: PP Term -\u003e Term -\u003e Maybe String\n\u003c/pre\u003e\u003cp\u003eSpecifications are built from primitive and derived combinators, which\n affect the input string in some way. For each constructor of each datatype,\n we need to write a \u003cem\u003elead\u003c/em\u003e, which is a pair of a construction function and a\n destruction function. Leads are pure combinators that do not affect the\n input string. By convention, we suffix their name with \u003ca\u003eL\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eInternally, the primitive combinators are written in CPS. Leads also need\n to be written in this style, being primitive. They can, however, be\n automatically generated for every datatype using some Template Haskell\n hackery (in a separate package). A number of leads for standard datatypes\n are defined in the \u003ccode\u003e\u003ca\u003eLead\u003c/a\u003e\u003c/code\u003e module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Cassette",
          "name": "Cassette",
          "package": "cassette",
          "source": "src/Text-Cassette.html",
          "type": "module"
        },
        "index": {
          "description": "The combinators of this library are all pairs of functions going in opposite directions These pairs are called cassettes sporting two tracks the two functions one of which is read is one direction the other of which accessed by flipping the cassette is read in the opossite direction Here is an example specification for the lambda-calculus varL K7 leadout leadin where leadout Var leadin Var leadin absL K7 leadout leadin where leadout Lam leadin Lam leadin appL K7 leadout leadin where leadout t2 t1 t2 t1 App t1 t2 leadin App t1 t2 t2 t1 leadin parens char char term PP Term term varL ident absL char ident term appL parens term sepSpace term From this single specification we can extract parser parse term PP Term String Maybe Term and also pretty printer pretty term PP Term Term Maybe String Specifications are built from primitive and derived combinators which affect the input string in some way For each constructor of each datatype we need to write lead which is pair of construction function and destruction function Leads are pure combinators that do not affect the input string By convention we suffix their name with Internally the primitive combinators are written in CPS Leads also need to be written in this style being primitive They can however be automatically generated for every datatype using some Template Haskell hackery in separate package number of leads for standard datatypes are defined in the Lead module",
          "hierarchy": "Text Cassette",
          "module": "Text.Cassette",
          "name": "Cassette",
          "package": "cassette",
          "partial": "Cassette",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cassette/docs/Text-Cassette.html#"
      }
    }
  ]
]