[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "igraph"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell bindings to the igraph C library.\n\u003c/p\u003e\u003cp\u003eFunction descriptions have been copied from\n \u003ca\u003ehttp://igraph.sourceforge.net/doc/html/index.html\u003c/a\u003e from the specified sections.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.IGraph",
          "name": "IGraph",
          "package": "igraph",
          "source": "src/Data-IGraph.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell bindings to the igraph library Function descriptions have been copied from http igraph.sourceforge.net doc html index.html from the specified sections",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "IGraph",
          "package": "igraph",
          "partial": "IGraph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "Connectedness",
          "package": "igraph",
          "source": "src/Data-IGraph-Internal-Constants.html#Connectedness",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "Connectedness",
          "package": "igraph",
          "partial": "Connectedness",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:Connectedness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirected graph\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "D",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#D",
          "type": "data"
        },
        "index": {
          "description": "Directed graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "D",
          "package": "igraph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass for graph edges, particularly for undirected edges \u003ccode\u003eEdge U a\u003c/code\u003e and\n directed edges \u003ccode\u003eEdge D a\u003c/code\u003e and weighted edges.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "E",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#E",
          "type": "class"
        },
        "index": {
          "description": "Class for graph edges particularly for undirected edges Edge and directed edges Edge and weighted edges",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "E",
          "package": "igraph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:E"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "EdgeSelector",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "EdgeSelector",
          "package": "igraph",
          "partial": "Edge Selector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:EdgeSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "FASAlgorithm",
          "package": "igraph",
          "source": "src/Data-IGraph-Internal-Constants.html#FASAlgorithm",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "FASAlgorithm",
          "package": "igraph",
          "partial": "FASAlgorithm",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:FASAlgorithm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe internal graph representation wrapped into a GADT to carry around the\n \u003ccode\u003eE d a\u003c/code\u003e class constraint.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "Graph",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#Graph",
          "type": "data"
        },
        "index": {
          "description": "The internal graph representation wrapped into GADT to carry around the class constraint",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "Graph",
          "package": "igraph",
          "partial": "Graph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "IsDirected",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#IsDirected",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "IsDirected",
          "package": "igraph",
          "partial": "Is Directed",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:IsDirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "IsUndirected",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#IsUndirected",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "IsUndirected",
          "package": "igraph",
          "partial": "Is Undirected",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:IsUndirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "IsUnweighted",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#IsUnweighted",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "IsUnweighted",
          "package": "igraph",
          "partial": "Is Unweighted",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:IsUnweighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "SubgraphImplementation",
          "package": "igraph",
          "source": "src/Data-IGraph-Internal-Constants.html#SubgraphImplementation",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "SubgraphImplementation",
          "package": "igraph",
          "partial": "Subgraph Implementation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:SubgraphImplementation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUndirected graph\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "U",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#U",
          "type": "data"
        },
        "index": {
          "description": "Undirected graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "U",
          "package": "igraph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:U"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "VertexSelector",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#VertexSelector",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "VertexSelector",
          "package": "igraph",
          "partial": "Vertex Selector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:VertexSelector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeighted graphs, weight defaults to 0\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "Weighted",
          "package": "igraph",
          "source": "src/Data-IGraph-Types.html#Weighted",
          "type": "data"
        },
        "index": {
          "description": "Weighted graphs weight defaults to",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "Weighted",
          "package": "igraph",
          "partial": "Weighted",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#t:Weighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "ApproxEades",
          "package": "igraph",
          "signature": "ApproxEades",
          "source": "src/Data-IGraph-Internal-Constants.html#FASAlgorithm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "ApproxEades",
          "package": "igraph",
          "partial": "Approx Eades",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:ApproxEades"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "CopyAndDelete",
          "package": "igraph",
          "signature": "CopyAndDelete",
          "source": "src/Data-IGraph-Internal-Constants.html#SubgraphImplementation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "CopyAndDelete",
          "package": "igraph",
          "partial": "Copy And Delete",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:CopyAndDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "CreateFromScratch",
          "package": "igraph",
          "signature": "CreateFromScratch",
          "source": "src/Data-IGraph-Internal-Constants.html#SubgraphImplementation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "CreateFromScratch",
          "package": "igraph",
          "partial": "Create From Scratch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:CreateFromScratch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "Es1",
          "package": "igraph",
          "signature": "Es1 (Edge d a)",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "Es1",
          "package": "igraph",
          "partial": "Es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:Es1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "EsAll",
          "package": "igraph",
          "signature": "EsAll",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "EsAll",
          "package": "igraph",
          "partial": "Es All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:EsAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "EsFromTo",
          "package": "igraph",
          "signature": "EsFromTo (VertexSelector a) (VertexSelector a)",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "EsFromTo",
          "package": "igraph",
          "partial": "Es From To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:EsFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "EsIncident",
          "package": "igraph",
          "signature": "EsIncident a",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "EsIncident",
          "package": "igraph",
          "partial": "Es Incident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:EsIncident"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "EsList",
          "package": "igraph",
          "signature": "EsList [Edge d a]",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "EsList",
          "normalized": "EsList[Edge a b]",
          "package": "igraph",
          "partial": "Es List",
          "signature": "EsList[Edge d a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:EsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "EsNone",
          "package": "igraph",
          "signature": "EsNone",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "EsNone",
          "package": "igraph",
          "partial": "Es None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:EsNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "EsSeq",
          "package": "igraph",
          "signature": "EsSeq a a",
          "source": "src/Data-IGraph-Types.html#EdgeSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "EsSeq",
          "package": "igraph",
          "partial": "Es Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:EsSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "ExactIP",
          "package": "igraph",
          "signature": "ExactIP",
          "source": "src/Data-IGraph-Internal-Constants.html#FASAlgorithm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "ExactIP",
          "package": "igraph",
          "partial": "Exact IP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:ExactIP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "G",
          "package": "igraph",
          "signature": "G d a -\u003e Graph d a",
          "source": "src/Data-IGraph-Types.html#Graph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "G",
          "normalized": "G a b-\u003eGraph a b",
          "package": "igraph",
          "signature": "G d a-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:G"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "Strong",
          "package": "igraph",
          "signature": "Strong",
          "source": "src/Data-IGraph-Internal-Constants.html#Connectedness",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "Strong",
          "package": "igraph",
          "partial": "Strong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:Strong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "SubgraphAuto",
          "package": "igraph",
          "signature": "SubgraphAuto",
          "source": "src/Data-IGraph-Internal-Constants.html#SubgraphImplementation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "SubgraphAuto",
          "package": "igraph",
          "partial": "Subgraph Auto",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:SubgraphAuto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "Vs1",
          "package": "igraph",
          "signature": "Vs1 a",
          "source": "src/Data-IGraph-Types.html#VertexSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "Vs1",
          "package": "igraph",
          "partial": "Vs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:Vs1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "VsAdj",
          "package": "igraph",
          "signature": "VsAdj a",
          "source": "src/Data-IGraph-Types.html#VertexSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "VsAdj",
          "package": "igraph",
          "partial": "Vs Adj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:VsAdj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "VsAll",
          "package": "igraph",
          "signature": "VsAll",
          "source": "src/Data-IGraph-Types.html#VertexSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "VsAll",
          "package": "igraph",
          "partial": "Vs All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:VsAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "VsList",
          "package": "igraph",
          "signature": "VsList [a]",
          "source": "src/Data-IGraph-Types.html#VertexSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "VsList",
          "normalized": "VsList[a]",
          "package": "igraph",
          "partial": "Vs List",
          "signature": "VsList[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:VsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "VsNonAdj",
          "package": "igraph",
          "signature": "VsNonAdj a",
          "source": "src/Data-IGraph-Types.html#VertexSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "VsNonAdj",
          "package": "igraph",
          "partial": "Vs Non Adj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:VsNonAdj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "VsNone",
          "package": "igraph",
          "signature": "VsNone",
          "source": "src/Data-IGraph-Types.html#VertexSelector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "VsNone",
          "package": "igraph",
          "partial": "Vs None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:VsNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "Weak",
          "package": "igraph",
          "signature": "Weak",
          "source": "src/Data-IGraph-Internal-Constants.html#Connectedness",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "Weak",
          "package": "igraph",
          "partial": "Weak",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:Weak"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e1.1. \u003ccode\u003eigraph_are_connected\u003c/code\u003e &#8212; Decides whether two vertices are connected\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "areConnected",
          "package": "igraph",
          "signature": "Graph d a -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Data-IGraph.html#areConnected",
          "type": "function"
        },
        "index": {
          "description": "igraph are connected Decides whether two vertices are connected",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "areConnected",
          "normalized": "Graph a b-\u003eb-\u003eb-\u003eBool",
          "package": "igraph",
          "partial": "Connected",
          "signature": "Graph d a-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:areConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.10. \u003ccode\u003eigraph_articulation_points\u003c/code\u003e &#8212; Find the articulation points in a\n graph.\n\u003c/p\u003e\u003cp\u003eA vertex is an articulation point if its removal increases the number of\n connected components in the graph.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "articulationPoints",
          "package": "igraph",
          "signature": "Graph d a -\u003e [a]",
          "source": "src/Data-IGraph.html#articulationPoints",
          "type": "function"
        },
        "index": {
          "description": "igraph articulation points Find the articulation points in graph vertex is an articulation point if its removal increases the number of connected components in the graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "articulationPoints",
          "normalized": "Graph a b-\u003e[b]",
          "package": "igraph",
          "partial": "Points",
          "signature": "Graph d a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:articulationPoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e14.2. \u003ccode\u003eigraph_assortativity\u003c/code\u003e &#8212; Assortativity based on numeric properties of\n vertices\n\u003c/p\u003e\u003cp\u003eThis function calculates the assortativity coefficient of the input graph.\n This coefficient is basically the correlation between the actual connectivity\n patterns of the vertices and the pattern expected from the distribution of\n the vertex types.\n\u003c/p\u003e\u003cp\u003eSee equation (21) in M. E. J. Newman: Mixing patterns in networks, Phys. Rev.\n E 67, 026126 (2003) (http:\u003cem/\u003earxiv.org\u003cem\u003eabs\u003c/em\u003econd-mat/0209450) for the proper\n definition. The actual calculation is performed using equation (26) in the\n same paper for directed graphs, and equation (4) in M. E. J. Newman:\n Assortative mixing in networks, Phys. Rev. Lett. 89, 208701 (2002)\n (http:\u003cem/\u003earxiv.org\u003cem\u003eabs\u003c/em\u003econd-mat\u003cem\u003e0205405\u003c/em\u003e) for undirected graphs.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "assortativity",
          "package": "igraph",
          "signature": "Graph d (vertexTypeIncoming, vertexTypeOutgoing, a)-\u003e Bool-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "igraph assortativity Assortativity based on numeric properties of vertices This function calculates the assortativity coefficient of the input graph This coefficient is basically the correlation between the actual connectivity patterns of the vertices and the pattern expected from the distribution of the vertex types See equation in Newman Mixing patterns in networks Phys Rev http arxiv.org abs cond-mat for the proper definition The actual calculation is performed using equation in the same paper for directed graphs and equation in Newman Assortative mixing in networks Phys Rev Lett http arxiv.org abs cond-mat for undirected graphs",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "assortativity",
          "normalized": "Graph a(b,c,d)-\u003eBool-\u003eDouble",
          "package": "igraph",
          "signature": "Graph d(vertexTypeIncoming,vertexTypeOutgoing,a)-\u003eBool-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:assortativity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e14.3. \u003ccode\u003eigraph_assortativity_degree\u003c/code\u003e &#8212; Assortativity of a graph based on vertex\n degree\n\u003c/p\u003e\u003cp\u003eAssortativity based on vertex degree, please see the discussion at the\n documentation of igraph_assortativity() for details.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "assortativityDegree",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "igraph assortativity degree Assortativity of graph based on vertex degree Assortativity based on vertex degree please see the discussion at the documentation of igraph assortativity for details",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "assortativityDegree",
          "normalized": "Graph a b-\u003eBool-\u003eDouble",
          "package": "igraph",
          "partial": "Degree",
          "signature": "Graph d a-\u003eBool-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:assortativityDegree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e14.1. \u003ccode\u003eigraph_assortativity_nominal\u003c/code\u003e &#8212; Assortativity of a graph based on\n vertex categories\n\u003c/p\u003e\u003cp\u003eAssuming the vertices of the input graph belong to different categories, this\n function calculates the assortativity coefficient of the graph. The\n assortativity coefficient is between minus one and one and it is one if all\n connections stay within categories, it is minus one, if the network is\n perfectly disassortative. For a randomly connected network it is\n (asymptotically) zero.\n\u003c/p\u003e\u003cp\u003eSee equation (2) in M. E. J. Newman: Mixing patterns in networks, Phys. Rev.\n E 67, 026126 (2003) (http:\u003cem/\u003earxiv.org\u003cem\u003eabs\u003c/em\u003econd-mat/0209450) for the proper\n definition.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "assortativityNominal",
          "package": "igraph",
          "signature": "Graph d (vertexType, a)-\u003e Bool-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "igraph assortativity nominal Assortativity of graph based on vertex categories Assuming the vertices of the input graph belong to different categories this function calculates the assortativity coefficient of the graph The assortativity coefficient is between minus one and one and it is one if all connections stay within categories it is minus one if the network is perfectly disassortative For randomly connected network it is asymptotically zero See equation in Newman Mixing patterns in networks Phys Rev http arxiv.org abs cond-mat for the proper definition",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "assortativityNominal",
          "normalized": "Graph a(b,c)-\u003eBool-\u003eDouble",
          "package": "igraph",
          "partial": "Nominal",
          "signature": "Graph d(vertexType,a)-\u003eBool-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:assortativityNominal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.13. \u003ccode\u003eigraph_authority_score\u003c/code\u003e &#8212; Kleinerg's authority scores\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "authorityScore",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e (Double, [(a, Double)])",
          "type": "function"
        },
        "index": {
          "description": "igraph authority score Kleinerg authority scores",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "authorityScore",
          "normalized": "Graph a b-\u003eBool-\u003e(Double,[(b,Double)])",
          "package": "igraph",
          "partial": "Score",
          "signature": "Graph d a-\u003eBool-\u003e(Double,[(a,Double)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:authorityScore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.11. \u003ccode\u003eigraph_average_path_length\u003c/code\u003e &#8212; Calculates the average geodesic length\n in a graph.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "averagePathLength",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e Bool-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "igraph average path length Calculates the average geodesic length in graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "averagePathLength",
          "normalized": "Graph a b-\u003eBool-\u003eBool-\u003eDouble",
          "package": "igraph",
          "partial": "Path Length",
          "signature": "Graph d a-\u003eBool-\u003eBool-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:averagePathLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.2. \u003ccode\u003eigraph_betweenness\u003c/code\u003e &#8212; Betweenness centrality of some vertices.\n\u003c/p\u003e\u003cp\u003eThe betweenness centrality of a vertex is the number of geodesics going\n through it. If there are more than one geodesic between two vertices, the\n value of these geodesics are weighted by one over the number of geodesics.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "betweenness",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e Map a Double",
          "source": "src/Data-IGraph.html#betweenness",
          "type": "function"
        },
        "index": {
          "description": "igraph betweenness Betweenness centrality of some vertices The betweenness centrality of vertex is the number of geodesics going through it If there are more than one geodesic between two vertices the value of these geodesics are weighted by one over the number of geodesics",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "betweenness",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eMap b Double",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eMap a Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:betweenness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e6.2. \u003ccode\u003eigraph_betweenness_estimate\u003c/code\u003e &#8212; Estimated betweenness centrality of\n some vertices.\n\u003c/p\u003e\u003cp\u003eThe betweenness centrality of a vertex is the number of geodesics going\n through it. If there are more than one geodesic between two vertices, the\n value of these geodesics are weighted by one over the number of geodesics.\n When estimating betweenness centrality, igraph takes into consideration only\n those paths that are shorter than or equal to a prescribed length. Note that\n the estimated centrality will always be less than the real one.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "betweennessEstimate",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Int-\u003e Map a Double",
          "type": "function"
        },
        "index": {
          "description": "igraph betweenness estimate Estimated betweenness centrality of some vertices The betweenness centrality of vertex is the number of geodesics going through it If there are more than one geodesic between two vertices the value of these geodesics are weighted by one over the number of geodesics When estimating betweenness centrality igraph takes into consideration only those paths that are shorter than or equal to prescribed length Note that the estimated centrality will always be less than the real one",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "betweennessEstimate",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eInt-\u003eMap b Double",
          "package": "igraph",
          "partial": "Estimate",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eInt-\u003eMap a Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:betweennessEstimate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.1. \u003ccode\u003eigraph_bibcoupling\u003c/code\u003e &#8212; Bibliographic coupling.\n\u003c/p\u003e\u003cp\u003eThe bibliographic coupling of two vertices is the number of other vertices\n they both cite, `igraph_bibcoupling()` calculates this. The bibliographic\n coupling score for each given vertex and all other vertices in the graph will\n be calculated.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "bibCoupling",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e [(a, [(a, Int)])]",
          "source": "src/Data-IGraph.html#bibCoupling",
          "type": "function"
        },
        "index": {
          "description": "igraph bibcoupling Bibliographic coupling The bibliographic coupling of two vertices is the number of other vertices they both cite igraph bibcoupling calculates this The bibliographic coupling score for each given vertex and all other vertices in the graph will be calculated",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "bibCoupling",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003e[(b,[(b,Int)])]",
          "package": "igraph",
          "partial": "Coupling",
          "signature": "Graph d a-\u003eVertexSelector a-\u003e[(a,[(a,Int)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:bibCoupling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.9. \u003ccode\u003eigraph_biconnected_components\u003c/code\u003e &#8212; Calculate biconnected components\n\u003c/p\u003e\u003cp\u003eA graph is biconnected if the removal of any single vertex (and its incident\n edges) does not disconnect it.\n\u003c/p\u003e\u003cp\u003eA biconnected component of a graph is a maximal biconnected subgraph of it.\n The biconnected components of a graph can be given by the partition of its\n edges: every edge is a member of exactly one biconnected component. Note that\n this is not true for vertices: the same vertex can be part of many\n biconnected components.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "biconnectedComponents",
          "package": "igraph",
          "signature": "Graph d a-\u003e (Int, [[Edge d a]], [[Edge d a]], [[a]], [a])",
          "type": "function"
        },
        "index": {
          "description": "igraph biconnected components Calculate biconnected components graph is biconnected if the removal of any single vertex and its incident edges does not disconnect it biconnected component of graph is maximal biconnected subgraph of it The biconnected components of graph can be given by the partition of its edges every edge is member of exactly one biconnected component Note that this is not true for vertices the same vertex can be part of many biconnected components",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "biconnectedComponents",
          "normalized": "Graph a b-\u003e(Int,[[Edge a b]],[[Edge a b]],[[b]],[b])",
          "package": "igraph",
          "partial": "Components",
          "signature": "Graph d a-\u003e(Int,[[Edge d a]],[[Edge d a]],[[a]],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:biconnectedComponents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.3. \u003ccode\u003eigraph_centralization_betweenness\u003c/code\u003e &#8212; Calculate vertex betweenness and\n graph centralization\n\u003c/p\u003e\u003cp\u003eThis function calculates the betweenness centrality of the vertices by\n passing its arguments to igraph_betweenness(); and it calculates the graph\n level centralization index based on the results by calling\n igraph_centralization().\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationBetweenness",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e (Map a Double, Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization betweenness Calculate vertex betweenness and graph centralization This function calculates the betweenness centrality of the vertices by passing its arguments to igraph betweenness and it calculates the graph level centralization index based on the results by calling igraph centralization",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationBetweenness",
          "normalized": "Graph a b-\u003eBool-\u003e(Map b Double,Double,Double)",
          "package": "igraph",
          "partial": "Betweenness",
          "signature": "Graph d a-\u003eBool-\u003e(Map a Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationBetweenness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.7. \u003ccode\u003eigraph_centralization_betweenness_tmax\u003c/code\u003e &#8212; Theoretical maximum for\n graph centralization based on betweenness\n\u003c/p\u003e\u003cp\u003eThis function returns the theoretical maximum graph centrality based on\n vertex betweenness.\n\u003c/p\u003e\u003cp\u003eThere are two ways to call this function, the first is to supply a graph as\n the graph argument, and then the number of vertices is taken from this\n object, and its directedness is considered as well. The nodes argument is\n ignored in this case. The directed argument is also ignored if the supplied\n graph is undirected.\n\u003c/p\u003e\u003cp\u003eThe other way is to supply a null pointer as the graph argument. In this case\n the nodes and directed arguments are considered.\n\u003c/p\u003e\u003cp\u003eThe most centralized structure is the star.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationBetweennessTMax",
          "package": "igraph",
          "signature": "Either (Graph d a) Int -\u003e Double",
          "source": "src/Data-IGraph.html#centralizationBetweennessTMax",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization betweenness tmax Theoretical maximum for graph centralization based on betweenness This function returns the theoretical maximum graph centrality based on vertex betweenness There are two ways to call this function the first is to supply graph as the graph argument and then the number of vertices is taken from this object and its directedness is considered as well The nodes argument is ignored in this case The directed argument is also ignored if the supplied graph is undirected The other way is to supply null pointer as the graph argument In this case the nodes and directed arguments are considered The most centralized structure is the star",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationBetweennessTMax",
          "normalized": "Either(Graph a b)Int-\u003eDouble",
          "package": "igraph",
          "partial": "Betweenness TMax",
          "signature": "Either(Graph d a)Int-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationBetweennessTMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.4. \u003ccode\u003eigraph_centralization_closeness\u003c/code\u003e &#8212; Calculate vertex closeness and\n graph centralization\n\u003c/p\u003e\u003cp\u003eThis function calculates the closeness centrality of the vertices by passing\n its arguments to igraph_closeness(); and it calculates the graph level\n centralization index based on the results by calling igraph_centralization().\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationCloseness",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e (Map a Double, Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization closeness Calculate vertex closeness and graph centralization This function calculates the closeness centrality of the vertices by passing its arguments to igraph closeness and it calculates the graph level centralization index based on the results by calling igraph centralization",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationCloseness",
          "normalized": "Graph a b-\u003eBool-\u003e(Map b Double,Double,Double)",
          "package": "igraph",
          "partial": "Closeness",
          "signature": "Graph d a-\u003eBool-\u003e(Map a Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationCloseness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.8. \u003ccode\u003eigraph_centralization_closeness_tmax\u003c/code\u003e &#8212; Theoretical maximum for graph\n centralization based on closeness\n\u003c/p\u003e\u003cp\u003eThis function returns the theoretical maximum graph centrality based on\n vertex closeness.\n\u003c/p\u003e\u003cp\u003eThere are two ways to call this function, the first is to supply a graph as\n the graph argument, and then the number of vertices is taken from this\n object, and its directedness is considered as well. The nodes argument is\n ignored in this case. The mode argument is also ignored if the supplied graph\n is undirected.\n\u003c/p\u003e\u003cp\u003eThe other way is to supply a null pointer as the graph argument. In this case\n the nodes and mode arguments are considered.\n\u003c/p\u003e\u003cp\u003eThe most centralized structure is the star.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationClosenessTMax",
          "package": "igraph",
          "signature": "Either (Graph d a) Int -\u003e Double",
          "source": "src/Data-IGraph.html#centralizationClosenessTMax",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization closeness tmax Theoretical maximum for graph centralization based on closeness This function returns the theoretical maximum graph centrality based on vertex closeness There are two ways to call this function the first is to supply graph as the graph argument and then the number of vertices is taken from this object and its directedness is considered as well The nodes argument is ignored in this case The mode argument is also ignored if the supplied graph is undirected The other way is to supply null pointer as the graph argument In this case the nodes and mode arguments are considered The most centralized structure is the star",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationClosenessTMax",
          "normalized": "Either(Graph a b)Int-\u003eDouble",
          "package": "igraph",
          "partial": "Closeness TMax",
          "signature": "Either(Graph d a)Int-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationClosenessTMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.2. \u003ccode\u003eigraph_centralization_degree\u003c/code\u003e &#8212; Calculate vertex degree and graph\n centralization\n\u003c/p\u003e\u003cp\u003eThis function calculates the degree of the vertices by passing its arguments\n to igraph_degree(); and it calculates the graph level centralization index\n based on the results by calling igraph_centralization().\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationDegree",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e Bool-\u003e (Map a Double, Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization degree Calculate vertex degree and graph centralization This function calculates the degree of the vertices by passing its arguments to igraph degree and it calculates the graph level centralization index based on the results by calling igraph centralization",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationDegree",
          "normalized": "Graph a b-\u003eBool-\u003eBool-\u003e(Map b Double,Double,Double)",
          "package": "igraph",
          "partial": "Degree",
          "signature": "Graph d a-\u003eBool-\u003eBool-\u003e(Map a Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationDegree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.6. \u003ccode\u003eigraph_centralization_degree_tmax\u003c/code\u003e &#8212; Theoretical maximum for graph\n centralization based on degree\n\u003c/p\u003e\u003cp\u003eThis function returns the theoretical maximum graph centrality based on\n vertex degree.\n\u003c/p\u003e\u003cp\u003eThere are two ways to call this function, the first is to supply a graph as\n the graph argument, and then the number of vertices is taken from this\n object, and its directedness is considered as well. The nodes argument is\n ignored in this case. The mode argument is also ignored if the supplied graph\n is undirected.\n\u003c/p\u003e\u003cp\u003eThe other way is to supply a null pointer as the graph argument. In this case\n the nodes and mode arguments are considered.\n\u003c/p\u003e\u003cp\u003eThe most centralized structure is the star. More specifically, for undirected\n graphs it is the star, for directed graphs it is the in-star or the out-star.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationDegreeTMax",
          "package": "igraph",
          "signature": "Either (Graph d a) Int-\u003e Bool-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization degree tmax Theoretical maximum for graph centralization based on degree This function returns the theoretical maximum graph centrality based on vertex degree There are two ways to call this function the first is to supply graph as the graph argument and then the number of vertices is taken from this object and its directedness is considered as well The nodes argument is ignored in this case The mode argument is also ignored if the supplied graph is undirected The other way is to supply null pointer as the graph argument In this case the nodes and mode arguments are considered The most centralized structure is the star More specifically for undirected graphs it is the star for directed graphs it is the in-star or the out-star",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationDegreeTMax",
          "normalized": "Either(Graph a b)Int-\u003eBool-\u003eDouble",
          "package": "igraph",
          "partial": "Degree TMax",
          "signature": "Either(Graph d a)Int-\u003eBool-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationDegreeTMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.5. \u003ccode\u003eigraph_centralization_eigenvector_centrality\u003c/code\u003e &#8212; Calculate\n eigenvector centrality scores and graph centralization\n\u003c/p\u003e\u003cp\u003eThis function calculates the eigenvector centrality of the vertices by\n passing its arguments to igraph_eigenvector_centrality); and it calculates\n the graph level centralization index based on the results by calling\n igraph_centralization().\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationEigenvectorCentrality",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e Bool-\u003e (Double, Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization eigenvector centrality Calculate eigenvector centrality scores and graph centralization This function calculates the eigenvector centrality of the vertices by passing its arguments to igraph eigenvector centrality and it calculates the graph level centralization index based on the results by calling igraph centralization",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationEigenvectorCentrality",
          "normalized": "Graph a b-\u003eBool-\u003eBool-\u003e(Double,Double,Double)",
          "package": "igraph",
          "partial": "Eigenvector Centrality",
          "signature": "Graph d a-\u003eBool-\u003eBool-\u003e(Double,Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationEigenvectorCentrality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e7.9. \u003ccode\u003eigraph_centralization_eigenvector_centrality_tmax\u003c/code\u003e &#8212; Theoretical\n maximum centralization for eigenvector centrality\n\u003c/p\u003e\u003cp\u003eThis function returns the theoretical maximum graph centrality based on\n vertex eigenvector centrality.\n\u003c/p\u003e\u003cp\u003eThere are two ways to call this function, the first is to supply a graph as\n the graph argument, and then the number of vertices is taken from this\n object, and its directedness is considered as well. The nodes argument is\n ignored in this case. The directed argument is also ignored if the supplied\n graph is undirected.\n\u003c/p\u003e\u003cp\u003eThe other way is to supply a null pointer as the graph argument. In this case\n the nodes and directed arguments are considered.\n\u003c/p\u003e\u003cp\u003eThe most centralized directed structure is the in-star. The most centralized\n undirected structure is the graph with a single edge.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "centralizationEigenvectorCentralityTMax",
          "package": "igraph",
          "signature": "Either (Graph d a) Int-\u003e Bool-\u003e Bool-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "igraph centralization eigenvector centrality tmax Theoretical maximum centralization for eigenvector centrality This function returns the theoretical maximum graph centrality based on vertex eigenvector centrality There are two ways to call this function the first is to supply graph as the graph argument and then the number of vertices is taken from this object and its directedness is considered as well The nodes argument is ignored in this case The directed argument is also ignored if the supplied graph is undirected The other way is to supply null pointer as the graph argument In this case the nodes and directed arguments are considered The most centralized directed structure is the in-star The most centralized undirected structure is the graph with single edge",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "centralizationEigenvectorCentralityTMax",
          "normalized": "Either(Graph a b)Int-\u003eBool-\u003eBool-\u003eDouble",
          "package": "igraph",
          "partial": "Eigenvector Centrality TMax",
          "signature": "Either(Graph d a)Int-\u003eBool-\u003eBool-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:centralizationEigenvectorCentralityTMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.1. \u003ccode\u003eigraph_closeness\u003c/code\u003e &#8212; Closeness centrality calculations for some\n vertices.\n\u003c/p\u003e\u003cp\u003eThe closeness centrality of a vertex measures how easily other vertices can\n be reached from it (or the other way: how easily it can be reached from the\n other vertices). It is defined as the number of the number of vertices minus\n one divided by the sum of the lengths of all geodesics from/to the given\n vertex.\n\u003c/p\u003e\u003cp\u003eIf the graph is not connected, and there is no path between two vertices, the\n number of vertices is used instead the length of the geodesic. This is always\n longer than the longest possible geodesic.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "closeness",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e Map a Double",
          "source": "src/Data-IGraph.html#closeness",
          "type": "function"
        },
        "index": {
          "description": "igraph closeness Closeness centrality calculations for some vertices The closeness centrality of vertex measures how easily other vertices can be reached from it or the other way how easily it can be reached from the other vertices It is defined as the number of the number of vertices minus one divided by the sum of the lengths of all geodesics from to the given vertex If the graph is not connected and there is no path between two vertices the number of vertices is used instead the length of the geodesic This is always longer than the longest possible geodesic",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "closeness",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eMap b Double",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eMap a Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:closeness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e6.1. \u003ccode\u003eigraph_closeness_estimate\u003c/code\u003e &#8212; Closeness centrality estimations for\n some vertices.\n\u003c/p\u003e\u003cp\u003eThe closeness centrality of a vertex measures how easily other vertices can\n be reached from it (or the other way: how easily it can be reached from the\n other vertices). It is defined as the number of the number of vertices minus\n one divided by the sum of the lengths of all geodesics from/to the given\n vertex. When estimating closeness centrality, igraph considers paths having a\n length less than or equal to a prescribed cutoff value.\n\u003c/p\u003e\u003cp\u003eIf the graph is not connected, and there is no such path between two\n vertices, the number of vertices is used instead the length of the geodesic.\n This is always longer than the longest possible geodesic.\n\u003c/p\u003e\u003cp\u003eSince the estimation considers vertex pairs with a distance greater than the\n given value as disconnected, the resulting estimation will always be lower\n than the actual closeness centrality.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "closenessEstimate",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Int-\u003e Map a Double",
          "type": "function"
        },
        "index": {
          "description": "igraph closeness estimate Closeness centrality estimations for some vertices The closeness centrality of vertex measures how easily other vertices can be reached from it or the other way how easily it can be reached from the other vertices It is defined as the number of the number of vertices minus one divided by the sum of the lengths of all geodesics from to the given vertex When estimating closeness centrality igraph considers paths having length less than or equal to prescribed cutoff value If the graph is not connected and there is no such path between two vertices the number of vertices is used instead the length of the geodesic This is always longer than the longest possible geodesic Since the estimation considers vertex pairs with distance greater than the given value as disconnected the resulting estimation will always be lower than the actual closeness centrality",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "closenessEstimate",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eInt-\u003eMap b Double",
          "package": "igraph",
          "partial": "Estimate",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eInt-\u003eMap a Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:closenessEstimate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.5. \u003ccode\u003eigraph_clusters\u003c/code\u003e &#8212; Calculates the (weakly or strongly) connected\n components in a graph.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "clusters",
          "package": "igraph",
          "signature": "Graph d a-\u003e Connectedness-\u003e (Int, [Int])",
          "type": "function"
        },
        "index": {
          "description": "igraph clusters Calculates the weakly or strongly connected components in graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "clusters",
          "normalized": "Graph a b-\u003eConnectedness-\u003e(Int,[Int])",
          "package": "igraph",
          "signature": "Graph d a-\u003eConnectedness-\u003e(Int,[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:clusters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.2. \u003ccode\u003eigraph_cocitation\u003c/code\u003e &#8212; Cocitation coupling.\n\u003c/p\u003e\u003cp\u003eTwo vertices are cocited if there is another vertex citing both of them.\n `igraph_cocitation()` simply counts how many times two vertices are cocited.\n The cocitation score for each given vertex and all other vertices in the\n graph will be calculated.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "cocitation",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e [(a, [(a, Int)])]",
          "source": "src/Data-IGraph.html#cocitation",
          "type": "function"
        },
        "index": {
          "description": "igraph cocitation Cocitation coupling Two vertices are cocited if there is another vertex citing both of them igraph cocitation simply counts how many times two vertices are cocited The cocitation score for each given vertex and all other vertices in the graph will be calculated",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "cocitation",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003e[(b,[(b,Int)])]",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003e[(a,[(a,Int)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:cocitation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.8. \u003ccode\u003eigraph_constraint\u003c/code\u003e &#8212; Burt's constraint scores.\n\u003c/p\u003e\u003cp\u003eThis function calculates Burt's constraint scores for the given vertices,\n also known as structural holes.\n\u003c/p\u003e\u003cp\u003eBurt's constraint is higher if ego has less, or mutually stronger related\n (i.e. more redundant) contacts. Burt's measure of constraint, C[i], of vertex\n i's ego network V[i], is defined for directed and valued graphs,\n\u003c/p\u003e\u003cp\u003eC[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in V[], j != i)\n\u003c/p\u003e\u003cp\u003efor a graph of order (ie. number of vertices) N, where proportional tie\n strengths are defined as\n\u003c/p\u003e\u003cp\u003ep[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i),\n\u003c/p\u003e\u003cp\u003ea[i,j] are elements of A and the latter being the graph adjacency matrix. For\n isolated vertices, constraint is undefined.\n\u003c/p\u003e\u003cp\u003eBurt, R.S. (2004). Structural holes and good ideas. American Journal of\n Sociology 110, 349-399.\n\u003c/p\u003e\u003cp\u003eThe first R version of this function was contributed by Jeroen Bruggeman.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "constraint",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e Map a Double",
          "source": "src/Data-IGraph.html#constraint",
          "type": "function"
        },
        "index": {
          "description": "igraph constraint Burt constraint scores This function calculates Burt constraint scores for the given vertices also known as structural holes Burt constraint is higher if ego has less or mutually stronger related i.e more redundant contacts Burt measure of constraint of vertex ego network is defined for directed and valued graphs sum sum in in for graph of order ie number of vertices where proportional tie strengths are defined as sum in are elements of and the latter being the graph adjacency matrix For isolated vertices constraint is undefined Burt R.S Structural holes and good ideas American Journal of Sociology The first version of this function was contributed by Jeroen Bruggeman",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "constraint",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eMap b Double",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eMap a Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:constraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e15.1. \u003ccode\u003eigraph_coreness\u003c/code\u003e &#8212; Finding the coreness of the vertices in a network.\n\u003c/p\u003e\u003cp\u003eThe k-core of a graph is a maximal subgraph in which each vertex has at least\n degree k. (Degree here means the degree in the subgraph of course.). The\n coreness of a vertex is the highest order of a k-core containing the vertex.\n\u003c/p\u003e\u003cp\u003eThis function implements the algorithm presented in Vladimir Batagelj, Matjaz\n Zaversnik: An O(m) Algorithm for Cores Decomposition of Networks.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "coreness",
          "package": "igraph",
          "signature": "Graph d a -\u003e [(Double, a)]",
          "source": "src/Data-IGraph.html#coreness",
          "type": "function"
        },
        "index": {
          "description": "igraph coreness Finding the coreness of the vertices in network The k-core of graph is maximal subgraph in which each vertex has at least degree Degree here means the degree in the subgraph of course The coreness of vertex is the highest order of k-core containing the vertex This function implements the algorithm presented in Vladimir Batagelj Matjaz Zaversnik An Algorithm for Cores Decomposition of Networks",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "coreness",
          "normalized": "Graph a b-\u003e[(Double,b)]",
          "package": "igraph",
          "signature": "Graph d a-\u003e[(Double,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:coreness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.7. \u003ccode\u003eigraph_decompose\u003c/code\u003e &#8212; Decompose a graph into connected components.\n\u003c/p\u003e\u003cp\u003eCreate separate graph for each component of a graph. Note that the vertex ids\n in the new graphs will be different than in the original graph. (Except if\n there is only one component in the original graph.)\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "decompose",
          "package": "igraph",
          "signature": "Graph d a -\u003e Connectedness -\u003e Int -\u003e Int -\u003e [Graph d a]",
          "source": "src/Data-IGraph.html#decompose",
          "type": "function"
        },
        "index": {
          "description": "igraph decompose Decompose graph into connected components Create separate graph for each component of graph Note that the vertex ids in the new graphs will be different than in the original graph Except if there is only one component in the original graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "decompose",
          "normalized": "Graph a b-\u003eConnectedness-\u003eInt-\u003eInt-\u003e[Graph a b]",
          "package": "igraph",
          "signature": "Graph d a-\u003eConnectedness-\u003eInt-\u003eInt-\u003e[Graph d a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:decompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "deleteEdge",
          "package": "igraph",
          "signature": "Edge d a -\u003e Graph d a -\u003e Graph d a",
          "source": "src/Data-IGraph-Internal.html#deleteEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "deleteEdge",
          "normalized": "Edge a b-\u003eGraph a b-\u003eGraph a b",
          "package": "igraph",
          "partial": "Edge",
          "signature": "Edge d a-\u003eGraph d a-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:deleteEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "deleteNode",
          "package": "igraph",
          "signature": "a -\u003e Graph d a -\u003e Graph d a",
          "source": "src/Data-IGraph-Internal.html#deleteNode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "deleteNode",
          "normalized": "a-\u003eGraph b a-\u003eGraph b a",
          "package": "igraph",
          "partial": "Node",
          "signature": "a-\u003eGraph d a-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:deleteNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.13. \u003ccode\u003eigraph_diameter\u003c/code\u003e &#8212; Calculates the diameter of a graph (longest\n geodesic).\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "diameter",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e Bool-\u003e (Int, (a, a), [a])",
          "type": "function"
        },
        "index": {
          "description": "igraph diameter Calculates the diameter of graph longest geodesic",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "diameter",
          "normalized": "Graph a b-\u003eBool-\u003eBool-\u003e(Int,(b,b),[b])",
          "package": "igraph",
          "signature": "Graph d a-\u003eBool-\u003eBool-\u003e(Int,(a,a),[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:diameter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.14. \u003ccode\u003eigraph_diameter_dijkstra\u003c/code\u003e &#8212; Weighted diameter using Dijkstra's\n algorithm, non-negative weights only.\n\u003c/p\u003e\u003cp\u003eThe diameter of a graph is its longest geodesic. I.e. the (weighted) shortest\n path is calculated for all pairs of vertices and the longest one is the\n diameter.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "diameterDijkstra",
          "package": "igraph",
          "signature": "Graph d a-\u003e (Double, a, a, [a])",
          "type": "function"
        },
        "index": {
          "description": "igraph diameter dijkstra Weighted diameter using Dijkstra algorithm non-negative weights only The diameter of graph is its longest geodesic I.e the weighted shortest path is calculated for all pairs of vertices and the longest one is the diameter",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "diameterDijkstra",
          "normalized": "Graph a b-\u003e(Double,b,b,[b])",
          "package": "igraph",
          "partial": "Dijkstra",
          "signature": "Graph d a-\u003e(Double,a,a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:diameterDijkstra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.16. \u003ccode\u003eigraph_eccentricity\u003c/code\u003e &#8212; Eccentricity of some vertices\n\u003c/p\u003e\u003cp\u003eThe eccentricity of a vertex is calculated by measuring the shortest distance\n from (or to) the vertex, to (or from) all vertices in the graph, and taking\n the maximum.\n\u003c/p\u003e\u003cp\u003eThis implementation ignores vertex pairs that are in different components.\n Isolated vertices have eccentricity zero.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "eccentricity",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e [(a, Int)]",
          "source": "src/Data-IGraph.html#eccentricity",
          "type": "function"
        },
        "index": {
          "description": "igraph eccentricity Eccentricity of some vertices The eccentricity of vertex is calculated by measuring the shortest distance from or to the vertex to or from all vertices in the graph and taking the maximum This implementation ignores vertex pairs that are in different components Isolated vertices have eccentricity zero",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "eccentricity",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003e[(b,Int)]",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003e[(a,Int)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:eccentricity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.3. \u003ccode\u003eigraph_edge_betweenness\u003c/code\u003e &#8212; Betweenness centrality of the edges.\n\u003c/p\u003e\u003cp\u003eThe betweenness centrality of an edge is the number of geodesics going\n through it. If there are more than one geodesics between two vertices, the\n value of these geodesics are weighted by one over the number of geodesics.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "edgeBetweenness",
          "package": "igraph",
          "signature": "Graph d a -\u003e Map (Edge d a) Double",
          "source": "src/Data-IGraph.html#edgeBetweenness",
          "type": "function"
        },
        "index": {
          "description": "igraph edge betweenness Betweenness centrality of the edges The betweenness centrality of an edge is the number of geodesics going through it If there are more than one geodesics between two vertices the value of these geodesics are weighted by one over the number of geodesics",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "edgeBetweenness",
          "normalized": "Graph a b-\u003eMap(Edge a b)Double",
          "package": "igraph",
          "partial": "Betweenness",
          "signature": "Graph d a-\u003eMap(Edge d a)Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:edgeBetweenness"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e6.3. \u003ccode\u003eigraph_edge_betweenness_estimate\u003c/code\u003e &#8212; Estimated betweenness centrality\n of the edges.\n\u003c/p\u003e\u003cp\u003eThe betweenness centrality of an edge is the number of geodesics going\n through it. If there are more than one geodesics between two vertices, the\n value of these geodesics are weighted by one over the number of geodesics.\n When estimating betweenness centrality, igraph takes into consideration only\n those paths that are shorter than or equal to a prescribed length. Note that\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "edgeBetweennessEstimate",
          "package": "igraph",
          "signature": "Graph d a-\u003e Int-\u003e Map (Edge d a) Double",
          "type": "function"
        },
        "index": {
          "description": "igraph edge betweenness estimate Estimated betweenness centrality of the edges The betweenness centrality of an edge is the number of geodesics going through it If there are more than one geodesics between two vertices the value of these geodesics are weighted by one over the number of geodesics When estimating betweenness centrality igraph takes into consideration only those paths that are shorter than or equal to prescribed length Note that",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "edgeBetweennessEstimate",
          "normalized": "Graph a b-\u003eInt-\u003eMap(Edge a b)Double",
          "package": "igraph",
          "partial": "Betweenness Estimate",
          "signature": "Graph d a-\u003eInt-\u003eMap(Edge d a)Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:edgeBetweennessEstimate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "edgeFrom",
          "package": "igraph",
          "signature": "Edge d a -\u003e a",
          "source": "src/Data-IGraph-Types.html#edgeFrom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "edgeFrom",
          "normalized": "Edge a b-\u003eb",
          "package": "igraph",
          "partial": "From",
          "signature": "Edge d a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:edgeFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "edgeTo",
          "package": "igraph",
          "signature": "Edge d a -\u003e a",
          "source": "src/Data-IGraph-Types.html#edgeTo",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "edgeTo",
          "normalized": "Edge a b-\u003eb",
          "package": "igraph",
          "partial": "To",
          "signature": "Edge d a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:edgeTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "edgeWeight",
          "package": "igraph",
          "signature": "Edge d a -\u003e Maybe Int",
          "source": "src/Data-IGraph-Types.html#edgeWeight",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "edgeWeight",
          "normalized": "Edge a b-\u003eMaybe Int",
          "package": "igraph",
          "partial": "Weight",
          "signature": "Edge d a-\u003eMaybe Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:edgeWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "edges",
          "package": "igraph",
          "signature": "Graph d a -\u003e [Edge d a]",
          "source": "src/Data-IGraph-Internal.html#edges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "edges",
          "normalized": "Graph a b-\u003e[Edge a b]",
          "package": "igraph",
          "signature": "Graph d a-\u003e[Edge d a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.11. \u003ccode\u003eigraph_eigenvector_centrality\u003c/code\u003e &#8212; Eigenvector centrality of the vertices\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "eigenvectorCentrality",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e (Double, [(a, Double)])",
          "type": "function"
        },
        "index": {
          "description": "igraph eigenvector centrality Eigenvector centrality of the vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "eigenvectorCentrality",
          "normalized": "Graph a b-\u003eBool-\u003e(Double,[(b,Double)])",
          "package": "igraph",
          "partial": "Centrality",
          "signature": "Graph d a-\u003eBool-\u003e(Double,[(a,Double)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:eigenvectorCentrality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "emptyGraph",
          "package": "igraph",
          "signature": "Graph d a",
          "source": "src/Data-IGraph-Internal.html#emptyGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "emptyGraph",
          "package": "igraph",
          "partial": "Graph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:emptyGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.4. \u003ccode\u003eigraph_es_size\u003c/code\u003e &#8212; Returns the size of the edge selector.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "esSize",
          "package": "igraph",
          "signature": "Graph d a -\u003e EdgeSelector d a -\u003e Int",
          "source": "src/Data-IGraph.html#esSize",
          "type": "function"
        },
        "index": {
          "description": "igraph es size Returns the size of the edge selector",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "esSize",
          "normalized": "Graph a b-\u003eEdgeSelector a b-\u003eInt",
          "package": "igraph",
          "partial": "Size",
          "signature": "Graph d a-\u003eEdgeSelector d a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:esSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16.3. \u003ccode\u003eigraph_feedback_arc_set\u003c/code\u003e &#8212; Calculates a feedback arc set of the graph\n using different\n\u003c/p\u003e\u003cp\u003eA feedback arc set is a set of edges whose removal makes the graph acyclic.\n We are usually interested in minimum feedback arc sets, i.e. sets of edges\n whose total weight is minimal among all the feedback arc sets.\n\u003c/p\u003e\u003cp\u003eFor undirected graphs, the problem is simple: one has to find a maximum\n weight spanning tree and then remove all the edges not in the spanning tree.\n For directed graphs, this is an NP-hard problem, and various heuristics are\n usually used to find an approximate solution to the problem. This function\n implements a few of these heuristics.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "feedbackArcSet",
          "package": "igraph",
          "signature": "Graph d a -\u003e FASAlgorithm -\u003e [a]",
          "source": "src/Data-IGraph.html#feedbackArcSet",
          "type": "function"
        },
        "index": {
          "description": "igraph feedback arc set Calculates feedback arc set of the graph using different feedback arc set is set of edges whose removal makes the graph acyclic We are usually interested in minimum feedback arc sets i.e sets of edges whose total weight is minimal among all the feedback arc sets For undirected graphs the problem is simple one has to find maximum weight spanning tree and then remove all the edges not in the spanning tree For directed graphs this is an NP-hard problem and various heuristics are usually used to find an approximate solution to the problem This function implements few of these heuristics",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "feedbackArcSet",
          "normalized": "Graph a b-\u003eFASAlgorithm-\u003e[b]",
          "package": "igraph",
          "partial": "Arc Set",
          "signature": "Graph d a-\u003eFASAlgorithm-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:feedbackArcSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "fromList",
          "package": "igraph",
          "signature": "[(a, a)] -\u003e Graph d a",
          "source": "src/Data-IGraph-Internal.html#fromList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "fromList",
          "normalized": "[(a,a)]-\u003eGraph b a",
          "package": "igraph",
          "partial": "List",
          "signature": "[(a,a)]-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "fromListWeighted",
          "package": "igraph",
          "signature": "[(a, a, Int)] -\u003e Graph (Weighted d) a",
          "source": "src/Data-IGraph-Internal.html#fromListWeighted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "fromListWeighted",
          "normalized": "[(a,a,Int)]-\u003eGraph(Weighted b)a",
          "package": "igraph",
          "partial": "List Weighted",
          "signature": "[(a,a,Int)]-\u003eGraph(Weighted d)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:fromListWeighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.9. \u003ccode\u003eigraph_get_all_shortest_paths\u003c/code\u003e &#8212; Finds all shortest paths (geodesics)\n from a vertex to all other vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "getAllShortestPaths",
          "package": "igraph",
          "signature": "Graph d a-\u003e a-\u003e VertexSelector a-\u003e [[a]]",
          "type": "function"
        },
        "index": {
          "description": "igraph get all shortest paths Finds all shortest paths geodesics from vertex to all other vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "getAllShortestPaths",
          "normalized": "Graph a b-\u003eb-\u003eVertexSelector b-\u003e[[b]]",
          "package": "igraph",
          "partial": "All Shortest Paths",
          "signature": "Graph d a-\u003ea-\u003eVertexSelector a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:getAllShortestPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.10. \u003ccode\u003eigraph_get_all_shortest_paths_dijkstra\u003c/code\u003e &#8212; Finds all shortest paths\n (geodesics) from a vertex to all other vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "getAllShortestPathsDijkstra",
          "package": "igraph",
          "signature": "Graph (Weighted d) a-\u003e a-\u003e VertexSelector a-\u003e [[a]]",
          "type": "function"
        },
        "index": {
          "description": "igraph get all shortest paths dijkstra Finds all shortest paths geodesics from vertex to all other vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "getAllShortestPathsDijkstra",
          "normalized": "Graph(Weighted a)b-\u003eb-\u003eVertexSelector b-\u003e[[b]]",
          "package": "igraph",
          "partial": "All Shortest Paths Dijkstra",
          "signature": "Graph(Weighted d)a-\u003ea-\u003eVertexSelector a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:getAllShortestPathsDijkstra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.6. \u003ccode\u003eigraph_get_shortest_path\u003c/code\u003e &#8212; Shortest path from one vertex to another\n one.\n\u003c/p\u003e\u003cp\u003eCalculates and returns a single unweighted shortest path from a given vertex\n to another one. If there are more than one shortest paths between the two\n vertices, then an arbitrary one is returned.\n\u003c/p\u003e\u003cp\u003eThis function is a wrapper to igraph_get_shortest_paths(), for the special\n case when only one target vertex is considered.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "getShortestPath",
          "package": "igraph",
          "signature": "Graph d a -\u003e a -\u003e a -\u003e ([a], [Edge d a])",
          "source": "src/Data-IGraph.html#getShortestPath",
          "type": "function"
        },
        "index": {
          "description": "igraph get shortest path Shortest path from one vertex to another one Calculates and returns single unweighted shortest path from given vertex to another one If there are more than one shortest paths between the two vertices then an arbitrary one is returned This function is wrapper to igraph get shortest paths for the special case when only one target vertex is considered",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "getShortestPath",
          "normalized": "Graph a b-\u003eb-\u003eb-\u003e([b],[Edge a b])",
          "package": "igraph",
          "partial": "Shortest Path",
          "signature": "Graph d a-\u003ea-\u003ea-\u003e([a],[Edge d a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:getShortestPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.8. \u003ccode\u003eigraph_get_shortest_path_dijkstra\u003c/code\u003e &#8212; Weighted shortest path from one\n vertex to another one.\n\u003c/p\u003e\u003cp\u003eCalculates a single (positively) weighted shortest path from a single vertex\n to another one, using Dijkstra's algorithm.\n\u003c/p\u003e\u003cp\u003eThis function is a special case (and a wrapper) to\n igraph_get_shortest_paths_dijkstra().\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "getShortestPathDijkstra",
          "package": "igraph",
          "signature": "Graph (Weighted d) a -\u003e a -\u003e a -\u003e ([a], [Edge (Weighted d) a])",
          "source": "src/Data-IGraph.html#getShortestPathDijkstra",
          "type": "function"
        },
        "index": {
          "description": "igraph get shortest path dijkstra Weighted shortest path from one vertex to another one Calculates single positively weighted shortest path from single vertex to another one using Dijkstra algorithm This function is special case and wrapper to igraph get shortest paths dijkstra",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "getShortestPathDijkstra",
          "normalized": "Graph(Weighted a)b-\u003eb-\u003eb-\u003e([b],[Edge(Weighted a)b])",
          "package": "igraph",
          "partial": "Shortest Path Dijkstra",
          "signature": "Graph(Weighted d)a-\u003ea-\u003ea-\u003e([a],[Edge(Weighted d)a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:getShortestPathDijkstra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.5. \u003ccode\u003eigraph_get_shortest_paths\u003c/code\u003e &#8212; Calculates the shortest paths from/to one\n vertex.\n\u003c/p\u003e\u003cp\u003eIf there is more than one geodesic between two vertices, this function gives\n only one of them.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "getShortestPaths",
          "package": "igraph",
          "signature": "Graph d a-\u003e a-\u003e VertexSelector a-\u003e [([a], [Edge d a])]",
          "type": "function"
        },
        "index": {
          "description": "igraph get shortest paths Calculates the shortest paths from to one vertex If there is more than one geodesic between two vertices this function gives only one of them",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "getShortestPaths",
          "normalized": "Graph a b-\u003eb-\u003eVertexSelector b-\u003e[([b],[Edge a b])]",
          "package": "igraph",
          "partial": "Shortest Paths",
          "signature": "Graph d a-\u003ea-\u003eVertexSelector a-\u003e[([a],[Edge d a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:getShortestPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.7. \u003ccode\u003eigraph_get_shortest_paths_dijkstra\u003c/code\u003e &#8212; Calculates the weighted\n shortest paths from/to one vertex.\n\u003c/p\u003e\u003cp\u003eIf there is more than one path with the smallest weight between two vertices,\n this function gives only one of them.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "getShortestPathsDijkstra",
          "package": "igraph",
          "signature": "Graph (Weighted d) a-\u003e a-\u003e VertexSelector a-\u003e [([a], [Edge (Weighted d) a])]",
          "type": "function"
        },
        "index": {
          "description": "igraph get shortest paths dijkstra Calculates the weighted shortest paths from to one vertex If there is more than one path with the smallest weight between two vertices this function gives only one of them",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "getShortestPathsDijkstra",
          "normalized": "Graph(Weighted a)b-\u003eb-\u003eVertexSelector b-\u003e[([b],[Edge(Weighted a)b])]",
          "package": "igraph",
          "partial": "Shortest Paths Dijkstra",
          "signature": "Graph(Weighted d)a-\u003ea-\u003eVertexSelector a-\u003e[([a],[Edge(Weighted d)a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:getShortestPathsDijkstra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "getWeight",
          "package": "igraph",
          "signature": "Edge (Weighted d) a -\u003e Int",
          "source": "src/Data-IGraph-Internal.html#getWeight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "getWeight",
          "normalized": "Edge(Weighted a)b-\u003eInt",
          "package": "igraph",
          "partial": "Weight",
          "signature": "Edge(Weighted d)a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:getWeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.15. \u003ccode\u003eigraph_girth\u003c/code\u003e &#8212; The girth of a graph is the length of the shortest\n circle in it.\n\u003c/p\u003e\u003cp\u003eThe current implementation works for undirected graphs only, directed graphs\n are treated as undirected graphs. Loop edges and multiple edges are ignored.\n\u003c/p\u003e\u003cp\u003eIf the graph is a forest (ie. acyclic), then zero is returned.\n\u003c/p\u003e\u003cp\u003eThis implementation is based on Alon Itai and Michael Rodeh: Finding a\n minimum circuit in a graph Proceedings of the ninth annual ACM symposium on\n Theory of computing , 1-10, 1977. The first implementation of this function\n was done by Keith Briggs, thanks Keith.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "girth",
          "package": "igraph",
          "signature": "Graph d a-\u003e (Int, [a])",
          "type": "function"
        },
        "index": {
          "description": "igraph girth The girth of graph is the length of the shortest circle in it The current implementation works for undirected graphs only directed graphs are treated as undirected graphs Loop edges and multiple edges are ignored If the graph is forest ie acyclic then zero is returned This implementation is based on Alon Itai and Michael Rodeh Finding minimum circuit in graph Proceedings of the ninth annual ACM symposium on Theory of computing The first implementation of this function was done by Keith Briggs thanks Keith",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "girth",
          "normalized": "Graph a b-\u003e(Int,[b])",
          "package": "igraph",
          "signature": "Graph d a-\u003e(Int,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:girth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.12. \u003ccode\u003eigraph_hub_score\u003c/code\u003e &#8212; Kleinberg's hub scores\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "hubScore",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e (Double, [(a, Double)])",
          "type": "function"
        },
        "index": {
          "description": "igraph hub score Kleinberg hub scores",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "hubScore",
          "normalized": "Graph a b-\u003eBool-\u003e(Double,[(b,Double)])",
          "package": "igraph",
          "partial": "Score",
          "signature": "Graph d a-\u003eBool-\u003e(Double,[(a,Double)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:hubScore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.2. \u003ccode\u003eigraph_induced_subgraph\u003c/code\u003e &#8212; Creates a subgraph induced by the specified vertices.\n\u003c/p\u003e\u003cp\u003eThis function collects the specified vertices and all edges between them to a\n new graph. As the vertex ids in a graph always start with zero, this function\n very likely needs to reassign ids to the vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "inducedSubgraph",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e SubgraphImplementation -\u003e Graph d a",
          "source": "src/Data-IGraph.html#inducedSubgraph",
          "type": "function"
        },
        "index": {
          "description": "igraph induced subgraph Creates subgraph induced by the specified vertices This function collects the specified vertices and all edges between them to new graph As the vertex ids in graph always start with zero this function very likely needs to reassign ids to the vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "inducedSubgraph",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eSubgraphImplementation-\u003eGraph a b",
          "package": "igraph",
          "partial": "Subgraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eSubgraphImplementation-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:inducedSubgraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "insertEdge",
          "package": "igraph",
          "signature": "Edge d a -\u003e Graph d a -\u003e Graph d a",
          "source": "src/Data-IGraph-Internal.html#insertEdge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "insertEdge",
          "normalized": "Edge a b-\u003eGraph a b-\u003eGraph a b",
          "package": "igraph",
          "partial": "Edge",
          "signature": "Edge d a-\u003eGraph d a-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:insertEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e17.2. \u003ccode\u003eigraph_is_chordal\u003c/code\u003e &#8212; Decides whether a graph is chordal\n\u003c/p\u003e\u003cp\u003eA graph is chordal if each of its cycles of four or more nodes has a chord,\n which is an edge joining two nodes that are not adjacent in the cycle. An\n equivalent definition is that any chordless cycles have at most three nodes.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "isChordal",
          "package": "igraph",
          "signature": "Graph d a-\u003e (Bool, [Edge d a])",
          "type": "function"
        },
        "index": {
          "description": "igraph is chordal Decides whether graph is chordal graph is chordal if each of its cycles of four or more nodes has chord which is an edge joining two nodes that are not adjacent in the cycle An equivalent definition is that any chordless cycles have at most three nodes",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "isChordal",
          "normalized": "Graph a b-\u003e(Bool,[Edge a b])",
          "package": "igraph",
          "partial": "Chordal",
          "signature": "Graph d a-\u003e(Bool,[Edge d a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:isChordal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.6. \u003ccode\u003eigraph_is_connected\u003c/code\u003e &#8212; Decides whether the graph is (weakly or strongly) connected.\n\u003c/p\u003e\u003cp\u003eA graph with zero vertices (i.e. the null graph) is connected by definition.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "isConnected",
          "package": "igraph",
          "signature": "Graph d a -\u003e Connectedness -\u003e Bool",
          "source": "src/Data-IGraph.html#isConnected",
          "type": "function"
        },
        "index": {
          "description": "igraph is connected Decides whether the graph is weakly or strongly connected graph with zero vertices i.e the null graph is connected by definition",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "isConnected",
          "normalized": "Graph a b-\u003eConnectedness-\u003eBool",
          "package": "igraph",
          "partial": "Connected",
          "signature": "Graph d a-\u003eConnectedness-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:isConnected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16.1. \u003ccode\u003eigraph_is_dag\u003c/code\u003e &#8212; Checks whether a graph is a directed acyclic graph\n (DAG) or not.\n\u003c/p\u003e\u003cp\u003eA directed acyclic graph (DAG) is a directed graph with no cycles.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "isDAG",
          "package": "igraph",
          "signature": "Graph d a -\u003e Bool",
          "source": "src/Data-IGraph.html#isDAG",
          "type": "function"
        },
        "index": {
          "description": "igraph is dag Checks whether graph is directed acyclic graph DAG or not directed acyclic graph DAG is directed graph with no cycles",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "isDAG",
          "normalized": "Graph a b-\u003eBool",
          "package": "igraph",
          "partial": "DAG",
          "signature": "Graph d a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:isDAG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "isDirected",
          "package": "igraph",
          "signature": "Graph d a -\u003e Bool",
          "source": "src/Data-IGraph-Types.html#isDirected",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "isDirected",
          "normalized": "Graph a b-\u003eBool",
          "package": "igraph",
          "partial": "Directed",
          "signature": "Graph d a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:isDirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "isWeighted",
          "package": "igraph",
          "signature": "Graph d a -\u003e Bool",
          "source": "src/Data-IGraph-Types.html#isWeighted",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "isWeighted",
          "normalized": "Graph a b-\u003eBool",
          "package": "igraph",
          "partial": "Weighted",
          "signature": "Graph d a-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:isWeighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e12.1. \u003ccode\u003eigraph_laplacian\u003c/code\u003e &#8212; Returns the Laplacian matrix of a graph\n\u003c/p\u003e\u003cp\u003eThe graph Laplacian matrix is similar to an adjacency matrix but contains\n -1's instead of 1's and the vertex degrees are included in the diagonal. So\n the result for edge i--j is -1 if i!=j and is equal to the degree of vertex i\n if i==j. igraph_laplacian will work on a directed graph; in this case, the\n diagonal will contain the out-degrees. Loop edges will be ignored.\n\u003c/p\u003e\u003cp\u003eThe normalized version of the Laplacian matrix has 1 in the diagonal and\n -1/sqrt(d[i]d[j]) if there is an edge from i to j.\n\u003c/p\u003e\u003cp\u003eThe first version of this function was written by Vincent Matossian.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "laplacian",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e [[Double]]",
          "type": "function"
        },
        "index": {
          "description": "igraph laplacian Returns the Laplacian matrix of graph The graph Laplacian matrix is similar to an adjacency matrix but contains instead of and the vertex degrees are included in the diagonal So the result for edge i--j is if and is equal to the degree of vertex if igraph laplacian will work on directed graph in this case the diagonal will contain the out-degrees Loop edges will be ignored The normalized version of the Laplacian matrix has in the diagonal and sqrt if there is an edge from to The first version of this function was written by Vincent Matossian",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "laplacian",
          "normalized": "Graph a b-\u003eBool-\u003e[[Double]]",
          "package": "igraph",
          "signature": "Graph d a-\u003eBool-\u003e[[Double]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:laplacian"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.9. \u003ccode\u003eigraph_maxdegree\u003c/code\u003e &#8212; Calculate the maximum degree in a graph (or set\n of vertices).\n\u003c/p\u003e\u003cp\u003eThe largest in-, out- or total degree of the specified vertices is\n calculated.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "maxdegree",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Bool-\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "igraph maxdegree Calculate the maximum degree in graph or set of vertices The largest in out or total degree of the specified vertices is calculated",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "maxdegree",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eBool-\u003eInt",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eBool-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:maxdegree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e17.1. \u003ccode\u003eigraph_maximum_cardinality_search\u003c/code\u003e &#8212; Maximum cardinality search\n\u003c/p\u003e\u003cp\u003eThis function implements the maximum cardinality search algorithm discussed\n in Robert E Tarjan and Mihalis Yannakakis: Simple linear-time algorithms to\n test chordality of graphs, test acyclicity of hypergraphs, and selectively\n reduce acyclic hypergraphs. SIAM Journal of Computation 13, 566--579, 1984.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "maximumCardinalitySearch",
          "package": "igraph",
          "signature": "Graph d a -\u003e [(Int, a)]",
          "source": "src/Data-IGraph.html#maximumCardinalitySearch",
          "type": "function"
        },
        "index": {
          "description": "igraph maximum cardinality search Maximum cardinality search This function implements the maximum cardinality search algorithm discussed in Robert Tarjan and Mihalis Yannakakis Simple linear-time algorithms to test chordality of graphs test acyclicity of hypergraphs and selectively reduce acyclic hypergraphs SIAM Journal of Computation",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "maximumCardinalitySearch",
          "normalized": "Graph a b-\u003e[(Int,b)]",
          "package": "igraph",
          "partial": "Cardinality Search",
          "signature": "Graph d a-\u003e[(Int,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:maximumCardinalitySearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "member",
          "package": "igraph",
          "signature": "a -\u003e Graph d a -\u003e Bool",
          "source": "src/Data-IGraph-Internal.html#member",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "member",
          "normalized": "a-\u003eGraph b a-\u003eBool",
          "package": "igraph",
          "signature": "a-\u003eGraph d a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e9.1. \u003ccode\u003eigraph_minimum_spanning_tree\u003c/code\u003e &#8212; Calculates one minimum spanning tree of a graph.\n\u003c/p\u003e\u003cp\u003eIf the graph has more minimum spanning trees (this is always the case, except\n if it is a forest) this implementation returns only the same one.\n\u003c/p\u003e\u003cp\u003eDirected graphs are considered as undirected for this computation.\n\u003c/p\u003e\u003cp\u003eIf the graph is not connected then its minimum spanning forest is returned.\n This is the set of the minimum spanning trees of each component.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "minimumSpanningTree",
          "package": "igraph",
          "signature": "Graph d a -\u003e [Edge d a]",
          "source": "src/Data-IGraph.html#minimumSpanningTree",
          "type": "function"
        },
        "index": {
          "description": "igraph minimum spanning tree Calculates one minimum spanning tree of graph If the graph has more minimum spanning trees this is always the case except if it is forest this implementation returns only the same one Directed graphs are considered as undirected for this computation If the graph is not connected then its minimum spanning forest is returned This is the set of the minimum spanning trees of each component",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "minimumSpanningTree",
          "normalized": "Graph a b-\u003e[Edge a b]",
          "package": "igraph",
          "partial": "Spanning Tree",
          "signature": "Graph d a-\u003e[Edge d a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:minimumSpanningTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e9.3. \u003ccode\u003eigraph_minimum_spanning_tree_prim\u003c/code\u003e &#8212; Calculates one minimum\n spanning tree of a weighted graph.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "minimumSpanningTreePrim",
          "package": "igraph",
          "signature": "Graph (Weighted d) a -\u003e Graph (Weighted d) a",
          "source": "src/Data-IGraph.html#minimumSpanningTreePrim",
          "type": "function"
        },
        "index": {
          "description": "igraph minimum spanning tree prim Calculates one minimum spanning tree of weighted graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "minimumSpanningTreePrim",
          "normalized": "Graph(Weighted a)b-\u003eGraph(Weighted a)b",
          "package": "igraph",
          "partial": "Spanning Tree Prim",
          "signature": "Graph(Weighted d)a-\u003eGraph(Weighted d)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:minimumSpanningTreePrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e9.2. \u003ccode\u003eigraph_minimum_spanning_tree_unweighted\u003c/code\u003e &#8212; Calculates one minimum\n spanning tree of an unweighted graph.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "minimumSpanningTreeUnweighted",
          "package": "igraph",
          "signature": "Graph d a -\u003e Graph d a",
          "source": "src/Data-IGraph.html#minimumSpanningTreeUnweighted",
          "type": "function"
        },
        "index": {
          "description": "igraph minimum spanning tree unweighted Calculates one minimum spanning tree of an unweighted graph",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "minimumSpanningTreeUnweighted",
          "normalized": "Graph a b-\u003eGraph a b",
          "package": "igraph",
          "partial": "Spanning Tree Unweighted",
          "signature": "Graph d a-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:minimumSpanningTreeUnweighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "neighbours",
          "package": "igraph",
          "signature": "a -\u003e Graph d a -\u003e [a]",
          "source": "src/Data-IGraph-Internal.html#neighbours",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "neighbours",
          "normalized": "a-\u003eGraph b a-\u003e[a]",
          "package": "igraph",
          "signature": "a-\u003eGraph d a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:neighbours"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "nodes",
          "package": "igraph",
          "signature": "Graph d a -\u003e [a]",
          "source": "src/Data-IGraph-Internal.html#nodes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "nodes",
          "normalized": "Graph a b-\u003e[b]",
          "package": "igraph",
          "signature": "Graph d a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:nodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "numberOfEdges",
          "package": "igraph",
          "signature": "Graph d a -\u003e Int",
          "source": "src/Data-IGraph-Internal.html#numberOfEdges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "numberOfEdges",
          "normalized": "Graph a b-\u003eInt",
          "package": "igraph",
          "partial": "Of Edges",
          "signature": "Graph d a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:numberOfEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "numberOfNodes",
          "package": "igraph",
          "signature": "Graph d a -\u003e Int",
          "source": "src/Data-IGraph-Internal.html#numberOfNodes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "numberOfNodes",
          "normalized": "Graph a b-\u003eInt",
          "package": "igraph",
          "partial": "Of Nodes",
          "signature": "Graph d a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:numberOfNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.4. \u003ccode\u003eigraph_pagerank\u003c/code\u003e &#8212; Calculates the Google PageRank for the specified vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "pagerank",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Double-\u003e (Double, [(a, Double)])",
          "type": "function"
        },
        "index": {
          "description": "igraph pagerank Calculates the Google PageRank for the specified vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "pagerank",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eDouble-\u003e(Double,[(b,Double)])",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eDouble-\u003e(Double,[(a,Double)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:pagerank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.12. \u003ccode\u003eigraph_path_length_hist\u003c/code\u003e &#8212; Create a histogram of all shortest path lengths.\n\u003c/p\u003e\u003cp\u003eThis function calculates a histogram, by calculating the shortest path length\n between each pair of vertices. For directed graphs both directions might be\n considered and then every pair of vertices appears twice in the histogram.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "pathLengthHist",
          "package": "igraph",
          "signature": "Graph d a-\u003e Bool-\u003e ([Double], Double)",
          "type": "function"
        },
        "index": {
          "description": "igraph path length hist Create histogram of all shortest path lengths This function calculates histogram by calculating the shortest path length between each pair of vertices For directed graphs both directions might be considered and then every pair of vertices appears twice in the histogram",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "pathLengthHist",
          "normalized": "Graph a b-\u003eBool-\u003e([Double],Double)",
          "package": "igraph",
          "partial": "Length Hist",
          "signature": "Graph d a-\u003eBool-\u003e([Double],Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:pathLengthHist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.6. \u003ccode\u003eigraph_personalized_pagerank\u003c/code\u003e &#8212; Calculates the personalized Google PageRank for the specified vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "personalizedPagerank",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Double-\u003e (Double, [(a, Double)])",
          "type": "function"
        },
        "index": {
          "description": "igraph personalized pagerank Calculates the personalized Google PageRank for the specified vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "personalizedPagerank",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eDouble-\u003e(Double,[(b,Double)])",
          "package": "igraph",
          "partial": "Pagerank",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eDouble-\u003e(Double,[(a,Double)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:personalizedPagerank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.7. \u003ccode\u003eigraph_personalized_pagerank_vs\u003c/code\u003e &#8212; Calculates the personalized\n Google PageRank for the specified vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "personalizedPagerankVs",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Double-\u003e VertexSelector a-\u003e (Double, [(a, Double)])",
          "type": "function"
        },
        "index": {
          "description": "igraph personalized pagerank vs Calculates the personalized Google PageRank for the specified vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "personalizedPagerankVs",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eDouble-\u003eVertexSelector b-\u003e(Double,[(b,Double)])",
          "package": "igraph",
          "partial": "Pagerank Vs",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eDouble-\u003eVertexSelector a-\u003e(Double,[(a,Double)])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:personalizedPagerankVs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.17. \u003ccode\u003eigraph_radius\u003c/code\u003e &#8212; Radius of a graph\n\u003c/p\u003e\u003cp\u003eThe radius of a graph is the defined as the minimum eccentricity of its\n vertices, see igraph_eccentricity().\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "radius",
          "package": "igraph",
          "signature": "Graph d a -\u003e Int",
          "source": "src/Data-IGraph.html#radius",
          "type": "function"
        },
        "index": {
          "description": "igraph radius Radius of graph The radius of graph is the defined as the minimum eccentricity of its vertices see igraph eccentricity",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "radius",
          "normalized": "Graph a b-\u003eInt",
          "package": "igraph",
          "signature": "Graph d a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:radius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse graph direction. This simply changes the associated\n \u003ccode\u003eigraph_neimode_t\u003c/code\u003e of the graph (\u003ccode\u003eIGRAPH_OUT\u003c/code\u003e to \u003ccode\u003eIGRAPH_IN\u003c/code\u003e, \u003ccode\u003eIGRAPH_IN\u003c/code\u003e to\n \u003ccode\u003eIGRAPH_OUT\u003c/code\u003e, other to \u003ccode\u003eIGRAPH_OUT\u003c/code\u003e). O(1)\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "reverseGraphDirection",
          "package": "igraph",
          "signature": "Graph d a -\u003e Graph d a",
          "source": "src/Data-IGraph-Internal.html#reverseGraphDirection",
          "type": "function"
        },
        "index": {
          "description": "Reverse graph direction This simply changes the associated igraph neimode of the graph IGRAPH OUT to IGRAPH IN IGRAPH IN to IGRAPH OUT other to IGRAPH OUT",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "reverseGraphDirection",
          "normalized": "Graph a b-\u003eGraph a b",
          "package": "igraph",
          "partial": "Graph Direction",
          "signature": "Graph d a-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:reverseGraphDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "selectedEdges",
          "package": "igraph",
          "signature": "Graph d a -\u003e EdgeSelector d a -\u003e [Edge d a]",
          "source": "src/Data-IGraph.html#selectedEdges",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "selectedEdges",
          "normalized": "Graph a b-\u003eEdgeSelector a b-\u003e[Edge a b]",
          "package": "igraph",
          "partial": "Edges",
          "signature": "Graph d a-\u003eEdgeSelector d a-\u003e[Edge d a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:selectedEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "selectedVertices",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e [a]",
          "source": "src/Data-IGraph.html#selectedVertices",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "selectedVertices",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003e[b]",
          "package": "igraph",
          "partial": "Vertices",
          "signature": "Graph d a-\u003eVertexSelector a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:selectedVertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.1. \u003ccode\u003eigraph_shortest_paths\u003c/code\u003e &#8212; The length of the shortest paths between\n vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "shortestPaths",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e VertexSelector a -\u003e Map (a, a) (Maybe Int)",
          "source": "src/Data-IGraph.html#shortestPaths",
          "type": "function"
        },
        "index": {
          "description": "igraph shortest paths The length of the shortest paths between vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "shortestPaths",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eVertexSelector b-\u003eMap(b,b)(Maybe Int)",
          "package": "igraph",
          "partial": "Paths",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eVertexSelector a-\u003eMap(a,a)(Maybe Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:shortestPaths"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.3. \u003ccode\u003eigraph_shortest_paths_bellman_ford\u003c/code\u003e &#8212; Weighted shortest paths from some\n sources allowing negative weights.\n\u003c/p\u003e\u003cp\u003eThis function is the Bellman-Ford algorithm to find the weighted shortest\n paths to all vertices from a single source. (It is run independently for the\n given sources.). If there are no negative weights, you are better off with\n igraph_shortest_paths_dijkstra() .\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "shortestPathsBellmanFord",
          "package": "igraph",
          "signature": "Graph (Weighted d) a -\u003e VertexSelector a -\u003e VertexSelector a -\u003e Map (a, a) (Maybe Int)",
          "source": "src/Data-IGraph.html#shortestPathsBellmanFord",
          "type": "function"
        },
        "index": {
          "description": "igraph shortest paths bellman ford Weighted shortest paths from some sources allowing negative weights This function is the Bellman-Ford algorithm to find the weighted shortest paths to all vertices from single source It is run independently for the given sources If there are no negative weights you are better off with igraph shortest paths dijkstra",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "shortestPathsBellmanFord",
          "normalized": "Graph(Weighted a)b-\u003eVertexSelector b-\u003eVertexSelector b-\u003eMap(b,b)(Maybe Int)",
          "package": "igraph",
          "partial": "Paths Bellman Ford",
          "signature": "Graph(Weighted d)a-\u003eVertexSelector a-\u003eVertexSelector a-\u003eMap(a,a)(Maybe Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:shortestPathsBellmanFord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.2. \u003ccode\u003eigraph_shortest_paths_dijkstra\u003c/code\u003e &#8212; Weighted shortest paths from some\n sources.\n\u003c/p\u003e\u003cp\u003eThis function is Dijkstra's algorithm to find the weighted shortest paths to\n all vertices from a single source. (It is run independently for the given\n sources.) It uses a binary heap for efficient implementation.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "shortestPathsDijkstra",
          "package": "igraph",
          "signature": "Graph (Weighted d) a -\u003e VertexSelector a -\u003e VertexSelector a -\u003e Map (a, a) (Maybe Int)",
          "source": "src/Data-IGraph.html#shortestPathsDijkstra",
          "type": "function"
        },
        "index": {
          "description": "igraph shortest paths dijkstra Weighted shortest paths from some sources This function is Dijkstra algorithm to find the weighted shortest paths to all vertices from single source It is run independently for the given sources It uses binary heap for efficient implementation",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "shortestPathsDijkstra",
          "normalized": "Graph(Weighted a)b-\u003eVertexSelector b-\u003eVertexSelector b-\u003eMap(b,b)(Maybe Int)",
          "package": "igraph",
          "partial": "Paths Dijkstra",
          "signature": "Graph(Weighted d)a-\u003eVertexSelector a-\u003eVertexSelector a-\u003eMap(a,a)(Maybe Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:shortestPathsDijkstra"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2.4. \u003ccode\u003eigraph_shortest_paths_johnson\u003c/code\u003e &#8212; Calculate shortest paths from some\n sources using Johnson's algorithm.\n\u003c/p\u003e\u003cp\u003eSee Wikipedia at http:\u003cem/\u003een.wikipedia.org\u003cem\u003ewiki\u003c/em\u003eJohnson's_algorithm for\n Johnson's algorithm. This algorithm works even if the graph contains negative\n edge weights, and it is worth using it if we calculate the shortest paths\n from many sources.\n\u003c/p\u003e\u003cp\u003eIf no edge weights are supplied, then the unweighted version,\n igraph_shortest_paths() is called.\n\u003c/p\u003e\u003cp\u003eIf all the supplied edge weights are non-negative, then Dijkstra's algorithm\n is used by calling igraph_shortest_paths_dijkstra().\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "shortestPathsJohnson",
          "package": "igraph",
          "signature": "Graph (Weighted d) a -\u003e VertexSelector a -\u003e VertexSelector a -\u003e Map (a, a) (Maybe Int)",
          "source": "src/Data-IGraph.html#shortestPathsJohnson",
          "type": "function"
        },
        "index": {
          "description": "igraph shortest paths johnson Calculate shortest paths from some sources using Johnson algorithm See Wikipedia at http en.wikipedia.org wiki Johnson algorithm for Johnson algorithm This algorithm works even if the graph contains negative edge weights and it is worth using it if we calculate the shortest paths from many sources If no edge weights are supplied then the unweighted version igraph shortest paths is called If all the supplied edge weights are non-negative then Dijkstra algorithm is used by calling igraph shortest paths dijkstra",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "shortestPathsJohnson",
          "normalized": "Graph(Weighted a)b-\u003eVertexSelector b-\u003eVertexSelector b-\u003eMap(b,b)(Maybe Int)",
          "package": "igraph",
          "partial": "Paths Johnson",
          "signature": "Graph(Weighted d)a-\u003eVertexSelector a-\u003eVertexSelector a-\u003eMap(a,a)(Maybe Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:shortestPathsJohnson"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.6. \u003ccode\u003eigraph_similarity_dice\u003c/code\u003e &#8212; Dice similarity coefficient.\n\u003c/p\u003e\u003cp\u003eThe Dice similarity coefficient of two vertices is twice the number of\n common neighbors divided by the sum of the degrees of the vertices. This\n function calculates the pairwise Dice similarities for some (or all) of the\n vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "similarityDice",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Bool-\u003e [(a, [(a, Double)])]",
          "type": "function"
        },
        "index": {
          "description": "igraph similarity dice Dice similarity coefficient The Dice similarity coefficient of two vertices is twice the number of common neighbors divided by the sum of the degrees of the vertices This function calculates the pairwise Dice similarities for some or all of the vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "similarityDice",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eBool-\u003e[(b,[(b,Double)])]",
          "package": "igraph",
          "partial": "Dice",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eBool-\u003e[(a,[(a,Double)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:similarityDice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.8. \u003ccode\u003eigraph_similarity_dice_es\u003c/code\u003e &#8212; Dice similarity coefficient for a given\n edge selector.\n\u003c/p\u003e\u003cp\u003eThe Dice similarity coefficient of two vertices is twice the number of common\n neighbors divided by the sum of the degrees of the vertices. This function\n calculates the pairwise Dice similarities for the endpoints of edges in a\n given edge selector.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "similarityDiceEs",
          "package": "igraph",
          "signature": "Graph d a-\u003e EdgeSelector d a-\u003e Bool-\u003e [(Edge d a, Double)]",
          "type": "function"
        },
        "index": {
          "description": "igraph similarity dice es Dice similarity coefficient for given edge selector The Dice similarity coefficient of two vertices is twice the number of common neighbors divided by the sum of the degrees of the vertices This function calculates the pairwise Dice similarities for the endpoints of edges in given edge selector",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "similarityDiceEs",
          "normalized": "Graph a b-\u003eEdgeSelector a b-\u003eBool-\u003e[(Edge a b,Double)]",
          "package": "igraph",
          "partial": "Dice Es",
          "signature": "Graph d a-\u003eEdgeSelector d a-\u003eBool-\u003e[(Edge d a,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:similarityDiceEs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.7. \u003ccode\u003eigraph_similarity_dice_pairs\u003c/code\u003e &#8212; Dice similarity coefficient for given\n vertex pairs.\n\u003c/p\u003e\u003cp\u003eThe Dice similarity coefficient of two vertices is twice the number of\n common neighbors divided by the sum of the degrees of the vertices. This\n function calculates the pairwise Dice similarities for a list of vertex\n pairs.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "similarityDicePairs",
          "package": "igraph",
          "signature": "Graph d a-\u003e [Edge d a]-\u003e Bool-\u003e [(Edge d a, Double)]",
          "type": "function"
        },
        "index": {
          "description": "igraph similarity dice pairs Dice similarity coefficient for given vertex pairs The Dice similarity coefficient of two vertices is twice the number of common neighbors divided by the sum of the degrees of the vertices This function calculates the pairwise Dice similarities for list of vertex pairs",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "similarityDicePairs",
          "normalized": "Graph a b-\u003e[Edge a b]-\u003eBool-\u003e[(Edge a b,Double)]",
          "package": "igraph",
          "partial": "Dice Pairs",
          "signature": "Graph d a-\u003e[Edge d a]-\u003eBool-\u003e[(Edge d a,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:similarityDicePairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.9. \u003ccode\u003eigraph_similarity_inverse_log_weighted\u003c/code\u003e &#8212; Vertex similarity based on\n the inverse logarithm of vertex degrees.\n\u003c/p\u003e\u003cp\u003eThe inverse log-weighted similarity of two vertices is the number of their\n common neighbors, weighted by the inverse logarithm of their degrees. It is\n based on the assumption that two vertices should be considered more similar\n if they share a low-degree common neighbor, since high-degree common\n neighbors are more likely to appear even by pure chance.\n\u003c/p\u003e\u003cp\u003eIsolated vertices will have zero similarity to any other vertex.\n Self-similarities are not calculated.\n\u003c/p\u003e\u003cp\u003eSee the following paper for more details: Lada A. Adamic and Eytan Adar:\n Friends and neighbors on the Web. Social Networks, 25(3):211-230, 2003.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "similarityInverseLogWeighted",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e [(a, [(a, Double)])]",
          "source": "src/Data-IGraph.html#similarityInverseLogWeighted",
          "type": "function"
        },
        "index": {
          "description": "igraph similarity inverse log weighted Vertex similarity based on the inverse logarithm of vertex degrees The inverse log-weighted similarity of two vertices is the number of their common neighbors weighted by the inverse logarithm of their degrees It is based on the assumption that two vertices should be considered more similar if they share low-degree common neighbor since high-degree common neighbors are more likely to appear even by pure chance Isolated vertices will have zero similarity to any other vertex Self-similarities are not calculated See the following paper for more details Lada Adamic and Eytan Adar Friends and neighbors on the Web Social Networks",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "similarityInverseLogWeighted",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003e[(b,[(b,Double)])]",
          "package": "igraph",
          "partial": "Inverse Log Weighted",
          "signature": "Graph d a-\u003eVertexSelector a-\u003e[(a,[(a,Double)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:similarityInverseLogWeighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.3. \u003ccode\u003eigraph_similarity_jaccard\u003c/code\u003e &#8212; Jaccard similarity coefficient for the\n given vertices.\n\u003c/p\u003e\u003cp\u003eThe Jaccard similarity coefficient of two vertices is the number of common\n neighbors divided by the number of vertices that are neighbors of at least\n one of the two vertices being considered. This function calculates the\n pairwise Jaccard similarities for some (or all) of the vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "similarityJaccard",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Bool-\u003e [(a, [(a, Double)])]",
          "type": "function"
        },
        "index": {
          "description": "igraph similarity jaccard Jaccard similarity coefficient for the given vertices The Jaccard similarity coefficient of two vertices is the number of common neighbors divided by the number of vertices that are neighbors of at least one of the two vertices being considered This function calculates the pairwise Jaccard similarities for some or all of the vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "similarityJaccard",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eBool-\u003e[(b,[(b,Double)])]",
          "package": "igraph",
          "partial": "Jaccard",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eBool-\u003e[(a,[(a,Double)])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:similarityJaccard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.5. \u003ccode\u003eigraph_similarity_jaccard_es\u003c/code\u003e &#8212; Jaccard similarity coefficient for a\n given edge selector.\n\u003c/p\u003e\u003cp\u003eThe Jaccard similarity coefficient of two vertices is the number of common\n neighbors divided by the number of vertices that are neighbors of at least\n one of the two vertices being considered. This function calculates the\n pairwise Jaccard similarities for the endpoints of edges in a given edge\n selector.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "similarityJaccardEs",
          "package": "igraph",
          "signature": "Graph d a-\u003e EdgeSelector d a-\u003e Bool-\u003e [(Edge d a, Double)]",
          "type": "function"
        },
        "index": {
          "description": "igraph similarity jaccard es Jaccard similarity coefficient for given edge selector The Jaccard similarity coefficient of two vertices is the number of common neighbors divided by the number of vertices that are neighbors of at least one of the two vertices being considered This function calculates the pairwise Jaccard similarities for the endpoints of edges in given edge selector",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "similarityJaccardEs",
          "normalized": "Graph a b-\u003eEdgeSelector a b-\u003eBool-\u003e[(Edge a b,Double)]",
          "package": "igraph",
          "partial": "Jaccard Es",
          "signature": "Graph d a-\u003eEdgeSelector d a-\u003eBool-\u003e[(Edge d a,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:similarityJaccardEs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e8.4. \u003ccode\u003eigraph_similarity_jaccard_pairs\u003c/code\u003e &#8212; Jaccard similarity coefficient for\n given vertex pairs.\n\u003c/p\u003e\u003cp\u003eThe Jaccard similarity coefficient of two vertices is the number of common\n neighbors divided by the number of vertices that are neighbors of at least\n one of the two vertices being considered. This function calculates the\n pairwise Jaccard similarities for a list of vertex pairs.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "similarityJaccardPairs",
          "package": "igraph",
          "signature": "Graph d a-\u003e [Edge d a]-\u003e Bool-\u003e [(Edge d a, Double)]",
          "type": "function"
        },
        "index": {
          "description": "igraph similarity jaccard pairs Jaccard similarity coefficient for given vertex pairs The Jaccard similarity coefficient of two vertices is the number of common neighbors divided by the number of vertices that are neighbors of at least one of the two vertices being considered This function calculates the pairwise Jaccard similarities for list of vertex pairs",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "similarityJaccardPairs",
          "normalized": "Graph a b-\u003e[Edge a b]-\u003eBool-\u003e[(Edge a b,Double)]",
          "package": "igraph",
          "partial": "Jaccard Pairs",
          "signature": "Graph d a-\u003e[Edge d a]-\u003eBool-\u003e[(Edge d a,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:similarityJaccardPairs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e5.10. \u003ccode\u003eigraph_strength\u003c/code\u003e &#8212; Strength of the vertices, weighted vertex degree\n in other words.\n\u003c/p\u003e\u003cp\u003eIn a weighted network the strength of a vertex is the sum of the weights of\n all incident edges. In a non-weighted network this is exactly the vertex\n degree.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "strength",
          "package": "igraph",
          "signature": "Graph d a-\u003e VertexSelector a-\u003e Bool-\u003e Map a Int",
          "type": "function"
        },
        "index": {
          "description": "igraph strength Strength of the vertices weighted vertex degree in other words In weighted network the strength of vertex is the sum of the weights of all incident edges In non-weighted network this is exactly the vertex degree",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "strength",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eBool-\u003eMap b Int",
          "package": "igraph",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eBool-\u003eMap a Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:strength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.1. \u003ccode\u003eigraph_subcomponent\u003c/code\u003e &#8212; The vertices in the same component as a given vertex.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "subcomponent",
          "package": "igraph",
          "signature": "Graph d a -\u003e a -\u003e [a]",
          "source": "src/Data-IGraph.html#subcomponent",
          "type": "function"
        },
        "index": {
          "description": "igraph subcomponent The vertices in the same component as given vertex",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "subcomponent",
          "normalized": "Graph a b-\u003eb-\u003e[b]",
          "package": "igraph",
          "signature": "Graph d a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:subcomponent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4.3. \u003ccode\u003eigraph_subgraph_edges\u003c/code\u003e &#8212; Creates a subgraph with the specified edges and their endpoints.\n\u003c/p\u003e\u003cp\u003eThis function collects the specified edges and their endpoints to a new\n graph. As the vertex ids in a graph always start with zero, this function\n very likely needs to reassign ids to the vertices.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "subgraphEdges",
          "package": "igraph",
          "signature": "Graph d a -\u003e EdgeSelector d a -\u003e Graph d a",
          "source": "src/Data-IGraph.html#subgraphEdges",
          "type": "function"
        },
        "index": {
          "description": "igraph subgraph edges Creates subgraph with the specified edges and their endpoints This function collects the specified edges and their endpoints to new graph As the vertex ids in graph always start with zero this function very likely needs to reassign ids to the vertices",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "subgraphEdges",
          "normalized": "Graph a b-\u003eEdgeSelector a b-\u003eGraph a b",
          "package": "igraph",
          "partial": "Edges",
          "signature": "Graph d a-\u003eEdgeSelector d a-\u003eGraph d a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:subgraphEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "toDirected",
          "package": "igraph",
          "signature": "Graph u a -\u003e Graph (ToDirected u) a",
          "source": "src/Data-IGraph-Internal.html#toDirected",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "toDirected",
          "normalized": "Graph a b-\u003eGraph(ToDirected a)b",
          "package": "igraph",
          "partial": "Directed",
          "signature": "Graph u a-\u003eGraph(ToDirected u)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:toDirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "toEdge",
          "package": "igraph",
          "signature": "a -\u003e a -\u003e Edge d a",
          "source": "src/Data-IGraph-Types.html#toEdge",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "toEdge",
          "normalized": "a-\u003ea-\u003eEdge b a",
          "package": "igraph",
          "partial": "Edge",
          "signature": "a-\u003ea-\u003eEdge d a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:toEdge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "toEdgeWeighted",
          "package": "igraph",
          "signature": "a -\u003e a -\u003e Int -\u003e Edge (Weighted d) a",
          "source": "src/Data-IGraph-Internal.html#toEdgeWeighted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "toEdgeWeighted",
          "normalized": "a-\u003ea-\u003eInt-\u003eEdge(Weighted b)a",
          "package": "igraph",
          "partial": "Edge Weighted",
          "signature": "a-\u003ea-\u003eInt-\u003eEdge(Weighted d)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:toEdgeWeighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IGraph",
          "name": "toUndirected",
          "package": "igraph",
          "signature": "Graph d a -\u003e Graph (ToUndirected d) a",
          "source": "src/Data-IGraph-Internal.html#toUndirected",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "toUndirected",
          "normalized": "Graph a b-\u003eGraph(ToUndirected a)b",
          "package": "igraph",
          "partial": "Undirected",
          "signature": "Graph d a-\u003eGraph(ToUndirected d)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:toUndirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e16.2. \u003ccode\u003eigraph_topological_sorting\u003c/code\u003e &#8212; Calculate a possible topological sorting\n of the graph.\n\u003c/p\u003e\u003cp\u003eA topological sorting of a directed acyclic graph is a linear ordering of its\n nodes where each node comes before all nodes to which it has edges. Every DAG\n has at least one topological sort, and may have many. This function returns a\n possible topological sort among them. If the graph is not acyclic (it has at\n least one cycle), a partial topological sort is returned and a warning is\n issued.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "topologicalSorting",
          "package": "igraph",
          "signature": "Graph d a -\u003e [a]",
          "source": "src/Data-IGraph.html#topologicalSorting",
          "type": "function"
        },
        "index": {
          "description": "igraph topological sorting Calculate possible topological sorting of the graph topological sorting of directed acyclic graph is linear ordering of its nodes where each node comes before all nodes to which it has edges Every DAG has at least one topological sort and may have many This function returns possible topological sort among them If the graph is not acyclic it has at least one cycle partial topological sort is returned and warning is issued",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "topologicalSorting",
          "normalized": "Graph a b-\u003e[b]",
          "package": "igraph",
          "partial": "Sorting",
          "signature": "Graph d a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:topologicalSorting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e10.3. \u003ccode\u003eigraph_transitivity_avglocal_undirected\u003c/code\u003e &#8212; Average local transitivity\n (clustering coefficient).\n\u003c/p\u003e\u003cp\u003eThe transitivity measures the probability that two neighbors of a vertex are\n connected. In case of the average local transitivity, this probability is\n calculated for each vertex and then the average is taken. Vertices with less\n than two neighbors require special treatment, they will either be left out\n from the calculation or they will be considered as having zero transitivity,\n depending on the mode argument.\n\u003c/p\u003e\u003cp\u003eNote that this measure is different from the global transitivity measure (see\n `igraph_transitivity_undirected()` ) as it simply takes the average local\n transitivity across the whole network. See the following reference for more\n details:\n\u003c/p\u003e\u003cp\u003eD. J. Watts and S. Strogatz: Collective dynamics of small-world networks.\n Nature 393(6684):440-442 (1998).\n\u003c/p\u003e\u003cp\u003eClustering coefficient is an alternative name for transitivity.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "transitivityAvglocalUndirected",
          "package": "igraph",
          "signature": "Graph d a -\u003e Double",
          "source": "src/Data-IGraph.html#transitivityAvglocalUndirected",
          "type": "function"
        },
        "index": {
          "description": "igraph transitivity avglocal undirected Average local transitivity clustering coefficient The transitivity measures the probability that two neighbors of vertex are connected In case of the average local transitivity this probability is calculated for each vertex and then the average is taken Vertices with less than two neighbors require special treatment they will either be left out from the calculation or they will be considered as having zero transitivity depending on the mode argument Note that this measure is different from the global transitivity measure see igraph transitivity undirected as it simply takes the average local transitivity across the whole network See the following reference for more details Watts and Strogatz Collective dynamics of small-world networks Nature Clustering coefficient is an alternative name for transitivity",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "transitivityAvglocalUndirected",
          "normalized": "Graph a b-\u003eDouble",
          "package": "igraph",
          "partial": "Avglocal Undirected",
          "signature": "Graph d a-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:transitivityAvglocalUndirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e10.4. \u003ccode\u003eigraph_transitivity_barrat\u003c/code\u003e &#8212; Weighted transitivity, as defined by A.\n Barrat.\n\u003c/p\u003e\u003cp\u003eThis is a local transitivity, i.e. a vertex-level index. For a given vertex\n i, from all triangles in which it participates we consider the weight of the\n edges incident on i. The transitivity is the sum of these weights divided by\n twice the strength of the vertex (see `igraph_strength()`) and the degree of\n the vertex minus one. See Alain Barrat, Marc Barthelemy, Romualdo\n Pastor-Satorras, Alessandro Vespignani: The architecture of complex weighted\n networks, Proc. Natl. Acad. Sci. USA 101, 3747 (2004) at\n http:\u003cem/\u003earxiv.org\u003cem\u003eabs\u003c/em\u003econd-mat/0311416 for the exact formula.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "transitivityBarrat",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e [(a, Double)]",
          "source": "src/Data-IGraph.html#transitivityBarrat",
          "type": "function"
        },
        "index": {
          "description": "igraph transitivity barrat Weighted transitivity as defined by Barrat This is local transitivity i.e vertex-level index For given vertex from all triangles in which it participates we consider the weight of the edges incident on The transitivity is the sum of these weights divided by twice the strength of the vertex see igraph strength and the degree of the vertex minus one See Alain Barrat Marc Barthelemy Romualdo Pastor-Satorras Alessandro Vespignani The architecture of complex weighted networks Proc Natl Acad Sci USA at http arxiv.org abs cond-mat for the exact formula",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "transitivityBarrat",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003e[(b,Double)]",
          "package": "igraph",
          "partial": "Barrat",
          "signature": "Graph d a-\u003eVertexSelector a-\u003e[(a,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:transitivityBarrat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e10.2. \u003ccode\u003eigraph_transitivity_local_undirected\u003c/code\u003e &#8212; Calculates the local\n transitivity (clustering coefficient) of a graph.\n\u003c/p\u003e\u003cp\u003eThe transitivity measures the probability that two neighbors of a vertex are\n connected. In case of the local transitivity, this probability is calculated\n separately for each vertex.\n\u003c/p\u003e\u003cp\u003eNote that this measure is different from the global transitivity measure (see\n igraph_transitivity_undirected() ) as it calculates a transitivity value for\n each vertex individually. See the following reference for more details:\n\u003c/p\u003e\u003cp\u003eD. J. Watts and S. Strogatz: Collective dynamics of small-world networks.\n Nature 393(6684):440-442 (1998).\n\u003c/p\u003e\u003cp\u003eClustering coefficient is an alternative name for transitivity.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "transitivityLocalUndirected",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e [(a, Double)]",
          "source": "src/Data-IGraph.html#transitivityLocalUndirected",
          "type": "function"
        },
        "index": {
          "description": "igraph transitivity local undirected Calculates the local transitivity clustering coefficient of graph The transitivity measures the probability that two neighbors of vertex are connected In case of the local transitivity this probability is calculated separately for each vertex Note that this measure is different from the global transitivity measure see igraph transitivity undirected as it calculates transitivity value for each vertex individually See the following reference for more details Watts and Strogatz Collective dynamics of small-world networks Nature Clustering coefficient is an alternative name for transitivity",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "transitivityLocalUndirected",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003e[(b,Double)]",
          "package": "igraph",
          "partial": "Local Undirected",
          "signature": "Graph d a-\u003eVertexSelector a-\u003e[(a,Double)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:transitivityLocalUndirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e10.1. \u003ccode\u003eigraph_transitivity_undirected\u003c/code\u003e &#8212; Calculates the transitivity\n (clustering coefficient) of a graph.\n\u003c/p\u003e\u003cp\u003eThe transitivity measures the probability that two neighbors of a vertex are\n connected. More precisely, this is the ratio of the triangles and connected\n triples in the graph, the result is a single real number. Directed graphs are\n considered as undirected ones.\n\u003c/p\u003e\u003cp\u003eNote that this measure is different from the local transitivity measure (see\n `igraph_transitivity_local_undirected()` ) as it calculates a single value for\n the whole graph. See the following reference for more details:\n\u003c/p\u003e\u003cp\u003eS. Wasserman and K. Faust: Social Network Analysis: Methods and Applications.\n Cambridge: Cambridge University Press, 1994.\n\u003c/p\u003e\u003cp\u003eClustering coefficient is an alternative name for transitivity.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "transitivityUndirected",
          "package": "igraph",
          "signature": "Graph d a -\u003e Double",
          "source": "src/Data-IGraph.html#transitivityUndirected",
          "type": "function"
        },
        "index": {
          "description": "igraph transitivity undirected Calculates the transitivity clustering coefficient of graph The transitivity measures the probability that two neighbors of vertex are connected More precisely this is the ratio of the triangles and connected triples in the graph the result is single real number Directed graphs are considered as undirected ones Note that this measure is different from the local transitivity measure see igraph transitivity local undirected as it calculates single value for the whole graph See the following reference for more details Wasserman and Faust Social Network Analysis Methods and Applications Cambridge Cambridge University Press Clustering coefficient is an alternative name for transitivity",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "transitivityUndirected",
          "normalized": "Graph a b-\u003eDouble",
          "package": "igraph",
          "partial": "Undirected",
          "signature": "Graph d a-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:transitivityUndirected"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e3.4. \u003ccode\u003eigraph_vs_size\u003c/code\u003e &#8212; Returns the size of the vertex selector.\n\u003c/p\u003e",
          "module": "Data.IGraph",
          "name": "vsSize",
          "package": "igraph",
          "signature": "Graph d a -\u003e VertexSelector a -\u003e Int",
          "source": "src/Data-IGraph.html#vsSize",
          "type": "function"
        },
        "index": {
          "description": "igraph vs size Returns the size of the vertex selector",
          "hierarchy": "Data IGraph",
          "module": "Data.IGraph",
          "name": "vsSize",
          "normalized": "Graph a b-\u003eVertexSelector b-\u003eInt",
          "package": "igraph",
          "partial": "Size",
          "signature": "Graph d a-\u003eVertexSelector a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/igraph/docs/Data-IGraph.html#v:vsSize"
      }
    }
  ]
]