[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "vector-functorlazy"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "Common",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Common.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "Common",
          "package": "vector-functorlazy",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery position in the super lazy vector is represented by a LazyBox\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyBox",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyBox",
          "type": "data"
        },
        "index": {
          "description": "Every position in the super lazy vector is represented by LazyBox",
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyBox",
          "package": "vector-functorlazy",
          "partial": "Lazy Box",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#t:LazyBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecords the sequence of fmaps that have occurred \n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyController",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyController",
          "type": "data"
        },
        "index": {
          "description": "Records the sequence of fmaps that have occurred",
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyController",
          "package": "vector-functorlazy",
          "partial": "Lazy Controller",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#t:LazyController"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyBox",
          "package": "vector-functorlazy",
          "signature": "LazyBox",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyBox",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyBox",
          "package": "vector-functorlazy",
          "partial": "Lazy Box",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:LazyBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyController",
          "package": "vector-functorlazy",
          "signature": "LazyController",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyController",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "LazyController",
          "package": "vector-functorlazy",
          "partial": "Lazy Controller",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:LazyController"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "appList",
          "package": "vector-functorlazy",
          "signature": "Any -\u003e [Any] -\u003e a",
          "source": "src/Data-Vector-FunctorLazy-Common.html#appList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "appList",
          "normalized": "Any-\u003e[Any]-\u003ea",
          "package": "vector-functorlazy",
          "partial": "List",
          "signature": "Any-\u003e[Any]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:appList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "funcC",
          "package": "vector-functorlazy",
          "signature": "Int",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyController",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "funcC",
          "package": "vector-functorlazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:funcC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "funcL",
          "package": "vector-functorlazy",
          "signature": "[Any]",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyController",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "funcL",
          "normalized": "[Any]",
          "package": "vector-functorlazy",
          "signature": "[Any]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:funcL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent partially evaluated thunk\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "lazyb",
          "package": "vector-functorlazy",
          "signature": "Any",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyBox",
          "type": "function"
        },
        "index": {
          "description": "current partially evaluated thunk",
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "lazyb",
          "package": "vector-functorlazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:lazyb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehow many functions have been applied to this box\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "lazyc",
          "package": "vector-functorlazy",
          "signature": "Int",
          "source": "src/Data-Vector-FunctorLazy-Common.html#LazyBox",
          "type": "function"
        },
        "index": {
          "description": "how many functions have been applied to this box",
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "lazyc",
          "package": "vector-functorlazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:lazyc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "mkLazyBox",
          "package": "vector-functorlazy",
          "signature": "a -\u003e LazyBox",
          "source": "src/Data-Vector-FunctorLazy-Common.html#mkLazyBox",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Common",
          "module": "Data.Vector.FunctorLazy.Common",
          "name": "mkLazyBox",
          "normalized": "a-\u003eLazyBox",
          "package": "vector-functorlazy",
          "partial": "Lazy Box",
          "signature": "a-\u003eLazyBox",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Common.html#v:mkLazyBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMutable functor-lazy vectors are like mutable boxed vectors, but support mapping a function onto all elements in constant time.  All vector operations (except slicing) are fully supported.  See \u003ca\u003ehttp://github.com/mikeizbicki/functor-lazy\u003c/a\u003e for more details.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "Mutable",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html",
          "type": "module"
        },
        "index": {
          "description": "Mutable functor-lazy vectors are like mutable boxed vectors but support mapping function onto all elements in constant time All vector operations except slicing are fully supported See http github.com mikeizbicki functor-lazy for more details",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "Mutable",
          "package": "vector-functorlazy",
          "partial": "Mutable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "IOVector",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#IOVector",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "IOVector",
          "package": "vector-functorlazy",
          "partial": "IOVector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#t:IOVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "MVector",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#MVector",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "MVector",
          "package": "vector-functorlazy",
          "partial": "MVector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#t:MVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "STVector",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#STVector",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "STVector",
          "package": "vector-functorlazy",
          "partial": "STVector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#t:STVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "MVector",
          "package": "vector-functorlazy",
          "signature": "MVector",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#MVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "MVector",
          "package": "vector-functorlazy",
          "partial": "MVector",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:MVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReset all elements of the vector to some undefined value, clearing all\n references to external objects. This is usually a noop for unboxed vectors. \n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "clear",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Reset all elements of the vector to some undefined value clearing all references to external objects This is usually noop for unboxed vectors",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "clear",
          "normalized": "a(PrimState b)c-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:clear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a copy of a mutable vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "clone",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e m (v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Create copy of mutable vector",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "clone",
          "normalized": "a(PrimState b)c-\u003eb(a(PrimState b)c)",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003em(v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:clone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "copy",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e v (PrimState m) a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Copy vector The two vectors must have the same length and may not overlap",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "copy",
          "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:copy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eforces all queued functions to be applied at a given index; this does not actually evaluate the functions, however, only stores the appropriate thunk in the index\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "forceElement",
          "package": "vector-functorlazy",
          "signature": "MVector s a -\u003e Int -\u003e a",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#forceElement",
          "type": "function"
        },
        "index": {
          "description": "forces all queued functions to be applied at given index this does not actually evaluate the functions however only stores the appropriate thunk in the index",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "forceElement",
          "normalized": "MVector a b-\u003eInt-\u003eb",
          "package": "vector-functorlazy",
          "partial": "Element",
          "signature": "MVector s a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:forceElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "grow",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e m (v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Grow vector by the given number of elements The number must be positive",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "grow",
          "normalized": "a(PrimState b)c-\u003eInt-\u003eb(a(PrimState b)c)",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003eInt-\u003em(v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:grow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLength of the mutable vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "length",
          "package": "vector-functorlazy",
          "signature": "v s a -\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "Length of the mutable vector",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "length",
          "normalized": "a b c-\u003eInt",
          "package": "vector-functorlazy",
          "signature": "v s a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap a function onto all elements in the vector; uses time O(1)\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mapM",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b) -\u003e MVector s a -\u003e m (MVector s b)",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#mapM",
          "type": "function"
        },
        "index": {
          "description": "map function onto all elements in the vector uses time",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mapM",
          "normalized": "(a-\u003eb)-\u003eMVector c a-\u003ed(MVector c b)",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb)-\u003eMVector s a-\u003em(MVector s b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:mapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mcontrol",
          "package": "vector-functorlazy",
          "signature": "LazyController",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#MVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mcontrol",
          "package": "vector-functorlazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:mcontrol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mlen",
          "package": "vector-functorlazy",
          "signature": "Int",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#MVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mlen",
          "package": "vector-functorlazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:mlen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003ecopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "move",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e v (PrimState m) a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Move the contents of vector The two vectors must have the same length If the vectors do not overlap then this is equivalent to copy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "move",
          "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:move"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mvecAny",
          "package": "vector-functorlazy",
          "signature": "(MutableArray s Any)",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#MVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mvecAny",
          "package": "vector-functorlazy",
          "partial": "Any",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:mvecAny"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mvecInt",
          "package": "vector-functorlazy",
          "signature": "(MutableByteArray s)",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#MVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "mvecInt",
          "package": "vector-functorlazy",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:mvecInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a mutable vector of the given length.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "new",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e m (v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Create mutable vector of the given length",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "new",
          "normalized": "Int-\u003ea(b(PrimState a)c)",
          "package": "vector-functorlazy",
          "signature": "Int-\u003em(v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether the vector is empty\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "null",
          "package": "vector-functorlazy",
          "signature": "v s a -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Check whether the vector is empty",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "null",
          "normalized": "a b c-\u003eBool",
          "package": "vector-functorlazy",
          "signature": "v s a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the element at the given position.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "read",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Yield the element at the given position",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "read",
          "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003eInt-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with an initial value.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "replicate",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e a -\u003e m (v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Create mutable vector of the given length if the length is negative and fill it with an initial value",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003eb(c(PrimState b)a)",
          "package": "vector-functorlazy",
          "signature": "Int-\u003ea-\u003em(v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a mutable vector of the given length (0 if the length is negative)\n and fill it with values produced by repeatedly executing the monadic action.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "replicateM",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e m a -\u003e m (v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Create mutable vector of the given length if the length is negative and fill it with values produced by repeatedly executing the monadic action",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "replicateM",
          "normalized": "Int-\u003ea b-\u003ea(c(PrimState a)b)",
          "package": "vector-functorlazy",
          "signature": "Int-\u003em a-\u003em(v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:replicateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet all elements of the vector to the given value.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "set",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Set all elements of the vector to the given value",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "set",
          "normalized": "a(PrimState b)c-\u003ec-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap the elements at the given positions.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "swap",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Swap the elements at the given positions",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "swap",
          "normalized": "a(PrimState b)c-\u003eInt-\u003eInt-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003eInt-\u003eInt-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCopy a vector. The two vectors must have the same length and may not\n overlap. This is not checked.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeCopy",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a-\u003e v (PrimState m) a-\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Copy vector The two vectors must have the same length and may not overlap This is not checked",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeCopy",
          "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
          "package": "vector-functorlazy",
          "partial": "Copy",
          "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:unsafeCopy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGrow a vector by the given number of elements. The number must be\n positive but this is not checked.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeGrow",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e m (v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Grow vector by the given number of elements The number must be positive but this is not checked",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeGrow",
          "normalized": "a(PrimState b)c-\u003eInt-\u003eb(a(PrimState b)c)",
          "package": "vector-functorlazy",
          "partial": "Grow",
          "signature": "v(PrimState m)a-\u003eInt-\u003em(v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:unsafeGrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove the contents of a vector. The two vectors must have the same\n length, but this is not checked.\n\u003c/p\u003e\u003cp\u003eIf the vectors do not overlap, then this is equivalent to \u003ccode\u003e\u003ca\u003eunsafeCopy\u003c/a\u003e\u003c/code\u003e.\n Otherwise, the copying is performed as if the source vector were\n copied to a temporary vector and then the temporary vector was copied\n to the target vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeMove",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a-\u003e v (PrimState m) a-\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Move the contents of vector The two vectors must have the same length but this is not checked If the vectors do not overlap then this is equivalent to unsafeCopy Otherwise the copying is performed as if the source vector were copied to temporary vector and then the temporary vector was copied to the target vector",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeMove",
          "normalized": "a(PrimState b)c-\u003ea(PrimState b)c-\u003eb()",
          "package": "vector-functorlazy",
          "partial": "Move",
          "signature": "v(PrimState m)a-\u003ev(PrimState m)a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:unsafeMove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a mutable vector of the given length. The length is not checked.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeNew",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e m (v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Create mutable vector of the given length The length is not checked",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeNew",
          "normalized": "Int-\u003ea(b(PrimState a)c)",
          "package": "vector-functorlazy",
          "partial": "New",
          "signature": "Int-\u003em(v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:unsafeNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYield the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeRead",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Yield the element at the given position No bounds checks are performed",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeRead",
          "normalized": "a(PrimState b)c-\u003eInt-\u003eb c",
          "package": "vector-functorlazy",
          "partial": "Read",
          "signature": "v(PrimState m)a-\u003eInt-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:unsafeRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap the elements at the given positions. No bounds checks are performed.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeSwap",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e Int -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Swap the elements at the given positions No bounds checks are performed",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeSwap",
          "normalized": "a(PrimState b)c-\u003eInt-\u003eInt-\u003eb()",
          "package": "vector-functorlazy",
          "partial": "Swap",
          "signature": "v(PrimState m)a-\u003eInt-\u003eInt-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:unsafeSwap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the element at the given position. No bounds checks are performed.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeWrite",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Replace the element at the given position No bounds checks are performed",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "unsafeWrite",
          "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
          "package": "vector-functorlazy",
          "partial": "Write",
          "signature": "v(PrimState m)a-\u003eInt-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:unsafeWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the element at the given position.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "write",
          "package": "vector-functorlazy",
          "signature": "v (PrimState m) a -\u003e Int -\u003e a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Replace the element at the given position",
          "hierarchy": "Data Vector FunctorLazy Mutable",
          "module": "Data.Vector.FunctorLazy.Mutable",
          "name": "write",
          "normalized": "a(PrimState b)c-\u003eInt-\u003ec-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "v(PrimState m)a-\u003eInt-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy-Mutable.html#v:write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctor-lazy vectors are like boxed vectors, but support mapping a function onto all elements in constant time.  All vector operations (except slicing) are fully supported.  See \u003ca\u003ehttp://github.com/mikeizbicki/functor-lazy\u003c/a\u003e for more details.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "FunctorLazy",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy.html",
          "type": "module"
        },
        "index": {
          "description": "Functor-lazy vectors are like boxed vectors but support mapping function onto all elements in constant time All vector operations except slicing are fully supported See http github.com mikeizbicki functor-lazy for more details",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "FunctorLazy",
          "package": "vector-functorlazy",
          "partial": "Functor Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "MVector",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy-Mutable.html#MVector",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "MVector",
          "package": "vector-functorlazy",
          "partial": "MVector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#t:MVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "Vector",
          "package": "vector-functorlazy",
          "source": "src/Data-Vector-FunctorLazy.html#Vector",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "Vector",
          "package": "vector-functorlazy",
          "partial": "Vector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eO(1) Indexing\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "(!)",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Indexing",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "(!) !",
          "normalized": "a b-\u003eInt-\u003eb",
          "package": "vector-functorlazy",
          "signature": "v a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eO(1) Safe indexing\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "(!?)",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int -\u003e Maybe a",
          "type": "function"
        },
        "index": {
          "description": "Safe indexing",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "(!?) !?",
          "normalized": "a b-\u003eInt-\u003eMaybe b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003eInt-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:-33--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e Concatenate two vectors\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "(++)",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Concatenate two vectors",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "(++) ++",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:-43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the list, replace the vector\n element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003c5,9,2,7\u003e // [(2,1),(0,3),(2,8)] = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "(//)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003e [(Int, a)]-\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "For each pair from the list replace the vector element at position by",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "(//) //",
          "normalized": "a b-\u003e[(Int,b)]-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003e[(Int,a)]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:-47--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the list, replace the vector element\n \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accum (+) \u003c5,9,2\u003e [(2,4),(1,6),(0,3),(1,7)] = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "accum",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e [(Int, b)]-\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "For each pair from the list replace the vector element at position by accum",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "accum",
          "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003e[(Int,b)]-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003e[(Int,b)]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:accum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,b)\u003c/code\u003e from the vector of pairs, replace the vector\n element \u003ccode\u003ea\u003c/code\u003e at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate (+) \u003c5,9,2\u003e \u003c(2,4),(1,6),(0,3),(1,7)\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "accumulate",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e v (Int, b)-\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "For each pair from the vector of pairs replace the vector element at position by accumulate",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "accumulate",
          "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec(Int,b)-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev(Int,b)-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:accumulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003eb\u003c/code\u003e from the the value vector,\n replace the element of the initial vector at\n position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ef a b\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e accumulate_ (+) \u003c5,9,2\u003e \u003c2,1,0,1\u003e \u003c4,6,3,7\u003e = \u003c5+3, 9+6+7, 2+4\u003e\n\u003c/pre\u003e\u003cp\u003eThis function is useful for instances of \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e that cannot store pairs.\n Otherwise, \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e is probably more convenient:\n\u003c/p\u003e\u003cpre\u003e\n accumulate_ f as is bs = \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e f as (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is bs)\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "accumulate_",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a)-\u003e v a-\u003e v Int-\u003e v b-\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 For each index from the index vector and the corresponding value from the the value vector replace the element of the initial vector at position by accumulate This function is useful for instances of Vector that cannot store pairs Otherwise accumulate is probably more convenient accumulate as is bs accumulate as zip is bs",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "accumulate_",
          "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec Int-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev Int-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:accumulate_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements satisfy the predicate.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "all",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Check if all elements satisfy the predicate",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "all",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eBool)-\u003ev a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:all"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if all elements are \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "and",
          "package": "vector-functorlazy",
          "signature": "v Bool -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Check if all elements are True",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "and",
          "normalized": "a Bool-\u003eBool",
          "package": "vector-functorlazy",
          "signature": "v Bool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element satisfies the predicate.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "any",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Check if any element satisfies the predicate",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "any",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eBool)-\u003ev a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:any"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the vector obtained by replacing each element \u003ccode\u003ei\u003c/code\u003e of the\n index vector by \u003ccode\u003exs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003ei\u003c/code\u003e. This is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e (xs\u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e) is\u003c/code\u003e but is\n often much more efficient.\n\u003c/p\u003e\u003cpre\u003e backpermute \u003ca,b,c,d\u003e \u003c0,3,2,3,1,0\u003e = \u003ca,d,c,d,b,a\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "backpermute",
          "package": "vector-functorlazy",
          "signature": "v a-\u003e v Int-\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Yield the vector obtained by replacing each element of the index vector by xs This is equivalent to map xs is but is often much more efficient backpermute",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "backpermute",
          "normalized": "a b-\u003ea Int-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev Int-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:backpermute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Concatenate all vectors in the list\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "concat",
          "package": "vector-functorlazy",
          "signature": "[v a] -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Concatenate all vectors in the list",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "concat",
          "normalized": "[a b]-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "[v a]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prepend an element\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "cons",
          "package": "vector-functorlazy",
          "signature": "a -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Prepend an element",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "cons",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "a-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements by repeatedly applying the\n generator function to the already constructed part of the vector.\n\u003c/p\u003e\u003cpre\u003e constructN 3 f = let a = f \u003c\u003e ; b = f \u003ca\u003e ; c = f \u003ca,b\u003e in f \u003ca,b,c\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "constructN",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e (v a -\u003e a) -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Construct vector with elements by repeatedly applying the generator function to the already constructed part of the vector constructN let in",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "constructN",
          "normalized": "Int-\u003e(a b-\u003eb)-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "Int-\u003e(v a-\u003ea)-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:constructN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with \u003ccode\u003en\u003c/code\u003e elements from right to left by\n repeatedly applying the generator function to the already constructed part\n of the vector.\n\u003c/p\u003e\u003cpre\u003e constructrN 3 f = let a = f \u003c\u003e ; b = f\u003ca\u003e ; c = f \u003cb,a\u003e in f \u003cc,b,a\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "constructrN",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e (v a -\u003e a) -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Construct vector with elements from right to left by repeatedly applying the generator function to the already constructed part of the vector constructrN let in",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "constructrN",
          "normalized": "Int-\u003e(a b-\u003eb)-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "Int-\u003e(v a-\u003ea)-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:constructrN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert different vector types\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "convert",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e w a",
          "type": "function"
        },
        "index": {
          "description": "Convert different vector types",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "convert",
          "normalized": "a b-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ew a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "copy",
          "package": "vector-functorlazy",
          "signature": "Mutable v (PrimState m) a -\u003e v a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Copy an immutable vector into mutable one The two vectors must have the same length",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "copy",
          "normalized": "Mutable a(PrimState b)c-\u003ea c-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "Mutable v(PrimState m)a-\u003ev a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:copy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute the monadic action and freeze the resulting vector.\n\u003c/p\u003e\u003cpre\u003e\n create (do { v \u003c- \u003ccode\u003e\u003ca\u003enew\u003c/a\u003e\u003c/code\u003e 2; \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e v 0 'a'; \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e v 1 'b'; return v }) = \u003c\u003ccode\u003ea\u003c/code\u003e,\u003ccode\u003eb\u003c/code\u003e\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "create",
          "package": "vector-functorlazy",
          "signature": "(forall s.  ST s (Mutable v s a)) -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Execute the monadic action and freeze the resulting vector create do new write write return",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "create",
          "normalized": "(a b ST c(Mutable d c e))-\u003ed e",
          "package": "vector-functorlazy",
          "signature": "(forall s. ST s(Mutable v s a))-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:create"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop the longest prefix of elements that satisfy the predicate\n without copying.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "dropWhile",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Drop the longest prefix of elements that satisfy the predicate without copying",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "dropWhile",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:dropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector contains an element\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "elem",
          "package": "vector-functorlazy",
          "signature": "a -\u003e v a -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Check if the vector contains an element",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "elem",
          "normalized": "a-\u003eb a-\u003eBool",
          "package": "vector-functorlazy",
          "signature": "a-\u003ev a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:elem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first occurence of the given element or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the vector does not contain the element. This is a specialised\n version of \u003ccode\u003e\u003ca\u003efindIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "elemIndex",
          "package": "vector-functorlazy",
          "signature": "a -\u003e v a -\u003e Maybe Int",
          "type": "function"
        },
        "index": {
          "description": "Yield Just the index of the first occurence of the given element or Nothing if the vector does not contain the element This is specialised version of findIndex",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "elemIndex",
          "normalized": "a-\u003eb a-\u003eMaybe Int",
          "package": "vector-functorlazy",
          "partial": "Index",
          "signature": "a-\u003ev a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:elemIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of all occurences of the given element in\n ascending order. This is a specialised version of \u003ccode\u003e\u003ca\u003efindIndices\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "elemIndices",
          "package": "vector-functorlazy",
          "signature": "a -\u003e v a -\u003e v Int",
          "type": "function"
        },
        "index": {
          "description": "Yield the indices of all occurences of the given element in ascending order This is specialised version of findIndices",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "elemIndices",
          "normalized": "a-\u003eb a-\u003eb Int",
          "package": "vector-functorlazy",
          "partial": "Indices",
          "signature": "a-\u003ev a-\u003ev Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:elemIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Empty vector\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "empty",
          "package": "vector-functorlazy",
          "signature": "v a",
          "type": "function"
        },
        "index": {
          "description": "Empty vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "empty",
          "package": "vector-functorlazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+1\u003c/code\u003e\n etc. This operation is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromN 5 3 = \u003c5,6,7\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromN",
          "package": "vector-functorlazy",
          "signature": "a -\u003e Int -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Yield vector of the given length containing the values etc This operation is usually more efficient than enumFromTo enumFromN",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromN",
          "normalized": "a-\u003eInt-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "From",
          "signature": "a-\u003eInt-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:enumFromN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a vector of the given length containing the values \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ex+y\u003c/code\u003e,\n \u003ccode\u003ex+y+y\u003c/code\u003e etc. This operations is usually more efficient than \u003ccode\u003e\u003ca\u003eenumFromThenTo\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e enumFromStepN 1 0.1 5 = \u003c1,1.1,1.2,1.3,1.4\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromStepN",
          "package": "vector-functorlazy",
          "signature": "a -\u003e a -\u003e Int -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Yield vector of the given length containing the values etc This operations is usually more efficient than enumFromThenTo enumFromStepN",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromStepN",
          "normalized": "a-\u003ea-\u003eInt-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "From Step",
          "signature": "a-\u003ea-\u003eInt-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:enumFromStepN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e with a specific step \u003ccode\u003ez\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromStepN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromThenTo",
          "package": "vector-functorlazy",
          "signature": "a -\u003e a -\u003e a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Enumerate values from to with specific step WARNING This operation can be very inefficient If at all possible use enumFromStepN instead",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromThenTo",
          "normalized": "a-\u003ea-\u003ea-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "From Then To",
          "signature": "a-\u003ea-\u003ea-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:enumFromThenTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Enumerate values from \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eWARNING:\u003c/em\u003e This operation can be very inefficient. If at all possible, use\n \u003ccode\u003e\u003ca\u003eenumFromN\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromTo",
          "package": "vector-functorlazy",
          "signature": "a -\u003e a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Enumerate values from to WARNING This operation can be very inefficient If at all possible use enumFromN instead",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "enumFromTo",
          "normalized": "a-\u003ea-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "From To",
          "signature": "a-\u003ea-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:enumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "filter",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Drop elements that do not satisfy the predicate",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eBool)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the monadic predicate\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "filterM",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e m Bool) -\u003e v a -\u003e m (v a)",
          "type": "function"
        },
        "index": {
          "description": "Drop elements that do not satisfy the monadic predicate",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "filterM",
          "normalized": "(a-\u003eb Bool)-\u003ec a-\u003eb(c a)",
          "package": "vector-functorlazy",
          "signature": "(a-\u003em Bool)-\u003ev a-\u003em(v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:filterM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the first element matching the predicate or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n if no such element exists.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "find",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e Maybe a",
          "type": "function"
        },
        "index": {
          "description": "Yield Just the first element matching the predicate or Nothing if no such element exists",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "find",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eMaybe a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eBool)-\u003ev a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:find"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index of the first element matching the predicate\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no such element exists.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "findIndex",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e Maybe Int",
          "type": "function"
        },
        "index": {
          "description": "Yield Just the index of the first element matching the predicate or Nothing if no such element exists",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "findIndex",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eMaybe Int",
          "package": "vector-functorlazy",
          "partial": "Index",
          "signature": "(a-\u003eBool)-\u003ev a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:findIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the indices of elements satisfying the predicate in ascending\n order.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "findIndices",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e v Int",
          "type": "function"
        },
        "index": {
          "description": "Yield the indices of elements satisfying the predicate in ascending order",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "findIndices",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb Int",
          "package": "vector-functorlazy",
          "partial": "Indices",
          "signature": "(a-\u003eBool)-\u003ev a-\u003ev Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:findIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over non-empty vectors",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M",
          "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:fold1M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over non-empty vectors with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M'",
          "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "M'",
          "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:fold1M-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monad fold over non-empty vectors with strict accumulator\n that discards the result\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M'_",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Monad fold over non-empty vectors with strict accumulator that discards the result",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M'_",
          "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb()",
          "package": "vector-functorlazy",
          "partial": "M'",
          "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:fold1M-39-_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold over non-empty vectors that discards the result\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M_",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e m a) -\u003e v a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over non-empty vectors that discards the result",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "fold1M_",
          "normalized": "(a-\u003ea-\u003eb a)-\u003ec a-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003em a)-\u003ev a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:fold1M_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM'",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec a",
          "package": "vector-functorlazy",
          "partial": "M'",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold with strict accumulator that discards the result\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM'_",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold with strict accumulator that discards the result",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM'_",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec()",
          "package": "vector-functorlazy",
          "partial": "M'",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldM-39-_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Monadic fold that discards the result\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM_",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e m a) -\u003e a -\u003e v b -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold that discards the result",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldM_",
          "normalized": "(a-\u003eb-\u003ec a)-\u003ea-\u003ed b-\u003ec()",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003em a)-\u003ea-\u003ev b-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Left fold",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Left fold with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl1",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Left fold on non-empty vectors",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl1'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Left fold on non-empty vectors with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldl1'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldl1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Right fold",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with a strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Right fold with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr1",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Right fold on non-empty vectors",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold on non-empty vectors with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr1'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Right fold on non-empty vectors with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "foldr1'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:foldr1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the argument but force it not to retain any extra memory,\n possibly by copying it.\n\u003c/p\u003e\u003cp\u003eThis is especially useful when dealing with slices. For example:\n\u003c/p\u003e\u003cpre\u003e force (slice 0 2 \u003chuge vector\u003e)\n\u003c/pre\u003e\u003cp\u003eHere, the slice retains a reference to the huge vector. Forcing it creates\n a copy of just the elements that belong to the slice and allows the huge\n vector to be garbage collected.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "force",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Yield the argument but force it not to retain any extra memory possibly by copying it This is especially useful when dealing with slices For example force slice huge vector Here the slice retains reference to the huge vector Forcing it creates copy of just the elements that belong to the slice and allows the huge vector to be garbage collected",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "force",
          "normalized": "a b-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:force"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield an immutable copy of the mutable vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "freeze",
          "package": "vector-functorlazy",
          "signature": "Mutable v (PrimState m) a -\u003e m (v a)",
          "type": "function"
        },
        "index": {
          "description": "Yield an immutable copy of the mutable vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "freeze",
          "normalized": "Mutable a(PrimState b)c-\u003eb(a c)",
          "package": "vector-functorlazy",
          "signature": "Mutable v(PrimState m)a-\u003em(v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:freeze"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a list to a vector\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "fromList",
          "package": "vector-functorlazy",
          "signature": "[a] -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Convert list to vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "fromList",
          "normalized": "[a]-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "List",
          "signature": "[a]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert the first \u003ccode\u003en\u003c/code\u003e elements of a list to a vector\n\u003c/p\u003e\u003cpre\u003e\n fromListN n xs = \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e n xs)\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "fromListN",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e [a] -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Convert the first elements of list to vector fromListN xs fromList take xs",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "fromListN",
          "normalized": "Int-\u003e[a]-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "List",
          "signature": "Int-\u003e[a]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:fromListN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the function to\n each index\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "generate",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e (Int -\u003e a) -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Construct vector of the given length by applying the function to each index",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "generate",
          "normalized": "Int-\u003e(Int-\u003ea)-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "Int-\u003e(Int-\u003ea)-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:generate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector of the given length by applying the monadic\n action to each index\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "generateM",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e (Int -\u003e m a) -\u003e m (v a)",
          "type": "function"
        },
        "index": {
          "description": "Construct vector of the given length by applying the monadic action to each index",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "generateM",
          "normalized": "Int-\u003e(Int-\u003ea b)-\u003ea(c b)",
          "package": "vector-functorlazy",
          "signature": "Int-\u003e(Int-\u003em a)-\u003em(v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:generateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "head",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "First element",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "head",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "headM",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "First element of vector in monad See indexM for an explanation of why this is useful",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "headM",
          "normalized": "a b-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:headM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Drop elements that do not satisfy the predicate which is applied to\n values and their indices\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifilter",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e Bool) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Drop elements that do not satisfy the predicate which is applied to values and their indices",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifilter",
          "normalized": "(Int-\u003ea-\u003eBool)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "(Int-\u003ea-\u003eBool)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:ifilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold (function applied to each element and its index)\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldl",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Left fold function applied to each element and its index",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldl",
          "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:ifoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Left fold with strict accumulator (function applied to each element\n and its index)\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldl'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Int -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Left fold with strict accumulator function applied to each element and its index",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldl'",
          "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ea",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:ifoldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold (function applied to each element and its index)\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldr",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Right fold function applied to each element and its index",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldr",
          "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "vector-functorlazy",
          "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:ifoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right fold with strict accumulator (function applied to each\n element and its index)\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldr'",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Right fold with strict accumulator function applied to each element and its index",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "ifoldr'",
          "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003eb",
          "package": "vector-functorlazy",
          "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:ifoldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad.\n\u003c/p\u003e\u003cp\u003eThe monad allows operations to be strict in the vector when necessary.\n Suppose vector copying is implemented like this:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... write mv i (v ! i) ...\n\u003c/pre\u003e\u003cp\u003eFor lazy vectors, \u003ccode\u003ev ! i\u003c/code\u003e would not be evaluated which means that \u003ccode\u003emv\u003c/code\u003e\n would unnecessarily retain a reference to \u003ccode\u003ev\u003c/code\u003e in each element written.\n\u003c/p\u003e\u003cp\u003eWith \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e, copying can be implemented like this instead:\n\u003c/p\u003e\u003cpre\u003e copy mv v = ... do\n                   x \u003c- indexM v i\n                   write mv i x\n\u003c/pre\u003e\u003cp\u003eHere, no references to \u003ccode\u003ev\u003c/code\u003e are retained because indexing (but \u003cem\u003enot\u003c/em\u003e the\n elements) is evaluated eagerly.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "indexM",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Indexing in monad The monad allows operations to be strict in the vector when necessary Suppose vector copying is implemented like this copy mv write mv For lazy vectors would not be evaluated which means that mv would unnecessarily retain reference to in each element written With indexM copying can be implemented like this instead copy mv do indexM write mv Here no references to are retained because indexing but not the elements is evaluated eagerly",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "indexM",
          "normalized": "a b-\u003eInt-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003eInt-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:indexM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Pair each element in a vector with its index\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "indexed",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v (Int, a)",
          "type": "function"
        },
        "index": {
          "description": "Pair each element in vector with its index",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "indexed",
          "normalized": "a b-\u003ea(Int,b)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev(Int,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:indexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Apply function n times to value. Zeroth element is original value.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "iterateN",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Apply function times to value Zeroth element is original value",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "iterateN",
          "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:iterateN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with a function that also takes the\n elements' indices.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e b -\u003e c) -\u003e v a -\u003e v b -\u003e v c",
          "type": "function"
        },
        "index": {
          "description": "min Zip two vectors with function that also takes the elements indices",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith",
          "normalized": "(Int-\u003ea-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(Int-\u003ea-\u003eb-\u003ec)-\u003ev a-\u003ev b-\u003ev c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:izipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith3",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d) -\u003e v a -\u003e v b -\u003e v c -\u003e v d",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith3",
          "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed)-\u003ev a-\u003ev b-\u003ev c-\u003ev d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:izipWith3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith4",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith4",
          "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:izipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith5",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith5",
          "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eg b-\u003eg c-\u003eg d-\u003eg e-\u003eg f",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:izipWith5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith6",
          "package": "vector-functorlazy",
          "signature": "(Int -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f -\u003e v g",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "izipWith6",
          "normalized": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eh a-\u003eh b-\u003eh c-\u003eh d-\u003eh e-\u003eh f-\u003eh g",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(Int-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f-\u003ev g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:izipWith6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "last",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Last element",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "last",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element of a vector in a monad. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "lastM",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Last element of vector in monad See indexM for an explanation of why this is useful",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "lastM",
          "normalized": "a b-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:lastM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the length of the vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "length",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "Yield the length of the vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "length",
          "normalized": "a b-\u003eInt",
          "package": "vector-functorlazy",
          "signature": "v a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "maxIndex",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "Yield the index of the maximum element of the vector The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "maxIndex",
          "normalized": "a b-\u003eInt",
          "package": "vector-functorlazy",
          "partial": "Index",
          "signature": "v a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:maxIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the maximum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "maxIndexBy",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "Yield the index of the maximum element of the vector according to the given comparison function The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "maxIndexBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eInt",
          "package": "vector-functorlazy",
          "partial": "Index By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:maxIndexBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "maximum",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Yield the maximum element of the vector The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "maximum",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:maximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the maximum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "maximumBy",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Yield the maximum element of the vector according to the given comparison function The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "maximumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
          "package": "vector-functorlazy",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:maximumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector. The vector\n may not be empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "minIndex",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "Yield the index of the minimum element of the vector The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "minIndex",
          "normalized": "a b-\u003eInt",
          "package": "vector-functorlazy",
          "partial": "Index",
          "signature": "v a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:minIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the index of the minimum element of the vector according to\n the given comparison function. The vector may not be empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "minIndexBy",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "Yield the index of the minimum element of the vector according to the given comparison function The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "minIndexBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003eInt",
          "package": "vector-functorlazy",
          "partial": "Index By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:minIndexBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector. The vector may not be\n empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "minimum",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Yield the minimum element of the vector The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "minimum",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:minimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the minimum element of the vector according to the given\n comparison function. The vector may not be empty.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "minimumBy",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Yield the minimum element of the vector according to the given comparison function The vector may not be empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "minimumBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eb a-\u003ea",
          "package": "vector-functorlazy",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:minimumBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a destructive operation to a vector. The operation will be\n performed in place if it is safe to do so and will modify a copy of the\n vector otherwise.\n\u003c/p\u003e\u003cpre\u003e\n modify (\\v -\u003e \u003ccode\u003e\u003ca\u003ewrite\u003c/a\u003e\u003c/code\u003e v 0 'x') (\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e 3 'a') = \u003c'x','a','a'\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "modify",
          "package": "vector-functorlazy",
          "signature": "(forall s.  Mutable v s a -\u003e ST s ()) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Apply destructive operation to vector The operation will be performed in place if it is safe to do so and will modify copy of the vector otherwise modify write replicate",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "modify",
          "normalized": "(a b Mutable c d e-\u003eST d())-\u003ec e-\u003ec e",
          "package": "vector-functorlazy",
          "signature": "(forall s. Mutable v s a-\u003eST s())-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:modify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if the vector does not contain an element (inverse of \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "notElem",
          "package": "vector-functorlazy",
          "signature": "a -\u003e v a -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Check if the vector does not contain an element inverse of elem",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "notElem",
          "normalized": "a-\u003eb a-\u003eBool",
          "package": "vector-functorlazy",
          "partial": "Elem",
          "signature": "a-\u003ev a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:notElem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Test whether a vector if empty\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "null",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Test whether vector if empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "null",
          "normalized": "a b-\u003eBool",
          "package": "vector-functorlazy",
          "signature": "v a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Check if any element is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "or",
          "package": "vector-functorlazy",
          "signature": "v Bool -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Check if any element is True",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "or",
          "normalized": "a Bool-\u003eBool",
          "package": "vector-functorlazy",
          "signature": "v Bool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan\n\u003c/p\u003e\u003cpre\u003e\n postscanl f z = \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003epostscanl (+) 0 \u003c1,2,3,4\u003e = \u003c1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanl",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Scan postscanl tail scanl Example postscanl",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:postscanl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanl'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Scan with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:postscanl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanr",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left scan",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:postscanr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanr'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left scan with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "postscanr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:postscanr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanl f z = \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e f z\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003eprescanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanl",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Prescan prescanl init scanl Example prescanl",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:prescanl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Prescan with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanl'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Prescan with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:prescanl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan\n\u003c/p\u003e\u003cpre\u003e\n prescanr f z = \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eprescanl\u003c/a\u003e\u003c/code\u003e (flip f) z . \u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanr",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left prescan prescanr reverse prescanl flip reverse",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:prescanr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left prescan with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanr'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left prescan with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "prescanr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:prescanr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the produce of the elements\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "product",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Compute the produce of the elements",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "product",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Vector of the given length with the same value in each position\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "replicate",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Vector of the given length with the same value in each position",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "Int-\u003ea-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Execute the monadic action the given number of times and store the\n results in a vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "replicateM",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e m a -\u003e m (v a)",
          "type": "function"
        },
        "index": {
          "description": "Execute the monadic action the given number of times and store the results in vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "replicateM",
          "normalized": "Int-\u003ea b-\u003ea(c b)",
          "package": "vector-functorlazy",
          "signature": "Int-\u003em a-\u003em(v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:replicateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Reverse a vector\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "reverse",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Reverse vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "reverse",
          "normalized": "a b-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan\n\u003c/p\u003e\u003cpre\u003e scanl f z \u003cx1,...,xn\u003e = \u003cy1,...,y(n+1)\u003e\n   where y1 = z\n         yi = f y(i-1) x(i-1)\n\u003c/pre\u003e\u003cp\u003eExample: \u003ccode\u003escanl (+) 0 \u003c1,2,3,4\u003e = \u003c0,1,3,6,10\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Haskell-style scan scanl x1 xn y1 where y1 yi i-1 i-1 Example scanl",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Haskell-style scan with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e v b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Haskell-style scan with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector\n\u003c/p\u003e\u003cpre\u003e scanl f \u003cx1,...,xn\u003e = \u003cy1,...,yn\u003e\n   where y1 = x1\n         yi = f y(i-1) xi\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl1",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Scan over non-empty vector scanl x1 xn y1 yn where y1 x1 yi i-1 xi",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Scan over a non-empty vector with a strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl1'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Scan over non-empty vector with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanl1'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanl1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left Haskell-style scan",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left Haskell-style scan with strict accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e v a -\u003e v b",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left Haskell-style scan with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003ec a-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003ev a-\u003ev b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr1",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left scan over non-empty vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Right-to-left scan over a non-empty vector with a strict\n accumulator\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr1'",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e a -\u003e a) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left scan over non-empty vector with strict accumulator",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "scanr1'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "(a-\u003ea-\u003ea)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:scanr1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action and collect the results\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "sequence",
          "package": "vector-functorlazy",
          "signature": "v (m a) -\u003e m (v a)",
          "type": "function"
        },
        "index": {
          "description": "Evaluate each action and collect the results",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "sequence",
          "normalized": "a(b c)-\u003eb(a c)",
          "package": "vector-functorlazy",
          "signature": "v(m a)-\u003em(v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action and discard the results\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "sequence_",
          "package": "vector-functorlazy",
          "signature": "v (m a) -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Evaluate each action and discard the results",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "sequence_",
          "normalized": "a(b c)-\u003eb()",
          "package": "vector-functorlazy",
          "signature": "v(m a)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:sequence_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Vector with exactly one element\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "singleton",
          "package": "vector-functorlazy",
          "signature": "a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Vector with exactly one element",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "singleton",
          "normalized": "a-\u003eb a",
          "package": "vector-functorlazy",
          "signature": "a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Append an element\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "snoc",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Append an element",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "snoc",
          "normalized": "a b-\u003eb-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ea-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:snoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Compute the sum of the elements\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "sum",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Compute the sum of the elements",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "sum",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield the longest prefix of elements satisfying the predicate\n without copying.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "takeWhile",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e Bool) -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Yield the longest prefix of elements satisfying the predicate without copying",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "takeWhile",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "vector-functorlazy",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Yield a mutable copy of the immutable vector.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "thaw",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e m (Mutable v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Yield mutable copy of the immutable vector",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "thaw",
          "normalized": "a b-\u003ec(Mutable a(PrimState c)b)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003em(Mutable v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:thaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Convert a vector to a list\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "toList",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "Convert vector to list",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "toList",
          "normalized": "a b-\u003e[b]",
          "package": "vector-functorlazy",
          "partial": "List",
          "signature": "v a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector by repeatedly applying the generator function\n to a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the next element and the\n new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldr (\\n -\u003e if n == 0 then Nothing else Just (n,n-1)) 10\n  = \u003c10,9,8,7,6,5,4,3,2,1\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unfoldr",
          "package": "vector-functorlazy",
          "signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Construct vector by repeatedly applying the generator function to seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldr if then Nothing else Just n-1",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unfoldr",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unfoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Construct a vector with at most \u003ccode\u003en\u003c/code\u003e by repeatedly applying the\n generator function to the a seed. The generator function yields \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the\n next element and the new seed or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no more elements.\n\u003c/p\u003e\u003cpre\u003e unfoldrN 3 (\\n -\u003e Just (n,n-1)) 10 = \u003c10,9,8\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unfoldrN",
          "package": "vector-functorlazy",
          "signature": "Int -\u003e (b -\u003e Maybe (a, b)) -\u003e b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Construct vector with at most by repeatedly applying the generator function to the seed The generator function yields Just the next element and the new seed or Nothing if there are no more elements unfoldrN Just n-1",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unfoldrN",
          "normalized": "Int-\u003e(a-\u003eMaybe(b,a))-\u003ea-\u003ec b",
          "package": "vector-functorlazy",
          "signature": "Int-\u003e(b-\u003eMaybe(a,b))-\u003eb-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unfoldrN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccum\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeAccum",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e [(Int, b)] -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Same as accum but without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeAccum",
          "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003e[(Int,b)]-\u003ec a",
          "package": "vector-functorlazy",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003e[(Int,b)]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeAccum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeAccumulate",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e v (Int, b) -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Same as accumulate but without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeAccumulate",
          "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec(Int,b)-\u003ec a",
          "package": "vector-functorlazy",
          "partial": "Accumulate",
          "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev(Int,b)-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeAccumulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eaccumulate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeAccumulate_",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e a) -\u003e v a -\u003e v Int -\u003e v b -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Same as accumulate but without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeAccumulate_",
          "normalized": "(a-\u003eb-\u003ea)-\u003ec a-\u003ec Int-\u003ec b-\u003ec a",
          "package": "vector-functorlazy",
          "partial": "Accumulate",
          "signature": "(a-\u003eb-\u003ea)-\u003ev a-\u003ev Int-\u003ev b-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeAccumulate_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ebackpermute\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeBackpermute",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v Int -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Same as backpermute but without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeBackpermute",
          "normalized": "a b-\u003ea Int-\u003ea b",
          "package": "vector-functorlazy",
          "partial": "Backpermute",
          "signature": "v a-\u003ev Int-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeBackpermute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Copy an immutable vector into a mutable one. The two vectors must\n have the same length. This is not checked.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeCopy",
          "package": "vector-functorlazy",
          "signature": "Mutable v (PrimState m) a -\u003e v a -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Copy an immutable vector into mutable one The two vectors must have the same length This is not checked",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeCopy",
          "normalized": "Mutable a(PrimState b)c-\u003ea c-\u003eb()",
          "package": "vector-functorlazy",
          "partial": "Copy",
          "signature": "Mutable v(PrimState m)a-\u003ev a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeCopy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe convert a mutable vector to an immutable one without\n copying. The mutable vector may not be used after this operation.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeFreeze",
          "package": "vector-functorlazy",
          "signature": "Mutable v (PrimState m) a -\u003e m (v a)",
          "type": "function"
        },
        "index": {
          "description": "Unsafe convert mutable vector to an immutable one without copying The mutable vector may not be used after this operation",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeFreeze",
          "normalized": "Mutable a(PrimState b)c-\u003eb(a c)",
          "package": "vector-functorlazy",
          "partial": "Freeze",
          "signature": "Mutable v(PrimState m)a-\u003em(v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeFreeze"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element without checking if the vector is empty\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeHead",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "First element without checking if the vector is empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeHead",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "partial": "Head",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e First element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeHeadM",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "First element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeHeadM",
          "normalized": "a b-\u003ec b",
          "package": "vector-functorlazy",
          "partial": "Head",
          "signature": "v a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeHeadM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafe indexing without bounds checking\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeIndex",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Unsafe indexing without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeIndex",
          "normalized": "a b-\u003eInt-\u003eb",
          "package": "vector-functorlazy",
          "partial": "Index",
          "signature": "v a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Indexing in a monad without bounds checks. See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an\n explanation of why this is useful.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeIndexM",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e Int -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Indexing in monad without bounds checks See indexM for an explanation of why this is useful",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeIndexM",
          "normalized": "a b-\u003eInt-\u003ec b",
          "package": "vector-functorlazy",
          "partial": "Index",
          "signature": "v a-\u003eInt-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeIndexM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element without checking if the vector is empty\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeLast",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Last element without checking if the vector is empty",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeLast",
          "normalized": "a b-\u003eb",
          "package": "vector-functorlazy",
          "partial": "Last",
          "signature": "v a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Last element in a monad without checking for empty vectors.\n See \u003ccode\u003e\u003ca\u003eindexM\u003c/a\u003e\u003c/code\u003e for an explanation of why this is useful.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeLastM",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Last element in monad without checking for empty vectors See indexM for an explanation of why this is useful",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeLastM",
          "normalized": "a b-\u003ec b",
          "package": "vector-functorlazy",
          "partial": "Last",
          "signature": "v a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeLastM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Unsafely convert an immutable vector to a mutable one without\n copying. The immutable vector may not be used after this operation.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeThaw",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e m (Mutable v (PrimState m) a)",
          "type": "function"
        },
        "index": {
          "description": "Unsafely convert an immutable vector to mutable one without copying The immutable vector may not be used after this operation",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeThaw",
          "normalized": "a b-\u003ec(Mutable a(PrimState c)b)",
          "package": "vector-functorlazy",
          "partial": "Thaw",
          "signature": "v a-\u003em(Mutable v(PrimState m)a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeThaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as (\u003ccode\u003e\u003ca\u003e//\u003c/a\u003e\u003c/code\u003e) but without bounds checking.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeUpd",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e [(Int, a)] -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Same as but without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeUpd",
          "normalized": "a b-\u003e[(Int,b)]-\u003ea b",
          "package": "vector-functorlazy",
          "partial": "Upd",
          "signature": "v a-\u003e[(Int,a)]-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeUpd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeUpdate",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v (Int, a) -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Same as update but without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeUpdate",
          "normalized": "a b-\u003ea(Int,b)-\u003ea b",
          "package": "vector-functorlazy",
          "partial": "Update",
          "signature": "v a-\u003ev(Int,a)-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003eupdate_\u003c/a\u003e\u003c/code\u003e but without bounds checking.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeUpdate_",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v Int -\u003e v a -\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "Same as update but without bounds checking",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unsafeUpdate_",
          "normalized": "a b-\u003ea Int-\u003ea b-\u003ea b",
          "package": "vector-functorlazy",
          "partial": "Update",
          "signature": "v a-\u003ev Int-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unsafeUpdate_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Unzip a vector of pairs.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip",
          "package": "vector-functorlazy",
          "signature": "v (a, b) -\u003e (v a, v b)",
          "type": "function"
        },
        "index": {
          "description": "min Unzip vector of pairs",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip",
          "normalized": "a(b,c)-\u003e(a b,a c)",
          "package": "vector-functorlazy",
          "signature": "v(a,b)-\u003e(v a,v b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip3",
          "package": "vector-functorlazy",
          "signature": "v (a, b, c) -\u003e (v a, v b, v c)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip3",
          "normalized": "a(b,c,d)-\u003e(a b,a c,a d)",
          "package": "vector-functorlazy",
          "signature": "v(a,b,c)-\u003e(v a,v b,v c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip4",
          "package": "vector-functorlazy",
          "signature": "v (a, b, c, d) -\u003e (v a, v b, v c, v d)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip4",
          "normalized": "a(b,c,d,e)-\u003e(a b,a c,a d,a e)",
          "package": "vector-functorlazy",
          "signature": "v(a,b,c,d)-\u003e(v a,v b,v c,v d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unzip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip5",
          "package": "vector-functorlazy",
          "signature": "v (a, b, c, d, e) -\u003e (v a, v b, v c, v d, v e)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip5",
          "normalized": "a(b,c,d,e,f)-\u003e(a b,a c,a d,a e,a f)",
          "package": "vector-functorlazy",
          "signature": "v(a,b,c,d,e)-\u003e(v a,v b,v c,v d,v e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unzip5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip6",
          "package": "vector-functorlazy",
          "signature": "v (a, b, c, d, e, f) -\u003e (v a, v b, v c, v d, v e, v f)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "unzip6",
          "normalized": "a(b,c,d,e,f,g)-\u003e(a b,a c,a d,a e,a f,a g)",
          "package": "vector-functorlazy",
          "signature": "v(a,b,c,d,e,f)-\u003e(v a,v b,v c,v d,v e,v f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:unzip6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(m+n)\u003c/em\u003e For each pair \u003ccode\u003e(i,a)\u003c/code\u003e from the vector of index/value pairs,\n replace the vector element at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update \u003c5,9,2,7\u003e \u003c(2,1),(0,3),(2,8)\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "update",
          "package": "vector-functorlazy",
          "signature": "v a-\u003e v (Int, a)-\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "For each pair from the vector of index value pairs replace the vector element at position by update",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "update",
          "normalized": "a b-\u003ea(Int,b)-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev(Int,a)-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(m+min(n1,n2))\u003c/em\u003e For each index \u003ccode\u003ei\u003c/code\u003e from the index vector and the\n corresponding value \u003ccode\u003ea\u003c/code\u003e from the value vector, replace the element of the\n initial vector at position \u003ccode\u003ei\u003c/code\u003e by \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e update_ \u003c5,9,2,7\u003e  \u003c2,0,2\u003e \u003c1,3,8\u003e = \u003c3,9,8,7\u003e\n\u003c/pre\u003e\u003cp\u003eThis function is useful for instances of \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e that cannot store pairs.\n Otherwise, \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e is probably more convenient.\n\u003c/p\u003e\u003cpre\u003e\n update_ xs is ys = \u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e xs (\u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e is ys)\n\u003c/pre\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "update_",
          "package": "vector-functorlazy",
          "signature": "v a-\u003e v Int-\u003e v a-\u003e v a",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 For each index from the index vector and the corresponding value from the value vector replace the element of the initial vector at position by update This function is useful for instances of Vector that cannot store pairs Otherwise update is probably more convenient update xs is ys update xs zip is ys",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "update_",
          "normalized": "a b-\u003ea Int-\u003ea b-\u003ea b",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev Int-\u003ev a-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:update_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "zip",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v b -\u003e v (a, b)",
          "type": "function"
        },
        "index": {
          "description": "min Zip two vectors",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zip",
          "normalized": "a b-\u003ea c-\u003ea(b,c)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev b-\u003ev(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "zip3",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v b -\u003e v c -\u003e v (a, b, c)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zip3",
          "normalized": "a b-\u003ea c-\u003ea d-\u003ea(b,c,d)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev b-\u003ev c-\u003ev(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "zip4",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v b -\u003e v c -\u003e v d -\u003e v (a, b, c, d)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zip4",
          "normalized": "a b-\u003ea c-\u003ea d-\u003ea e-\u003ea(b,c,d,e)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev b-\u003ev c-\u003ev d-\u003ev(a,b,c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "zip5",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v (a, b, c, d, e)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zip5",
          "normalized": "a b-\u003ea c-\u003ea d-\u003ea e-\u003ea f-\u003ea(b,c,d,e,f)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev(a,b,c,d,e)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zip5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "zip6",
          "package": "vector-functorlazy",
          "signature": "v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f -\u003e v (a, b, c, d, e, f)",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zip6",
          "normalized": "a b-\u003ea c-\u003ea d-\u003ea e-\u003ea f-\u003ea g-\u003ea(b,c,d,e,f,g)",
          "package": "vector-functorlazy",
          "signature": "v a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f-\u003ev(a,b,c,d,e,f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zip6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip two vectors with the given function.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e c) -\u003e v a -\u003e v b -\u003e v c",
          "type": "function"
        },
        "index": {
          "description": "min Zip two vectors with the given function",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003ev a-\u003ev b-\u003ev c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eZip three vectors with the given function.\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith3",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e v a -\u003e v b -\u003e v c -\u003e v d",
          "type": "function"
        },
        "index": {
          "description": "Zip three vectors with the given function",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003ev a-\u003ev b-\u003ev c-\u003ev d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zipWith3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith4",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith5",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith5",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eg b-\u003eg c-\u003eg d-\u003eg e-\u003eg f",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zipWith5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith6",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e v a -\u003e v b -\u003e v c -\u003e v d -\u003e v e -\u003e v f -\u003e v g",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWith6",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003eh a-\u003eh b-\u003eh c-\u003eh d-\u003eh e-\u003eh f-\u003eh g",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003ev a-\u003ev b-\u003ev c-\u003ev d-\u003ev e-\u003ev f-\u003ev g",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zipWith6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and yield a\n vector of results\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWithM",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e m c) -\u003e v a -\u003e v b -\u003e m (v c)",
          "type": "function"
        },
        "index": {
          "description": "min Zip the two vectors with the monadic action and yield vector of results",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWithM",
          "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ee b-\u003ec(e d)",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(a-\u003eb-\u003em c)-\u003ev a-\u003ev b-\u003em(v c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zipWithM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(m,n))\u003c/em\u003e Zip the two vectors with the monadic action and ignore the\n results\n\u003c/p\u003e",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWithM_",
          "package": "vector-functorlazy",
          "signature": "(a -\u003e b -\u003e m c) -\u003e v a -\u003e v b -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "min Zip the two vectors with the monadic action and ignore the results",
          "hierarchy": "Data Vector FunctorLazy",
          "module": "Data.Vector.FunctorLazy",
          "name": "zipWithM_",
          "normalized": "(a-\u003eb-\u003ec d)-\u003ee a-\u003ee b-\u003ec()",
          "package": "vector-functorlazy",
          "partial": "With",
          "signature": "(a-\u003eb-\u003em c)-\u003ev a-\u003ev b-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/vector-functorlazy/docs/Data-Vector-FunctorLazy.html#v:zipWithM_"
      }
    }
  ]
]