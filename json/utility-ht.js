[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "utility-ht"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Functor.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Control-Functor-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Functor HT",
          "module": "Control.Functor.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Functor-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Functor.HT",
          "name": "for",
          "package": "utility-ht",
          "signature": "f a -\u003e (a -\u003e b) -\u003e f b",
          "source": "src/Control-Functor-HT.html#for",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Functor HT",
          "module": "Control.Functor.HT",
          "name": "for",
          "normalized": "a b-\u003e(b-\u003ec)-\u003ea c",
          "package": "utility-ht",
          "signature": "f a-\u003e(a-\u003eb)-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Functor-HT.html#v:for"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Functor.HT",
          "name": "map",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/Control-Functor-HT.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Functor HT",
          "module": "Control.Functor.HT",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Functor-HT.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Functor.HT",
          "name": "unzip",
          "package": "utility-ht",
          "signature": "f (a, b) -\u003e (f a, f b)",
          "source": "src/Control-Functor-HT.html#unzip",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Functor HT",
          "module": "Control.Functor.HT",
          "name": "unzip",
          "normalized": "a(b,c)-\u003e(a b,a c)",
          "package": "utility-ht",
          "signature": "f(a,b)-\u003e(f a,f b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Functor-HT.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Functor.HT",
          "name": "unzip3",
          "package": "utility-ht",
          "signature": "f (a, b, c) -\u003e (f a, f b, f c)",
          "source": "src/Control-Functor-HT.html#unzip3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Functor HT",
          "module": "Control.Functor.HT",
          "name": "unzip3",
          "normalized": "a(b,c,d)-\u003e(a b,a c,a d)",
          "package": "utility-ht",
          "signature": "f(a,b,c)-\u003e(f a,f b,f c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Functor-HT.html#v:unzip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Functor.HT",
          "name": "void",
          "package": "utility-ht",
          "signature": "f a -\u003e f ()",
          "source": "src/Control-Functor-HT.html#void",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Functor HT",
          "module": "Control.Functor.HT",
          "name": "void",
          "normalized": "a b-\u003ea()",
          "package": "utility-ht",
          "signature": "f a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Functor-HT.html#v:void"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Control-Monad-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlso present in newer versions of the \u003ccode\u003ebase\u003c/code\u003e package.\n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "(\u003c=\u003c)",
          "package": "utility-ht",
          "signature": "(b -\u003e m c) -\u003e (a -\u003e m b) -\u003e a -\u003e m c",
          "source": "src/Control-Monad-HT.html#%3C%3D%3C",
          "type": "function"
        },
        "index": {
          "description": "Also present in newer versions of the base package",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "(\u003c=\u003c) \u003c=\u003c",
          "normalized": "(a-\u003eb c)-\u003e(d-\u003eb a)-\u003ed-\u003eb c",
          "package": "utility-ht",
          "signature": "(b-\u003em c)-\u003e(a-\u003em b)-\u003ea-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:-60--61--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLazy monadic conjunction.\nThat is, when the first action returns \u003ccode\u003eFalse\u003c/code\u003e,\nthen \u003ccode\u003eFalse\u003c/code\u003e is immediately returned, without running the second action.\n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "andLazy",
          "package": "utility-ht",
          "signature": "m Bool -\u003e m Bool -\u003e m Bool",
          "source": "src/Control-Monad-HT.html#andLazy",
          "type": "function"
        },
        "index": {
          "description": "Lazy monadic conjunction That is when the first action returns False then False is immediately returned without running the second action",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "andLazy",
          "normalized": "a Bool-\u003ea Bool-\u003ea Bool",
          "package": "utility-ht",
          "partial": "Lazy",
          "signature": "m Bool-\u003em Bool-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:andLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "filter",
          "package": "utility-ht",
          "signature": "(a -\u003e m Bool) -\u003e [a] -\u003e m [a]",
          "source": "src/Control-Monad-HT.html#filter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "filter",
          "normalized": "(a-\u003eb Bool)-\u003e[a]-\u003eb[a]",
          "package": "utility-ht",
          "signature": "(a-\u003em Bool)-\u003e[a]-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "for",
          "package": "utility-ht",
          "signature": "[a] -\u003e (a -\u003e m b) -\u003e m [b]",
          "source": "src/Control-Monad-HT.html#for",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "for",
          "normalized": "[a]-\u003e(a-\u003eb c)-\u003eb[c]",
          "package": "utility-ht",
          "signature": "[a]-\u003e(a-\u003em b)-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:for"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparameter order equal to that of \u003ccode\u003enest\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "iterateLimit",
          "package": "utility-ht",
          "signature": "Int -\u003e (a -\u003e m a) -\u003e a -\u003e m [a]",
          "source": "src/Control-Monad-HT.html#iterateLimit",
          "type": "function"
        },
        "index": {
          "description": "parameter order equal to that of nest",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "iterateLimit",
          "normalized": "Int-\u003e(a-\u003eb a)-\u003ea-\u003eb[a]",
          "package": "utility-ht",
          "partial": "Limit",
          "signature": "Int-\u003e(a-\u003em a)-\u003ea-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:iterateLimit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use M.iterateLimit\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eparameter order equal to that of \u003ccode\u003enest\u003c/code\u003e \n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "iterateLimitM",
          "package": "utility-ht",
          "signature": "Int -\u003e (a -\u003e m a) -\u003e a -\u003e m [a]",
          "source": "src/Control-Monad-HT.html#iterateLimitM",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use M.iterateLimit parameter order equal to that of nest",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "iterateLimitM",
          "normalized": "Int-\u003e(a-\u003eb a)-\u003ea-\u003eb[a]",
          "package": "utility-ht",
          "partial": "Limit",
          "signature": "Int-\u003e(a-\u003em a)-\u003ea-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:iterateLimitM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "lift",
          "package": "utility-ht",
          "signature": "(a -\u003e r) -\u003e m a -\u003e m r",
          "source": "src/Control-Monad-HT.html#lift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "lift",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "utility-ht",
          "signature": "(a-\u003er)-\u003em a-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "lift2",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e r) -\u003e m a -\u003e m b -\u003e m r",
          "source": "src/Control-Monad-HT.html#lift2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "lift2",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed a-\u003ed b-\u003ed c",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003er)-\u003em a-\u003em b-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:lift2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "lift3",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c -\u003e r) -\u003e m a -\u003e m b -\u003e m c -\u003e m r",
          "source": "src/Control-Monad-HT.html#lift3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "lift3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ee a-\u003ee b-\u003ee c-\u003ee d",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ec-\u003er)-\u003em a-\u003em b-\u003em c-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:lift3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "lift4",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e r) -\u003e m a -\u003e m b -\u003e m c -\u003e m d -\u003e m r",
          "source": "src/Control-Monad-HT.html#lift4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "lift4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ef a-\u003ef b-\u003ef c-\u003ef d-\u003ef e",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003er)-\u003em a-\u003em b-\u003em c-\u003em d-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:lift4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "lift5",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e r) -\u003e m a -\u003e m b -\u003e m c -\u003e m d -\u003e m e -\u003e m r",
          "source": "src/Control-Monad-HT.html#lift5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "lift5",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003eg a-\u003eg b-\u003eg c-\u003eg d-\u003eg e-\u003eg f",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003er)-\u003em a-\u003em b-\u003em c-\u003em d-\u003em e-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:lift5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "map",
          "package": "utility-ht",
          "signature": "(a -\u003e m b) -\u003e [a] -\u003e m [b]",
          "source": "src/Control-Monad-HT.html#map",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "map",
          "normalized": "(a-\u003eb c)-\u003e[a]-\u003eb[c]",
          "package": "utility-ht",
          "signature": "(a-\u003em b)-\u003e[a]-\u003em[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLazy monadic disjunction.\nThat is, when the first action returns \u003ccode\u003eTrue\u003c/code\u003e,\nthen \u003ccode\u003eTrue\u003c/code\u003e is immediately returned, without running the second action.\n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "orLazy",
          "package": "utility-ht",
          "signature": "m Bool -\u003e m Bool -\u003e m Bool",
          "source": "src/Control-Monad-HT.html#orLazy",
          "type": "function"
        },
        "index": {
          "description": "Lazy monadic disjunction That is when the first action returns True then True is immediately returned without running the second action",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "orLazy",
          "normalized": "a Bool-\u003ea Bool-\u003ea Bool",
          "package": "utility-ht",
          "partial": "Lazy",
          "signature": "m Bool-\u003em Bool-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:orLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic \u003ccode\u003e\u003ca\u003erepeat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "repeat",
          "package": "utility-ht",
          "signature": "m a -\u003e m [a]",
          "source": "src/Control-Monad-HT.html#repeat",
          "type": "function"
        },
        "index": {
          "description": "Monadic repeat",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "repeat",
          "normalized": "a b-\u003ea[b]",
          "package": "utility-ht",
          "signature": "m a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "replicate",
          "package": "utility-ht",
          "signature": "Int -\u003e m a -\u003e m [a]",
          "source": "src/Control-Monad-HT.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "replicate",
          "normalized": "Int-\u003ea b-\u003ea[b]",
          "package": "utility-ht",
          "signature": "Int-\u003em a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erepeat action until result fulfills condition \n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "until",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e m a -\u003e m a",
          "source": "src/Control-Monad-HT.html#until",
          "type": "function"
        },
        "index": {
          "description": "repeat action until result fulfills condition",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "until",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "utility-ht",
          "signature": "(a-\u003eBool)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:until"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use M.until\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003erepeat action until result fulfills condition \n\u003c/p\u003e",
          "module": "Control.Monad.HT",
          "name": "untilM",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e m a -\u003e m a",
          "source": "src/Control-Monad-HT.html#untilM",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use M.until repeat action until result fulfills condition",
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "untilM",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "utility-ht",
          "signature": "(a-\u003eBool)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:untilM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "void",
          "package": "utility-ht",
          "signature": "m a -\u003e m ()",
          "source": "src/Control-Monad-HT.html#void",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "void",
          "normalized": "a b-\u003ea()",
          "package": "utility-ht",
          "signature": "m a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:void"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.HT",
          "name": "zipWith",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e m c) -\u003e [a] -\u003e [b] -\u003e m [c]",
          "source": "src/Control-Monad-HT.html#zipWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad HT",
          "module": "Control.Monad.HT",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec d)-\u003e[a]-\u003e[b]-\u003ec[d]",
          "package": "utility-ht",
          "partial": "With",
          "signature": "(a-\u003eb-\u003em c)-\u003e[a]-\u003e[b]-\u003em[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Control-Monad-HT.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bool.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Bool-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Bool HT",
          "module": "Data.Bool.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Bool-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike the \u003ccode\u003e?\u003c/code\u003e operator of the C progamming language.\nExample: \u003ccode\u003ebool ?: (\u003ca\u003eyes\u003c/a\u003e, \u003ca\u003eno\u003c/a\u003e)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Bool.HT",
          "name": "(?:)",
          "package": "utility-ht",
          "signature": "Bool -\u003e (a, a) -\u003e a",
          "source": "src/Data-Bool-HT-Private.html#%3F%3A",
          "type": "function"
        },
        "index": {
          "description": "Like the operator of the progamming language Example bool yes no",
          "hierarchy": "Data Bool HT",
          "module": "Data.Bool.HT",
          "name": "(?:) ?:",
          "normalized": "Bool-\u003e(a,a)-\u003ea",
          "package": "utility-ht",
          "signature": "Bool-\u003e(a,a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Bool-HT.html#v:-63-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eif-then-else\u003c/code\u003e as function.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e if' (even n) \"even\" $\n if' (isPrime n) \"prime\" $\n \"boring\"\n\u003c/pre\u003e",
          "module": "Data.Bool.HT",
          "name": "if'",
          "package": "utility-ht",
          "signature": "Bool -\u003e a -\u003e a -\u003e a",
          "source": "src/Data-Bool-HT-Private.html#if%27",
          "type": "function"
        },
        "index": {
          "description": "if-then-else as function Example if even even if isPrime prime boring",
          "hierarchy": "Data Bool HT",
          "module": "Data.Bool.HT",
          "name": "if'",
          "normalized": "Bool-\u003ea-\u003ea-\u003ea",
          "package": "utility-ht",
          "signature": "Bool-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Bool-HT.html#v:if-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003eif'\u003c/a\u003e\u003c/code\u003e, but the name is chosen\nsuch that it can be used for GHC-7.0's rebindable if-then-else syntax.\n\u003c/p\u003e",
          "module": "Data.Bool.HT",
          "name": "ifThenElse",
          "package": "utility-ht",
          "signature": "Bool -\u003e a -\u003e a -\u003e a",
          "source": "src/Data-Bool-HT-Private.html#ifThenElse",
          "type": "function"
        },
        "index": {
          "description": "The same as if but the name is chosen such that it can be used for GHC-7.0 rebindable if-then-else syntax",
          "hierarchy": "Data Bool HT",
          "module": "Data.Bool.HT",
          "name": "ifThenElse",
          "normalized": "Bool-\u003ea-\u003ea-\u003ea",
          "package": "utility-ht",
          "partial": "Then Else",
          "signature": "Bool-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Bool-HT.html#v:ifThenElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical operator for implication.\n\u003c/p\u003e\u003cp\u003eFunnily because of the ordering of \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e it holds \u003ccode\u003eimplies == (\u003c=)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Bool.HT",
          "name": "implies",
          "package": "utility-ht",
          "signature": "Bool -\u003e Bool -\u003e Bool",
          "source": "src/Data-Bool-HT-Private.html#implies",
          "type": "function"
        },
        "index": {
          "description": "Logical operator for implication Funnily because of the ordering of Bool it holds implies",
          "hierarchy": "Data Bool HT",
          "module": "Data.Bool.HT",
          "name": "implies",
          "normalized": "Bool-\u003eBool-\u003eBool",
          "package": "utility-ht",
          "signature": "Bool-\u003eBool-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Bool-HT.html#v:implies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrom a list of expressions choose the one,\nwhose condition is true.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e select \"boring\" $\n   (even n, \"even\") :\n   (isPrime n, \"prime\") :\n   []\n\u003c/pre\u003e",
          "module": "Data.Bool.HT",
          "name": "select",
          "package": "utility-ht",
          "signature": "a -\u003e [(Bool, a)] -\u003e a",
          "source": "src/Data-Bool-HT-Private.html#select",
          "type": "function"
        },
        "index": {
          "description": "From list of expressions choose the one whose condition is true Example select boring even even isPrime prime",
          "hierarchy": "Data Bool HT",
          "module": "Data.Bool.HT",
          "name": "select",
          "normalized": "a-\u003e[(Bool,a)]-\u003ea",
          "package": "utility-ht",
          "signature": "a-\u003e[(Bool,a)]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Bool-HT.html#v:select"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Eq.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Eq-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Eq HT",
          "module": "Data.Eq.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Eq-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Eq.HT",
          "name": "equating",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Data-Eq-HT.html#equating",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Eq HT",
          "module": "Data.Eq.HT",
          "name": "equating",
          "normalized": "(a-\u003eb)-\u003ea-\u003ea-\u003eBool",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Eq-HT.html#v:equating"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Function.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Function-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Function HT",
          "module": "Data.Function.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Function-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKnown as \u003ccode\u003eon\u003c/code\u003e in newer versions of the \u003ccode\u003ebase\u003c/code\u003e package.\n\u003c/p\u003e",
          "module": "Data.Function.HT",
          "name": "compose2",
          "package": "utility-ht",
          "signature": "(b -\u003e b -\u003e c) -\u003e (a -\u003e b) -\u003e a -\u003e a -\u003e c",
          "source": "src/Data-Function-HT.html#compose2",
          "type": "function"
        },
        "index": {
          "description": "Known as on in newer versions of the base package",
          "hierarchy": "Data Function HT",
          "module": "Data.Function.HT",
          "name": "compose2",
          "normalized": "(a-\u003ea-\u003eb)-\u003e(c-\u003ea)-\u003ec-\u003ec-\u003eb",
          "package": "utility-ht",
          "signature": "(b-\u003eb-\u003ec)-\u003e(a-\u003eb)-\u003ea-\u003ea-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Function-HT.html#v:compose2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompositional power of a function,\ni.e. apply the function \u003ccode\u003en\u003c/code\u003e times to a value.\nIt is rather the same as \u003ccode\u003eiter\u003c/code\u003e\nin Simon Thompson: \"The Craft of Functional Programming\", page 172\n\u003c/p\u003e",
          "module": "Data.Function.HT",
          "name": "nest",
          "package": "utility-ht",
          "signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e a",
          "source": "src/Data-Function-HT-Private.html#nest",
          "type": "function"
        },
        "index": {
          "description": "Compositional power of function i.e apply the function times to value It is rather the same as iter in Simon Thompson The Craft of Functional Programming page",
          "hierarchy": "Data Function HT",
          "module": "Data.Function.HT",
          "name": "nest",
          "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003ea",
          "package": "utility-ht",
          "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Function-HT.html#v:nest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epowerAssociative\u003c/code\u003e is an auxiliary function that,\nfor an associative operation \u003ccode\u003eop\u003c/code\u003e,\ncomputes the same value as\n\u003c/p\u003e\u003cpre\u003epowerAssociative op a0 a n = foldr op a0 (genericReplicate n a)\u003c/pre\u003e\u003cp\u003ebut applies \u003ca\u003eop\u003c/a\u003e O(log n) times and works for large n.\n\u003c/p\u003e",
          "module": "Data.Function.HT",
          "name": "powerAssociative",
          "package": "utility-ht",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e a -\u003e Integer -\u003e a",
          "source": "src/Data-Function-HT-Private.html#powerAssociative",
          "type": "function"
        },
        "index": {
          "description": "powerAssociative is an auxiliary function that for an associative operation op computes the same value as powerAssociative op a0 foldr op a0 genericReplicate but applies op log times and works for large",
          "hierarchy": "Data Function HT",
          "module": "Data.Function.HT",
          "name": "powerAssociative",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eInteger-\u003ea",
          "package": "utility-ht",
          "partial": "Associative",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003ea-\u003eInteger-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Function-HT.html#v:powerAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eImplementations of \u003ccode\u003eIx\u003c/code\u003e methods in terms of \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e methods.\n\u003c/p\u003e\u003cp\u003eFor a type \u003ccode\u003eT\u003c/code\u003e of class \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e you can easily define an \u003ccode\u003eIx\u003c/code\u003e instance\nby copying the following code into your module:\n\u003c/p\u003e\u003cpre\u003eimport qualified Data.Ix.Enum as IxEnum\n\ninstance Ix T where\n   range           = IxEnum.range\n   index           = IxEnum.index\n   inRange         = IxEnum.inRange\n   rangeSize       = IxEnum.rangeSize\n   unsafeIndex     = IxEnum.unsafeIndex\n   unsafeRangeSize = IxEnum.unsafeRangeSize\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.Ix.Enum",
          "name": "Enum",
          "package": "utility-ht",
          "source": "src/Data-Ix-Enum.html",
          "type": "module"
        },
        "index": {
          "description": "Implementations of Ix methods in terms of Enum methods For type of class Enum you can easily define an Ix instance by copying the following code into your module import qualified Data.Ix.Enum as IxEnum instance Ix where range IxEnum.range index IxEnum.index inRange IxEnum.inRange rangeSize IxEnum.rangeSize unsafeIndex IxEnum.unsafeIndex unsafeRangeSize IxEnum.unsafeRangeSize",
          "hierarchy": "Data Ix Enum",
          "module": "Data.Ix.Enum",
          "name": "Enum",
          "package": "utility-ht",
          "partial": "Enum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ix-Enum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ix.Enum",
          "name": "inRange",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e a -\u003e Bool",
          "source": "src/Data-Ix-Enum.html#inRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ix Enum",
          "module": "Data.Ix.Enum",
          "name": "inRange",
          "normalized": "(a,a)-\u003ea-\u003eBool",
          "package": "utility-ht",
          "partial": "Range",
          "signature": "(a,a)-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ix-Enum.html#v:inRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ix.Enum",
          "name": "index",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e a -\u003e Int",
          "source": "src/Data-Ix-Enum.html#index",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ix Enum",
          "module": "Data.Ix.Enum",
          "name": "index",
          "normalized": "(a,a)-\u003ea-\u003eInt",
          "package": "utility-ht",
          "signature": "(a,a)-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ix-Enum.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ix.Enum",
          "name": "range",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e [a]",
          "source": "src/Data-Ix-Enum.html#range",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ix Enum",
          "module": "Data.Ix.Enum",
          "name": "range",
          "normalized": "(a,a)-\u003e[a]",
          "package": "utility-ht",
          "signature": "(a,a)-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ix-Enum.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ix.Enum",
          "name": "rangeSize",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e Int",
          "source": "src/Data-Ix-Enum.html#rangeSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ix Enum",
          "module": "Data.Ix.Enum",
          "name": "rangeSize",
          "normalized": "(a,a)-\u003eInt",
          "package": "utility-ht",
          "partial": "Size",
          "signature": "(a,a)-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ix-Enum.html#v:rangeSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ix.Enum",
          "name": "unsafeIndex",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e a -\u003e Int",
          "source": "src/Data-Ix-Enum.html#unsafeIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ix Enum",
          "module": "Data.Ix.Enum",
          "name": "unsafeIndex",
          "normalized": "(a,a)-\u003ea-\u003eInt",
          "package": "utility-ht",
          "partial": "Index",
          "signature": "(a,a)-\u003ea-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ix-Enum.html#v:unsafeIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ix.Enum",
          "name": "unsafeRangeSize",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e Int",
          "source": "src/Data-Ix-Enum.html#unsafeRangeSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ix Enum",
          "module": "Data.Ix.Enum",
          "name": "unsafeRangeSize",
          "normalized": "(a,a)-\u003eInt",
          "package": "utility-ht",
          "partial": "Range Size",
          "signature": "(a,a)-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ix-Enum.html#v:unsafeRangeSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-List-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "allEqual",
          "package": "utility-ht",
          "signature": "[a] -\u003e Bool",
          "source": "src/Data-List-HT-Private.html#allEqual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "allEqual",
          "normalized": "[a]-\u003eBool",
          "package": "utility-ht",
          "partial": "Equal",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:allEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is \u003ccode\u003eData.List.span f undefined = undefined\u003c/code\u003e,\nwhereas \u003ccode\u003espan f undefined = (undefined, undefined)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "break",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Data-List-HT-Private.html#break",
          "type": "function"
        },
        "index": {
          "description": "It is Data.List.span undefined undefined whereas span undefined undefined undefined",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "break",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "utility-ht",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:break"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ebreak\u003c/a\u003e\u003c/code\u003e, but splits after the matching element.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "breakAfter",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Data-List-HT-Private.html#breakAfter",
          "type": "function"
        },
        "index": {
          "description": "Like break but splits after the matching element",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "breakAfter",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "utility-ht",
          "partial": "After",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:breakAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the list at the occurrences of a separator into sub-lists.\nRemove the separators.\nThis is somehow a generalization of \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e.\nBut note the differences:\n\u003c/p\u003e\u003cpre\u003e Prelude Data.List.HT\u003e words \"a  a\"\n [\"a\",\"a\"]\n Prelude Data.List.HT\u003e chop (' '==) \"a  a\"\n [\"a\",\"\",\"a\"]\n\u003c/pre\u003e\u003cpre\u003e Prelude Data.List.HT\u003e lines \"a\\n\\na\"\n [\"a\",\"\",\"a\"]\n Prelude Data.List.HT\u003e chop ('\\n'==) \"a\\n\\na\"\n [\"a\",\"\",\"a\"]\n\u003c/pre\u003e\u003cpre\u003e Prelude Data.List.HT\u003e lines \"a\\n\"\n [\"a\"]\n Prelude Data.List.HT\u003e chop ('\\n'==) \"a\\n\"\n [\"a\",\"\"]\n\u003c/pre\u003e",
          "module": "Data.List.HT",
          "name": "chop",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#chop",
          "type": "function"
        },
        "index": {
          "description": "Split the list at the occurrences of separator into sub-lists Remove the separators This is somehow generalization of lines and words But note the differences Prelude Data.List.HT words Prelude Data.List.HT chop Prelude Data.List.HT lines na Prelude Data.List.HT chop na Prelude Data.List.HT lines Prelude Data.List.HT chop",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "chop",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "utility-ht",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:chop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove the longest suffix of elements satisfying p.\nIn contrast to \u003ccode\u003ereverse . dropWhile p . reverse\u003c/code\u003e\nthis works for infinite lists, too.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "dropWhileRev",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#dropWhileRev",
          "type": "function"
        },
        "index": {
          "description": "Remove the longest suffix of elements satisfying In contrast to reverse dropWhile reverse this works for infinite lists too",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "dropWhileRev",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "While Rev",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:dropWhileRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "group",
          "package": "utility-ht",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#group",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "group",
          "normalized": "[a]-\u003e[[a]]",
          "package": "utility-ht",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function compares adjacent elements of a list.\nIf two adjacent elements satisfy a relation then they are put into the same sublist.\nExample:\n\u003c/p\u003e\u003cpre\u003e groupBy (\u003c) \"abcdebcdef\"  ==  [\"abcde\",\"bcdef\"]\n\u003c/pre\u003e\u003cp\u003eIn contrast to that \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e compares\nthe head of each sublist with each candidate for this sublist.\nThis yields\n\u003c/p\u003e\u003cpre\u003e List.groupBy (\u003c) \"abcdebcdef\"  ==  [\"abcdebcdef\"]\n\u003c/pre\u003e\u003cp\u003eThe second \u003ccode\u003e\u003ccode\u003eb\u003c/code\u003e\u003c/code\u003e is compared with the leading \u003ccode\u003e\u003ccode\u003ea\u003c/code\u003e\u003c/code\u003e.\nThus it is put into the same sublist as \u003ccode\u003e\u003ccode\u003ea\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe sublists are never empty.\nThus the more precise result type would be \u003ccode\u003e[(a,[a])]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "groupBy",
          "package": "utility-ht",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#groupBy",
          "type": "function"
        },
        "index": {
          "description": "This function compares adjacent elements of list If two adjacent elements satisfy relation then they are put into the same sublist Example groupBy abcdebcdef abcde bcdef In contrast to that groupBy compares the head of each sublist with each candidate for this sublist This yields List.groupBy abcdebcdef abcdebcdef The second is compared with the leading Thus it is put into the same sublist as The sublists are never empty Thus the more precise result type would be",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "groupBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "utility-ht",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:groupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is lazier than the one suggested in the Haskell 98 report.\nIt is \u003ccode\u003einits undefined = [] : undefined\u003c/code\u003e,\nin contrast to \u003ccode\u003eData.List.inits undefined = undefined\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "inits",
          "package": "utility-ht",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#inits",
          "type": "function"
        },
        "index": {
          "description": "This function is lazier than the one suggested in the Haskell report It is inits undefined undefined in contrast to Data.List.inits undefined undefined",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "inits",
          "normalized": "[a]-\u003e[[a]]",
          "package": "utility-ht",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:inits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "isAscending",
          "package": "utility-ht",
          "signature": "[a] -\u003e Bool",
          "source": "src/Data-List-HT-Private.html#isAscending",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "isAscending",
          "normalized": "[a]-\u003eBool",
          "package": "utility-ht",
          "partial": "Ascending",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:isAscending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "isAscendingLazy",
          "package": "utility-ht",
          "signature": "[a] -\u003e [Bool]",
          "source": "src/Data-List-HT-Private.html#isAscendingLazy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "isAscendingLazy",
          "normalized": "[a]-\u003e[Bool]",
          "package": "utility-ht",
          "partial": "Ascending Lazy",
          "signature": "[a]-\u003e[Bool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:isAscendingLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor an associative operation \u003ccode\u003eop\u003c/code\u003e this computes\n   \u003ccode\u003eiterateAssociative op a = iterate (op a) a\u003c/code\u003e\nbut it is even faster than \u003ccode\u003emap (powerAssociative op a a) [0..]\u003c/code\u003e\nsince it shares temporary results.\n\u003c/p\u003e\u003cp\u003eThe idea is:\nFrom the list \u003ccode\u003emap (powerAssociative op a a) [0,(2*n)..]\u003c/code\u003e\nwe compute the list \u003ccode\u003emap (powerAssociative op a a) [0,n..]\u003c/code\u003e,\nand iterate that until \u003ccode\u003en==1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "iterateAssociative",
          "package": "utility-ht",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#iterateAssociative",
          "type": "function"
        },
        "index": {
          "description": "For an associative operation op this computes iterateAssociative op iterate op but it is even faster than map powerAssociative op since it shares temporary results The idea is From the list map powerAssociative op we compute the list map powerAssociative op and iterate that until",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "iterateAssociative",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003e[a]",
          "package": "utility-ht",
          "partial": "Associative",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:iterateAssociative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is equal to \u003ccode\u003e\u003ca\u003eiterateAssociative\u003c/a\u003e\u003c/code\u003e.\nThe idea is the following:\nThe list we search is the fixpoint of the function:\n\u003ca\u003eSquare all elements of the list,\nthen spread it and fill the holes with successive numbers\nof their left neighbour.\u003c/a\u003e\nThis also preserves log n applications per value.\nHowever it has a space leak,\nbecause for the value with index \u003ccode\u003en\u003c/code\u003e\nall elements starting at \u003ccode\u003ediv n 2\u003c/code\u003e must be kept.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "iterateLeaky",
          "package": "utility-ht",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#iterateLeaky",
          "type": "function"
        },
        "index": {
          "description": "This is equal to iterateAssociative The idea is the following The list we search is the fixpoint of the function Square all elements of the list then spread it and fill the holes with successive numbers of their left neighbour This also preserves log applications per value However it has space leak because for the value with index all elements starting at div must be kept",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "iterateLeaky",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003e[a]",
          "package": "utility-ht",
          "partial": "Leaky",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:iterateLeaky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "lengthAtLeast",
          "package": "utility-ht",
          "signature": "Int -\u003e [a] -\u003e Bool",
          "source": "src/Data-List-HT-Private.html#lengthAtLeast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "lengthAtLeast",
          "normalized": "Int-\u003e[a]-\u003eBool",
          "package": "utility-ht",
          "partial": "At Least",
          "signature": "Int-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:lengthAtLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function combines every pair of neighbour elements\nin a list with a certain function.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "mapAdjacent",
          "package": "utility-ht",
          "signature": "(a -\u003e a -\u003e b) -\u003e [a] -\u003e [b]",
          "source": "src/Data-List-HT-Private.html#mapAdjacent",
          "type": "function"
        },
        "index": {
          "description": "This function combines every pair of neighbour elements in list with certain function",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "mapAdjacent",
          "normalized": "(a-\u003ea-\u003eb)-\u003e[a]-\u003e[b]",
          "package": "utility-ht",
          "partial": "Adjacent",
          "signature": "(a-\u003ea-\u003eb)-\u003e[a]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:mapAdjacent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emaybePrefixOf xs ys\u003c/code\u003e is \u003ccode\u003eJust zs\u003c/code\u003e if \u003ccode\u003exs\u003c/code\u003e is a prefix of \u003ccode\u003eys\u003c/code\u003e,\nwhere \u003ccode\u003ezs\u003c/code\u003e is \u003ccode\u003eys\u003c/code\u003e without the prefix \u003ccode\u003exs\u003c/code\u003e.\nOtherwise it is \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "maybePrefixOf",
          "package": "utility-ht",
          "signature": "[a] -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Data-List-HT-Private.html#maybePrefixOf",
          "type": "function"
        },
        "index": {
          "description": "maybePrefixOf xs ys is Just zs if xs is prefix of ys where zs is ys without the prefix xs Otherwise it is Nothing",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "maybePrefixOf",
          "normalized": "[a]-\u003e[a]-\u003eMaybe[a]",
          "package": "utility-ht",
          "partial": "Prefix Of",
          "signature": "[a]-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:maybePrefixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven two lists that are ordered\n(i.e. \u003ccode\u003ep x y\u003c/code\u003e holds for subsequent \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e)\n\u003ccode\u003e\u003ca\u003emergeBy\u003c/a\u003e\u003c/code\u003e them into a list that is ordered, again.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "mergeBy",
          "package": "utility-ht",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#mergeBy",
          "type": "function"
        },
        "index": {
          "description": "Given two lists that are ordered i.e holds for subsequent and mergeBy them into list that is ordered again",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "mergeBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:mergeBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "multiReplace",
          "package": "utility-ht",
          "signature": "[([a], [a])] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#multiReplace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "multiReplace",
          "normalized": "[([a],[a])]-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "Replace",
          "signature": "[([a],[a])]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:multiReplace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperate on each combination of elements of the first and the second list.\nIn contrast to the list instance of \u003ccode\u003e\u003ca\u003eliftM2\u003c/a\u003e\u003c/code\u003e\nin holds the results in a list of lists.\nIt holds\n\u003ccode\u003econcat (outerProduct f xs ys)  ==  liftM2 f xs ys\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "outerProduct",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c) -\u003e [a] -\u003e [b] -\u003e [[c]]",
          "source": "src/Data-List-HT-Private.html#outerProduct",
          "type": "function"
        },
        "index": {
          "description": "Operate on each combination of elements of the first and the second list In contrast to the list instance of liftM2 in holds the results in list of lists It holds concat outerProduct xs ys liftM2 xs ys",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "outerProduct",
          "normalized": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e[[c]]",
          "package": "utility-ht",
          "partial": "Product",
          "signature": "(a-\u003eb-\u003ec)-\u003e[a]-\u003e[b]-\u003e[[c]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:outerProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "padLeft",
          "package": "utility-ht",
          "signature": "a -\u003e Int -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#padLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "padLeft",
          "normalized": "a-\u003eInt-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "Left",
          "signature": "a-\u003eInt-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:padLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "padRight",
          "package": "utility-ht",
          "signature": "a -\u003e Int -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#padRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "padRight",
          "normalized": "a-\u003eInt-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "Right",
          "signature": "a-\u003eInt-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:padRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e of GHC 6.2.1 fails on infinite lists.\nBut this one does not.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "partition",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Data-List-HT-Private.html#partition",
          "type": "function"
        },
        "index": {
          "description": "partition of GHC fails on infinite lists But this one does not",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "utility-ht",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartition a list into elements which evaluate to \u003ccode\u003eJust\u003c/code\u003e or \u003ccode\u003eNothing\u003c/code\u003e by \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIt holds \u003ccode\u003emapMaybe f == fst . partitionMaybe f\u003c/code\u003e\nand \u003ccode\u003epartition p == partitionMaybe ( x -\u003e toMaybe (p x) x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "partitionMaybe",
          "package": "utility-ht",
          "signature": "(a -\u003e Maybe b) -\u003e [a] -\u003e ([b], [a])",
          "source": "src/Data-List-HT-Private.html#partitionMaybe",
          "type": "function"
        },
        "index": {
          "description": "Partition list into elements which evaluate to Just or Nothing by It holds mapMaybe fst partitionMaybe and partition partitionMaybe toMaybe",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "partitionMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003e[a]-\u003e([b],[a])",
          "package": "utility-ht",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003e[a]-\u003e([b],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:partitionMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerate without Enum context.\nFor Enum equivalent to enumFrom.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "range",
          "package": "utility-ht",
          "signature": "Int -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#range",
          "type": "function"
        },
        "index": {
          "description": "Enumerate without Enum context For Enum equivalent to enumFrom",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "range",
          "normalized": "Int-\u003e[a]",
          "package": "utility-ht",
          "signature": "Int-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eremoveEach xs\u003c/code\u003e represents a list of sublists of \u003ccode\u003exs\u003c/code\u003e,\nwhere each element of \u003ccode\u003exs\u003c/code\u003e is removed and\nthe removed element is separated.\nIt seems to be much simpler to achieve with\n\u003ccode\u003ezip xs (map (flip List.delete xs) xs)\u003c/code\u003e,\nbut the implementation of \u003ccode\u003e\u003ca\u003eremoveEach\u003c/a\u003e\u003c/code\u003e does not need the \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instance\nand thus can also be used for lists of functions.\n\u003c/p\u003e\u003cp\u003eSee also the proposal\n \u003ca\u003ehttp://www.haskell.org/pipermail/libraries/2008-February/009270.html\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "removeEach",
          "package": "utility-ht",
          "signature": "[a] -\u003e [(a, [a])]",
          "source": "src/Data-List-HT-Private.html#removeEach",
          "type": "function"
        },
        "index": {
          "description": "removeEach xs represents list of sublists of xs where each element of xs is removed and the removed element is separated It seems to be much simpler to achieve with zip xs map flip List.delete xs xs but the implementation of removeEach does not need the Eq instance and thus can also be used for lists of functions See also the proposal http www.haskell.org pipermail libraries February html",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "removeEach",
          "normalized": "[a]-\u003e[(a,[a])]",
          "package": "utility-ht",
          "partial": "Each",
          "signature": "[a]-\u003e[(a,[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:removeEach"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "replace",
          "package": "utility-ht",
          "signature": "[a] -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#replace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "replace",
          "normalized": "[a]-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "signature": "[a]-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erotate left \n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "rotate",
          "package": "utility-ht",
          "signature": "Int -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#rotate",
          "type": "function"
        },
        "index": {
          "description": "rotate left",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "rotate",
          "normalized": "Int-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "signature": "Int-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:rotate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "search",
          "package": "utility-ht",
          "signature": "[a] -\u003e [a] -\u003e [Int]",
          "source": "src/Data-List-HT-Private.html#search",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "search",
          "normalized": "[a]-\u003e[a]-\u003e[Int]",
          "package": "utility-ht",
          "signature": "[a]-\u003e[a]-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:search"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the list after each occurence of a terminator.\nKeep the terminator.\nThere is always a list for the part after the last terminator.\nIt may be empty.\nSee package \u003ccode\u003enon-empty\u003c/code\u003e for more precise result type.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "segmentAfter",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#segmentAfter",
          "type": "function"
        },
        "index": {
          "description": "Split the list after each occurence of terminator Keep the terminator There is always list for the part after the last terminator It may be empty See package non-empty for more precise result type",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "segmentAfter",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "utility-ht",
          "partial": "After",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:segmentAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e Data.List.HT Data.Char\u003e segmentAfterMaybe (\\c -\u003e toMaybe (isLetter c) (toUpper c)) \"123a5345b---\"\n ([(\"123\",'A'),(\"5345\",'B')],\"---\")\n\u003c/pre\u003e",
          "module": "Data.List.HT",
          "name": "segmentAfterMaybe",
          "package": "utility-ht",
          "signature": "(a -\u003e Maybe b) -\u003e [a] -\u003e ([([a], b)], [a])",
          "source": "src/Data-List-HT-Private.html#segmentAfterMaybe",
          "type": "function"
        },
        "index": {
          "description": "Data.List.HT Data.Char segmentAfterMaybe toMaybe isLetter toUpper a5345b",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "segmentAfterMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003e[a]-\u003e([([a],b)],[a])",
          "package": "utility-ht",
          "partial": "After Maybe",
          "signature": "(a-\u003eMaybe b)-\u003e[a]-\u003e([([a],b)],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:segmentAfterMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the list before each occurence of a leading character.\nKeep these characters.\nThere is always a list for the part before the first leading character.\nIt may be empty.\nSee package \u003ccode\u003enon-empty\u003c/code\u003e for more precise result type.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "segmentBefore",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#segmentBefore",
          "type": "function"
        },
        "index": {
          "description": "Split the list before each occurence of leading character Keep these characters There is always list for the part before the first leading character It may be empty See package non-empty for more precise result type",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "segmentBefore",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "utility-ht",
          "partial": "Before",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:segmentBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e Data.List.HT Data.Char\u003e segmentBeforeMaybe (\\c -\u003e toMaybe (isLetter c) (toUpper c)) \"123a5345b---\"\n (\"123\",[('A',\"5345\"),('B',\"---\")])\n\u003c/pre\u003e",
          "module": "Data.List.HT",
          "name": "segmentBeforeMaybe",
          "package": "utility-ht",
          "signature": "(a -\u003e Maybe b) -\u003e [a] -\u003e ([a], [(b, [a])])",
          "source": "src/Data-List-HT-Private.html#segmentBeforeMaybe",
          "type": "function"
        },
        "index": {
          "description": "Data.List.HT Data.Char segmentBeforeMaybe toMaybe isLetter toUpper a5345b",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "segmentBeforeMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003e[a]-\u003e([a],[(b,[a])])",
          "package": "utility-ht",
          "partial": "Before Maybe",
          "signature": "(a-\u003eMaybe b)-\u003e[a]-\u003e([a],[(b,[a])])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:segmentBeforeMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform\n\u003c/p\u003e\u003cpre\u003e [[00,01,02,...],          [[00],\n  [10,11,12,...],   --\u003e     [10,01],\n  [20,21,22,...],           [20,11,02],\n  ...]                      ...]\n\u003c/pre\u003e\u003cp\u003eWith \u003ccode\u003econcat . shear\u003c/code\u003e you can perform a Cantor diagonalization,\nthat is an enumeration of all elements of the sub-lists\nwhere each element is reachable within a finite number of steps.\nIt is also useful for polynomial multiplication (convolution).\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "shear",
          "package": "utility-ht",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#shear",
          "type": "function"
        },
        "index": {
          "description": "Transform With concat shear you can perform Cantor diagonalization that is an enumeration of all elements of the sub-lists where each element is reachable within finite number of steps It is also useful for polynomial multiplication convolution",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "shear",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "utility-ht",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:shear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform\n\u003c/p\u003e\u003cpre\u003e [[00,01,02,...],          [[00],\n  [10,11,12,...],   --\u003e     [01,10],\n  [20,21,22,...],           [02,11,20],\n  ...]                      ...]\n\u003c/pre\u003e\u003cp\u003eIt's like \u003ccode\u003e\u003ca\u003eshear\u003c/a\u003e\u003c/code\u003e but the order of elements in the sub list is reversed.\nIts implementation seems to be more efficient than that of \u003ccode\u003e\u003ca\u003eshear\u003c/a\u003e\u003c/code\u003e.\nIf the order does not matter, better choose \u003ccode\u003e\u003ca\u003eshearTranspose\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "shearTranspose",
          "package": "utility-ht",
          "signature": "[[a]] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#shearTranspose",
          "type": "function"
        },
        "index": {
          "description": "Transform It like shear but the order of elements in the sub list is reversed Its implementation seems to be more efficient than that of shear If the order does not matter better choose shearTranspose",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "shearTranspose",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "utility-ht",
          "partial": "Transpose",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:shearTranspose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ekeep every k-th value from the list \n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "sieve",
          "package": "utility-ht",
          "signature": "Int -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#sieve",
          "type": "function"
        },
        "index": {
          "description": "keep every k-th value from the list",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "sieve",
          "normalized": "Int-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "signature": "Int-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:sieve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "sliceHorizontal",
          "package": "utility-ht",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#sliceHorizontal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "sliceHorizontal",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "utility-ht",
          "partial": "Horizontal",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:sliceHorizontal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "sliceVertical",
          "package": "utility-ht",
          "signature": "Int -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#sliceVertical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "sliceVertical",
          "normalized": "Int-\u003e[a]-\u003e[[a]]",
          "package": "utility-ht",
          "partial": "Vertical",
          "signature": "Int-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:sliceVertical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIt is \u003ccode\u003eData.List.span f undefined = undefined\u003c/code\u003e,\nwhereas \u003ccode\u003espan f undefined = (undefined, undefined)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "span",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Data-List-HT-Private.html#span",
          "type": "function"
        },
        "index": {
          "description": "It is Data.List.span undefined undefined whereas span undefined undefined undefined",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "span",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "utility-ht",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "splitEverywhere",
          "package": "utility-ht",
          "signature": "[a] -\u003e [([a], a, [a])]",
          "source": "src/Data-List-HT-Private.html#splitEverywhere",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "splitEverywhere",
          "normalized": "[a]-\u003e[([a],a,[a])]",
          "package": "utility-ht",
          "partial": "Everywhere",
          "signature": "[a]-\u003e[([a],a,[a])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:splitEverywhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use viewR instead\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eIt holds \u003ccode\u003esplitLast xs == (init xs, last xs)\u003c/code\u003e,\nbut \u003ccode\u003e\u003ca\u003esplitLast\u003c/a\u003e\u003c/code\u003e is more efficient\nif the last element is accessed after the initial ones,\nbecause it avoids memoizing list.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "splitLast",
          "package": "utility-ht",
          "signature": "[a] -\u003e ([a], a)",
          "source": "src/Data-List-HT-Private.html#splitLast",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use viewR instead It holds splitLast xs init xs last xs but splitLast is more efficient if the last element is accessed after the initial ones because it avoids memoizing list",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "splitLast",
          "normalized": "[a]-\u003e([a],a)",
          "package": "utility-ht",
          "partial": "Last",
          "signature": "[a]-\u003e([a],a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:splitLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould be prefered to \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "switchL",
          "package": "utility-ht",
          "signature": "b -\u003e (a -\u003e [a] -\u003e b) -\u003e [a] -\u003e b",
          "source": "src/Data-List-HT-Private.html#switchL",
          "type": "function"
        },
        "index": {
          "description": "Should be prefered to head and tail",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "switchL",
          "normalized": "a-\u003e(b-\u003e[b]-\u003ea)-\u003e[b]-\u003ea",
          "package": "utility-ht",
          "signature": "b-\u003e(a-\u003e[a]-\u003eb)-\u003e[a]-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:switchL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould be prefered to \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elast\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "switchR",
          "package": "utility-ht",
          "signature": "b -\u003e ([a] -\u003e a -\u003e b) -\u003e [a] -\u003e b",
          "source": "src/Data-List-HT-Private.html#switchR",
          "type": "function"
        },
        "index": {
          "description": "Should be prefered to init and last",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "switchR",
          "normalized": "a-\u003e([b]-\u003eb-\u003ea)-\u003e[b]-\u003ea",
          "package": "utility-ht",
          "signature": "b-\u003e([a]-\u003ea-\u003eb)-\u003e[a]-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:switchR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function is lazier than the one suggested in the Haskell 98 report.\nIt is \u003ccode\u003etails undefined = ([] : undefined) : undefined\u003c/code\u003e,\nin contrast to \u003ccode\u003eData.List.tails undefined = undefined\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "tails",
          "package": "utility-ht",
          "signature": "[a] -\u003e [[a]]",
          "source": "src/Data-List-HT-Private.html#tails",
          "type": "function"
        },
        "index": {
          "description": "This function is lazier than the one suggested in the Haskell report It is tails undefined undefined undefined in contrast to Data.List.tails undefined undefined",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "tails",
          "normalized": "[a]-\u003e[[a]]",
          "package": "utility-ht",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the cousin of \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e\nanalogously to \u003ccode\u003e\u003ca\u003ecatMaybes\u003c/a\u003e\u003c/code\u003e being the cousin of \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eExample: Keep the heads of sublists until an empty list occurs.\n\u003c/p\u003e\u003cpre\u003e takeWhileJust $ map (fmap fst . viewL) xs\n\u003c/pre\u003e",
          "module": "Data.List.HT",
          "name": "takeWhileJust",
          "package": "utility-ht",
          "signature": "[Maybe a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#takeWhileJust",
          "type": "function"
        },
        "index": {
          "description": "This is the cousin of takeWhile analogously to catMaybes being the cousin of filter Example Keep the heads of sublists until an empty list occurs takeWhileJust map fmap fst viewL xs",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "takeWhileJust",
          "normalized": "[Maybe a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "While Just",
          "signature": "[Maybe a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:takeWhileJust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake while first predicate holds,\nthen continue taking while second predicate holds,\nand so on.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "takeWhileMulti",
          "package": "utility-ht",
          "signature": "[a -\u003e Bool] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#takeWhileMulti",
          "type": "function"
        },
        "index": {
          "description": "Take while first predicate holds then continue taking while second predicate holds and so on",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "takeWhileMulti",
          "normalized": "[a-\u003eBool]-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "While Multi",
          "signature": "[a-\u003eBool]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:takeWhileMulti"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlternative version of \u003ccode\u003ereverse . takeWhile p . reverse\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "takeWhileRev",
          "package": "utility-ht",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-HT-Private.html#takeWhileRev",
          "type": "function"
        },
        "index": {
          "description": "Alternative version of reverse takeWhile reverse",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "takeWhileRev",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "While Rev",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:takeWhileRev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike standard \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e but more lazy.\nIt is \u003ccode\u003eData.List.unzip undefined == undefined\u003c/code\u003e,\nbut \u003ccode\u003eunzip undefined == (undefined, undefined)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "unzip",
          "package": "utility-ht",
          "signature": "[(a, b)] -\u003e ([a], [b])",
          "source": "src/Data-List-HT-Private.html#unzip",
          "type": "function"
        },
        "index": {
          "description": "Like standard unzip but more lazy It is Data.List.unzip undefined undefined but unzip undefined undefined undefined",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "unzip",
          "normalized": "[(a,b)]-\u003e([a],[b])",
          "package": "utility-ht",
          "signature": "[(a,b)]-\u003e([a],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:unzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.HT",
          "name": "unzipEithers",
          "package": "utility-ht",
          "signature": "[Either a b] -\u003e ([a], [b])",
          "source": "src/Data-List-HT-Private.html#unzipEithers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "unzipEithers",
          "normalized": "[Either a b]-\u003e([a],[b])",
          "package": "utility-ht",
          "partial": "Eithers",
          "signature": "[Either a b]-\u003e([a],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:unzipEithers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould be prefered to \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "viewL",
          "package": "utility-ht",
          "signature": "[a] -\u003e Maybe (a, [a])",
          "source": "src/Data-List-HT-Private.html#viewL",
          "type": "function"
        },
        "index": {
          "description": "Should be prefered to head and tail",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "viewL",
          "normalized": "[a]-\u003eMaybe(a,[a])",
          "package": "utility-ht",
          "signature": "[a]-\u003eMaybe(a,[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:viewL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould be prefered to \u003ccode\u003e\u003ca\u003einit\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003elast\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.HT",
          "name": "viewR",
          "package": "utility-ht",
          "signature": "[a] -\u003e Maybe ([a], a)",
          "source": "src/Data-List-HT-Private.html#viewR",
          "type": "function"
        },
        "index": {
          "description": "Should be prefered to init and last",
          "hierarchy": "Data List HT",
          "module": "Data.List.HT",
          "name": "viewR",
          "normalized": "[a]-\u003eMaybe([a],a)",
          "package": "utility-ht",
          "signature": "[a]-\u003eMaybe([a],a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-HT.html#v:viewR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVariant of \u003ca\u003eData.List\u003c/a\u003e functions like \u003ccode\u003e\u003ca\u003egroup\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e\nwhere the comparison is performed on a key computed from the list elements.\nIn principle these functions could be replaced by e.g. \u003ccode\u003esortBy (compare \u003ccode\u003eon\u003c/code\u003e f)\u003c/code\u003e,\nbut \u003ccode\u003ef\u003c/code\u003e will be re-computed for every comparison.\nIf the evaluation of \u003ccode\u003ef\u003c/code\u003e is expensive,\nour functions are better, since they buffer the results of \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.List.Key",
          "name": "Key",
          "package": "utility-ht",
          "source": "src/Data-List-Key.html",
          "type": "module"
        },
        "index": {
          "description": "Variant of Data.List functions like group sort where the comparison is performed on key computed from the list elements In principle these functions could be replaced by e.g sortBy compare on but will be re-computed for every comparison If the evaluation of is expensive our functions are better since they buffer the results of",
          "hierarchy": "Data List Key",
          "module": "Data.List.Key",
          "name": "Key",
          "package": "utility-ht",
          "partial": "Key",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Key.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivides a list into sublists such that the members in a sublist\nshare the same key.\nIt uses semantics of \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e,\nnot that of \u003ccode\u003e\u003ca\u003egroupBy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.Key",
          "name": "group",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [[a]]",
          "source": "src/Data-List-Key-Private.html#group",
          "type": "function"
        },
        "index": {
          "description": "Divides list into sublists such that the members in sublist share the same key It uses semantics of groupBy not that of groupBy",
          "hierarchy": "Data List Key",
          "module": "Data.List.Key",
          "name": "group",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Key.html#v:group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eargmax \n\u003c/p\u003e",
          "module": "Data.List.Key",
          "name": "maximum",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e a",
          "source": "src/Data-List-Key-Private.html#maximum",
          "type": "function"
        },
        "index": {
          "description": "argmax",
          "hierarchy": "Data List Key",
          "module": "Data.List.Key",
          "name": "maximum",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003ea",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Key.html#v:maximum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.Key",
          "name": "merge",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-Key-Private.html#merge",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List Key",
          "module": "Data.List.Key",
          "name": "merge",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Key.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eargmin \n\u003c/p\u003e",
          "module": "Data.List.Key",
          "name": "minimum",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e a",
          "source": "src/Data-List-Key-Private.html#minimum",
          "type": "function"
        },
        "index": {
          "description": "argmin",
          "hierarchy": "Data List Key",
          "module": "Data.List.Key",
          "name": "minimum",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003ea",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Key.html#v:minimum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.Key",
          "name": "nub",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-Key-Private.html#nub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List Key",
          "module": "Data.List.Key",
          "name": "nub",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Key.html#v:nub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.Key",
          "name": "sort",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-Key-Private.html#sort",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List Key",
          "module": "Data.List.Key",
          "name": "sort",
          "normalized": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Key.html#v:sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.Match",
          "name": "Match",
          "package": "utility-ht",
          "source": "src/Data-List-Match.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "Match",
          "package": "utility-ht",
          "partial": "Match",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare the length of two lists over different types.\nIt is equivalent to \u003ccode\u003e(compare (length xs) (length ys))\u003c/code\u003e\nbut more efficient.\n\u003c/p\u003e",
          "module": "Data.List.Match",
          "name": "compareLength",
          "package": "utility-ht",
          "signature": "[a] -\u003e [b] -\u003e Ordering",
          "source": "src/Data-List-Match-Private.html#compareLength",
          "type": "function"
        },
        "index": {
          "description": "Compare the length of two lists over different types It is equivalent to compare length xs length ys but more efficient",
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "compareLength",
          "normalized": "[a]-\u003e[b]-\u003eOrdering",
          "package": "utility-ht",
          "partial": "Length",
          "signature": "[a]-\u003e[b]-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:compareLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDrop as many elements as the first list is long \n\u003c/p\u003e",
          "module": "Data.List.Match",
          "name": "drop",
          "package": "utility-ht",
          "signature": "[b] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-Match-Private.html#drop",
          "type": "function"
        },
        "index": {
          "description": "Drop as many elements as the first list is long",
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "drop",
          "normalized": "[a]-\u003e[b]-\u003e[b]",
          "package": "utility-ht",
          "signature": "[b]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether two lists with different element types have equal length.\nIt is equivalent to \u003ccode\u003elength xs == length ys\u003c/code\u003e but more efficient.\n\u003c/p\u003e",
          "module": "Data.List.Match",
          "name": "equalLength",
          "package": "utility-ht",
          "signature": "[a] -\u003e [b] -\u003e Bool",
          "source": "src/Data-List-Match-Private.html#equalLength",
          "type": "function"
        },
        "index": {
          "description": "Check whether two lists with different element types have equal length It is equivalent to length xs length ys but more efficient",
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "equalLength",
          "normalized": "[a]-\u003e[b]-\u003eBool",
          "package": "utility-ht",
          "partial": "Length",
          "signature": "[a]-\u003e[b]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:equalLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elessOrEqualLength x y\u003c/code\u003e is almost the same as \u003ccode\u003ecompareLength x y \u003c= EQ\u003c/code\u003e,\nbut \u003ccode\u003elessOrEqualLength [] undefined  =  True\u003c/code\u003e,\nwhereas \u003ccode\u003ecompareLength [] undefined \u003c= EQ  =  undefined\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.Match",
          "name": "lessOrEqualLength",
          "package": "utility-ht",
          "signature": "[a] -\u003e [b] -\u003e Bool",
          "source": "src/Data-List-Match-Private.html#lessOrEqualLength",
          "type": "function"
        },
        "index": {
          "description": "lessOrEqualLength is almost the same as compareLength EQ but lessOrEqualLength undefined True whereas compareLength undefined EQ undefined",
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "lessOrEqualLength",
          "normalized": "[a]-\u003e[b]-\u003eBool",
          "package": "utility-ht",
          "partial": "Or Equal Length",
          "signature": "[a]-\u003e[b]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:lessOrEqualLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.Match",
          "name": "replicate",
          "package": "utility-ht",
          "signature": "[a] -\u003e b -\u003e [b]",
          "source": "src/Data-List-Match-Private.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "replicate",
          "normalized": "[a]-\u003eb-\u003e[b]",
          "package": "utility-ht",
          "signature": "[a]-\u003eb-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the shorter one of two lists.\nIt works also for infinite lists as much as possible.\nE.g. \u003ccode\u003eshorterList (shorterList (repeat 1) (repeat 2)) [1,2,3]\u003c/code\u003e\ncan be computed.\nThe trick is, that the skeleton of the resulting list\nis constructed using \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e without touching the elements.\nThe contents is then computed (only) if requested.\n\u003c/p\u003e",
          "module": "Data.List.Match",
          "name": "shorterList",
          "package": "utility-ht",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-Match-Private.html#shorterList",
          "type": "function"
        },
        "index": {
          "description": "Returns the shorter one of two lists It works also for infinite lists as much as possible E.g shorterList shorterList repeat repeat can be computed The trick is that the skeleton of the resulting list is constructed using zipWith without touching the elements The contents is then computed only if requested",
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "shorterList",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "utility-ht",
          "partial": "List",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:shorterList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.Match",
          "name": "splitAt",
          "package": "utility-ht",
          "signature": "[b] -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Data-List-Match-Private.html#splitAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "splitAt",
          "normalized": "[a]-\u003e[b]-\u003e([b],[b])",
          "package": "utility-ht",
          "partial": "At",
          "signature": "[b]-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a list as long as another one \n\u003c/p\u003e",
          "module": "Data.List.Match",
          "name": "take",
          "package": "utility-ht",
          "signature": "[b] -\u003e [a] -\u003e [a]",
          "source": "src/Data-List-Match-Private.html#take",
          "type": "function"
        },
        "index": {
          "description": "Make list as long as another one",
          "hierarchy": "Data List Match",
          "module": "Data.List.Match",
          "name": "take",
          "normalized": "[a]-\u003e[b]-\u003e[b]",
          "package": "utility-ht",
          "signature": "[b]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-List-Match.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maybe.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Maybe-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Maybe HT",
          "module": "Data.Maybe.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Maybe-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an infix version of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e\nfor writing \u003ccode\u003e\u003ca\u003eselect\u003c/a\u003e\u003c/code\u003e style expressions\nusing test functions, that produce \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cp\u003eThe precedence is chosen to be higher than '(:)',\nin order to allow:\n\u003c/p\u003e\u003cpre\u003e alternatives default $\n    checkForA ?-\u003e (\\a -\u003e f a) :\n    checkForB ?-\u003e (\\b -\u003e g b) :\n    []\n\u003c/pre\u003e\u003cp\u003eThe operation is left associative\nin order to allow to write\n\u003c/p\u003e\u003cpre\u003e checkForA ?-\u003e f ?-\u003e g\n\u003c/pre\u003e\u003cp\u003ewhich is equivalent to\n\u003c/p\u003e\u003cpre\u003e checkForA ?-\u003e g . f\n\u003c/pre\u003e\u003cp\u003edue to the functor law.\n\u003c/p\u003e",
          "module": "Data.Maybe.HT",
          "name": "(?-\u003e)",
          "package": "utility-ht",
          "signature": "Maybe a -\u003e (a -\u003e b) -\u003e Maybe b",
          "source": "src/Data-Maybe-HT.html#%3F-%3E",
          "type": "function"
        },
        "index": {
          "description": "This is an infix version of fmap for writing select style expressions using test functions that produce Maybe The precedence is chosen to be higher than in order to allow alternatives default checkForA checkForB The operation is left associative in order to allow to write checkForA which is equivalent to checkForA due to the functor law",
          "hierarchy": "Data Maybe HT",
          "module": "Data.Maybe.HT",
          "name": "(?-\u003e) ?-\u003e",
          "normalized": "Maybe a-\u003e(a-\u003eb)-\u003eMaybe b",
          "package": "utility-ht",
          "signature": "Maybe a-\u003e(a-\u003eb)-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Maybe-HT.html#v:-63--45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Maybe.HT",
          "name": "alternatives",
          "package": "utility-ht",
          "signature": "a -\u003e [Maybe a] -\u003e a",
          "source": "src/Data-Maybe-HT.html#alternatives",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Maybe HT",
          "module": "Data.Maybe.HT",
          "name": "alternatives",
          "normalized": "a-\u003e[Maybe a]-\u003ea",
          "package": "utility-ht",
          "signature": "a-\u003e[Maybe a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Maybe-HT.html#v:alternatives"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e if the precondition is fulfilled. \n\u003c/p\u003e",
          "module": "Data.Maybe.HT",
          "name": "toMaybe",
          "package": "utility-ht",
          "signature": "Bool -\u003e a -\u003e Maybe a",
          "source": "src/Data-Maybe-HT.html#toMaybe",
          "type": "function"
        },
        "index": {
          "description": "Returns Just if the precondition is fulfilled",
          "hierarchy": "Data Maybe HT",
          "module": "Data.Maybe.HT",
          "name": "toMaybe",
          "normalized": "Bool-\u003ea-\u003eMaybe a",
          "package": "utility-ht",
          "partial": "Maybe",
          "signature": "Bool-\u003ea-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Maybe-HT.html#v:toMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Monoid-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Monoid HT",
          "module": "Data.Monoid.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Monoid-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix synonym for \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Monoid.HT",
          "name": "(\u003c\u003e)",
          "package": "utility-ht",
          "signature": "m -\u003e m -\u003e m",
          "source": "src/Data-Monoid-HT.html#%3C%3E",
          "type": "function"
        },
        "index": {
          "description": "Infix synonym for mappend",
          "hierarchy": "Data Monoid HT",
          "module": "Data.Monoid.HT",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "utility-ht",
          "signature": "m-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Monoid-HT.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralization of \u003ccode\u003e\u003ca\u003ecycle\u003c/a\u003e\u003c/code\u003e to any monoid.\n\u003c/p\u003e",
          "module": "Data.Monoid.HT",
          "name": "cycle",
          "package": "utility-ht",
          "signature": "m -\u003e m",
          "source": "src/Data-Monoid-HT.html#cycle",
          "type": "function"
        },
        "index": {
          "description": "Generalization of cycle to any monoid",
          "hierarchy": "Data Monoid HT",
          "module": "Data.Monoid.HT",
          "name": "cycle",
          "normalized": "a-\u003ea",
          "package": "utility-ht",
          "signature": "m-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Monoid-HT.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Monoid.HT",
          "name": "when",
          "package": "utility-ht",
          "signature": "Bool -\u003e m -\u003e m",
          "source": "src/Data-Monoid-HT.html#when",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Monoid HT",
          "module": "Data.Monoid.HT",
          "name": "when",
          "normalized": "Bool-\u003ea-\u003ea",
          "package": "utility-ht",
          "signature": "Bool-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Monoid-HT.html#v:when"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Ord-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Ord HT",
          "module": "Data.Ord.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ord-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Ord.HT",
          "name": "comparing",
          "package": "utility-ht",
          "signature": "(a -\u003e b) -\u003e a -\u003e a -\u003e Ordering",
          "source": "src/Data-Ord-HT.html#comparing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Ord HT",
          "module": "Data.Ord.HT",
          "name": "comparing",
          "normalized": "(a-\u003eb)-\u003ea-\u003ea-\u003eOrdering",
          "package": "utility-ht",
          "signature": "(a-\u003eb)-\u003ea-\u003ea-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ord-HT.html#v:comparing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elimit (lower,upper) x\u003c/code\u003e checks whether \u003ccode\u003ex\u003c/code\u003e is in the range from \u003ccode\u003elower\u003c/code\u003e to \u003ccode\u003eupper\u003c/code\u003e.\nDon't expect a sensible result for \u003ccode\u003elower\u003eupper\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Ord.HT",
          "name": "inRange",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e a -\u003e Bool",
          "source": "src/Data-Ord-HT.html#inRange",
          "type": "function"
        },
        "index": {
          "description": "limit lower upper checks whether is in the range from lower to upper Don expect sensible result for lower upper",
          "hierarchy": "Data Ord HT",
          "module": "Data.Ord.HT",
          "name": "inRange",
          "normalized": "(a,a)-\u003ea-\u003eBool",
          "package": "utility-ht",
          "partial": "Range",
          "signature": "(a,a)-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ord-HT.html#v:inRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elimit (lower,upper) x\u003c/code\u003e restricts \u003ccode\u003ex\u003c/code\u003e to the range from \u003ccode\u003elower\u003c/code\u003e to \u003ccode\u003eupper\u003c/code\u003e.\nDon't expect a sensible result for \u003ccode\u003elower\u003eupper\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Ord.HT",
          "name": "limit",
          "package": "utility-ht",
          "signature": "(a, a) -\u003e a -\u003e a",
          "source": "src/Data-Ord-HT.html#limit",
          "type": "function"
        },
        "index": {
          "description": "limit lower upper restricts to the range from lower to upper Don expect sensible result for lower upper",
          "hierarchy": "Data Ord HT",
          "module": "Data.Ord.HT",
          "name": "limit",
          "normalized": "(a,a)-\u003ea-\u003ea",
          "package": "utility-ht",
          "signature": "(a,a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Ord-HT.html#v:limit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Record.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Record-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Record HT",
          "module": "Data.Record.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Record-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexicographically compare a list of attributes of two records.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e compare [comparing fst, comparing snd]\n\u003c/pre\u003e",
          "module": "Data.Record.HT",
          "name": "compare",
          "package": "utility-ht",
          "signature": "[a -\u003e a -\u003e Ordering] -\u003e a -\u003e a -\u003e Ordering",
          "source": "src/Data-Record-HT-Private.html#compare",
          "type": "function"
        },
        "index": {
          "description": "Lexicographically compare list of attributes of two records Example compare comparing fst comparing snd",
          "hierarchy": "Data Record HT",
          "module": "Data.Record.HT",
          "name": "compare",
          "normalized": "[a-\u003ea-\u003eOrdering]-\u003ea-\u003ea-\u003eOrdering",
          "package": "utility-ht",
          "signature": "[a-\u003ea-\u003eOrdering]-\u003ea-\u003ea-\u003eOrdering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Record-HT.html#v:compare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a selected set of fields of two records is equal.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e equal [equating fst, equating snd]\n\u003c/pre\u003e",
          "module": "Data.Record.HT",
          "name": "equal",
          "package": "utility-ht",
          "signature": "[a -\u003e a -\u003e Bool] -\u003e a -\u003e a -\u003e Bool",
          "source": "src/Data-Record-HT-Private.html#equal",
          "type": "function"
        },
        "index": {
          "description": "Check whether selected set of fields of two records is equal Example equal equating fst equating snd",
          "hierarchy": "Data Record HT",
          "module": "Data.Record.HT",
          "name": "equal",
          "normalized": "[a-\u003ea-\u003eBool]-\u003ea-\u003ea-\u003eBool",
          "package": "utility-ht",
          "signature": "[a-\u003ea-\u003eBool]-\u003ea-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Record-HT.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Strictness.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Strictness-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Strictness HT",
          "module": "Data.Strictness.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Strictness-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Strictness.HT",
          "name": "arguments1",
          "package": "utility-ht",
          "signature": "(a -\u003e x) -\u003e a -\u003e x",
          "source": "src/Data-Strictness-HT.html#arguments1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Strictness HT",
          "module": "Data.Strictness.HT",
          "name": "arguments1",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "utility-ht",
          "signature": "(a-\u003ex)-\u003ea-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Strictness-HT.html#v:arguments1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Strictness.HT",
          "name": "arguments2",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e x) -\u003e a -\u003e b -\u003e x",
          "source": "src/Data-Strictness-HT.html#arguments2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Strictness HT",
          "module": "Data.Strictness.HT",
          "name": "arguments2",
          "normalized": "(a-\u003eb-\u003ec)-\u003ea-\u003eb-\u003ec",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ex)-\u003ea-\u003eb-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Strictness-HT.html#v:arguments2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Strictness.HT",
          "name": "arguments3",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c -\u003e x) -\u003e a -\u003e b -\u003e c -\u003e x",
          "source": "src/Data-Strictness-HT.html#arguments3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Strictness HT",
          "module": "Data.Strictness.HT",
          "name": "arguments3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003ea-\u003eb-\u003ec-\u003ed",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ec-\u003ex)-\u003ea-\u003eb-\u003ec-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Strictness-HT.html#v:arguments3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Strictness.HT",
          "name": "arguments4",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e x) -\u003e a -\u003e b -\u003e c -\u003e d -\u003e x",
          "source": "src/Data-Strictness-HT.html#arguments4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Strictness HT",
          "module": "Data.Strictness.HT",
          "name": "arguments4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ex)-\u003ea-\u003eb-\u003ec-\u003ed-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Strictness-HT.html#v:arguments4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Strictness.HT",
          "name": "arguments5",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e x) -\u003e a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e x",
          "source": "src/Data-Strictness-HT.html#arguments5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Strictness HT",
          "module": "Data.Strictness.HT",
          "name": "arguments5",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ex)-\u003ea-\u003eb-\u003ec-\u003ed-\u003ee-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Strictness-HT.html#v:arguments5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.String.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-String-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data String HT",
          "module": "Data.String.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-String-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eremove leading and trailing spaces\n\u003c/p\u003e",
          "module": "Data.String.HT",
          "name": "trim",
          "package": "utility-ht",
          "signature": "String -\u003e String",
          "source": "src/Data-String-HT.html#trim",
          "type": "function"
        },
        "index": {
          "description": "remove leading and trailing spaces",
          "hierarchy": "Data String HT",
          "module": "Data.String.HT",
          "name": "trim",
          "normalized": "String-\u003eString",
          "package": "utility-ht",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-String-HT.html#v:trim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Data-Tuple-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "curry3",
          "package": "utility-ht",
          "signature": "((a, b, c) -\u003e d) -\u003e a -\u003e b -\u003e c -\u003e d",
          "source": "src/Data-Tuple-HT.html#curry3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "curry3",
          "normalized": "((a,b,c)-\u003ed)-\u003ea-\u003eb-\u003ec-\u003ed",
          "package": "utility-ht",
          "signature": "((a,b,c)-\u003ed)-\u003ea-\u003eb-\u003ec-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:curry3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "forcePair",
          "package": "utility-ht",
          "signature": "(a, b) -\u003e (a, b)",
          "source": "src/Data-Tuple-HT.html#forcePair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "forcePair",
          "normalized": "(a,b)-\u003e(a,b)",
          "package": "utility-ht",
          "partial": "Pair",
          "signature": "(a,b)-\u003e(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:forcePair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "fst3",
          "package": "utility-ht",
          "signature": "(a, b, c) -\u003e a",
          "source": "src/Data-Tuple-HT.html#fst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "fst3",
          "normalized": "(a,b,c)-\u003ea",
          "package": "utility-ht",
          "signature": "(a,b,c)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:fst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Tuple.HT",
          "name": "mapFst",
          "package": "utility-ht",
          "signature": "(a -\u003e c) -\u003e (a, b) -\u003e (c, b)",
          "source": "src/Data-Tuple-HT.html#mapFst",
          "type": "function"
        },
        "index": {
          "description": "first",
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "mapFst",
          "normalized": "(a-\u003eb)-\u003e(a,c)-\u003e(b,c)",
          "package": "utility-ht",
          "partial": "Fst",
          "signature": "(a-\u003ec)-\u003e(a,b)-\u003e(c,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:mapFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "mapFst3",
          "package": "utility-ht",
          "signature": "(a -\u003e d) -\u003e (a, b, c) -\u003e (d, b, c)",
          "source": "src/Data-Tuple-HT.html#mapFst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "mapFst3",
          "normalized": "(a-\u003eb)-\u003e(a,c,d)-\u003e(b,c,d)",
          "package": "utility-ht",
          "partial": "Fst",
          "signature": "(a-\u003ed)-\u003e(a,b,c)-\u003e(d,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:mapFst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCf. '(Control.Arrow.***)'.\n\u003c/p\u003e\u003cp\u003eApply two functions on corresponding values in a pair,\nwhere the pattern match on the pair constructor is lazy.\nThis is crucial in recursions such as the of \u003ccode\u003epartition\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Tuple.HT",
          "name": "mapPair",
          "package": "utility-ht",
          "signature": "(a -\u003e c, b -\u003e d) -\u003e (a, b) -\u003e (c, d)",
          "source": "src/Data-Tuple-HT.html#mapPair",
          "type": "function"
        },
        "index": {
          "description": "Cf Control.Arrow Apply two functions on corresponding values in pair where the pattern match on the pair constructor is lazy This is crucial in recursions such as the of partition",
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "mapPair",
          "normalized": "(a-\u003eb,c-\u003ed)-\u003e(a,c)-\u003e(b,d)",
          "package": "utility-ht",
          "partial": "Pair",
          "signature": "(a-\u003ec,b-\u003ed)-\u003e(a,b)-\u003e(c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:mapPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Tuple.HT",
          "name": "mapSnd",
          "package": "utility-ht",
          "signature": "(b -\u003e c) -\u003e (a, b) -\u003e (a, c)",
          "source": "src/Data-Tuple-HT.html#mapSnd",
          "type": "function"
        },
        "index": {
          "description": "second",
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "mapSnd",
          "normalized": "(a-\u003eb)-\u003e(c,a)-\u003e(c,b)",
          "package": "utility-ht",
          "partial": "Snd",
          "signature": "(b-\u003ec)-\u003e(a,b)-\u003e(a,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:mapSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "mapSnd3",
          "package": "utility-ht",
          "signature": "(b -\u003e d) -\u003e (a, b, c) -\u003e (a, d, c)",
          "source": "src/Data-Tuple-HT.html#mapSnd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "mapSnd3",
          "normalized": "(a-\u003eb)-\u003e(c,a,d)-\u003e(c,b,d)",
          "package": "utility-ht",
          "partial": "Snd",
          "signature": "(b-\u003ed)-\u003e(a,b,c)-\u003e(a,d,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:mapSnd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "mapThd3",
          "package": "utility-ht",
          "signature": "(c -\u003e d) -\u003e (a, b, c) -\u003e (a, b, d)",
          "source": "src/Data-Tuple-HT.html#mapThd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "mapThd3",
          "normalized": "(a-\u003eb)-\u003e(c,d,a)-\u003e(c,d,b)",
          "package": "utility-ht",
          "partial": "Thd",
          "signature": "(c-\u003ed)-\u003e(a,b,c)-\u003e(a,b,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:mapThd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "mapTriple",
          "package": "utility-ht",
          "signature": "(a -\u003e d, b -\u003e e, c -\u003e f) -\u003e (a, b, c) -\u003e (d, e, f)",
          "source": "src/Data-Tuple-HT.html#mapTriple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "mapTriple",
          "normalized": "(a-\u003eb,c-\u003ed,e-\u003ef)-\u003e(a,c,e)-\u003e(b,d,f)",
          "package": "utility-ht",
          "partial": "Triple",
          "signature": "(a-\u003ed,b-\u003ee,c-\u003ef)-\u003e(a,b,c)-\u003e(d,e,f)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:mapTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "snd3",
          "package": "utility-ht",
          "signature": "(a, b, c) -\u003e b",
          "source": "src/Data-Tuple-HT.html#snd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "snd3",
          "normalized": "(a,b,c)-\u003eb",
          "package": "utility-ht",
          "signature": "(a,b,c)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:snd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "swap",
          "package": "utility-ht",
          "signature": "(a, b) -\u003e (b, a)",
          "source": "src/Data-Tuple-HT.html#swap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "swap",
          "normalized": "(a,b)-\u003e(b,a)",
          "package": "utility-ht",
          "signature": "(a,b)-\u003e(b,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "thd3",
          "package": "utility-ht",
          "signature": "(a, b, c) -\u003e c",
          "source": "src/Data-Tuple-HT.html#thd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "thd3",
          "normalized": "(a,b,c)-\u003ec",
          "package": "utility-ht",
          "signature": "(a,b,c)-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:thd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tuple.HT",
          "name": "uncurry3",
          "package": "utility-ht",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e (a, b, c) -\u003e d",
          "source": "src/Data-Tuple-HT.html#uncurry3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tuple HT",
          "module": "Data.Tuple.HT",
          "name": "uncurry3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003e(a,b,c)-\u003ed",
          "package": "utility-ht",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003e(a,b,c)-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Data-Tuple-HT.html#v:uncurry3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Text-Read-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Read HT",
          "module": "Text.Read.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Read-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose two parsers sequentially. \n\u003c/p\u003e",
          "module": "Text.Read.HT",
          "name": "(.\u003e)",
          "package": "utility-ht",
          "signature": "ReadS (b -\u003e c) -\u003e ReadS b -\u003e ReadS c",
          "source": "src/Text-Read-HT.html#.%3E",
          "type": "function"
        },
        "index": {
          "description": "Compose two parsers sequentially",
          "hierarchy": "Text Read HT",
          "module": "Text.Read.HT",
          "name": "(.\u003e) .\u003e",
          "normalized": "ReadS(a-\u003eb)-\u003eReadS a-\u003eReadS b",
          "package": "utility-ht",
          "signature": "ReadS(b-\u003ec)-\u003eReadS b-\u003eReadS c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Read-HT.html#v:.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.HT",
          "name": "maybeRead",
          "package": "utility-ht",
          "signature": "String -\u003e Maybe a",
          "source": "src/Text-Read-HT.html#maybeRead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read HT",
          "module": "Text.Read.HT",
          "name": "maybeRead",
          "normalized": "String-\u003eMaybe a",
          "package": "utility-ht",
          "partial": "Read",
          "signature": "String-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Read-HT.html#v:maybeRead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Read.HT",
          "name": "readMany",
          "package": "utility-ht",
          "signature": "String -\u003e [a]",
          "source": "src/Text-Read-HT.html#readMany",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Read HT",
          "module": "Text.Read.HT",
          "name": "readMany",
          "normalized": "String-\u003e[a]",
          "package": "utility-ht",
          "partial": "Many",
          "signature": "String-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Read-HT.html#v:readMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string containing an infix operator. \n\u003c/p\u003e",
          "module": "Text.Read.HT",
          "name": "readsInfixPrec",
          "package": "utility-ht",
          "signature": "String -\u003e Int -\u003e Int -\u003e (a -\u003e b -\u003e c) -\u003e ReadS c",
          "source": "src/Text-Read-HT.html#readsInfixPrec",
          "type": "function"
        },
        "index": {
          "description": "Parse string containing an infix operator",
          "hierarchy": "Text Read HT",
          "module": "Text.Read.HT",
          "name": "readsInfixPrec",
          "normalized": "String-\u003eInt-\u003eInt-\u003e(a-\u003eb-\u003ec)-\u003eReadS c",
          "package": "utility-ht",
          "partial": "Infix Prec",
          "signature": "String-\u003eInt-\u003eInt-\u003e(a-\u003eb-\u003ec)-\u003eReadS c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Read-HT.html#v:readsInfixPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Show.HT",
          "name": "HT",
          "package": "utility-ht",
          "source": "src/Text-Show-HT.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Show HT",
          "module": "Text.Show.HT",
          "name": "HT",
          "package": "utility-ht",
          "partial": "HT",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Show-HT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Show.HT",
          "name": "concatS",
          "package": "utility-ht",
          "signature": "[ShowS] -\u003e ShowS",
          "source": "src/Text-Show-HT.html#concatS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Show HT",
          "module": "Text.Show.HT",
          "name": "concatS",
          "normalized": "[ShowS]-\u003eShowS",
          "package": "utility-ht",
          "signature": "[ShowS]-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Show-HT.html#v:concatS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a value using an infix operator. \n\u003c/p\u003e",
          "module": "Text.Show.HT",
          "name": "showsInfixPrec",
          "package": "utility-ht",
          "signature": "String -\u003e Int -\u003e Int -\u003e a -\u003e b -\u003e ShowS",
          "source": "src/Text-Show-HT.html#showsInfixPrec",
          "type": "function"
        },
        "index": {
          "description": "Show value using an infix operator",
          "hierarchy": "Text Show HT",
          "module": "Text.Show.HT",
          "name": "showsInfixPrec",
          "normalized": "String-\u003eInt-\u003eInt-\u003ea-\u003eb-\u003eShowS",
          "package": "utility-ht",
          "partial": "Infix Prec",
          "signature": "String-\u003eInt-\u003eInt-\u003ea-\u003eb-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/utility-ht/docs/Text-Show-HT.html#v:showsInfixPrec"
      }
    }
  ]
]