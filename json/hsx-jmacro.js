[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hsx-jmacro"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides support for:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e embedding Javascript generated by JMacro into HSX.\n\u003c/li\u003e\u003cli\u003e turning XML generated by HSX into a DOM node in Javascript\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eIt provides the following instances:\n\u003c/p\u003e\u003cpre\u003e instance (XMLGenerator m, IntegerSupply m) =\u003e EmbedAsChild m JStat\n instance (IntegerSupply m, IsName n, EmbedAsAttr m (Attr Name String)) =\u003e EmbedAsAttr m (Attr n JStat)\n instance ToJExpr XML\n instance ToJExpr DOMNode\n instance ToJExpr XMLToInnerHTML\n instance ToJExpr XMLToDOM\n\u003c/pre\u003e\u003cp\u003eIn order to ensure that each embedded \u003ccode\u003e\u003ca\u003eJStat\u003c/a\u003e\u003c/code\u003e block has unique\n variable names, the monad must supply a source of unique\n names. This is done by adding an instance of \u003ccode\u003e\u003ca\u003eIntegerSupply\u003c/a\u003e\u003c/code\u003e for\n the monad being used with \u003ccode\u003e\u003ca\u003eXMLGenerator\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example, we can use \u003ccode\u003eStateT\u003c/code\u003e to provide an \u003ccode\u003e\u003ca\u003eIntegerSupply\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003eServerPartT\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e instance IntegerSupply (ServerPartT (StateT Integer IO)) where\n     nextInteger = nextInteger'\n\u003c/pre\u003e\u003cp\u003eAlternatively, we can exploit the IO monad to provide an \u003ccode\u003e\u003ca\u003eIntegerSupply\u003c/a\u003e\u003c/code\u003e instance for \u003ccode\u003eServerPartT\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e instance IntegerSupply (ServerPartT IO) where\n     nextInteger = fmap (fromIntegral . (`mod` 1024) . hashUnique) (liftIO newUnique)\n\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eToJExpr XML\u003c/code\u003e instance allows you to splice in XML lifted out of an\n arbitrary monad to generate DOM nodes with JMacro antiquotation:\n\u003c/p\u003e\u003cpre\u003e js = do html \u003c- unXMLGenT \u003cp\u003eI'm in a Monad!\u003c/p\u003e\n         return [jmacro| document.getElementById(\"messages\").appendChild(`(html)`); |]\n\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eToJExpr DOMNode\u003c/code\u003e instance allows you to run HSP in the Identity\n monad to render JMacro in pure code:\n\u003c/p\u003e\u003cpre\u003e html :: DOMNode\n html = \u003cp\u003eI'm using \u003cem\u003eJavaScript\u003c/em\u003e!\u003c/p\u003e\n js = [jmacro| var language = `(html)`.getElementsByTagName(\"em\")[0].textContent; |]\n\u003c/pre\u003e\u003cp\u003eYou can see here that you get an actual DOM tree in JavaScript.  This is\n also compatible with libraries such as jQuery and YUI which are able to\n wrap DOM nodes in their own type, for example with jQuery:\n\u003c/p\u003e\u003cpre\u003e js = [jmacro| var languages = $(`(html)`).find(\"em\").text(); |]\n\u003c/pre\u003e\u003cp\u003eOr with YUI:\n\u003c/p\u003e\u003cpre\u003e js = [jmacro| var languages = Y.one(`(html)`).one(\"em\").get(\"text\"); |]\n\u003c/pre\u003e\u003cp\u003eThere are two ways to turn HTML into a a DOM node in the\n browser. One way is to render the HTML to a string, and pass the\n string to \u003ccode\u003eelement.innerHTML\u003c/code\u003e. The other way is to us the use the\n DOM functions like \u003ccode\u003ecreateElement\u003c/code\u003e, \u003ccode\u003esetAttribute\u003c/code\u003e, to\n programatically create the DOM on the client.\n\u003c/p\u003e\u003cp\u003eIn webkit-based browsers like Chrome and Safari, the DOM method\n appears to be slightly faster. In other browsers, the \u003ccode\u003einnerHTML\u003c/code\u003e\n method appears to be faster. The \u003ccode\u003einnerHTML\u003c/code\u003e method will almost\n always required fewer bytes to be transmitted. Additionally, if\n your XML/HTML contains pre-escaped content, you are required to use\n \u003ccode\u003einnerHTML\u003c/code\u003e anyway.\n\u003c/p\u003e\u003cp\u003eSo, by default the \u003ccode\u003e\u003ca\u003eToJExpr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eXML\u003c/a\u003e\u003c/code\u003e instance uses the \u003ccode\u003einnerHTML\u003c/code\u003e\n method. Though, that could change in the future. If you care about\n using one method over the other you can use the \u003ccode\u003enewtype\u003c/code\u003e wrappers\n \u003ccode\u003e\u003ca\u003eXMLToInnerHTML\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eXMLToDOM\u003c/a\u003e\u003c/code\u003e to select which method to use.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "HSP.JMacro",
          "name": "JMacro",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacro.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides support for embedding Javascript generated by JMacro into HSX turning XML generated by HSX into DOM node in Javascript It provides the following instances instance XMLGenerator IntegerSupply EmbedAsChild JStat instance IntegerSupply IsName EmbedAsAttr Attr Name String EmbedAsAttr Attr JStat instance ToJExpr XML instance ToJExpr DOMNode instance ToJExpr XMLToInnerHTML instance ToJExpr XMLToDOM In order to ensure that each embedded JStat block has unique variable names the monad must supply source of unique names This is done by adding an instance of IntegerSupply for the monad being used with XMLGenerator For example we can use StateT to provide an IntegerSupply instance for ServerPartT instance IntegerSupply ServerPartT StateT Integer IO where nextInteger nextInteger Alternatively we can exploit the IO monad to provide an IntegerSupply instance for ServerPartT instance IntegerSupply ServerPartT IO where nextInteger fmap fromIntegral mod hashUnique liftIO newUnique The ToJExpr XML instance allows you to splice in XML lifted out of an arbitrary monad to generate DOM nodes with JMacro antiquotation js do html unXMLGenT in Monad return jmacro document.getElementById messages appendChild html The ToJExpr DOMNode instance allows you to run HSP in the Identity monad to render JMacro in pure code html DOMNode html using em JavaScript em js jmacro var language html getElementsByTagName em textContent You can see here that you get an actual DOM tree in JavaScript This is also compatible with libraries such as jQuery and YUI which are able to wrap DOM nodes in their own type for example with jQuery js jmacro var languages html find em text Or with YUI js jmacro var languages Y.one html one em get text There are two ways to turn HTML into DOM node in the browser One way is to render the HTML to string and pass the string to element.innerHTML The other way is to us the use the DOM functions like createElement setAttribute to programatically create the DOM on the client In webkit-based browsers like Chrome and Safari the DOM method appears to be slightly faster In other browsers the innerHTML method appears to be faster The innerHTML method will almost always required fewer bytes to be transmitted Additionally if your XML HTML contains pre-escaped content you are required to use innerHTML anyway So by default the ToJExpr XML instance uses the innerHTML method Though that could change in the future If you care about using one method over the other you can use the newtype wrappers XMLToInnerHTML or XMLToDOM to select which method to use",
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "JMacro",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvided for convenience since \u003ccode\u003eIdent\u003c/code\u003e is exported by both\n \u003ccode\u003eHSP.Identity\u003c/code\u003e and \u003ccode\u003eJMacro\u003c/code\u003e.  Using this you can avoid the need for an\n extra and qualified import.\n\u003c/p\u003e",
          "module": "HSP.JMacro",
          "name": "DOMNode",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacro.html#DOMNode",
          "type": "type"
        },
        "index": {
          "description": "Provided for convenience since Ident is exported by both HSP.Identity and JMacro Using this you can avoid the need for an extra and qualified import",
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "DOMNode",
          "package": "hsx-jmacro",
          "partial": "DOMNode",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#t:DOMNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class provides a monotonically increasing supply of non-duplicate \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e values\n\u003c/p\u003e",
          "module": "HSP.JMacro",
          "name": "IntegerSupply",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacro.html#IntegerSupply",
          "type": "class"
        },
        "index": {
          "description": "This class provides monotonically increasing supply of non-duplicate Integer values",
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "IntegerSupply",
          "package": "hsx-jmacro",
          "partial": "Integer Supply",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#t:IntegerSupply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enewtype which can be used with \u003ccode\u003e\u003ca\u003etoJExpr\u003c/a\u003e\u003c/code\u003e to specify that the XML\n should be converted to a DOM in javascript by using\n \u003ccode\u003ecreateElement\u003c/code\u003e, \u003ccode\u003eappendChild\u003c/code\u003e, and other DOM functions.\n\u003c/p\u003e\u003cp\u003eWARNING: \u003ccode\u003eCDATA FALSE\u003c/code\u003e values are assumed to be pre-escaped HTML and will be converted to a DOM node by using \u003ccode\u003einnerHTML\u003c/code\u003e. Additionally, if the call to \u003ccode\u003einnerHTML\u003c/code\u003e returns more than one node, only the first node is used.\n\u003c/p\u003e",
          "module": "HSP.JMacro",
          "name": "XMLToDOM",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacro.html#XMLToDOM",
          "type": "newtype"
        },
        "index": {
          "description": "newtype which can be used with toJExpr to specify that the XML should be converted to DOM in javascript by using createElement appendChild and other DOM functions WARNING CDATA FALSE values are assumed to be pre-escaped HTML and will be converted to DOM node by using innerHTML Additionally if the call to innerHTML returns more than one node only the first node is used",
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "XMLToDOM",
          "package": "hsx-jmacro",
          "partial": "XMLTo DOM",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#t:XMLToDOM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enewtype which can be used with \u003ccode\u003e\u003ca\u003etoJExpr\u003c/a\u003e\u003c/code\u003e to specify that the XML\n should be converted to a DOM in javascript by using \u003ccode\u003einnerHTML\u003c/code\u003e\n\u003c/p\u003e",
          "module": "HSP.JMacro",
          "name": "XMLToInnerHTML",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacro.html#XMLToInnerHTML",
          "type": "newtype"
        },
        "index": {
          "description": "newtype which can be used with toJExpr to specify that the XML should be converted to DOM in javascript by using innerHTML",
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "XMLToInnerHTML",
          "package": "hsx-jmacro",
          "partial": "XMLTo Inner HTML",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#t:XMLToInnerHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "HSP.JMacro",
          "name": "XMLToDOM",
          "package": "hsx-jmacro",
          "signature": "XMLToDOM XML",
          "source": "src/HSP-JMacro.html#XMLToDOM",
          "type": "function"
        },
        "index": {
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "XMLToDOM",
          "package": "hsx-jmacro",
          "partial": "XMLTo DOM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#v:XMLToDOM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "HSP.JMacro",
          "name": "XMLToInnerHTML",
          "package": "hsx-jmacro",
          "signature": "XMLToInnerHTML XML",
          "source": "src/HSP-JMacro.html#XMLToInnerHTML",
          "type": "function"
        },
        "index": {
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "XMLToInnerHTML",
          "package": "hsx-jmacro",
          "partial": "XMLTo Inner HTML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#v:XMLToInnerHTML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "HSP.JMacro",
          "name": "nextInteger",
          "package": "hsx-jmacro",
          "signature": "m Integer",
          "source": "src/HSP-JMacro.html#nextInteger",
          "type": "method"
        },
        "index": {
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "nextInteger",
          "package": "hsx-jmacro",
          "partial": "Integer",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#v:nextInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis help function allows you to easily create an \u003ccode\u003e\u003ca\u003eIntegerSupply\u003c/a\u003e\u003c/code\u003e\n instance for monads that have a \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e\u003cp\u003eFor example:\n\u003c/p\u003e\u003cpre\u003e instance IntegerSupply (ServerPartT (StateT Integer IO)) where\n     nextInteger = nextInteger'\n\u003c/pre\u003e",
          "module": "HSP.JMacro",
          "name": "nextInteger'",
          "package": "hsx-jmacro",
          "signature": "m Integer",
          "source": "src/HSP-JMacro.html#nextInteger%27",
          "type": "function"
        },
        "index": {
          "description": "This help function allows you to easily create an IntegerSupply instance for monads that have MonadState Integer instance For example instance IntegerSupply ServerPartT StateT Integer IO where nextInteger nextInteger",
          "hierarchy": "HSP JMacro",
          "module": "HSP.JMacro",
          "name": "nextInteger'",
          "package": "hsx-jmacro",
          "partial": "Integer'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacro.html#v:nextInteger-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis experimental module provides a monad transformer \u003ccode\u003e\u003ca\u003eJMacroT\u003c/a\u003e\u003c/code\u003e\n and corresponding \u003ccode\u003e\u003ca\u003eXMLGenerator\u003c/a\u003e\u003c/code\u003e instance which can be used to\n directly generate javascript which builds an XML/HTML DOM.\n\u003c/p\u003e\u003cp\u003eThis is similar to the 'ToJExpr XMLToDOM' instance except that\n there is no intermediate XML type. The \u003ccode\u003e\u003ca\u003eXMLGenerator\u003c/a\u003e\u003c/code\u003e instance\n directly generates the javascript needed to build the DOM.\n\u003c/p\u003e\u003cp\u003eThis is intellectually fun. But it is not clear how it is valuable.\n That is why this module is marked as experimental.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "HSP.JMacroT",
          "name": "JMacroT",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacroT.html",
          "type": "module"
        },
        "index": {
          "description": "This experimental module provides monad transformer JMacroT and corresponding XMLGenerator instance which can be used to directly generate javascript which builds an XML HTML DOM This is similar to the ToJExpr XMLToDOM instance except that there is no intermediate XML type The XMLGenerator instance directly generates the javascript needed to build the DOM This is intellectually fun But it is not clear how it is valuable That is why this module is marked as experimental",
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "JMacroT",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean alias for 'JMacroT Identity'\n\u003c/p\u003e",
          "module": "HSP.JMacroT",
          "name": "JMacroM",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacroT.html#JMacroM",
          "type": "type"
        },
        "index": {
          "description": "an alias for JMacroT Identity",
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "JMacroM",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#t:JMacroM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eisomorphic to IdentityT, but used for generating javascript that generates XML/HTML\n\u003c/p\u003e",
          "module": "HSP.JMacroT",
          "name": "JMacroT",
          "package": "hsx-jmacro",
          "source": "src/HSP-JMacroT.html#JMacroT",
          "type": "newtype"
        },
        "index": {
          "description": "isomorphic to IdentityT but used for generating javascript that generates XML HTML",
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "JMacroT",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#t:JMacroT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "HSP.JMacroT",
          "name": "JMacroT",
          "package": "hsx-jmacro",
          "signature": "JMacroT",
          "source": "src/HSP-JMacroT.html#JMacroT",
          "type": "function"
        },
        "index": {
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "JMacroT",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#v:JMacroT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eevaluate \u003ccode\u003e\u003ca\u003eJMacroM\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "HSP.JMacroT",
          "name": "evalJMacroM",
          "package": "hsx-jmacro",
          "signature": "XMLGenT JMacroM a -\u003e a",
          "source": "src/HSP-JMacroT.html#evalJMacroM",
          "type": "function"
        },
        "index": {
          "description": "evaluate JMacroM",
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "evalJMacroM",
          "normalized": "XMLGenT JMacroM a-\u003ea",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "signature": "XMLGenT JMacroM a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#v:evalJMacroM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunwrap the \u003ccode\u003e\u003ca\u003eXMLGenT\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eJMacroT\u003c/a\u003e\u003c/code\u003e constructors\n\u003c/p\u003e",
          "module": "HSP.JMacroT",
          "name": "evalJMacroT",
          "package": "hsx-jmacro",
          "signature": "XMLGenT (JMacroT m) JExpr -\u003e m JExpr",
          "source": "src/HSP-JMacroT.html#evalJMacroT",
          "type": "function"
        },
        "index": {
          "description": "unwrap the XMLGenT and JMacroT constructors",
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "evalJMacroT",
          "normalized": "XMLGenT(JMacroT a)JExpr-\u003ea JExpr",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "signature": "XMLGenT(JMacroT m)JExpr-\u003em JExpr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#v:evalJMacroT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap a function over the inner monad\n\u003c/p\u003e",
          "module": "HSP.JMacroT",
          "name": "mapJMacroT",
          "package": "hsx-jmacro",
          "signature": "(m a -\u003e n b) -\u003e JMacroT m a -\u003e JMacroT n b",
          "source": "src/HSP-JMacroT.html#mapJMacroT",
          "type": "function"
        },
        "index": {
          "description": "map function over the inner monad",
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "mapJMacroT",
          "normalized": "(a b-\u003ec d)-\u003eJMacroT a b-\u003eJMacroT c d",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "signature": "(m a-\u003en b)-\u003eJMacroT m a-\u003eJMacroT n b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#v:mapJMacroT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "HSP.JMacroT",
          "name": "unJMacroT",
          "package": "hsx-jmacro",
          "signature": "m a",
          "source": "src/HSP-JMacroT.html#JMacroT",
          "type": "function"
        },
        "index": {
          "hierarchy": "HSP JMacroT",
          "module": "HSP.JMacroT",
          "name": "unJMacroT",
          "package": "hsx-jmacro",
          "partial": "JMacro",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hsx-jmacro/docs/HSP-JMacroT.html#v:unJMacroT"
      }
    }
  ]
]