[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "pqueue-mtl"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AQKey",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#QKey",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AQKey",
          "package": "pqueue-mtl",
          "partial": "AQKey",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#t:3AQKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AMonadQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#MonadQueue",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AMonadQueue",
          "package": "pqueue-mtl",
          "partial": "AMonad Queue",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AMonadQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueDelete",
          "package": "pqueue-mtl",
          "signature": "m ()",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#queueDelete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueDelete",
          "normalized": "a()",
          "package": "pqueue-mtl",
          "partial": "Aqueue Delete",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AqueueDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueEmpty",
          "package": "pqueue-mtl",
          "signature": "m Bool",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#queueEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueEmpty",
          "package": "pqueue-mtl",
          "partial": "Aqueue Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AqueueEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueExtract",
          "package": "pqueue-mtl",
          "signature": "m (Maybe (QKey m))",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#queueExtract",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueExtract",
          "package": "pqueue-mtl",
          "partial": "Aqueue Extract",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AqueueExtract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueInsert",
          "package": "pqueue-mtl",
          "signature": "QKey m -\u003e m ()",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#queueInsert",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueInsert",
          "normalized": "QKey a-\u003ea()",
          "package": "pqueue-mtl",
          "partial": "Aqueue Insert",
          "signature": "QKey m-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AqueueInsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueInsertAll",
          "package": "pqueue-mtl",
          "signature": "[QKey m] -\u003e m ()",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#queueInsertAll",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueInsertAll",
          "normalized": "[QKey a]-\u003ea()",
          "package": "pqueue-mtl",
          "partial": "Aqueue Insert All",
          "signature": "[QKey m]-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AqueueInsertAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueuePeek",
          "package": "pqueue-mtl",
          "signature": "m (Maybe (QKey m))",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#queuePeek",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueuePeek",
          "package": "pqueue-mtl",
          "partial": "Aqueue Peek",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AqueuePeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueSize",
          "package": "pqueue-mtl",
          "signature": "m Int",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Class.html#queueSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Class",
          "module": "Control.Monad.Queue.Class",
          "name": "3AqueueSize",
          "package": "pqueue-mtl",
          "partial": "Aqueue Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Class.html#v:3AqueueSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Monad based on an array implementation of a standard binary heap.\n",
          "module": "Control.Monad.Queue.Heap",
          "name": "3AHeapM",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#HeapM",
          "type": "type"
        },
        "index": {
          "description": "Monad based on an array implementation of standard binary heap",
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3AHeapM",
          "package": "pqueue-mtl",
          "partial": "AHeap",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#t:3AHeapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Heap",
          "name": "3AHeapT",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#HeapT",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3AHeapT",
          "package": "pqueue-mtl",
          "partial": "AHeap",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#t:3AHeapT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Heap",
          "name": "3AUHeapT",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#UHeapT",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3AUHeapT",
          "package": "pqueue-mtl",
          "partial": "AUHeap",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#t:3AUHeapT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Runs an \u003ctt\u003e\u003ca\u003eHeapM\u003c/a\u003e\u003c/tt\u003e computation starting with an empty heap.\n",
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapM",
          "package": "pqueue-mtl",
          "signature": "(forall s.  HeapM s e a) -\u003e a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#runHeapM",
          "type": "function"
        },
        "index": {
          "description": "Runs an HeapM computation starting with an empty heap",
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapM",
          "normalized": "(a b HeapM c d e)-\u003ee",
          "package": "pqueue-mtl",
          "partial": "Arun Heap",
          "signature": "(forall s. HeapM s e a)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#v:3ArunHeapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapMOn",
          "package": "pqueue-mtl",
          "signature": "(forall s.  HeapM s e a) -\u003e Int -\u003e [e] -\u003e a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#runHeapMOn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapMOn",
          "normalized": "(a b HeapM c d e)-\u003eInt-\u003e[d]-\u003ee",
          "package": "pqueue-mtl",
          "partial": "Arun Heap MOn",
          "signature": "(forall s. HeapM s e a)-\u003eInt-\u003e[e]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#v:3ArunHeapMOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapT",
          "package": "pqueue-mtl",
          "signature": "HeapT e m a -\u003e m a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#runHeapT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapT",
          "normalized": "HeapT a b c-\u003eb c",
          "package": "pqueue-mtl",
          "partial": "Arun Heap",
          "signature": "HeapT e m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#v:3ArunHeapT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "The transformer operation.\nThe starting size of the heap (must be equal to the length of the list)\nThe initial contents of the heap\n",
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapTOn",
          "package": "pqueue-mtl",
          "signature": "HeapT e m a-\u003e Int-\u003e [e]-\u003e m a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#runHeapTOn",
          "type": "function"
        },
        "index": {
          "description": "The transformer operation The starting size of the heap must be equal to the length of the list The initial contents of the heap",
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunHeapTOn",
          "normalized": "HeapT a b c-\u003eInt-\u003e[a]-\u003eb c",
          "package": "pqueue-mtl",
          "partial": "Arun Heap TOn",
          "signature": "HeapT e m a-\u003eInt-\u003e[e]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#v:3ArunHeapTOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunUHeapT",
          "package": "pqueue-mtl",
          "signature": "UHeapT e m a -\u003e m a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-Heap.html#runUHeapT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Queue Heap",
          "module": "Control.Monad.Queue.Heap",
          "name": "3ArunUHeapT",
          "normalized": "UHeapT a b c-\u003eb c",
          "package": "pqueue-mtl",
          "partial": "Arun UHeap",
          "signature": "UHeapT e m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-Heap.html#v:3ArunUHeapT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AFibQueueM",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#FibQueueM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AFibQueueM",
          "package": "pqueue-mtl",
          "partial": "AFib Queue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3AFibQueueM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AFibQueueT",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#FibQueueT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AFibQueueT",
          "package": "pqueue-mtl",
          "partial": "AFib Queue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3AFibQueueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AIntQueueM",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#IntQueueM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AIntQueueM",
          "package": "pqueue-mtl",
          "partial": "AInt Queue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3AIntQueueM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AIntQueueT",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#IntQueueT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AIntQueueT",
          "package": "pqueue-mtl",
          "partial": "AInt Queue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3AIntQueueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3APQueueM",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#PQueueM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3APQueueM",
          "package": "pqueue-mtl",
          "partial": "APQueue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3APQueueM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3APQueueT",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#PQueueT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3APQueueT",
          "package": "pqueue-mtl",
          "partial": "APQueue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3APQueueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AQueueM",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#QueueM",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AQueueM",
          "package": "pqueue-mtl",
          "partial": "AQueue",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3AQueueM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AQueueT",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#QueueT",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3AQueueT",
          "package": "pqueue-mtl",
          "partial": "AQueue",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3AQueueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ASkewQueueM",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#SkewQueueM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ASkewQueueM",
          "package": "pqueue-mtl",
          "partial": "ASkew Queue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3ASkewQueueM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ASkewQueueT",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#SkewQueueT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ASkewQueueT",
          "package": "pqueue-mtl",
          "partial": "ASkew Queue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#t:3ASkewQueueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Executes a computation in a queue monad, starting with an empty queue.\n",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueM",
          "package": "pqueue-mtl",
          "signature": "QueueM q a -\u003e a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#runQueueM",
          "type": "function"
        },
        "index": {
          "description": "Executes computation in queue monad starting with an empty queue",
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueM",
          "normalized": "QueueM a b-\u003eb",
          "package": "pqueue-mtl",
          "partial": "Arun Queue",
          "signature": "QueueM q a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#v:3ArunQueueM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Executes a computation in a queue monad, starting with a queue with the specified contents.\n",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueMOn",
          "package": "pqueue-mtl",
          "signature": "QueueM q a -\u003e [QueueKey q] -\u003e a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#runQueueMOn",
          "type": "function"
        },
        "index": {
          "description": "Executes computation in queue monad starting with queue with the specified contents",
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueMOn",
          "normalized": "QueueM a b-\u003e[QueueKey a]-\u003eb",
          "package": "pqueue-mtl",
          "partial": "Arun Queue MOn",
          "signature": "QueueM q a-\u003e[QueueKey q]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#v:3ArunQueueMOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unwraps a queue transformer, initializing it with an empty queue.\n",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueT",
          "package": "pqueue-mtl",
          "signature": "QueueT q m a -\u003e m a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#runQueueT",
          "type": "function"
        },
        "index": {
          "description": "Unwraps queue transformer initializing it with an empty queue",
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueT",
          "normalized": "QueueT a b c-\u003eb c",
          "package": "pqueue-mtl",
          "partial": "Arun Queue",
          "signature": "QueueT q m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#v:3ArunQueueT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Unwraps a queue transformer, initializing it with a queue with the specified contents.\n",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueTOn",
          "package": "pqueue-mtl",
          "signature": "QueueT q m a -\u003e [QueueKey q] -\u003e m a",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Control-Monad-Queue-QueueT.html#runQueueTOn",
          "type": "function"
        },
        "index": {
          "description": "Unwraps queue transformer initializing it with queue with the specified contents",
          "hierarchy": "Control Monad Queue QueueT",
          "module": "Control.Monad.Queue.QueueT",
          "name": "3ArunQueueTOn",
          "normalized": "QueueT a b c-\u003e[QueueKey a]-\u003eb c",
          "package": "pqueue-mtl",
          "partial": "Arun Queue TOn",
          "signature": "QueueT q m a-\u003e[QueueKey q]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Control-Monad-Queue-QueueT.html#v:3ArunQueueTOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.Class",
          "name": "3A:-\u003e",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#%3A-%3E",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3A:-\u003e",
          "package": "pqueue-mtl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#t:3A:-\u003e"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.Class",
          "name": "3AQueueKey",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#QueueKey",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AQueueKey",
          "package": "pqueue-mtl",
          "partial": "AQueue Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#t:3AQueueKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.Class",
          "name": "3AQueuelike",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#Queuelike",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AQueuelike",
          "package": "pqueue-mtl",
          "partial": "AQueuelike",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3AQueuelike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Deletes an element from the queue, if the queue is nonempty.  The default implementation uses \u003ctt\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Adelete",
          "package": "pqueue-mtl",
          "signature": "q -\u003e Maybe q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#delete",
          "type": "function"
        },
        "index": {
          "description": "Deletes an element from the queue if the queue is nonempty The default implementation uses extract",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Adelete",
          "normalized": "a-\u003eMaybe a",
          "package": "pqueue-mtl",
          "partial": "Adelete",
          "signature": "q-\u003eMaybe q",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Adelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Constructs an empty queue.  The default implementation uses \u003ctt\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Aempty",
          "package": "pqueue-mtl",
          "signature": "q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#empty",
          "type": "function"
        },
        "index": {
          "description": "Constructs an empty queue The default implementation uses fromList",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Aempty",
          "package": "pqueue-mtl",
          "partial": "Aempty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Aempty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Attempts to extract an element from the queue; if the queue is empty, returns Nothing.  The default implementation uses \u003ctt\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003edelete\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Aextract",
          "package": "pqueue-mtl",
          "signature": "q -\u003e Maybe (QueueKey q, q)",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#extract",
          "type": "function"
        },
        "index": {
          "description": "Attempts to extract an element from the queue if the queue is empty returns Nothing The default implementation uses peek and delete",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Aextract",
          "normalized": "a-\u003eMaybe(QueueKey a,a)",
          "package": "pqueue-mtl",
          "partial": "Aextract",
          "signature": "q-\u003eMaybe(QueueKey q,q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Aextract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Constructs a queue with all of the elements in the list.  The default implementation uses \u003ctt\u003e\u003ca\u003einsertAll\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3AfromList",
          "package": "pqueue-mtl",
          "signature": "[QueueKey q] -\u003e q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Constructs queue with all of the elements in the list The default implementation uses insertAll and empty",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AfromList",
          "normalized": "[QueueKey a]-\u003ea",
          "package": "pqueue-mtl",
          "partial": "Afrom List",
          "signature": "[QueueKey q]-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3AfromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Inserts a single element into the queue.  The default implementation uses \u003ctt\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003esingleton\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Ainsert",
          "package": "pqueue-mtl",
          "signature": "QueueKey q -\u003e q -\u003e q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#insert",
          "type": "function"
        },
        "index": {
          "description": "Inserts single element into the queue The default implementation uses merge and singleton",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Ainsert",
          "normalized": "QueueKey a-\u003ea-\u003ea",
          "package": "pqueue-mtl",
          "partial": "Ainsert",
          "signature": "QueueKey q-\u003eq-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Ainsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Inserts several elements into the queue.  The default implementation uses \u003ctt\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/tt\u003e.  (In some cases, it may be advantageous to override this implementation with \u003ctt\u003exs `\u003ctt\u003e\u003ca\u003einsertAll\u003c/a\u003e\u003c/tt\u003e` q = q `\u003ctt\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/tt\u003e` \u003ctt\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/tt\u003e xs\u003c/tt\u003e.)\n",
          "module": "Data.Queue.Class",
          "name": "3AinsertAll",
          "package": "pqueue-mtl",
          "signature": "[QueueKey q] -\u003e q -\u003e q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#insertAll",
          "type": "function"
        },
        "index": {
          "description": "Inserts several elements into the queue The default implementation uses insert In some cases it may be advantageous to override this implementation with xs insertAll merge fromList xs",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AinsertAll",
          "normalized": "[QueueKey a]-\u003ea-\u003ea",
          "package": "pqueue-mtl",
          "partial": "Ainsert All",
          "signature": "[QueueKey q]-\u003eq-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3AinsertAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Checks if the queue is empty.  The default implementation uses \u003ctt\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3AisEmpty",
          "package": "pqueue-mtl",
          "signature": "q -\u003e Bool",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#isEmpty",
          "type": "function"
        },
        "index": {
          "description": "Checks if the queue is empty The default implementation uses peek",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AisEmpty",
          "normalized": "a-\u003eBool",
          "package": "pqueue-mtl",
          "partial": "Ais Empty",
          "signature": "q-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3AisEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Merges two queues so that the contents of the second queue are inserted into the first queue in extraction order.  The default implementation uses \u003ctt\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003einsertAll\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Amerge",
          "package": "pqueue-mtl",
          "signature": "q -\u003e q -\u003e q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#merge",
          "type": "function"
        },
        "index": {
          "description": "Merges two queues so that the contents of the second queue are inserted into the first queue in extraction order The default implementation uses toList and insertAll",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Amerge",
          "normalized": "a-\u003ea-\u003ea",
          "package": "pqueue-mtl",
          "partial": "Amerge",
          "signature": "q-\u003eq-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Amerge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.Class",
          "name": "3AmergeAll",
          "package": "pqueue-mtl",
          "signature": "[q] -\u003e q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#mergeAll",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AmergeAll",
          "normalized": "[a]-\u003ea",
          "package": "pqueue-mtl",
          "partial": "Amerge All",
          "signature": "[q]-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3AmergeAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Gets the element that will next be extracted from the queue, if there is an element available.  The default implementation uses \u003ctt\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Apeek",
          "package": "pqueue-mtl",
          "signature": "q -\u003e Maybe (QueueKey q)",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#peek",
          "type": "function"
        },
        "index": {
          "description": "Gets the element that will next be extracted from the queue if there is an element available The default implementation uses extract",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Apeek",
          "normalized": "a-\u003eMaybe(QueueKey a)",
          "package": "pqueue-mtl",
          "partial": "Apeek",
          "signature": "q-\u003eMaybe(QueueKey q)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Apeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Constructs a queue with a single element.  The default implementation uses \u003ctt\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/tt\u003e and \u003ctt\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Asingleton",
          "package": "pqueue-mtl",
          "signature": "QueueKey q -\u003e q",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "Constructs queue with single element The default implementation uses insert and empty",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Asingleton",
          "normalized": "QueueKey a-\u003ea",
          "package": "pqueue-mtl",
          "partial": "Asingleton",
          "signature": "QueueKey q-\u003eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Asingleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Gets the size of the queue.  The default implementation uses \u003ctt\u003e\u003ca\u003etoList_\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3Asize",
          "package": "pqueue-mtl",
          "signature": "q -\u003e Int",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#size",
          "type": "function"
        },
        "index": {
          "description": "Gets the size of the queue The default implementation uses toList",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3Asize",
          "normalized": "a-\u003eInt",
          "package": "pqueue-mtl",
          "partial": "Asize",
          "signature": "q-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3Asize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Extracts every element from the queue.  The default implementation uses \u003ctt\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3AtoList",
          "package": "pqueue-mtl",
          "signature": "q -\u003e [QueueKey q]",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#toList",
          "type": "function"
        },
        "index": {
          "description": "Extracts every element from the queue The default implementation uses extract",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AtoList",
          "normalized": "a-\u003e[QueueKey a]",
          "package": "pqueue-mtl",
          "partial": "Ato List",
          "signature": "q-\u003e[QueueKey q]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3AtoList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "Extracts every element from the queue, with no guarantees upon order.  The default implementation uses \u003ctt\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/tt\u003e.\n",
          "module": "Data.Queue.Class",
          "name": "3AtoList_",
          "package": "pqueue-mtl",
          "signature": "q -\u003e [QueueKey q]",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Class.html#toList_",
          "type": "function"
        },
        "index": {
          "description": "Extracts every element from the queue with no guarantees upon order The default implementation uses toList",
          "hierarchy": "Data Queue Class",
          "module": "Data.Queue.Class",
          "name": "3AtoList_",
          "normalized": "a-\u003e[QueueKey a]",
          "package": "pqueue-mtl",
          "partial": "Ato List",
          "signature": "q-\u003e[QueueKey q]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Class.html#v:3AtoList_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.FibQueue",
          "name": "3AFQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-FibQueue.html#FQueue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue FibQueue",
          "module": "Data.Queue.FibQueue",
          "name": "3AFQueue",
          "package": "pqueue-mtl",
          "partial": "AFQueue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-FibQueue.html#t:3AFQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.IntQueue",
          "name": "3AIntAssocQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-IntQueue.html#IntAssocQueue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue IntQueue",
          "module": "Data.Queue.IntQueue",
          "name": "3AIntAssocQueue",
          "package": "pqueue-mtl",
          "partial": "AInt Assoc Queue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-IntQueue.html#t:3AIntAssocQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.IntQueue",
          "name": "3AIntQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-IntQueue.html#IntQueue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue IntQueue",
          "module": "Data.Queue.IntQueue",
          "name": "3AIntQueue",
          "package": "pqueue-mtl",
          "partial": "AInt Queue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-IntQueue.html#t:3AIntQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.PQueue",
          "name": "3APQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-PQueue.html#PQueue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue PQueue",
          "module": "Data.Queue.PQueue",
          "name": "3APQueue",
          "package": "pqueue-mtl",
          "partial": "APQueue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-PQueue.html#t:3APQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.Queue",
          "name": "3AQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Queue.html#Queue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue Queue",
          "module": "Data.Queue.Queue",
          "name": "3AQueue",
          "package": "pqueue-mtl",
          "partial": "AQueue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Queue.html#t:3AQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.ReverseQueue",
          "name": "3ADown",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-ReverseQueue.html#Down",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Data Queue ReverseQueue",
          "module": "Data.Queue.ReverseQueue",
          "name": "3ADown",
          "package": "pqueue-mtl",
          "partial": "ADown",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-ReverseQueue.html#t:3ADown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.ReverseQueue",
          "name": "3AReverseQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-ReverseQueue.html#ReverseQueue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue ReverseQueue",
          "module": "Data.Queue.ReverseQueue",
          "name": "3AReverseQueue",
          "package": "pqueue-mtl",
          "partial": "AReverse Queue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-ReverseQueue.html#t:3AReverseQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.SkewQueue",
          "name": "3ASkewQueue",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-SkewQueue.html#SkewQueue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue SkewQueue",
          "module": "Data.Queue.SkewQueue",
          "name": "3ASkewQueue",
          "package": "pqueue-mtl",
          "partial": "ASkew Queue",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-SkewQueue.html#t:3ASkewQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Queue.Stack",
          "name": "3AStack",
          "package": "pqueue-mtl",
          "source": "http://hackage.haskell.org/package/pqueue-mtl/docs/src/Data-Queue-Stack.html#Stack",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Queue Stack",
          "module": "Data.Queue.Stack",
          "name": "3AStack",
          "package": "pqueue-mtl",
          "partial": "AStack",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/pqueue-mtl/docs/Data-Queue-Stack.html#t:3AStack"
      }
    }
  ]
]