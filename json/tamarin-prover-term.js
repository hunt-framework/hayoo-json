[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "tamarin-prover-term"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConvenience abbreviations, mostly used for testing and debugging.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Builtin.Convenience",
          "name": "Convenience",
          "package": "tamarin-prover-term",
          "source": "src/Term-Builtin-Convenience.html",
          "type": "module"
        },
        "index": {
          "description": "Convenience abbreviations mostly used for testing and debugging",
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "Convenience",
          "package": "tamarin-prover-term",
          "partial": "Convenience",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "(#)",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Term a -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#%23",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "(#) #",
          "normalized": "Term a-\u003eTerm a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "Term a-\u003eTerm a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "(*:)",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Term a -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#%2A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "(*:) *:",
          "normalized": "Term a-\u003eTerm a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "Term a-\u003eTerm a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:-42-:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "adec",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#adec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "adec",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:adec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "aenc",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#aenc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "aenc",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:aenc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "f9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#f9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "f9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:f9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "freshVar",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e Integer -\u003e LNTerm",
          "source": "src/Term-Builtin-Convenience.html#freshVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "freshVar",
          "normalized": "String-\u003eInteger-\u003eLNTerm",
          "package": "tamarin-prover-term",
          "partial": "Var",
          "signature": "String-\u003eInteger-\u003eLNTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:freshVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx0",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx0",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx10",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx10",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "fx9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#fx9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "fx9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:fx9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "i9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#i9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "i9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:i9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li1",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li2",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li3",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li4",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li5",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li6",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li7",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li8",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "li9",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#li9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "li9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:li9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv1",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv2",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv3",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv4",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv5",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv6",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv7",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv8",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lv9",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lv9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lv9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lv9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx1",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx10",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx10",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx2",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx3",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx4",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx5",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx6",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx7",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx8",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "lx9",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-Builtin-Convenience.html#lx9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "lx9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:lx9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "p9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#p9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "p9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:p9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "pk",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#pk",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "pk",
          "normalized": "Term a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "Term a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:pk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "pubVar",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e Integer -\u003e LNTerm",
          "source": "src/Term-Builtin-Convenience.html#pubVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "pubVar",
          "normalized": "String-\u003eInteger-\u003eLNTerm",
          "package": "tamarin-prover-term",
          "partial": "Var",
          "signature": "String-\u003eInteger-\u003eLNTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:pubVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px0",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px0",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px10",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px10",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "px9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#px9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "px9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:px9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "sdec",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#sdec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "sdec",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:sdec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "senc",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#senc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "senc",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:senc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "sign",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#sign",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "sign",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:sign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "trueC",
          "package": "tamarin-prover-term",
          "signature": "Term a",
          "source": "src/Term-Builtin-Convenience.html#trueC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "trueC",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:trueC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "v9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#v9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "v9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:v9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "var",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e Integer -\u003e LNTerm",
          "source": "src/Term-Builtin-Convenience.html#var",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "var",
          "normalized": "String-\u003eInteger-\u003eLNTerm",
          "package": "tamarin-prover-term",
          "signature": "String-\u003eInteger-\u003eLNTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "verify",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a, Term a) -\u003e Term a",
          "source": "src/Term-Builtin-Convenience.html#verify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "verify",
          "normalized": "(Term a,Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:verify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x0",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x0",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x10",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x10",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "x9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#x9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "x9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:x9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y0",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y0",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y1",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y1",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y2",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y2",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y3",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y3",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y4",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y5",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y5",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y6",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y7",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y7",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y8",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y8",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Builtin.Convenience",
          "name": "y9",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-Builtin-Convenience.html#y9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Builtin Convenience",
          "module": "Term.Builtin.Convenience",
          "name": "y9",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Convenience.html#v:y9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBuiltin rewriting rules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Builtin.Rules",
          "name": "Rules",
          "package": "tamarin-prover-term",
          "source": "src/Term-Builtin-Rules.html",
          "type": "module"
        },
        "index": {
          "description": "Builtin rewriting rules",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "Rules",
          "package": "tamarin-prover-term",
          "partial": "Rules",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rewrite rule.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "RRule",
          "package": "tamarin-prover-term",
          "source": "src/Term-Rewriting-Definitions.html#RRule",
          "type": "data"
        },
        "index": {
          "description": "rewrite rule",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "RRule",
          "package": "tamarin-prover-term",
          "partial": "RRule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#t:RRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Term.Builtin.Rules\",\"Term.Rewriting.Definitions\"]",
          "name": "RRule",
          "package": "tamarin-prover-term",
          "signature": "RRule a a",
          "source": "src/Term-Rewriting-Definitions.html#RRule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:RRule\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:RRule\"]"
        },
        "index": {
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "RRule",
          "package": "tamarin-prover-term",
          "partial": "RRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:RRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rewriting rules for standard subterm operators that are builtin.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "asymEncRules",
          "package": "tamarin-prover-term",
          "signature": "Set StRule",
          "source": "src/Term-Builtin-Rules.html#asymEncRules",
          "type": "function"
        },
        "index": {
          "description": "The rewriting rules for standard subterm operators that are builtin",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "asymEncRules",
          "package": "tamarin-prover-term",
          "partial": "Enc Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:asymEncRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rewriting rules for bilinear pairing. These rules extend the\n   the rules for Diffie-Hellman.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "bpRules",
          "package": "tamarin-prover-term",
          "signature": "Set (RRule LNTerm)",
          "source": "src/Term-Builtin-Rules.html#bpRules",
          "type": "function"
        },
        "index": {
          "description": "The rewriting rules for bilinear pairing These rules extend the the rules for Diffie-Hellman",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "bpRules",
          "package": "tamarin-prover-term",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:bpRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rewriting rules for Diffie-Hellman. This is a presentation due to Lankford\n   with the finite variant property.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "dhRules",
          "package": "tamarin-prover-term",
          "signature": "Set (RRule LNTerm)",
          "source": "src/Term-Builtin-Rules.html#dhRules",
          "type": "function"
        },
        "index": {
          "description": "The rewriting rules for Diffie-Hellman This is presentation due to Lankford with the finite variant property",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "dhRules",
          "package": "tamarin-prover-term",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:dhRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rewriting rules for multisets.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "msetRules",
          "package": "tamarin-prover-term",
          "signature": "Set (RRule LNTerm)",
          "source": "src/Term-Builtin-Rules.html#msetRules",
          "type": "function"
        },
        "index": {
          "description": "The rewriting rules for multisets",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "msetRules",
          "package": "tamarin-prover-term",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:msetRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rewriting rules for standard subterm operators that are builtin.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "pairRules",
          "package": "tamarin-prover-term",
          "signature": "Set StRule",
          "source": "src/Term-Builtin-Rules.html#pairRules",
          "type": "function"
        },
        "index": {
          "description": "The rewriting rules for standard subterm operators that are builtin",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "pairRules",
          "package": "tamarin-prover-term",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:pairRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rewriting rules for standard subterm operators that are builtin.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "signatureRules",
          "package": "tamarin-prover-term",
          "signature": "Set StRule",
          "source": "src/Term-Builtin-Rules.html#signatureRules",
          "type": "function"
        },
        "index": {
          "description": "The rewriting rules for standard subterm operators that are builtin",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "signatureRules",
          "package": "tamarin-prover-term",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:signatureRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rewriting rules for standard subterm operators that are builtin.\n\u003c/p\u003e",
          "module": "Term.Builtin.Rules",
          "name": "symEncRules",
          "package": "tamarin-prover-term",
          "signature": "Set StRule",
          "source": "src/Term-Builtin-Rules.html#symEncRules",
          "type": "function"
        },
        "index": {
          "description": "The rewriting rules for standard subterm operators that are builtin",
          "hierarchy": "Term Builtin Rules",
          "module": "Term.Builtin.Rules",
          "name": "symEncRules",
          "package": "tamarin-prover-term",
          "partial": "Enc Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Rules.html#v:symEncRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBuiltin function symbols and signatures.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Builtin.Signature",
          "name": "Signature",
          "package": "tamarin-prover-term",
          "source": "src/Term-Builtin-Signature.html",
          "type": "module"
        },
        "index": {
          "description": "Builtin function symbols and signatures",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "Signature",
          "package": "tamarin-prover-term",
          "partial": "Signature",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "adecSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#adecSym",
          "type": "function"
        },
        "index": {
          "description": "Binary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "adecSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:adecSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "aencSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#aencSym",
          "type": "function"
        },
        "index": {
          "description": "Binary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "aencSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:aencSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for asymmetric encryption.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "asymEncFunSig",
          "package": "tamarin-prover-term",
          "signature": "NoEqFunSig",
          "source": "src/Term-Builtin-Signature.html#asymEncFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for asymmetric encryption",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "asymEncFunSig",
          "package": "tamarin-prover-term",
          "partial": "Enc Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:asymEncFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for hashing.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "hashFunSig",
          "package": "tamarin-prover-term",
          "signature": "NoEqFunSig",
          "source": "src/Term-Builtin-Signature.html#hashFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for hashing",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "hashFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:hashFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "hashSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#hashSym",
          "type": "function"
        },
        "index": {
          "description": "Unary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "hashSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:hashSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "pkSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#pkSym",
          "type": "function"
        },
        "index": {
          "description": "Unary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "pkSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:pkSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "sdecSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#sdecSym",
          "type": "function"
        },
        "index": {
          "description": "Binary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "sdecSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:sdecSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "sencSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#sencSym",
          "type": "function"
        },
        "index": {
          "description": "Binary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "sencSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:sencSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBinary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "signSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#signSym",
          "type": "function"
        },
        "index": {
          "description": "Binary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "signSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:signSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for cryptographic signatures.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "signatureFunSig",
          "package": "tamarin-prover-term",
          "signature": "NoEqFunSig",
          "source": "src/Term-Builtin-Signature.html#signatureFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for cryptographic signatures",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "signatureFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:signatureFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for symmetric encryption.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "symEncFunSig",
          "package": "tamarin-prover-term",
          "signature": "NoEqFunSig",
          "source": "src/Term-Builtin-Signature.html#symEncFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for symmetric encryption",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "symEncFunSig",
          "package": "tamarin-prover-term",
          "partial": "Enc Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:symEncFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNullary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "trueSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#trueSym",
          "type": "function"
        },
        "index": {
          "description": "Nullary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "trueSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:trueSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTernary builtin function symbols.\n\u003c/p\u003e",
          "module": "Term.Builtin.Signature",
          "name": "verifySym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Builtin-Signature.html#verifySym",
          "type": "function"
        },
        "index": {
          "description": "Ternary builtin function symbols",
          "hierarchy": "Term Builtin Signature",
          "module": "Term.Builtin.Signature",
          "name": "verifySym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Builtin-Signature.html#v:verifySym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTerms with logical variables  and names.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.LTerm",
          "name": "LTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html",
          "type": "module"
        },
        "index": {
          "description": "Terms with logical variables and names",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LTerm",
          "package": "tamarin-prover-term",
          "partial": "LTerm",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTerms built over names and \u003ccode\u003e\u003ca\u003eLVar\u003c/a\u003e\u003c/code\u003es combined with quantified variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "BLTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#BLTerm",
          "type": "type"
        },
        "index": {
          "description": "Terms built over names and LVar combined with quantified variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "BLTerm",
          "package": "tamarin-prover-term",
          "partial": "BLTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:BLTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eLVar\u003c/a\u003e\u003c/code\u003es combined with quantified variables. They occur only in \u003ccode\u003eLFormula\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "BLVar",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#BLVar",
          "type": "type"
        },
        "index": {
          "description": "LVar combined with quantified variables They occur only in LFormula",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "BLVar",
          "package": "tamarin-prover-term",
          "partial": "BLVar",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:BLVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBound and free variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "BVar",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#BVar",
          "type": "data"
        },
        "index": {
          "description": "Bound and free variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "BVar",
          "package": "tamarin-prover-term",
          "partial": "BVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:BVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eHasFree t\u003c/code\u003e denotes that the type \u003ccode\u003et\u003c/code\u003e has free \u003ccode\u003eLVar\u003c/code\u003e variables. They can\n be collected using \u003ccode\u003e\u003ca\u003efoldFrees\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efoldFreesOcc\u003c/a\u003e\u003c/code\u003e and mapped in the context\n of an applicative functor using \u003ccode\u003e\u003ca\u003emapFrees\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen defining instances of this class, you have to ensure that only the free\n LVars are collected and mapped and no others. The instances for standard\n Haskell types assume that all variables free in all type arguments are free.\n The \u003ccode\u003e\u003ca\u003efoldFreesOcc\u003c/a\u003e\u003c/code\u003e is only used to define the function \u003ccode\u003e\u003ca\u003evarOccurences\u003c/a\u003e\u003c/code\u003e. See\n below for required properties of the instance methods.\n\u003c/p\u003e\u003cp\u003eOnce we need it, we can use type synonym instances to parametrize over the\n variable type.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "HasFrees",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#HasFrees",
          "type": "class"
        },
        "index": {
          "description": "HasFree denotes that the type has free LVar variables They can be collected using foldFrees and foldFreesOcc and mapped in the context of an applicative functor using mapFrees When defining instances of this class you have to ensure that only the free LVars are collected and mapped and no others The instances for standard Haskell types assume that all variables free in all type arguments are free The foldFreesOcc is only used to define the function varOccurences See below for required properties of the instance methods Once we need it we can use type synonym instances to parametrize over the variable type",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "HasFrees",
          "package": "tamarin-prover-term",
          "partial": "Has Frees",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:HasFrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTerms used for proving; i.e., variables fixed to logical variables\n   and constants to Names.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "LNTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#LNTerm",
          "type": "type"
        },
        "index": {
          "description": "Terms used for proving i.e variables fixed to logical variables and constants to Names",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LNTerm",
          "package": "tamarin-prover-term",
          "partial": "LNTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:LNTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSorts for logical variables. They satisfy the following sub-sort relation:\n\u003c/p\u003e\u003cpre\u003e  LSortFresh \u003c LSortMsg\n  LSortPub   \u003c LSortMsg\n\u003c/pre\u003e",
          "module": "Term.LTerm",
          "name": "LSort",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#LSort",
          "type": "data"
        },
        "index": {
          "description": "Sorts for logical variables They satisfy the following sub-sort relation LSortFresh LSortMsg LSortPub LSortMsg",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LSort",
          "package": "tamarin-prover-term",
          "partial": "LSort",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:LSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTerms used for proving; i.e., variables fixed to logical variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "LTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#LTerm",
          "type": "type"
        },
        "index": {
          "description": "Terms used for proving i.e variables fixed to logical variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LTerm",
          "package": "tamarin-prover-term",
          "partial": "LTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:LTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogical variables. Variables with the same name and index but different\n sorts are regarded as different variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "LVar",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#LVar",
          "type": "data"
        },
        "index": {
          "description": "Logical variables Variables with the same name and index but different sorts are regarded as different variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LVar",
          "package": "tamarin-prover-term",
          "partial": "LVar",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:LVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor performance reasons, we distinguish between monotone functions on\n \u003ccode\u003e\u003ca\u003eLVar\u003c/a\u003e\u003c/code\u003es and arbitrary functions. For a monotone f, if \u003ccode\u003ex \u003c= y\u003c/code\u003e, then\n \u003ccode\u003ef x \u003c= f y\u003c/code\u003e. This ensures that the AC-normal form does not have\n to be recomputed. If you are unsure about what to use, then use the\n \u003ccode\u003e\u003ca\u003eArbitrary\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "MonotoneFunction",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#MonotoneFunction",
          "type": "data"
        },
        "index": {
          "description": "For performance reasons we distinguish between monotone functions on LVar and arbitrary functions For monotone if then This ensures that the AC-normal form does not have to be recomputed If you are unsure about what to use then use the Arbitrary function",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "MonotoneFunction",
          "package": "tamarin-prover-term",
          "partial": "Monotone Function",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:MonotoneFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTerms with literals containing names and arbitrary variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "NTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#NTerm",
          "type": "type"
        },
        "index": {
          "description": "Terms with literals containing names and arbitrary variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "NTerm",
          "package": "tamarin-prover-term",
          "partial": "NTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:NTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNames.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "Name",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#Name",
          "type": "data"
        },
        "index": {
          "description": "Names",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "Name",
          "package": "tamarin-prover-term",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType safety for names.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "NameId",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#NameId",
          "type": "newtype"
        },
        "index": {
          "description": "Type safety for names",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "NameId",
          "package": "tamarin-prover-term",
          "partial": "Name Id",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:NameId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTags for names.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "NameTag",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#NameTag",
          "type": "data"
        },
        "index": {
          "description": "Tags for names",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "NameTag",
          "package": "tamarin-prover-term",
          "partial": "Name Tag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:NameTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alternative name for logical variables, which are intented to be\n variables of sort \u003ccode\u003e\u003ca\u003eLSortNode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "NodeId",
          "package": "tamarin-prover-term",
          "source": "src/Term-LTerm.html#NodeId",
          "type": "type"
        },
        "index": {
          "description": "An alternative name for logical variables which are intented to be variables of sort LSortNode",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "NodeId",
          "package": "tamarin-prover-term",
          "partial": "Node Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#t:NodeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "Arbitrary",
          "package": "tamarin-prover-term",
          "signature": "Arbitrary (LVar -\u003e f LVar)",
          "source": "src/Term-LTerm.html#MonotoneFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "Arbitrary",
          "normalized": "Arbitrary(LVar-\u003ea LVar)",
          "package": "tamarin-prover-term",
          "partial": "Arbitrary",
          "signature": "Arbitrary(LVar-\u003ef LVar)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:Arbitrary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA bound variable in De-Brujin notation.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "Bound",
          "package": "tamarin-prover-term",
          "signature": "Bound Integer",
          "source": "src/Term-LTerm.html#BVar",
          "type": "function"
        },
        "index": {
          "description": "bound variable in De-Brujin notation",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "Bound",
          "package": "tamarin-prover-term",
          "partial": "Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:Bound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA free variable.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "Free",
          "package": "tamarin-prover-term",
          "signature": "Free v",
          "source": "src/Term-LTerm.html#BVar",
          "type": "function"
        },
        "index": {
          "description": "free variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "Free",
          "package": "tamarin-prover-term",
          "partial": "Free",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:Free"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "FreshName",
          "package": "tamarin-prover-term",
          "signature": "FreshName",
          "source": "src/Term-LTerm.html#NameTag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "FreshName",
          "package": "tamarin-prover-term",
          "partial": "Fresh Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:FreshName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary fresh names.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "LSortFresh",
          "package": "tamarin-prover-term",
          "signature": "LSortFresh",
          "source": "src/Term-LTerm.html#LSort",
          "type": "function"
        },
        "index": {
          "description": "Arbitrary fresh names",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LSortFresh",
          "package": "tamarin-prover-term",
          "partial": "LSort Fresh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:LSortFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary messages.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "LSortMsg",
          "package": "tamarin-prover-term",
          "signature": "LSortMsg",
          "source": "src/Term-LTerm.html#LSort",
          "type": "function"
        },
        "index": {
          "description": "Arbitrary messages",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LSortMsg",
          "package": "tamarin-prover-term",
          "partial": "LSort Msg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:LSortMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort for variables denoting nodes of derivation graphs.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "LSortNode",
          "package": "tamarin-prover-term",
          "signature": "LSortNode",
          "source": "src/Term-LTerm.html#LSort",
          "type": "function"
        },
        "index": {
          "description": "Sort for variables denoting nodes of derivation graphs",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LSortNode",
          "package": "tamarin-prover-term",
          "partial": "LSort Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:LSortNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary public names.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "LSortPub",
          "package": "tamarin-prover-term",
          "signature": "LSortPub",
          "source": "src/Term-LTerm.html#LSort",
          "type": "function"
        },
        "index": {
          "description": "Arbitrary public names",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LSortPub",
          "package": "tamarin-prover-term",
          "partial": "LSort Pub",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:LSortPub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "LVar",
          "package": "tamarin-prover-term",
          "signature": "LVar",
          "source": "src/Term-LTerm.html#LVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "LVar",
          "package": "tamarin-prover-term",
          "partial": "LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:LVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "Monotone",
          "package": "tamarin-prover-term",
          "signature": "Monotone (LVar -\u003e f LVar)",
          "source": "src/Term-LTerm.html#MonotoneFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "Monotone",
          "normalized": "Monotone(LVar-\u003ea LVar)",
          "package": "tamarin-prover-term",
          "partial": "Monotone",
          "signature": "Monotone(LVar-\u003ef LVar)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:Monotone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "Name",
          "package": "tamarin-prover-term",
          "signature": "Name",
          "source": "src/Term-LTerm.html#Name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "Name",
          "package": "tamarin-prover-term",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "NameId",
          "package": "tamarin-prover-term",
          "signature": "NameId",
          "source": "src/Term-LTerm.html#NameId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "NameId",
          "package": "tamarin-prover-term",
          "partial": "Name Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:NameId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "PubName",
          "package": "tamarin-prover-term",
          "signature": "PubName",
          "source": "src/Term-LTerm.html#NameTag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "PubName",
          "package": "tamarin-prover-term",
          "partial": "Pub Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:PubName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eavoid t\u003c/code\u003e computes a \u003ccode\u003e\u003ca\u003eFreshState\u003c/a\u003e\u003c/code\u003e that avoids generating\n variables occurring in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "avoid",
          "package": "tamarin-prover-term",
          "signature": "t -\u003e FreshState",
          "source": "src/Term-LTerm.html#avoid",
          "type": "function"
        },
        "index": {
          "description": "avoid computes FreshState that avoids generating variables occurring in",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "avoid",
          "normalized": "a-\u003eFreshState",
          "package": "tamarin-prover-term",
          "signature": "t-\u003eFreshState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:avoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eavoidPrecise t\u003c/code\u003e computes a \u003ccode\u003e\u003ca\u003eFreshState\u003c/a\u003e\u003c/code\u003e that avoids generating\n variables occurring in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "avoidPrecise",
          "package": "tamarin-prover-term",
          "signature": "t -\u003e FreshState",
          "source": "src/Term-LTerm.html#avoidPrecise",
          "type": "function"
        },
        "index": {
          "description": "avoidPrecise computes FreshState that avoids generating variables occurring in",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "avoidPrecise",
          "normalized": "a-\u003eFreshState",
          "package": "tamarin-prover-term",
          "partial": "Precise",
          "signature": "t-\u003eFreshState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:avoidPrecise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a node-id variable from a term that may be a node-id variable.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "bltermNodeId",
          "package": "tamarin-prover-term",
          "signature": "BLTerm -\u003e Maybe LVar",
          "source": "src/Term-LTerm.html#bltermNodeId",
          "type": "function"
        },
        "index": {
          "description": "Extract node-id variable from term that may be node-id variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "bltermNodeId",
          "normalized": "BLTerm-\u003eMaybe LVar",
          "package": "tamarin-prover-term",
          "partial": "Node Id",
          "signature": "BLTerm-\u003eMaybe LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:bltermNodeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a node-id variable from a term that must be a node-id variable.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "bltermNodeId'",
          "package": "tamarin-prover-term",
          "signature": "BLTerm -\u003e LVar",
          "source": "src/Term-LTerm.html#bltermNodeId%27",
          "type": "function"
        },
        "index": {
          "description": "Extract node-id variable from term that must be node-id variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "bltermNodeId'",
          "normalized": "BLTerm-\u003eLVar",
          "package": "tamarin-prover-term",
          "partial": "Node Id'",
          "signature": "BLTerm-\u003eLVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:bltermNodeId-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003econtainsPrivate t\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e if \u003ccode\u003et\u003c/code\u003e contains private function symbols.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "containsPrivate",
          "package": "tamarin-prover-term",
          "signature": "Term t -\u003e Bool",
          "source": "src/Term-LTerm.html#containsPrivate",
          "type": "function"
        },
        "index": {
          "description": "containsPrivate returns True if contains private function symbols",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "containsPrivate",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Private",
          "signature": "Term t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:containsPrivate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eeqModuloFreshness t1 t2\u003c/code\u003e checks whether \u003ccode\u003et1\u003c/code\u003e is equal to \u003ccode\u003et2\u003c/code\u003e modulo\n renaming of indices of free variables. Note that the normal form is not\n unique with respect to AC symbols.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "eqModuloFreshnessNoAC",
          "package": "tamarin-prover-term",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Term-LTerm.html#eqModuloFreshnessNoAC",
          "type": "function"
        },
        "index": {
          "description": "eqModuloFreshness t1 t2 checks whether t1 is equal to t2 modulo renaming of indices of free variables Note that the normal form is not unique with respect to AC symbols",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "eqModuloFreshnessNoAC",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Modulo Freshness No AC",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:eqModuloFreshnessNoAC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003em \u003ccode\u003e\u003ca\u003eevalFreshAvoiding\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e evaluates the monadic action \u003ccode\u003em\u003c/code\u003e with a\n fresh-variable supply that avoids generating variables occurring in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "evalFreshAvoiding",
          "package": "tamarin-prover-term",
          "signature": "Fresh a -\u003e t -\u003e a",
          "source": "src/Term-LTerm.html#evalFreshAvoiding",
          "type": "function"
        },
        "index": {
          "description": "evalFreshAvoiding evaluates the monadic action with fresh-variable supply that avoids generating variables occurring in",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "evalFreshAvoiding",
          "normalized": "Fresh a-\u003eb-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Fresh Avoiding",
          "signature": "Fresh a-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:evalFreshAvoiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003em \u003ccode\u003e\u003ca\u003eevalFreshTAvoiding\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e evaluates the monadic action \u003ccode\u003em\u003c/code\u003e in the\n underlying monad with a fresh-variable supply that avoids generating\n variables occurring in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "evalFreshTAvoiding",
          "package": "tamarin-prover-term",
          "signature": "FreshT m a -\u003e t -\u003e m a",
          "source": "src/Term-LTerm.html#evalFreshTAvoiding",
          "type": "function"
        },
        "index": {
          "description": "evalFreshTAvoiding evaluates the monadic action in the underlying monad with fresh-variable supply that avoids generating variables occurring in",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "evalFreshTAvoiding",
          "normalized": "FreshT a b-\u003ec-\u003ea b",
          "package": "tamarin-prover-term",
          "partial": "Fresh TAvoiding",
          "signature": "FreshT m a-\u003et-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:evalFreshTAvoiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold a possibly bound variable.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "foldBVar",
          "package": "tamarin-prover-term",
          "signature": "(Integer -\u003e a) -\u003e (v -\u003e a) -\u003e BVar v -\u003e a",
          "source": "src/Term-LTerm.html#foldBVar",
          "type": "function"
        },
        "index": {
          "description": "Fold possibly bound variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "foldBVar",
          "normalized": "(Integer-\u003ea)-\u003e(b-\u003ea)-\u003eBVar b-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "BVar",
          "signature": "(Integer-\u003ea)-\u003e(v-\u003ea)-\u003eBVar v-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:foldBVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "foldFrees",
          "package": "tamarin-prover-term",
          "signature": "(LVar -\u003e m) -\u003e t -\u003e m",
          "source": "src/Term-LTerm.html#foldFrees",
          "type": "method"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "foldFrees",
          "normalized": "(LVar-\u003ea)-\u003eb-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Frees",
          "signature": "(LVar-\u003em)-\u003et-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:foldFrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "foldFreesOcc",
          "package": "tamarin-prover-term",
          "signature": "(Occurence -\u003e LVar -\u003e m) -\u003e Occurence -\u003e t -\u003e m",
          "source": "src/Term-LTerm.html#foldFreesOcc",
          "type": "method"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "foldFreesOcc",
          "normalized": "(Occurence-\u003eLVar-\u003ea)-\u003eOccurence-\u003eb-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Frees Occ",
          "signature": "(Occurence-\u003eLVar-\u003em)-\u003eOccurence-\u003et-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:foldFreesOcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efrees t\u003c/code\u003e is the sorted and duplicate-free list of all free variables in\n \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "frees",
          "package": "tamarin-prover-term",
          "signature": "t -\u003e [LVar]",
          "source": "src/Term-LTerm.html#frees",
          "type": "function"
        },
        "index": {
          "description": "frees is the sorted and duplicate-free list of all free variables in",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "frees",
          "normalized": "a-\u003e[LVar]",
          "package": "tamarin-prover-term",
          "signature": "t-\u003e[LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:frees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreesList t\u003c/code\u003e is the list of all free variables of \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "freesList",
          "package": "tamarin-prover-term",
          "signature": "t -\u003e [LVar]",
          "source": "src/Term-LTerm.html#freesList",
          "type": "function"
        },
        "index": {
          "description": "freesList is the list of all free variables of",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "freesList",
          "normalized": "a-\u003e[LVar]",
          "package": "tamarin-prover-term",
          "partial": "List",
          "signature": "t-\u003e[LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:freesList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreshLVar v\u003c/code\u003e represents a fresh logical variable with name \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "freshLVar",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e LSort -\u003e m LVar",
          "source": "src/Term-LTerm.html#freshLVar",
          "type": "function"
        },
        "index": {
          "description": "freshLVar represents fresh logical variable with name",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "freshLVar",
          "normalized": "String-\u003eLSort-\u003ea LVar",
          "package": "tamarin-prover-term",
          "partial": "LVar",
          "signature": "String-\u003eLSort-\u003em LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:freshLVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreshTerm f\u003c/code\u003e represents the fresh name \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "freshTerm",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e NTerm v",
          "source": "src/Term-LTerm.html#freshTerm",
          "type": "function"
        },
        "index": {
          "description": "freshTerm represents the fresh name",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "freshTerm",
          "normalized": "String-\u003eNTerm a",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "String-\u003eNTerm v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:freshTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the name of free variable under the assumption the variable is\n guaranteed to be of the form \u003ccode\u003eFree a\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "fromFree",
          "package": "tamarin-prover-term",
          "signature": "BVar v -\u003e v",
          "source": "src/Term-LTerm.html#fromFree",
          "type": "function"
        },
        "index": {
          "description": "Extract the name of free variable under the assumption the variable is guaranteed to be of the form Free",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "fromFree",
          "normalized": "BVar a-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Free",
          "signature": "BVar v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:fromFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "getNameId",
          "package": "tamarin-prover-term",
          "signature": "String",
          "source": "src/Term-LTerm.html#NameId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "getNameId",
          "package": "tamarin-prover-term",
          "partial": "Name Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:getNameId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs a term a fresh variable?\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "isFreshVar",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e Bool",
          "source": "src/Term-LTerm.html#isFreshVar",
          "type": "function"
        },
        "index": {
          "description": "Is term fresh variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "isFreshVar",
          "normalized": "LNTerm-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Fresh Var",
          "signature": "LNTerm-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:isFreshVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs a term a message variable?\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "isMsgVar",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e Bool",
          "source": "src/Term-LTerm.html#isMsgVar",
          "type": "function"
        },
        "index": {
          "description": "Is term message variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "isMsgVar",
          "normalized": "LNTerm-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Msg Var",
          "signature": "LNTerm-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:isMsgVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA term is *simple* iff there is an instance of this term that can be\n constructed from public names only. i.e., the term does not contain any\n fresh names, fresh variables, or private function symbols.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "isSimpleTerm",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e Bool",
          "source": "src/Term-LTerm.html#isSimpleTerm",
          "type": "function"
        },
        "index": {
          "description": "term is simple iff there is an instance of this term that can be constructed from public names only i.e the term does not contain any fresh names fresh variables or private function symbols",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "isSimpleTerm",
          "normalized": "LNTerm-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Simple Term",
          "signature": "LNTerm-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:isSimpleTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a node-id variable from a term that may be a node-id variable.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "ltermNodeId",
          "package": "tamarin-prover-term",
          "signature": "LTerm c -\u003e Maybe LVar",
          "source": "src/Term-LTerm.html#ltermNodeId",
          "type": "function"
        },
        "index": {
          "description": "Extract node-id variable from term that may be node-id variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "ltermNodeId",
          "normalized": "LTerm a-\u003eMaybe LVar",
          "package": "tamarin-prover-term",
          "partial": "Node Id",
          "signature": "LTerm c-\u003eMaybe LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:ltermNodeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a node-id variable from a term that must be a node-id variable.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "ltermNodeId'",
          "package": "tamarin-prover-term",
          "signature": "LTerm c -\u003e LVar",
          "source": "src/Term-LTerm.html#ltermNodeId%27",
          "type": "function"
        },
        "index": {
          "description": "Extract node-id variable from term that must be node-id variable",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "ltermNodeId'",
          "normalized": "LTerm a-\u003eLVar",
          "package": "tamarin-prover-term",
          "partial": "Node Id'",
          "signature": "LTerm c-\u003eLVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:ltermNodeId-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a variable of the given sort from a term that may be such a\n variable. Use \u003ccode\u003e\u003ca\u003etermVar\u003c/a\u003e\u003c/code\u003e, if you do not want to restrict the sort.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "ltermVar",
          "package": "tamarin-prover-term",
          "signature": "LSort -\u003e LTerm c -\u003e Maybe LVar",
          "source": "src/Term-LTerm.html#ltermVar",
          "type": "function"
        },
        "index": {
          "description": "Extract variable of the given sort from term that may be such variable Use termVar if you do not want to restrict the sort",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "ltermVar",
          "normalized": "LSort-\u003eLTerm a-\u003eMaybe LVar",
          "package": "tamarin-prover-term",
          "partial": "Var",
          "signature": "LSort-\u003eLTerm c-\u003eMaybe LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:ltermVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a variable of the given sort from a term that must be such a\n variable. Fails with an error, if that is not possible.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "ltermVar'",
          "package": "tamarin-prover-term",
          "signature": "LSort -\u003e LTerm c -\u003e LVar",
          "source": "src/Term-LTerm.html#ltermVar%27",
          "type": "function"
        },
        "index": {
          "description": "Extract variable of the given sort from term that must be such variable Fails with an error if that is not possible",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "ltermVar'",
          "normalized": "LSort-\u003eLTerm a-\u003eLVar",
          "package": "tamarin-prover-term",
          "partial": "Var'",
          "signature": "LSort-\u003eLTerm c-\u003eLVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:ltermVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "lvarIdx",
          "package": "tamarin-prover-term",
          "signature": "Integer",
          "source": "src/Term-LTerm.html#LVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "lvarIdx",
          "package": "tamarin-prover-term",
          "partial": "Idx",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:lvarIdx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "lvarName",
          "package": "tamarin-prover-term",
          "signature": "String",
          "source": "src/Term-LTerm.html#LVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "lvarName",
          "package": "tamarin-prover-term",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:lvarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "lvarSort",
          "package": "tamarin-prover-term",
          "signature": "LSort",
          "source": "src/Term-LTerm.html#LVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "lvarSort",
          "package": "tamarin-prover-term",
          "partial": "Sort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:lvarSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "mapFrees",
          "package": "tamarin-prover-term",
          "signature": "MonotoneFunction f -\u003e t -\u003e f t",
          "source": "src/Term-LTerm.html#mapFrees",
          "type": "method"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "mapFrees",
          "normalized": "MonotoneFunction a-\u003eb-\u003ea b",
          "package": "tamarin-prover-term",
          "partial": "Frees",
          "signature": "MonotoneFunction f-\u003et-\u003ef t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:mapFrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "nId",
          "package": "tamarin-prover-term",
          "signature": "NameId",
          "source": "src/Term-LTerm.html#Name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "nId",
          "package": "tamarin-prover-term",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:nId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "nTag",
          "package": "tamarin-prover-term",
          "signature": "NameTag",
          "source": "src/Term-LTerm.html#Name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "nTag",
          "package": "tamarin-prover-term",
          "partial": "Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:nTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff no instance of this term contains fresh names or private function symbols.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "neverContainsFreshPriv",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e Bool",
          "source": "src/Term-LTerm.html#neverContainsFreshPriv",
          "type": "function"
        },
        "index": {
          "description": "True iff no instance of this term contains fresh names or private function symbols",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "neverContainsFreshPriv",
          "normalized": "LNTerm-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Contains Fresh Priv",
          "signature": "LNTerm-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:neverContainsFreshPriv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe non-inverse factors of a term.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "niFactors",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e [LNTerm]",
          "source": "src/Term-LTerm.html#niFactors",
          "type": "function"
        },
        "index": {
          "description": "The non-inverse factors of term",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "niFactors",
          "normalized": "LNTerm-\u003e[LNTerm]",
          "package": "tamarin-prover-term",
          "partial": "Factors",
          "signature": "LNTerm-\u003e[LNTerm]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:niFactors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ev \u003ccode\u003e\u003ca\u003eoccurs\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e iff variable \u003ccode\u003ev\u003c/code\u003e occurs as a free variable in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "occurs",
          "package": "tamarin-prover-term",
          "signature": "LVar -\u003e t -\u003e Bool",
          "source": "src/Term-LTerm.html#occurs",
          "type": "function"
        },
        "index": {
          "description": "occurs iff variable occurs as free variable in",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "occurs",
          "normalized": "LVar-\u003ea-\u003eBool",
          "package": "tamarin-prover-term",
          "signature": "LVar-\u003et-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:occurs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print an \u003ccode\u003eLTerm\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "prettyLNTerm",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e d",
          "source": "src/Term-LTerm.html#prettyLNTerm",
          "type": "function"
        },
        "index": {
          "description": "Pretty print an LTerm",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "prettyLNTerm",
          "normalized": "LNTerm-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "LNTerm",
          "signature": "LNTerm-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:prettyLNTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a \u003ccode\u003e\u003ca\u003eLVar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "prettyLVar",
          "package": "tamarin-prover-term",
          "signature": "LVar -\u003e d",
          "source": "src/Term-LTerm.html#prettyLVar",
          "type": "function"
        },
        "index": {
          "description": "Pretty print LVar",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "prettyLVar",
          "normalized": "LVar-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "LVar",
          "signature": "LVar-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:prettyLVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print an \u003ccode\u003eNTerm\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "prettyNTerm",
          "package": "tamarin-prover-term",
          "signature": "NTerm v -\u003e d",
          "source": "src/Term-LTerm.html#prettyNTerm",
          "type": "function"
        },
        "index": {
          "description": "Pretty print an NTerm",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "prettyNTerm",
          "normalized": "NTerm a-\u003eb",
          "package": "tamarin-prover-term",
          "partial": "NTerm",
          "signature": "NTerm v-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:prettyNTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a \u003ccode\u003e\u003ca\u003eNodeId\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "prettyNodeId",
          "package": "tamarin-prover-term",
          "signature": "NodeId -\u003e d",
          "source": "src/Term-LTerm.html#prettyNodeId",
          "type": "function"
        },
        "index": {
          "description": "Pretty print NodeId",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "prettyNodeId",
          "normalized": "NodeId-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Node Id",
          "signature": "NodeId-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:prettyNodeId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epubTerm f\u003c/code\u003e represents the pub name \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "pubTerm",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e NTerm v",
          "source": "src/Term-LTerm.html#pubTerm",
          "type": "function"
        },
        "index": {
          "description": "pubTerm represents the pub name",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "pubTerm",
          "normalized": "String-\u003eNTerm a",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "String-\u003eNTerm v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:pubTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erename t\u003c/code\u003e replaces all variables in \u003ccode\u003et\u003c/code\u003e with fresh variables.\n   Note that the result is not guaranteed to be equal for terms that are\n   equal modulo changing the indices of variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "rename",
          "package": "tamarin-prover-term",
          "signature": "a -\u003e m a",
          "source": "src/Term-LTerm.html#rename",
          "type": "function"
        },
        "index": {
          "description": "rename replaces all variables in with fresh variables Note that the result is not guaranteed to be equal for terms that are equal modulo changing the indices of variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "rename",
          "normalized": "a-\u003eb a",
          "package": "tamarin-prover-term",
          "signature": "a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:rename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003es \u003ccode\u003e\u003ca\u003erenameAvoiding\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e replaces all free variables in \u003ccode\u003es\u003c/code\u003e by\n   fresh variables avoiding variables in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "renameAvoiding",
          "package": "tamarin-prover-term",
          "signature": "s -\u003e t -\u003e s",
          "source": "src/Term-LTerm.html#renameAvoiding",
          "type": "function"
        },
        "index": {
          "description": "renameAvoiding replaces all free variables in by fresh variables avoiding variables in",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "renameAvoiding",
          "normalized": "a-\u003eb-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Avoiding",
          "signature": "s-\u003et-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:renameAvoiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.LTerm",
          "name": "renameDropNamehint",
          "package": "tamarin-prover-term",
          "signature": "a -\u003e m a",
          "source": "src/Term-LTerm.html#renameDropNamehint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "renameDropNamehint",
          "normalized": "a-\u003eb a",
          "package": "tamarin-prover-term",
          "partial": "Drop Namehint",
          "signature": "a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:renameDropNamehint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erenamePrecise t\u003c/code\u003e replaces all variables in \u003ccode\u003et\u003c/code\u003e with fresh variables.\n   If \u003ccode\u003e\u003ca\u003ePreciseFresh\u003c/a\u003e\u003c/code\u003e is used with non-AC terms and identical\n   fresh state, the same result is returned for two terms that only differ\n   in the indices of variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "renamePrecise",
          "package": "tamarin-prover-term",
          "signature": "a -\u003e m a",
          "source": "src/Term-LTerm.html#renamePrecise",
          "type": "function"
        },
        "index": {
          "description": "renamePrecise replaces all variables in with fresh variables If PreciseFresh is used with non-AC terms and identical fresh state the same result is returned for two terms that only differ in the indices of variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "renamePrecise",
          "normalized": "a-\u003eb a",
          "package": "tamarin-prover-term",
          "partial": "Precise",
          "signature": "a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:renamePrecise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esomeInst t\u003c/code\u003e returns an instance of \u003ccode\u003et\u003c/code\u003e where all free variables whose\n binding is not yet determined by the caller are replaced with fresh\n variables.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "someInst",
          "package": "tamarin-prover-term",
          "signature": "t -\u003e m t",
          "source": "src/Term-LTerm.html#someInst",
          "type": "function"
        },
        "index": {
          "description": "someInst returns an instance of where all free variables whose binding is not yet determined by the caller are replaced with fresh variables",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "someInst",
          "normalized": "a-\u003eb a",
          "package": "tamarin-prover-term",
          "partial": "Inst",
          "signature": "t-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:someInst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esortCompare s1 s2\u003c/code\u003e compares \u003ccode\u003es1\u003c/code\u003e and \u003ccode\u003es2\u003c/code\u003e with respect to the partial order on sorts.\n   Partial order: Node      Msg\n                           /   --                         Pub  Fresh\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "sortCompare",
          "package": "tamarin-prover-term",
          "signature": "LSort -\u003e LSort -\u003e Maybe Ordering",
          "source": "src/Term-LTerm.html#sortCompare",
          "type": "function"
        },
        "index": {
          "description": "sortCompare s1 s2 compares s1 and s2 with respect to the partial order on sorts Partial order Node Msg Pub Fresh",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "sortCompare",
          "normalized": "LSort-\u003eLSort-\u003eMaybe Ordering",
          "package": "tamarin-prover-term",
          "partial": "Compare",
          "signature": "LSort-\u003eLSort-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:sortCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the most precise sort of an \u003ccode\u003e\u003ca\u003eLNTerm\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "sortOfLNTerm",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LSort",
          "source": "src/Term-LTerm.html#sortOfLNTerm",
          "type": "function"
        },
        "index": {
          "description": "Returns the most precise sort of an LNTerm",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "sortOfLNTerm",
          "normalized": "LNTerm-\u003eLSort",
          "package": "tamarin-prover-term",
          "partial": "Of LNTerm",
          "signature": "LNTerm-\u003eLSort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:sortOfLNTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the most precise sort of an \u003ccode\u003e\u003ca\u003eLTerm\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "sortOfLTerm",
          "package": "tamarin-prover-term",
          "signature": "(c -\u003e LSort) -\u003e LTerm c -\u003e LSort",
          "source": "src/Term-LTerm.html#sortOfLTerm",
          "type": "function"
        },
        "index": {
          "description": "Returns the most precise sort of an LTerm",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "sortOfLTerm",
          "normalized": "(a-\u003eLSort)-\u003eLTerm a-\u003eLSort",
          "package": "tamarin-prover-term",
          "partial": "Of LTerm",
          "signature": "(c-\u003eLSort)-\u003eLTerm c-\u003eLSort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:sortOfLTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the most precise sort of a \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "sortOfLit",
          "package": "tamarin-prover-term",
          "signature": "Lit Name LVar -\u003e LSort",
          "source": "src/Term-LTerm.html#sortOfLit",
          "type": "function"
        },
        "index": {
          "description": "Returns the most precise sort of Lit",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "sortOfLit",
          "normalized": "Lit Name LVar-\u003eLSort",
          "package": "tamarin-prover-term",
          "partial": "Of Lit",
          "signature": "Lit Name LVar-\u003eLSort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:sortOfLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eLSort\u003c/a\u003e\u003c/code\u003e for given \u003ccode\u003e\u003ca\u003eName\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "sortOfName",
          "package": "tamarin-prover-term",
          "signature": "Name -\u003e LSort",
          "source": "src/Term-LTerm.html#sortOfName",
          "type": "function"
        },
        "index": {
          "description": "Return LSort for given Name",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "sortOfName",
          "normalized": "Name-\u003eLSort",
          "package": "tamarin-prover-term",
          "partial": "Of Name",
          "signature": "Name-\u003eLSort",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:sortOfName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esortPrefix s\u003c/code\u003e is the prefix we use for annotating variables of sort \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "sortPrefix",
          "package": "tamarin-prover-term",
          "signature": "LSort -\u003e String",
          "source": "src/Term-LTerm.html#sortPrefix",
          "type": "function"
        },
        "index": {
          "description": "sortPrefix is the prefix we use for annotating variables of sort",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "sortPrefix",
          "normalized": "LSort-\u003eString",
          "package": "tamarin-prover-term",
          "partial": "Prefix",
          "signature": "LSort-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:sortPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esortSuffix s\u003c/code\u003e is the suffix we use for annotating variables of sort \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.LTerm",
          "name": "sortSuffix",
          "package": "tamarin-prover-term",
          "signature": "LSort -\u003e String",
          "source": "src/Term-LTerm.html#sortSuffix",
          "type": "function"
        },
        "index": {
          "description": "sortSuffix is the suffix we use for annotating variables of sort",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "sortSuffix",
          "normalized": "LSort-\u003eString",
          "package": "tamarin-prover-term",
          "partial": "Suffix",
          "signature": "LSort-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:sortSuffix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the variables occuring in \u003ccode\u003et\u003c/code\u003e together with the contexts they appear in.\n Note that certain contexts (and variables only occuring in such contexts) are\n ignored by this function.\n The function is used to \u003ca\u003eguess\u003c/a\u003e renamings of variables, i.e., if t is a renaming of s,\n then variables that occur in equal contexts in t and s are probably renamings of\n each other.\n\u003c/p\u003e",
          "module": "[\"Term.LTerm\",\"Term.Subsumption\"]",
          "name": "varOccurences",
          "package": "tamarin-prover-term",
          "signature": "a -\u003e [(LVar, Set Occurence)]",
          "source": "src/Term-LTerm.html#varOccurences",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:varOccurences\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Subsumption.html#v:varOccurences\"]"
        },
        "index": {
          "description": "Returns the variables occuring in together with the contexts they appear in Note that certain contexts and variables only occuring in such contexts are ignored by this function The function is used to guess renamings of variables i.e if is renaming of then variables that occur in equal contexts in and are probably renamings of each other",
          "hierarchy": "Term LTerm",
          "module": "Term.LTerm",
          "name": "varOccurences",
          "normalized": "a-\u003e[(LVar,Set Occurence)]",
          "package": "tamarin-prover-term",
          "partial": "Occurences",
          "signature": "a-\u003e[(LVar,Set Occurence)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-LTerm.html#v:varOccurences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePretty printing and parsing of Maude terms and replies.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Maude.Parser",
          "name": "Parser",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "Pretty printing and parsing of Maude terms and replies",
          "hierarchy": "Term Maude Parser",
          "module": "Term.Maude.Parser",
          "name": "Parser",
          "package": "tamarin-prover-term",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eparseMatchReply reply\u003c/code\u003e takes a \u003ccode\u003ereply\u003c/code\u003e to a match query\n   returned by Maude and extracts the unifiers.\n\u003c/p\u003e",
          "module": "Term.Maude.Parser",
          "name": "parseMatchReply",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e ByteString -\u003e Either String [MSubst]",
          "source": "src/Term-Maude-Parser.html#parseMatchReply",
          "type": "function"
        },
        "index": {
          "description": "parseMatchReply reply takes reply to match query returned by Maude and extracts the unifiers",
          "hierarchy": "Term Maude Parser",
          "module": "Term.Maude.Parser",
          "name": "parseMatchReply",
          "normalized": "MaudeSig-\u003eByteString-\u003eEither String[MSubst]",
          "package": "tamarin-prover-term",
          "partial": "Match Reply",
          "signature": "MaudeSig-\u003eByteString-\u003eEither String[MSubst]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Parser.html#v:parseMatchReply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eparseReduceReply l\u003c/code\u003e parses a single solution returned by Maude.\n\u003c/p\u003e",
          "module": "Term.Maude.Parser",
          "name": "parseReduceReply",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e ByteString -\u003e Either String MTerm",
          "source": "src/Term-Maude-Parser.html#parseReduceReply",
          "type": "function"
        },
        "index": {
          "description": "parseReduceReply parses single solution returned by Maude",
          "hierarchy": "Term Maude Parser",
          "module": "Term.Maude.Parser",
          "name": "parseReduceReply",
          "normalized": "MaudeSig-\u003eByteString-\u003eEither String MTerm",
          "package": "tamarin-prover-term",
          "partial": "Reduce Reply",
          "signature": "MaudeSig-\u003eByteString-\u003eEither String MTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Parser.html#v:parseReduceReply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eparseUnifyReply reply\u003c/code\u003e takes a \u003ccode\u003ereply\u003c/code\u003e to a unification query\n   returned by Maude and extracts the unifiers.\n\u003c/p\u003e",
          "module": "Term.Maude.Parser",
          "name": "parseUnifyReply",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e ByteString -\u003e Either String [MSubst]",
          "source": "src/Term-Maude-Parser.html#parseUnifyReply",
          "type": "function"
        },
        "index": {
          "description": "parseUnifyReply reply takes reply to unification query returned by Maude and extracts the unifiers",
          "hierarchy": "Term Maude Parser",
          "module": "Term.Maude.Parser",
          "name": "parseUnifyReply",
          "normalized": "MaudeSig-\u003eByteString-\u003eEither String[MSubst]",
          "package": "tamarin-prover-term",
          "partial": "Unify Reply",
          "signature": "MaudeSig-\u003eByteString-\u003eEither String[MSubst]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Parser.html#v:parseUnifyReply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eppMaude t\u003c/code\u003e pretty prints the term \u003ccode\u003et\u003c/code\u003e for Maude.\n\u003c/p\u003e",
          "module": "Term.Maude.Parser",
          "name": "ppMaude",
          "package": "tamarin-prover-term",
          "signature": "Term MaudeLit -\u003e ByteString",
          "source": "src/Term-Maude-Parser.html#ppMaude",
          "type": "function"
        },
        "index": {
          "description": "ppMaude pretty prints the term for Maude",
          "hierarchy": "Term Maude Parser",
          "module": "Term.Maude.Parser",
          "name": "ppMaude",
          "normalized": "Term MaudeLit-\u003eByteString",
          "package": "tamarin-prover-term",
          "partial": "Maude",
          "signature": "Term MaudeLit-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Parser.html#v:ppMaude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe term algebra and rewriting rules as a functional module in Maude.\n\u003c/p\u003e",
          "module": "Term.Maude.Parser",
          "name": "ppTheory",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e ByteString",
          "source": "src/Term-Maude-Parser.html#ppTheory",
          "type": "function"
        },
        "index": {
          "description": "The term algebra and rewriting rules as functional module in Maude",
          "hierarchy": "Term Maude Parser",
          "module": "Term.Maude.Parser",
          "name": "ppTheory",
          "normalized": "MaudeSig-\u003eByteString",
          "package": "tamarin-prover-term",
          "partial": "Theory",
          "signature": "MaudeSig-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Parser.html#v:ppTheory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAC-unification of DH terms using Maude as a backend.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Maude.Process",
          "name": "Process",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Process.html",
          "type": "module"
        },
        "index": {
          "description": "AC-unification of DH terms using Maude as backend",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "Process",
          "package": "tamarin-prover-term",
          "partial": "Process",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA handle to a Maude process. It requires the Maude path for Signatures to\n be serializable. If we also add the string for the Maude config file, then\n it would even be serializable on its own.\n\u003c/p\u003e",
          "module": "Term.Maude.Process",
          "name": "MaudeHandle",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Process.html#MaudeHandle",
          "type": "data"
        },
        "index": {
          "description": "handle to Maude process It requires the Maude path for Signatures to be serializable If we also add the string for the Maude config file then it would even be serializable on its own",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "MaudeHandle",
          "package": "tamarin-prover-term",
          "partial": "Maude Handle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#t:MaudeHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValues that depend on a \u003ccode\u003e\u003ca\u003eMaudeHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Maude.Process",
          "name": "WithMaude",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Process.html#WithMaude",
          "type": "type"
        },
        "index": {
          "description": "Values that depend on MaudeHandle",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "WithMaude",
          "package": "tamarin-prover-term",
          "partial": "With Maude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#t:WithMaude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Process",
          "name": "MaudeHandle",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle",
          "source": "src/Term-Maude-Process.html#MaudeHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "MaudeHandle",
          "package": "tamarin-prover-term",
          "partial": "Maude Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:MaudeHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egetMaudeStats\u003c/code\u003e returns the maude stats formatted as a string.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Process\",\"Term.Unification\"]",
          "name": "getMaudeStats",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e IO String",
          "source": "src/Term-Maude-Process.html#getMaudeStats",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:getMaudeStats\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:getMaudeStats\"]"
        },
        "index": {
          "description": "getMaudeStats returns the maude stats formatted as string",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "getMaudeStats",
          "normalized": "MaudeHandle-\u003eIO String",
          "package": "tamarin-prover-term",
          "partial": "Maude Stats",
          "signature": "MaudeHandle-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:getMaudeStats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ematchViaMaude (t, p)\u003c/code\u003e computes a complete set of AC matchers of the term\n \u003ccode\u003et\u003c/code\u003e to the pattern \u003ccode\u003ep\u003c/code\u003e via Maude.\n\u003c/p\u003e",
          "module": "Term.Maude.Process",
          "name": "matchViaMaude",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e (c -\u003e LSort) -\u003e Match (VTerm c LVar) -\u003e IO [Subst c LVar]",
          "source": "src/Term-Maude-Process.html#matchViaMaude",
          "type": "function"
        },
        "index": {
          "description": "matchViaMaude computes complete set of AC matchers of the term to the pattern via Maude",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "matchViaMaude",
          "normalized": "MaudeHandle-\u003e(a-\u003eLSort)-\u003eMatch(VTerm a LVar)-\u003eIO[Subst a LVar]",
          "package": "tamarin-prover-term",
          "partial": "Via Maude",
          "signature": "MaudeHandle-\u003e(c-\u003eLSort)-\u003eMatch(VTerm c LVar)-\u003eIO[Subst c LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:matchViaMaude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Process",
          "name": "mhFilePath",
          "package": "tamarin-prover-term",
          "signature": "FilePath",
          "source": "src/Term-Maude-Process.html#MaudeHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "mhFilePath",
          "package": "tamarin-prover-term",
          "partial": "File Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:mhFilePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Process",
          "name": "mhMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Process.html#MaudeHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "mhMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:mhMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Process",
          "name": "mhProc",
          "package": "tamarin-prover-term",
          "signature": "MVar MaudeProcess",
          "source": "src/Term-Maude-Process.html#MaudeHandle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "mhProc",
          "package": "tamarin-prover-term",
          "partial": "Proc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:mhProc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enormViaMaude t\u003c/code\u003e normalizes the term t via Maude.\n\u003c/p\u003e",
          "module": "Term.Maude.Process",
          "name": "normViaMaude",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e (c -\u003e LSort) -\u003e VTerm c LVar -\u003e IO (VTerm c LVar)",
          "source": "src/Term-Maude-Process.html#normViaMaude",
          "type": "function"
        },
        "index": {
          "description": "normViaMaude normalizes the term via Maude",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "normViaMaude",
          "normalized": "MaudeHandle-\u003e(a-\u003eLSort)-\u003eVTerm a LVar-\u003eIO(VTerm a LVar)",
          "package": "tamarin-prover-term",
          "partial": "Via Maude",
          "signature": "MaudeHandle-\u003e(c-\u003eLSort)-\u003eVTerm c LVar-\u003eIO(VTerm c LVar)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:normViaMaude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003estartMaude\u003c/code\u003e starts a new instance of Maude and returns a Handle to it.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Process\",\"Term.Unification\"]",
          "name": "startMaude",
          "package": "tamarin-prover-term",
          "signature": "FilePath -\u003e MaudeSig -\u003e IO MaudeHandle",
          "source": "src/Term-Maude-Process.html#startMaude",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:startMaude\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:startMaude\"]"
        },
        "index": {
          "description": "startMaude starts new instance of Maude and returns Handle to it",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "startMaude",
          "normalized": "FilePath-\u003eMaudeSig-\u003eIO MaudeHandle",
          "package": "tamarin-prover-term",
          "partial": "Maude",
          "signature": "FilePath-\u003eMaudeSig-\u003eIO MaudeHandle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:startMaude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunifyViaMaude hnd eqs\u003c/code\u003e computes all AC unifiers of \u003ccode\u003eeqs\u003c/code\u003e using the\n   Maude process \u003ccode\u003ehnd\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Maude.Process",
          "name": "unifyViaMaude",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e (c -\u003e LSort) -\u003e [Equal (VTerm c LVar)] -\u003e IO [SubstVFresh c LVar]",
          "source": "src/Term-Maude-Process.html#unifyViaMaude",
          "type": "function"
        },
        "index": {
          "description": "unifyViaMaude hnd eqs computes all AC unifiers of eqs using the Maude process hnd",
          "hierarchy": "Term Maude Process",
          "module": "Term.Maude.Process",
          "name": "unifyViaMaude",
          "normalized": "MaudeHandle-\u003e(a-\u003eLSort)-\u003e[Equal(VTerm a LVar)]-\u003eIO[SubstVFresh a LVar]",
          "package": "tamarin-prover-term",
          "partial": "Via Maude",
          "signature": "MaudeHandle-\u003e(c-\u003eLSort)-\u003e[Equal(VTerm c LVar)]-\u003eIO[SubstVFresh c LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Process.html#v:unifyViaMaude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eEquational signatures for Maude.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Maude.Signature",
          "name": "Signature",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Signature.html",
          "type": "module"
        },
        "index": {
          "description": "Equational signatures for Maude",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "Signature",
          "package": "tamarin-prover-term",
          "partial": "Signature",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe required information to define a \u003ccode\u003eMaude functional module\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Maude.Signature",
          "name": "MaudeSig",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Signature.html#MaudeSig",
          "type": "data"
        },
        "index": {
          "description": "The required information to define Maude functional module",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "MaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#t:MaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd function symbol to given maude signature.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "addFunSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym -\u003e MaudeSig -\u003e MaudeSig",
          "source": "src/Term-Maude-Signature.html#addFunSym",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:addFunSym\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:addFunSym\"]"
        },
        "index": {
          "description": "Add function symbol to given maude signature",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "addFunSym",
          "normalized": "NoEqSym-\u003eMaudeSig-\u003eMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sym",
          "signature": "NoEqSym-\u003eMaudeSig-\u003eMaudeSig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:addFunSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd subterm rule to given maude signature.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "addStRule",
          "package": "tamarin-prover-term",
          "signature": "StRule -\u003e MaudeSig -\u003e MaudeSig",
          "source": "src/Term-Maude-Signature.html#addStRule",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:addStRule\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:addStRule\"]"
        },
        "index": {
          "description": "Add subterm rule to given maude signature",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "addStRule",
          "normalized": "StRule-\u003eMaudeSig-\u003eMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "St Rule",
          "signature": "StRule-\u003eMaudeSig-\u003eMaudeSig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:addStRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the default subterm symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "asymEncMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#asymEncMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:asymEncMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:asymEncMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the default subterm symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "asymEncMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Enc Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:asymEncMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the AC symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "bpMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#bpMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:bpMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:bpMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the AC symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "bpMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:bpMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the AC symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "dhMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#dhMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:dhMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:dhMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the AC symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "dhMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:dhMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "enableBP",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e Bool",
          "source": "src/Term-Maude-Signature.html#enableBP",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:enableBP\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:enableBP\"]"
        },
        "index": {
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "enableBP",
          "normalized": "MaudeSig-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "BP",
          "signature": "MaudeSig-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:enableBP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "enableDH",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e Bool",
          "source": "src/Term-Maude-Signature.html#enableDH",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:enableDH\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:enableDH\"]"
        },
        "index": {
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "enableDH",
          "normalized": "MaudeSig-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "DH",
          "signature": "MaudeSig-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:enableDH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "enableMSet",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e Bool",
          "source": "src/Term-Maude-Signature.html#enableMSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:enableMSet\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:enableMSet\"]"
        },
        "index": {
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "enableMSet",
          "normalized": "MaudeSig-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "MSet",
          "signature": "MaudeSig-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:enableMSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction signature including the\n function symbols for DH, BP, and Multiset\n can be computed from enableX and stFunSyms\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "funSyms",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e FunSig",
          "source": "src/Term-Maude-Signature.html#funSyms",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:funSyms\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:funSyms\"]"
        },
        "index": {
          "description": "function signature including the function symbols for DH BP and Multiset can be computed from enableX and stFunSyms",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "funSyms",
          "normalized": "MaudeSig-\u003eFunSig",
          "package": "tamarin-prover-term",
          "partial": "Syms",
          "signature": "MaudeSig-\u003eFunSig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:funSyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the default subterm symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "hashMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#hashMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:hashMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:hashMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the default subterm symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "hashMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:hashMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eirreducible function symbols (can be computed)\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "irreducibleFunSyms",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e FunSig",
          "source": "src/Term-Maude-Signature.html#irreducibleFunSyms",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:irreducibleFunSyms\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:irreducibleFunSyms\"]"
        },
        "index": {
          "description": "irreducible function symbols can be computed",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "irreducibleFunSyms",
          "normalized": "MaudeSig-\u003eFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Syms",
          "signature": "MaudeSig-\u003eFunSig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:irreducibleFunSyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe minimal maude signature.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "minimalMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#minimalMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:minimalMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:minimalMaudeSig\"]"
        },
        "index": {
          "description": "The minimal maude signature",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "minimalMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:minimalMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the AC symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "msetMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#msetMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:msetMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:msetMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the AC symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "msetMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:msetMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon-AC function symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "noEqFunSyms",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e NoEqFunSig",
          "source": "src/Term-Maude-Signature.html#noEqFunSyms",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:noEqFunSyms\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:noEqFunSyms\"]"
        },
        "index": {
          "description": "Non-AC function symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "noEqFunSyms",
          "normalized": "MaudeSig-\u003eNoEqFunSig",
          "package": "tamarin-prover-term",
          "partial": "Eq Fun Syms",
          "signature": "MaudeSig-\u003eNoEqFunSig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:noEqFunSyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the default subterm symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "pairMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#pairMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:pairMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:pairMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the default subterm symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "pairMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:pairMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Signature",
          "name": "prettyMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e d",
          "source": "src/Term-Maude-Signature.html#prettyMaudeSig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "prettyMaudeSig",
          "normalized": "MaudeSig-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "signature": "MaudeSig-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:prettyMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all rewriting rules including the rules\n   for DH, BP, and multiset.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "rrulesForMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e Set (RRule LNTerm)",
          "source": "src/Term-Maude-Signature.html#rrulesForMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:rrulesForMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:rrulesForMaudeSig\"]"
        },
        "index": {
          "description": "Returns all rewriting rules including the rules for DH BP and multiset",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "rrulesForMaudeSig",
          "normalized": "MaudeSig-\u003eSet(RRule LNTerm)",
          "package": "tamarin-prover-term",
          "partial": "For Maude Sig",
          "signature": "MaudeSig-\u003eSet(RRule LNTerm)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:rrulesForMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the default subterm symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "signatureMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#signatureMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:signatureMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:signatureMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the default subterm symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "signatureMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:signatureMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction signature for subterm theory\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "stFunSyms",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e Set NoEqSym",
          "source": "src/Term-Maude-Signature.html#stFunSyms",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:stFunSyms\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:stFunSyms\"]"
        },
        "index": {
          "description": "function signature for subterm theory",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "stFunSyms",
          "normalized": "MaudeSig-\u003eSet NoEqSym",
          "package": "tamarin-prover-term",
          "partial": "Fun Syms",
          "signature": "MaudeSig-\u003eSet NoEqSym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:stFunSyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erewriting rules for subterm theory\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "stRules",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e Set StRule",
          "source": "src/Term-Maude-Signature.html#stRules",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:stRules\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:stRules\"]"
        },
        "index": {
          "description": "rewriting rules for subterm theory",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "stRules",
          "normalized": "MaudeSig-\u003eSet StRule",
          "package": "tamarin-prover-term",
          "partial": "Rules",
          "signature": "MaudeSig-\u003eSet StRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:stRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures for the default subterm symbols.\n\u003c/p\u003e",
          "module": "[\"Term.Maude.Signature\",\"Term.Unification\"]",
          "name": "symEncMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-Maude-Signature.html#symEncMaudeSig",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:symEncMaudeSig\",\"http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:symEncMaudeSig\"]"
        },
        "index": {
          "description": "Maude signatures for the default subterm symbols",
          "hierarchy": "Term Maude Signature",
          "module": "Term.Maude.Signature",
          "name": "symEncMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Enc Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Signature.html#v:symEncMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes for communicating with Maude.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Maude.Types",
          "name": "Types",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Types.html",
          "type": "module"
        },
        "index": {
          "description": "Types for communicating with Maude",
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "Types",
          "package": "tamarin-prover-term",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Types",
          "name": "MSubst",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Types.html#MSubst",
          "type": "type"
        },
        "index": {
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "MSubst",
          "package": "tamarin-prover-term",
          "partial": "MSubst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#t:MSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Types",
          "name": "MTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Types.html#MTerm",
          "type": "type"
        },
        "index": {
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "MTerm",
          "package": "tamarin-prover-term",
          "partial": "MTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#t:MTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Types",
          "name": "MaudeLit",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Types.html#MaudeLit",
          "type": "data"
        },
        "index": {
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "MaudeLit",
          "package": "tamarin-prover-term",
          "partial": "Maude Lit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#t:MaudeLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Types",
          "name": "FreshVar",
          "package": "tamarin-prover-term",
          "signature": "FreshVar Integer LSort",
          "source": "src/Term-Maude-Types.html#MaudeLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "FreshVar",
          "package": "tamarin-prover-term",
          "partial": "Fresh Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:FreshVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Types",
          "name": "MaudeConst",
          "package": "tamarin-prover-term",
          "signature": "MaudeConst Integer LSort",
          "source": "src/Term-Maude-Types.html#MaudeLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "MaudeConst",
          "package": "tamarin-prover-term",
          "partial": "Maude Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:MaudeConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Maude.Types",
          "name": "MaudeVar",
          "package": "tamarin-prover-term",
          "signature": "MaudeVar Integer LSort",
          "source": "src/Term-Maude-Types.html#MaudeLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "MaudeVar",
          "package": "tamarin-prover-term",
          "partial": "Maude Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:MaudeVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003eLNTerm\u003c/code\u003e with arbitrary names to an \u003ccode\u003eMTerm\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Maude.Types",
          "name": "lTermToMTerm",
          "package": "tamarin-prover-term",
          "signature": "(c -\u003e LSort)-\u003e VTerm c LVar-\u003e m MTerm",
          "type": "function"
        },
        "index": {
          "description": "Convert an LNTerm with arbitrary names to an MTerm",
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "lTermToMTerm",
          "normalized": "(a-\u003eLSort)-\u003eVTerm a LVar-\u003eb MTerm",
          "package": "tamarin-prover-term",
          "partial": "Term To MTerm",
          "signature": "(c-\u003eLSort)-\u003eVTerm c LVar-\u003em MTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:lTermToMTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003eLNTerm\u003c/code\u003e to an \u003ccode\u003eMTerm\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Maude.Types",
          "name": "lTermToMTerm'",
          "package": "tamarin-prover-term",
          "signature": "LNTerm-\u003e m MTerm",
          "type": "function"
        },
        "index": {
          "description": "Convert an LNTerm to an MTerm",
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "lTermToMTerm'",
          "normalized": "LNTerm-\u003ea MTerm",
          "package": "tamarin-prover-term",
          "partial": "Term To MTerm'",
          "signature": "LNTerm-\u003em MTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:lTermToMTerm-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an \u003ccode\u003e\u003ca\u003eMTerm\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eLNTerm\u003c/a\u003e\u003c/code\u003e under the assumption that the bindings\n for the constants are already available.\n\u003c/p\u003e",
          "module": "Term.Maude.Types",
          "name": "mTermToLNTerm",
          "package": "tamarin-prover-term",
          "signature": "String-\u003e MTerm-\u003e m (VTerm c LVar)",
          "type": "function"
        },
        "index": {
          "description": "Convert an MTerm to an LNTerm under the assumption that the bindings for the constants are already available",
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "mTermToLNTerm",
          "normalized": "String-\u003eMTerm-\u003ea(VTerm b LVar)",
          "package": "tamarin-prover-term",
          "partial": "Term To LNTerm",
          "signature": "String-\u003eMTerm-\u003em(VTerm c LVar)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:mTermToLNTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emsubstToLSubstVFree bindings substMaude\u003c/code\u003e converts a substitution\n   returned by Maude to a \u003ccode\u003eVFree\u003c/code\u003e substitution. It expects that the\n   maude substitution contains no fresh variables in its range and raises an\n   error otherwise.\n\u003c/p\u003e",
          "module": "Term.Maude.Types",
          "name": "msubstToLSubstVFree",
          "package": "tamarin-prover-term",
          "signature": "Map MaudeLit (Lit c LVar) -\u003e MSubst -\u003e Subst c LVar",
          "source": "src/Term-Maude-Types.html#msubstToLSubstVFree",
          "type": "function"
        },
        "index": {
          "description": "msubstToLSubstVFree bindings substMaude converts substitution returned by Maude to VFree substitution It expects that the maude substitution contains no fresh variables in its range and raises an error otherwise",
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "msubstToLSubstVFree",
          "normalized": "Map MaudeLit(Lit a LVar)-\u003eMSubst-\u003eSubst a LVar",
          "package": "tamarin-prover-term",
          "partial": "To LSubst VFree",
          "signature": "Map MaudeLit(Lit c LVar)-\u003eMSubst-\u003eSubst c LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:msubstToLSubstVFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emsubstToLSubstVFresh bindings substMaude\u003c/code\u003e converts a substitution\n   returned by Maude to a \u003ccode\u003eVFresh\u003c/code\u003e substitution. It expects that the\n   range of the maude substitution contains only fresh variables in its\n   range and raises an error otherwise.\n\u003c/p\u003e",
          "module": "Term.Maude.Types",
          "name": "msubstToLSubstVFresh",
          "package": "tamarin-prover-term",
          "signature": "Map MaudeLit (Lit c LVar)-\u003e MSubst-\u003e SubstVFresh c LVar",
          "type": "function"
        },
        "index": {
          "description": "msubstToLSubstVFresh bindings substMaude converts substitution returned by Maude to VFresh substitution It expects that the range of the maude substitution contains only fresh variables in its range and raises an error otherwise",
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "msubstToLSubstVFresh",
          "normalized": "Map MaudeLit(Lit a LVar)-\u003eMSubst-\u003eSubstVFresh a LVar",
          "package": "tamarin-prover-term",
          "partial": "To LSubst VFresh",
          "signature": "Map MaudeLit(Lit c LVar)-\u003eMSubst-\u003eSubstVFresh c LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:msubstToLSubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003eBindT (Lit c LVar) MaudeLit Fresh\u003c/code\u003e computation\n   with an empty fresh supply and an empty binding map and return\n   the result and the resulting inverted binding map.\n\u003c/p\u003e",
          "module": "Term.Maude.Types",
          "name": "runConversion",
          "package": "tamarin-prover-term",
          "signature": "BindT (Lit c LVar) MaudeLit Fresh a-\u003e (a, Map MaudeLit (Lit c LVar))",
          "type": "function"
        },
        "index": {
          "description": "Run BindT Lit LVar MaudeLit Fresh computation with an empty fresh supply and an empty binding map and return the result and the resulting inverted binding map",
          "hierarchy": "Term Maude Types",
          "module": "Term.Maude.Types",
          "name": "runConversion",
          "normalized": "BindT(Lit a LVar)MaudeLit Fresh b-\u003e(b,Map MaudeLit(Lit a LVar))",
          "package": "tamarin-prover-term",
          "partial": "Conversion",
          "signature": "BindT(Lit c LVar)MaudeLit Fresh a-\u003e(a,Map MaudeLit(Lit c LVar))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Maude-Types.html#v:runConversion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCompleteness and minimality checking for the variants of a term.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Narrowing.Variants.Check",
          "name": "Check",
          "package": "tamarin-prover-term",
          "source": "src/Term-Narrowing-Variants-Check.html",
          "type": "module"
        },
        "index": {
          "description": "Completeness and minimality checking for the variants of term",
          "hierarchy": "Term Narrowing Variants Check",
          "module": "Term.Narrowing.Variants.Check",
          "name": "Check",
          "package": "tamarin-prover-term",
          "partial": "Check",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Check.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echeckComplete t substs\u003c/code\u003e checks if \u003ccode\u003esubsts\u003c/code\u003e is a complete set of variants\n   for \u003ccode\u003et\u003c/code\u003e and returns \u003ccode\u003eJust (subst1,subst2)\u003c/code\u003e if there is a narrowing step\n   from \u003ccode\u003esubst1\u003c/code\u003e that yields a new variant \u003ccode\u003esubst2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Check",
          "name": "checkComplete",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e [LNSubstVFresh] -\u003e WithMaude Bool",
          "source": "src/Term-Narrowing-Variants-Check.html#checkComplete",
          "type": "function"
        },
        "index": {
          "description": "checkComplete substs checks if substs is complete set of variants for and returns Just subst1 subst2 if there is narrowing step from subst1 that yields new variant subst2",
          "hierarchy": "Term Narrowing Variants Check",
          "module": "Term.Narrowing.Variants.Check",
          "name": "checkComplete",
          "normalized": "LNTerm-\u003e[LNSubstVFresh]-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "partial": "Complete",
          "signature": "LNTerm-\u003e[LNSubstVFresh]-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Check.html#v:checkComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003echeckMinimal t substs\u003c/code\u003e checks if \u003ccode\u003esubsts\u003c/code\u003e is a minimal set of variants\n   for \u003ccode\u003et\u003c/code\u003e and returns \u003ccode\u003eFalse\u003c/code\u003e if there are subst1 /= subst2 in substs with\n   subst1 \u003c=_Var_t subst2.\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Check",
          "name": "checkMinimal",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e [LNSubstVFresh] -\u003e WithMaude Bool",
          "source": "src/Term-Narrowing-Variants-Check.html#checkMinimal",
          "type": "function"
        },
        "index": {
          "description": "checkMinimal substs checks if substs is minimal set of variants for and returns False if there are subst1 subst2 in substs with subst1 Var subst2",
          "hierarchy": "Term Narrowing Variants Check",
          "module": "Term.Narrowing.Variants.Check",
          "name": "checkMinimal",
          "normalized": "LNTerm-\u003e[LNSubstVFresh]-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "partial": "Minimal",
          "signature": "LNTerm-\u003e[LNSubstVFresh]-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Check.html#v:checkMinimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eisNormalInstance t s s'\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e if \u003ccode\u003es'(norm(s(t)))\u003c/code\u003e is in normal\n   form.\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Check",
          "name": "isNormalInstance",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LNSubst -\u003e LNSubst -\u003e WithMaude Bool",
          "source": "src/Term-Narrowing-Variants-Check.html#isNormalInstance",
          "type": "function"
        },
        "index": {
          "description": "isNormalInstance returns True if norm is in normal form",
          "hierarchy": "Term Narrowing Variants Check",
          "module": "Term.Narrowing.Variants.Check",
          "name": "isNormalInstance",
          "normalized": "LNTerm-\u003eLNSubst-\u003eLNSubst-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "partial": "Normal Instance",
          "signature": "LNTerm-\u003eLNSubst-\u003eLNSubst-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Check.html#v:isNormalInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eleqSubstVariant t s1 s2\u003c/code\u003e compares two substitutions using the variant order \n   with respect to \u003ccode\u003et\u003c/code\u003e and returns \u003ccode\u003eTrue\u003c/code\u003e if \u003ccode\u003es1\u003c/code\u003e is less or equal than \u003ccode\u003es2\u003c/code\u003e\n   and \u003ccode\u003eFalse\u003c/code\u003e otherwise. Use the more expensive \u003ccode\u003ecompareSubstVariant\u003c/code\u003e\n   which uses two AC matchings instead of one if you also want to distinguish\n   \u003ccode\u003eNothing\u003c/code\u003e, \u003ccode\u003eJust EQ\u003c/code\u003e, and \u003ccode\u003eJust GT\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003es1 is smaller or equal to s2 wrt. to the variant order (less general) iff there\n   is an s1' such that s1 = s2' . s2 restricted to vars(t) and s2'(norm(s2(t)))\n   is in normal form, or equivalently norm(s1(t)) =AC= s2'(norm(s2(1))). This\n   means s1 is redundant since it is just an AC instance of s2 that does\n   not \u003ca\u003erequire additional normalization steps.\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Check",
          "name": "leqSubstVariant",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LNSubstVFresh -\u003e LNSubstVFresh -\u003e WithMaude Bool",
          "source": "src/Term-Narrowing-Variants-Check.html#leqSubstVariant",
          "type": "function"
        },
        "index": {
          "description": "leqSubstVariant s1 s2 compares two substitutions using the variant order with respect to and returns True if s1 is less or equal than s2 and False otherwise Use the more expensive compareSubstVariant which uses two AC matchings instead of one if you also want to distinguish Nothing Just EQ and Just GT s1 is smaller or equal to s2 wrt to the variant order less general iff there is an s1 such that s1 s2 s2 restricted to vars and s2 norm s2 is in normal form or equivalently norm s1 AC s2 norm s2 This means s1 is redundant since it is just an AC instance of s2 that does not require additional normalization steps",
          "hierarchy": "Term Narrowing Variants Check",
          "module": "Term.Narrowing.Variants.Check",
          "name": "leqSubstVariant",
          "normalized": "LNTerm-\u003eLNSubstVFresh-\u003eLNSubstVFresh-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "partial": "Subst Variant",
          "signature": "LNTerm-\u003eLNSubstVFresh-\u003eLNSubstVFresh-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Check.html#v:leqSubstVariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evariantsFrom rules t subst\u003c/code\u003e returns all the \u003ca\u003eone-step variants\u003c/a\u003e of\n   \u003ccode\u003enorm (t subst)\u003c/code\u003e for the given set of \u003ccode\u003erules\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Check",
          "name": "variantsFrom",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LNSubstVFresh -\u003e WithMaude [LNSubstVFresh]",
          "source": "src/Term-Narrowing-Variants-Check.html#variantsFrom",
          "type": "function"
        },
        "index": {
          "description": "variantsFrom rules subst returns all the one-step variants of norm subst for the given set of rules",
          "hierarchy": "Term Narrowing Variants Check",
          "module": "Term.Narrowing.Variants.Check",
          "name": "variantsFrom",
          "normalized": "LNTerm-\u003eLNSubstVFresh-\u003eWithMaude[LNSubstVFresh]",
          "package": "tamarin-prover-term",
          "partial": "From",
          "signature": "LNTerm-\u003eLNSubstVFresh-\u003eWithMaude[LNSubstVFresh]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Check.html#v:variantsFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComputing the variants of a term.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "Compute",
          "package": "tamarin-prover-term",
          "source": "src/Term-Narrowing-Variants-Compute.html",
          "type": "module"
        },
        "index": {
          "description": "Computing the variants of term",
          "hierarchy": "Term Narrowing Variants Compute",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "Compute",
          "package": "tamarin-prover-term",
          "partial": "Compute",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Compute.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esubstCompareVariant t s1 t2\u003c/code\u003e compares two substitutions using the variant order\n   with respect to \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "compareSubstVariant",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LNSubstVFresh -\u003e LNSubstVFresh -\u003e WithMaude (Maybe Ordering)",
          "source": "src/Term-Narrowing-Variants-Compute.html#compareSubstVariant",
          "type": "function"
        },
        "index": {
          "description": "substCompareVariant s1 t2 compares two substitutions using the variant order with respect to",
          "hierarchy": "Term Narrowing Variants Compute",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "compareSubstVariant",
          "normalized": "LNTerm-\u003eLNSubstVFresh-\u003eLNSubstVFresh-\u003eWithMaude(Maybe Ordering)",
          "package": "tamarin-prover-term",
          "partial": "Subst Variant",
          "signature": "LNTerm-\u003eLNSubstVFresh-\u003eLNSubstVFresh-\u003eWithMaude(Maybe Ordering)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Compute.html#v:compareSubstVariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evariantsList ts\u003c/code\u003e computes all variants of \u003ccode\u003ets\u003c/code\u003e considered as a single term\n   without a bound or symmetry substitution.\n   The rewriting rules are taken from the Maude context.\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "computeVariants",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e WithMaude [LNSubstVFresh]",
          "source": "src/Term-Narrowing-Variants-Compute.html#computeVariants",
          "type": "function"
        },
        "index": {
          "description": "variantsList ts computes all variants of ts considered as single term without bound or symmetry substitution The rewriting rules are taken from the Maude context",
          "hierarchy": "Term Narrowing Variants Compute",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "computeVariants",
          "normalized": "LNTerm-\u003eWithMaude[LNSubstVFresh]",
          "package": "tamarin-prover-term",
          "partial": "Variants",
          "signature": "LNTerm-\u003eWithMaude[LNSubstVFresh]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Compute.html#v:computeVariants"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecomputeVariants t d\u003c/code\u003e compute the variants of term \u003ccode\u003et\u003c/code\u003e with bound \u003ccode\u003ed\u003c/code\u003e.\n   The rewriting rules are taken from the Maude context.\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "computeVariantsBound",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e Maybe Int -\u003e WithMaude (Maybe [LNSubstVFresh])",
          "source": "src/Term-Narrowing-Variants-Compute.html#computeVariantsBound",
          "type": "function"
        },
        "index": {
          "description": "computeVariants compute the variants of term with bound The rewriting rules are taken from the Maude context",
          "hierarchy": "Term Narrowing Variants Compute",
          "module": "Term.Narrowing.Variants.Compute",
          "name": "computeVariantsBound",
          "normalized": "LNTerm-\u003eMaybe Int-\u003eWithMaude(Maybe[LNSubstVFresh])",
          "package": "tamarin-prover-term",
          "partial": "Variants Bound",
          "signature": "LNTerm-\u003eMaybe Int-\u003eWithMaude(Maybe[LNSubstVFresh])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants-Compute.html#v:computeVariantsBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComputing and checking the variants of a term.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Narrowing.Variants",
          "name": "Variants",
          "package": "tamarin-prover-term",
          "source": "src/Term-Narrowing-Variants.html",
          "type": "module"
        },
        "index": {
          "description": "Computing and checking the variants of term",
          "hierarchy": "Term Narrowing Variants",
          "module": "Term.Narrowing.Variants",
          "name": "Variants",
          "package": "tamarin-prover-term",
          "partial": "Variants",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evariantsListCheck ts\u003c/code\u003e computes all variants of \u003ccode\u003ets\u003c/code\u003e considered as a single term\n   without a bound or symmetry substitution. Before returning the result, it checks\n   if the set of variants is complete and minimal. If that is not the case, it\n   fails with an error\n\u003c/p\u003e",
          "module": "Term.Narrowing.Variants",
          "name": "computeVariantsCheck",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e WithMaude [LNSubstVFresh]",
          "source": "src/Term-Narrowing-Variants.html#computeVariantsCheck",
          "type": "function"
        },
        "index": {
          "description": "variantsListCheck ts computes all variants of ts considered as single term without bound or symmetry substitution Before returning the result it checks if the set of variants is complete and minimal If that is not the case it fails with an error",
          "hierarchy": "Term Narrowing Variants",
          "module": "Term.Narrowing.Variants",
          "name": "computeVariantsCheck",
          "normalized": "LNTerm-\u003eWithMaude[LNSubstVFresh]",
          "package": "tamarin-prover-term",
          "partial": "Variants Check",
          "signature": "LNTerm-\u003eWithMaude[LNSubstVFresh]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Narrowing-Variants.html#v:computeVariantsCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePositions and replacement in terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Positions",
          "name": "Positions",
          "package": "tamarin-prover-term",
          "source": "src/Term-Positions.html",
          "type": "module"
        },
        "index": {
          "description": "Positions and replacement in terms",
          "hierarchy": "Term Positions",
          "module": "Term.Positions",
          "name": "Positions",
          "package": "tamarin-prover-term",
          "partial": "Positions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Positions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA position in a term is a list of integers.\n\u003c/p\u003e",
          "module": "Term.Positions",
          "name": "Position",
          "package": "tamarin-prover-term",
          "source": "src/Term-Positions.html#Position",
          "type": "type"
        },
        "index": {
          "description": "position in term is list of integers",
          "hierarchy": "Term Positions",
          "module": "Term.Positions",
          "name": "Position",
          "package": "tamarin-prover-term",
          "partial": "Position",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Positions.html#t:Position"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003et \u003ccode\u003e\u003ca\u003eatPos\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e returns the subterm of term \u003ccode\u003et\u003c/code\u003e at position \u003ccode\u003ep\u003c/code\u003e.\n   The standard notation for \u003ccode\u003et \u003ccode\u003e\u003ca\u003eatPos\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e is \u003ccode\u003et|_p\u003c/code\u003e.\n   \u003ccode\u003e\u003ca\u003eatPos\u003c/a\u003e\u003c/code\u003e accounts for AC symbols by interpreting n-ary operator\n   applications \u003ccode\u003e*[t1,t2,..tk-1,tk]\u003c/code\u003e as binary applications\n   \u003ccode\u003et1*(t2*..(tk-1*tk)..)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Positions",
          "name": "atPos",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Position -\u003e Term a",
          "source": "src/Term-Positions.html#atPos",
          "type": "function"
        },
        "index": {
          "description": "atPos returns the subterm of term at position The standard notation for atPos is atPos accounts for AC symbols by interpreting n-ary operator applications t1 t2 tk-1 tk as binary applications t1 t2 tk-1 tk",
          "hierarchy": "Term Positions",
          "module": "Term.Positions",
          "name": "atPos",
          "normalized": "Term a-\u003ePosition-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "Pos",
          "signature": "Term a-\u003ePosition-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Positions.html#v:atPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epositionsNonVar t\u003c/code\u003e returns all the non-variable positions in the term \u003ccode\u003et\u003c/code\u003e.\n   \u003ccode\u003e\u003ca\u003epositionsNonVar\u003c/a\u003e\u003c/code\u003e accounts for AC symbols in the same ways as \u003ccode\u003e\u003ca\u003eatPos\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Positions",
          "name": "positionsNonVar",
          "package": "tamarin-prover-term",
          "signature": "VTerm a b -\u003e [Position]",
          "source": "src/Term-Positions.html#positionsNonVar",
          "type": "function"
        },
        "index": {
          "description": "positionsNonVar returns all the non-variable positions in the term positionsNonVar accounts for AC symbols in the same ways as atPos",
          "hierarchy": "Term Positions",
          "module": "Term.Positions",
          "name": "positionsNonVar",
          "normalized": "VTerm a b-\u003e[Position]",
          "package": "tamarin-prover-term",
          "partial": "Non Var",
          "signature": "VTerm a b-\u003e[Position]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Positions.html#v:positionsNonVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003et \u003ccode\u003e\u003ca\u003ereplacePos\u003c/a\u003e\u003c/code\u003e (s,p)\u003c/code\u003e returns the term \u003ccode\u003et'\u003c/code\u003e where the subterm at position \u003ccode\u003ep\u003c/code\u003e\n   is replaced by \u003ccode\u003es\u003c/code\u003e. The standard notation for \u003ccode\u003et \u003ccode\u003e\u003ca\u003ereplacePos\u003c/a\u003e\u003c/code\u003e (s,p)\u003c/code\u003e is \u003ccode\u003et[s]_p\u003c/code\u003e.\n   \u003ccode\u003e\u003ca\u003ereplacePos\u003c/a\u003e\u003c/code\u003e accounts for AC symbols in the same ways as \u003ccode\u003e\u003ca\u003eatPos\u003c/a\u003e\u003c/code\u003e.\n   FIXME: The AC can be optimized.\n\u003c/p\u003e",
          "module": "Term.Positions",
          "name": "replacePos",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e (Term a, Position) -\u003e Term a",
          "source": "src/Term-Positions.html#replacePos",
          "type": "function"
        },
        "index": {
          "description": "replacePos returns the term where the subterm at position is replaced by The standard notation for replacePos is replacePos accounts for AC symbols in the same ways as atPos FIXME The AC can be optimized",
          "hierarchy": "Term Positions",
          "module": "Term.Positions",
          "name": "replacePos",
          "normalized": "Term a-\u003e(Term a,Position)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "Pos",
          "signature": "Term a-\u003e(Term a,Position)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Positions.html#v:replacePos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTerm Equalities, Matching Problems, and Subterm Rules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "Definitions",
          "package": "tamarin-prover-term",
          "source": "src/Term-Rewriting-Definitions.html",
          "type": "module"
        },
        "index": {
          "description": "Term Equalities Matching Problems and Subterm Rules",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "Definitions",
          "package": "tamarin-prover-term",
          "partial": "Definitions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn equality.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "Equal",
          "package": "tamarin-prover-term",
          "source": "src/Term-Rewriting-Definitions.html#Equal",
          "type": "data"
        },
        "index": {
          "description": "An equality",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "Equal",
          "package": "tamarin-prover-term",
          "partial": "Equal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#t:Equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatching problems. Use the \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e instance to compose matching\n problems.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "Match",
          "package": "tamarin-prover-term",
          "source": "src/Term-Rewriting-Definitions.html#Match",
          "type": "data"
        },
        "index": {
          "description": "Matching problems Use the Monoid instance to compose matching problems",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "Match",
          "package": "tamarin-prover-term",
          "partial": "Match",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#t:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rewrite rule.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "RRule",
          "package": "tamarin-prover-term",
          "source": "src/Term-Rewriting-Definitions.html#RRule",
          "type": "data"
        },
        "index": {
          "description": "rewrite rule",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "RRule",
          "package": "tamarin-prover-term",
          "partial": "RRule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#t:RRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA bunch of delayed (term,pattern) pairs.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "DelayedMatches",
          "package": "tamarin-prover-term",
          "signature": "DelayedMatches [(a, a)]",
          "source": "src/Term-Rewriting-Definitions.html#Match",
          "type": "function"
        },
        "index": {
          "description": "bunch of delayed term pattern pairs",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "DelayedMatches",
          "normalized": "DelayedMatches[(a,a)]",
          "package": "tamarin-prover-term",
          "partial": "Delayed Matches",
          "signature": "DelayedMatches[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:DelayedMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Rewriting.Definitions",
          "name": "Equal",
          "package": "tamarin-prover-term",
          "signature": "Equal",
          "source": "src/Term-Rewriting-Definitions.html#Equal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "Equal",
          "package": "tamarin-prover-term",
          "partial": "Equal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:Equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo matcher exists.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "NoMatch",
          "package": "tamarin-prover-term",
          "signature": "NoMatch",
          "source": "src/Term-Rewriting-Definitions.html#Match",
          "type": "function"
        },
        "index": {
          "description": "No matcher exists",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "NoMatch",
          "package": "tamarin-prover-term",
          "partial": "No Match",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:NoMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Rewriting.Definitions",
          "name": "eqLHS",
          "package": "tamarin-prover-term",
          "signature": "a",
          "source": "src/Term-Rewriting-Definitions.html#Equal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "eqLHS",
          "package": "tamarin-prover-term",
          "partial": "LHS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:eqLHS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Rewriting.Definitions",
          "name": "eqRHS",
          "package": "tamarin-prover-term",
          "signature": "a",
          "source": "src/Term-Rewriting-Definitions.html#Equal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "eqRHS",
          "package": "tamarin-prover-term",
          "partial": "RHS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:eqRHS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue iff the two sides of the equality are equal with respect to their\n \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "evalEqual",
          "package": "tamarin-prover-term",
          "signature": "Equal a -\u003e Bool",
          "source": "src/Term-Rewriting-Definitions.html#evalEqual",
          "type": "function"
        },
        "index": {
          "description": "True iff the two sides of the equality are equal with respect to their Eq instance",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "evalEqual",
          "normalized": "Equal a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Equal",
          "signature": "Equal a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:evalEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlatten a matching problem to a list of (term,pattern) pairs. If no\n matcher exists, then \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "flattenMatch",
          "package": "tamarin-prover-term",
          "signature": "Match a -\u003e Maybe [(a, a)]",
          "source": "src/Term-Rewriting-Definitions.html#flattenMatch",
          "type": "function"
        },
        "index": {
          "description": "Flatten matching problem to list of term pattern pairs If no matcher exists then Nothing is returned",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "flattenMatch",
          "normalized": "Match a-\u003eMaybe[(a,a)]",
          "package": "tamarin-prover-term",
          "partial": "Match",
          "signature": "Match a-\u003eMaybe[(a,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:flattenMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnsure that matching only succeeds if the condition holds.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "matchOnlyIf",
          "package": "tamarin-prover-term",
          "signature": "Bool -\u003e Match a",
          "source": "src/Term-Rewriting-Definitions.html#matchOnlyIf",
          "type": "function"
        },
        "index": {
          "description": "Ensure that matching only succeeds if the condition holds",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "matchOnlyIf",
          "normalized": "Bool-\u003eMatch a",
          "package": "tamarin-prover-term",
          "partial": "Only If",
          "signature": "Bool-\u003eMatch a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:matchOnlyIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a term with a pattern.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Definitions",
          "name": "matchWith",
          "package": "tamarin-prover-term",
          "signature": "a-\u003e a-\u003e Match a",
          "type": "function"
        },
        "index": {
          "description": "Match term with pattern",
          "hierarchy": "Term Rewriting Definitions",
          "module": "Term.Rewriting.Definitions",
          "name": "matchWith",
          "normalized": "a-\u003ea-\u003eMatch a",
          "package": "tamarin-prover-term",
          "partial": "With",
          "signature": "a-\u003ea-\u003eMatch a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Definitions.html#v:matchWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements normalization and normal-form checks of terms.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Rewriting.Norm",
          "name": "Norm",
          "package": "tamarin-prover-term",
          "source": "src/Term-Rewriting-Norm.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements normalization and normal-form checks of terms",
          "hierarchy": "Term Rewriting Norm",
          "module": "Term.Rewriting.Norm",
          "name": "Norm",
          "package": "tamarin-prover-term",
          "partial": "Norm",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Norm.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all subterms that may be not in normal form.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Norm",
          "name": "maybeNotNfSubterms",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig -\u003e LNTerm -\u003e [LNTerm]",
          "source": "src/Term-Rewriting-Norm.html#maybeNotNfSubterms",
          "type": "function"
        },
        "index": {
          "description": "Returns all subterms that may be not in normal form",
          "hierarchy": "Term Rewriting Norm",
          "module": "Term.Rewriting.Norm",
          "name": "maybeNotNfSubterms",
          "normalized": "MaudeSig-\u003eLNTerm-\u003e[LNTerm]",
          "package": "tamarin-prover-term",
          "partial": "Not Nf Subterms",
          "signature": "MaudeSig-\u003eLNTerm-\u003e[LNTerm]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Norm.html#v:maybeNotNfSubterms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enf' t\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e if the term \u003ccode\u003et\u003c/code\u003e is in normal form.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Norm",
          "name": "nf'",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e WithMaude Bool",
          "source": "src/Term-Rewriting-Norm.html#nf%27",
          "type": "function"
        },
        "index": {
          "description": "nf returns True if the term is in normal form",
          "hierarchy": "Term Rewriting Norm",
          "module": "Term.Rewriting.Norm",
          "name": "nf'",
          "normalized": "LNTerm-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "signature": "LNTerm-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Norm.html#v:nf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enfSubst s\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e if the substitution \u003ccode\u003es\u003c/code\u003e is in normal form.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Norm",
          "name": "nfSubstVFresh'",
          "package": "tamarin-prover-term",
          "signature": "LNSubstVFresh -\u003e WithMaude Bool",
          "source": "src/Term-Rewriting-Norm.html#nfSubstVFresh%27",
          "type": "function"
        },
        "index": {
          "description": "nfSubst returns True if the substitution is in normal form",
          "hierarchy": "Term Rewriting Norm",
          "module": "Term.Rewriting.Norm",
          "name": "nfSubstVFresh'",
          "normalized": "LNSubstVFresh-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "partial": "Subst VFresh'",
          "signature": "LNSubstVFresh-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Norm.html#v:nfSubstVFresh-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enorm' t\u003c/code\u003e normalizes the term \u003ccode\u003et\u003c/code\u003e using Maude.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Norm",
          "name": "norm'",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e WithMaude LNTerm",
          "source": "src/Term-Rewriting-Norm.html#norm%27",
          "type": "function"
        },
        "index": {
          "description": "norm normalizes the term using Maude",
          "hierarchy": "Term Rewriting Norm",
          "module": "Term.Rewriting.Norm",
          "name": "norm'",
          "normalized": "LNTerm-\u003eWithMaude LNTerm",
          "package": "tamarin-prover-term",
          "signature": "LNTerm-\u003eWithMaude LNTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Norm.html#v:norm-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003enormSubst s\u003c/code\u003e normalizes the substitution \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Rewriting.Norm",
          "name": "normSubstVFresh'",
          "package": "tamarin-prover-term",
          "signature": "LNSubstVFresh -\u003e WithMaude LNSubstVFresh",
          "source": "src/Term-Rewriting-Norm.html#normSubstVFresh%27",
          "type": "function"
        },
        "index": {
          "description": "normSubst normalizes the substitution",
          "hierarchy": "Term Rewriting Norm",
          "module": "Term.Rewriting.Norm",
          "name": "normSubstVFresh'",
          "normalized": "LNSubstVFresh-\u003eWithMaude LNSubstVFresh",
          "package": "tamarin-prover-term",
          "partial": "Subst VFresh'",
          "signature": "LNSubstVFresh-\u003eWithMaude LNSubstVFresh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Rewriting-Norm.html#v:normSubstVFresh-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eStandard and fresh substitutions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Substitution",
          "name": "Substitution",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution.html",
          "type": "module"
        },
        "index": {
          "description": "Standard and fresh substitutions",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "Substitution",
          "package": "tamarin-prover-term",
          "partial": "Substitution",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTypes that support the application of \u003ccode\u003e\u003ca\u003eLSubst\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "Apply",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution-SubstVFree.html#Apply",
          "type": "class"
        },
        "index": {
          "description": "Types that support the application of LSubst",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "Apply",
          "package": "tamarin-prover-term",
          "partial": "Apply",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#t:Apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA substitution with names and logical variables.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "LNSubst",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution-SubstVFree.html#LNSubst",
          "type": "type"
        },
        "index": {
          "description": "substitution with names and logical variables",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "LNSubst",
          "package": "tamarin-prover-term",
          "partial": "LNSubst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#t:LNSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFresh substitution with logical variables and names\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "LNSubstVFresh",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution-SubstVFresh.html#LNSubstVFresh",
          "type": "type"
        },
        "index": {
          "description": "Fresh substitution with logical variables and names",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "LNSubstVFresh",
          "package": "tamarin-prover-term",
          "partial": "LNSubst VFresh",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#t:LNSubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA substitution for logical variables.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "LSubst",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution-SubstVFree.html#LSubst",
          "type": "type"
        },
        "index": {
          "description": "substitution for logical variables",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "LSubst",
          "package": "tamarin-prover-term",
          "partial": "LSubst",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#t:LSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFresh substitution with logical variables\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "LSubstVFresh",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution-SubstVFresh.html#LSubstVFresh",
          "type": "type"
        },
        "index": {
          "description": "Fresh substitution with logical variables",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "LSubstVFresh",
          "package": "tamarin-prover-term",
          "partial": "LSubst VFresh",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#t:LSubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe use the data type \u003ccode\u003eSubst c v\u003c/code\u003e of substitutions. \u003ccode\u003ec\u003c/code\u003e is the type of constants\n   and \u003ccode\u003ev\u003c/code\u003e the type of variables.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "Subst",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution-SubstVFree.html#Subst",
          "type": "newtype"
        },
        "index": {
          "description": "We use the data type Subst of substitutions is the type of constants and the type of variables",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "Subst",
          "package": "tamarin-prover-term",
          "partial": "Subst",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#t:Subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe use the data type \u003ccode\u003eSubstVFresh c v\u003c/code\u003e of substitutions.\n   \u003ccode\u003ec\u003c/code\u003e denotes the type of constants and \u003ccode\u003ev\u003c/code\u003e the type of variables.\n   Fresh substitutions cannot be applied directly, they have to be converted\n   to free substitutions in a certain context (MonadFresh).\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "SubstVFresh",
          "package": "tamarin-prover-term",
          "source": "src/Term-Substitution-SubstVFresh.html#SubstVFresh",
          "type": "newtype"
        },
        "index": {
          "description": "We use the data type SubstVFresh of substitutions denotes the type of constants and the type of variables Fresh substitutions cannot be applied directly they have to be converted to free substitutions in certain context MonadFresh",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "SubstVFresh",
          "package": "tamarin-prover-term",
          "partial": "Subst VFresh",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#t:SubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Substitution",
          "name": "Subst",
          "package": "tamarin-prover-term",
          "signature": "Subst",
          "source": "src/Term-Substitution-SubstVFree.html#Subst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "Subst",
          "package": "tamarin-prover-term",
          "partial": "Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:Subst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Substitution",
          "name": "SubstVFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh",
          "source": "src/Term-Substitution-SubstVFresh.html#SubstVFresh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "SubstVFresh",
          "package": "tamarin-prover-term",
          "partial": "Subst VFresh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:SubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Substitution",
          "name": "apply",
          "package": "tamarin-prover-term",
          "signature": "LNSubst -\u003e t -\u003e t",
          "source": "src/Term-Substitution-SubstVFree.html#apply",
          "type": "method"
        },
        "index": {
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "apply",
          "normalized": "LNSubst-\u003ea-\u003ea",
          "package": "tamarin-prover-term",
          "signature": "LNSubst-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:apply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eapplyLit subst l\u003c/code\u003e applies the substitution \u003ccode\u003esubst\u003c/code\u003e to the literal \u003ccode\u003el\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "applyLit",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e Lit c v -\u003e VTerm c v",
          "source": "src/Term-Substitution-SubstVFree.html#applyLit",
          "type": "function"
        },
        "index": {
          "description": "applyLit subst applies the substitution subst to the literal",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "applyLit",
          "normalized": "Subst a b-\u003eLit a b-\u003eVTerm a b",
          "package": "tamarin-prover-term",
          "partial": "Lit",
          "signature": "Subst c v-\u003eLit c v-\u003eVTerm c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:applyLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eapplySubst subst subst'\u003c/code\u003e applies the substitution \u003ccode\u003esubst\u003c/code\u003e to the range of\n   the substitution \u003ccode\u003esubst'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "applySubst",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e Subst c v -\u003e Subst c v",
          "source": "src/Term-Substitution-SubstVFree.html#applySubst",
          "type": "function"
        },
        "index": {
          "description": "applySubst subst subst applies the substitution subst to the range of the substitution subst",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "applySubst",
          "normalized": "Subst a b-\u003eSubst a b-\u003eSubst a b",
          "package": "tamarin-prover-term",
          "partial": "Subst",
          "signature": "Subst c v-\u003eSubst c v-\u003eSubst c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:applySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eapplyVTerm subst t\u003c/code\u003e applies the substitution \u003ccode\u003esubst\u003c/code\u003e to the term \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "applyVTerm",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e VTerm c v -\u003e VTerm c v",
          "source": "src/Term-Substitution-SubstVFree.html#applyVTerm",
          "type": "function"
        },
        "index": {
          "description": "applyVTerm subst applies the substitution subst to the term",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "applyVTerm",
          "normalized": "Subst a b-\u003eVTerm a b-\u003eVTerm a b",
          "package": "tamarin-prover-term",
          "partial": "VTerm",
          "signature": "Subst c v-\u003eVTerm c v-\u003eVTerm c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:applyVTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecompose s1 s2\u003c/code\u003e composes the substitutions s1 and s2. The result is\n   \u003ccode\u003es1.s2\u003c/code\u003e, i.e., it has the same effect as \u003ccode\u003e(t s2) s1 = s1(s2(t))\u003c/code\u003e\n   when applied to a term \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "compose",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e Subst c v -\u003e Subst c v",
          "source": "src/Term-Substitution-SubstVFree.html#compose",
          "type": "function"
        },
        "index": {
          "description": "compose s1 s2 composes the substitutions s1 and s2 The result is s1.s2 i.e it has the same effect as s2 s1 s1 s2 when applied to term",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "compose",
          "normalized": "Subst a b-\u003eSubst a b-\u003eSubst a b",
          "package": "tamarin-prover-term",
          "signature": "Subst c v-\u003eSubst c v-\u003eSubst c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:compose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecomposeVFresh s1 s2\u003c/code\u003e composes the fresh substitution s1 and the free substitution s2.\n   The result is the fresh substitution s = s1.s2.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "composeVFresh",
          "package": "tamarin-prover-term",
          "signature": "LSubstVFresh c -\u003e LSubst c -\u003e LSubstVFresh c",
          "source": "src/Term-Substitution.html#composeVFresh",
          "type": "function"
        },
        "index": {
          "description": "composeVFresh s1 s2 composes the fresh substitution s1 and the free substitution s2 The result is the fresh substitution s1.s2",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "composeVFresh",
          "normalized": "LSubstVFresh a-\u003eLSubst a-\u003eLSubstVFresh a",
          "package": "tamarin-prover-term",
          "partial": "VFresh",
          "signature": "LSubstVFresh c-\u003eLSubst c-\u003eLSubstVFresh c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:composeVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edom subst\u003c/code\u003e returns the domain of the substitution \u003ccode\u003esubsts\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "dom",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e [v]",
          "source": "src/Term-Substitution-SubstVFree.html#dom",
          "type": "function"
        },
        "index": {
          "description": "dom subst returns the domain of the substitution substs",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "dom",
          "normalized": "Subst a b-\u003e[b]",
          "package": "tamarin-prover-term",
          "signature": "Subst c v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:dom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edomVFresh subst\u003c/code\u003e returns the domain of the substitution \u003ccode\u003esubsts\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "domVFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c v -\u003e [v]",
          "source": "src/Term-Substitution-SubstVFresh.html#domVFresh",
          "type": "function"
        },
        "index": {
          "description": "domVFresh subst returns the domain of the substitution substs",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "domVFresh",
          "normalized": "SubstVFresh a b-\u003e[b]",
          "package": "tamarin-prover-term",
          "partial": "VFresh",
          "signature": "SubstVFresh c v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:domVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eemptySubVFree\u003c/code\u003e is the substitution with empty domain.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "emptySubst",
          "package": "tamarin-prover-term",
          "signature": "Subst c v",
          "source": "src/Term-Substitution-SubstVFree.html#emptySubst",
          "type": "function"
        },
        "index": {
          "description": "emptySubVFree is the substitution with empty domain",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "emptySubst",
          "package": "tamarin-prover-term",
          "partial": "Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:emptySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eemptySubstVFresh\u003c/code\u003e is the fresh substitution with empty domain.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "emptySubstVFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c v",
          "source": "src/Term-Substitution-SubstVFresh.html#emptySubstVFresh",
          "type": "function"
        },
        "index": {
          "description": "emptySubstVFresh is the fresh substitution with empty domain",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "emptySubstVFresh",
          "package": "tamarin-prover-term",
          "partial": "Subst VFresh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:emptySubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eextendWithRenaming vs s\u003c/code\u003e extends the substitution \u003ccode\u003es\u003c/code\u003e with renamings (with\n   fresh variables) for the variables in \u003ccode\u003evs\u003c/code\u003e that are not already in \u003ccode\u003edom s\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "extendWithRenaming",
          "package": "tamarin-prover-term",
          "signature": "[LVar] -\u003e SubstVFresh c LVar -\u003e SubstVFresh c LVar",
          "source": "src/Term-Substitution-SubstVFresh.html#extendWithRenaming",
          "type": "function"
        },
        "index": {
          "description": "extendWithRenaming vs extends the substitution with renamings with fresh variables for the variables in vs that are not already in dom",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "extendWithRenaming",
          "normalized": "[LVar]-\u003eSubstVFresh a LVar-\u003eSubstVFresh a LVar",
          "package": "tamarin-prover-term",
          "partial": "With Renaming",
          "signature": "[LVar]-\u003eSubstVFresh c LVar-\u003eSubstVFresh c LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:extendWithRenaming"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreeToFreshRaw s\u003c/code\u003e considers all variables in the range of \u003ccode\u003es\u003c/code\u003e as fresh.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "freeToFreshRaw",
          "package": "tamarin-prover-term",
          "signature": "Subst c LVar -\u003e SubstVFresh c LVar",
          "source": "src/Term-Substitution.html#freeToFreshRaw",
          "type": "function"
        },
        "index": {
          "description": "freeToFreshRaw considers all variables in the range of as fresh",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "freeToFreshRaw",
          "normalized": "Subst a LVar-\u003eSubstVFresh a LVar",
          "package": "tamarin-prover-term",
          "partial": "To Fresh Raw",
          "signature": "Subst c LVar-\u003eSubstVFresh c LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:freeToFreshRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreshToFree s\u003c/code\u003e converts the bound variables in \u003ccode\u003es\u003c/code\u003e to free variables\n using fresh variable names. We try to preserve variables names if possible.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "freshToFree",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c LVar -\u003e m (Subst c LVar)",
          "source": "src/Term-Substitution.html#freshToFree",
          "type": "function"
        },
        "index": {
          "description": "freshToFree converts the bound variables in to free variables using fresh variable names We try to preserve variables names if possible",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "freshToFree",
          "normalized": "SubstVFresh a LVar-\u003eb(Subst a LVar)",
          "package": "tamarin-prover-term",
          "partial": "To Free",
          "signature": "SubstVFresh c LVar-\u003em(Subst c LVar)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:freshToFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreshToFreeAvoiding s t\u003c/code\u003e converts all fresh variables in the range of\n   \u003ccode\u003es\u003c/code\u003e to free variables avoiding free variables in \u003ccode\u003et\u003c/code\u003e. This function tries\n   to reuse variable names from the domain of the substitution if possible.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "freshToFreeAvoiding",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c LVar -\u003e t -\u003e Subst c LVar",
          "source": "src/Term-Substitution.html#freshToFreeAvoiding",
          "type": "function"
        },
        "index": {
          "description": "freshToFreeAvoiding converts all fresh variables in the range of to free variables avoiding free variables in This function tries to reuse variable names from the domain of the substitution if possible",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "freshToFreeAvoiding",
          "normalized": "SubstVFresh a LVar-\u003eb-\u003eSubst a LVar",
          "package": "tamarin-prover-term",
          "partial": "To Free Avoiding",
          "signature": "SubstVFresh c LVar-\u003et-\u003eSubst c LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:freshToFreeAvoiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efreshToFreeAvoidingFast s t\u003c/code\u003e converts all fresh variables in the range of\n   \u003ccode\u003es\u003c/code\u003e to free variables avoiding free variables in \u003ccode\u003et\u003c/code\u003e. This function does\n   not try to reuse variable names from the domain of the substitution.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "freshToFreeAvoidingFast",
          "package": "tamarin-prover-term",
          "signature": "LSubstVFresh c -\u003e t -\u003e LSubst c",
          "source": "src/Term-Substitution.html#freshToFreeAvoidingFast",
          "type": "function"
        },
        "index": {
          "description": "freshToFreeAvoidingFast converts all fresh variables in the range of to free variables avoiding free variables in This function does not try to reuse variable names from the domain of the substitution",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "freshToFreeAvoidingFast",
          "normalized": "LSubstVFresh a-\u003eb-\u003eLSubst a",
          "package": "tamarin-prover-term",
          "partial": "To Free Avoiding Fast",
          "signature": "LSubstVFresh c-\u003et-\u003eLSubst c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:freshToFreeAvoidingFast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the image of \u003ccode\u003ei\u003c/code\u003e under \u003ccode\u003esubst\u003c/code\u003e if \u003ccode\u003ei\u003c/code\u003e is in the domain of \u003ccode\u003esubst\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "imageOf",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e v -\u003e Maybe (VTerm c v)",
          "source": "src/Term-Substitution-SubstVFree.html#imageOf",
          "type": "function"
        },
        "index": {
          "description": "Returns the image of under subst if is in the domain of subst",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "imageOf",
          "normalized": "Subst a b-\u003eb-\u003eMaybe(VTerm a b)",
          "package": "tamarin-prover-term",
          "partial": "Of",
          "signature": "Subst c v-\u003ev-\u003eMaybe(VTerm c v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:imageOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the image of \u003ccode\u003ei\u003c/code\u003e under \u003ccode\u003esubst\u003c/code\u003e if \u003ccode\u003ei\u003c/code\u003e is in the domain of \u003ccode\u003esubst\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "imageOfVFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c v -\u003e v -\u003e Maybe (VTerm c v)",
          "source": "src/Term-Substitution-SubstVFresh.html#imageOfVFresh",
          "type": "function"
        },
        "index": {
          "description": "Returns the image of under subst if is in the domain of subst",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "imageOfVFresh",
          "normalized": "SubstVFresh a b-\u003eb-\u003eMaybe(VTerm a b)",
          "package": "tamarin-prover-term",
          "partial": "Of VFresh",
          "signature": "SubstVFresh c v-\u003ev-\u003eMaybe(VTerm c v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:imageOfVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003eTrue\u003c/code\u003e if the substitution is a renaming.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "isRenaming",
          "package": "tamarin-prover-term",
          "signature": "LSubstVFresh c -\u003e Bool",
          "source": "src/Term-Substitution-SubstVFresh.html#isRenaming",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the substitution is renaming",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "isRenaming",
          "normalized": "LSubstVFresh a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Renaming",
          "signature": "LSubstVFresh c-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:isRenaming"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emapRange f subst\u003c/code\u003e maps the function \u003ccode\u003ef\u003c/code\u003e over the range of the substitution \u003ccode\u003esubst\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "mapRange",
          "package": "tamarin-prover-term",
          "signature": "(VTerm c v -\u003e VTerm c2 v) -\u003e Subst c v -\u003e Subst c2 v",
          "source": "src/Term-Substitution-SubstVFree.html#mapRange",
          "type": "function"
        },
        "index": {
          "description": "mapRange subst maps the function over the range of the substitution subst",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "mapRange",
          "normalized": "(VTerm a b-\u003eVTerm a b)-\u003eSubst a b-\u003eSubst a b",
          "package": "tamarin-prover-term",
          "partial": "Range",
          "signature": "(VTerm c v-\u003eVTerm c v)-\u003eSubst c v-\u003eSubst c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:mapRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emapRangeVFresh f subst\u003c/code\u003e maps the function \u003ccode\u003ef\u003c/code\u003e over the range of the substitution \u003ccode\u003esubst\u003c/code\u003e.\n   Note that all introduced variables are considered fresh.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "mapRangeVFresh",
          "package": "tamarin-prover-term",
          "signature": "(VTerm c v -\u003e VTerm c2 v) -\u003e SubstVFresh c v -\u003e SubstVFresh c2 v",
          "source": "src/Term-Substitution-SubstVFresh.html#mapRangeVFresh",
          "type": "function"
        },
        "index": {
          "description": "mapRangeVFresh subst maps the function over the range of the substitution subst Note that all introduced variables are considered fresh",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "mapRangeVFresh",
          "normalized": "(VTerm a b-\u003eVTerm a b)-\u003eSubstVFresh a b-\u003eSubstVFresh a b",
          "package": "tamarin-prover-term",
          "partial": "Range VFresh",
          "signature": "(VTerm c v-\u003eVTerm c v)-\u003eSubstVFresh c v-\u003eSubstVFresh c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:mapRangeVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a disjunction of substitutions.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "prettyDisjLNSubstsVFresh",
          "package": "tamarin-prover-term",
          "signature": "Disj LNSubstVFresh -\u003e d",
          "source": "src/Term-Substitution-SubstVFresh.html#prettyDisjLNSubstsVFresh",
          "type": "function"
        },
        "index": {
          "description": "Pretty print disjunction of substitutions",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "prettyDisjLNSubstsVFresh",
          "normalized": "Disj LNSubstVFresh-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "Disj LNSubsts VFresh",
          "signature": "Disj LNSubstVFresh-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:prettyDisjLNSubstsVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a substitution with logical variables.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "prettyLNSubst",
          "package": "tamarin-prover-term",
          "signature": "LSubst c -\u003e d",
          "source": "src/Term-Substitution-SubstVFree.html#prettyLNSubst",
          "type": "function"
        },
        "index": {
          "description": "Pretty print substitution with logical variables",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "prettyLNSubst",
          "normalized": "LSubst a-\u003eb",
          "package": "tamarin-prover-term",
          "partial": "LNSubst",
          "signature": "LSubst c-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:prettyLNSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a substitution with logical variables.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "prettyLSubstVFresh",
          "package": "tamarin-prover-term",
          "signature": "LSubstVFresh c -\u003e d",
          "source": "src/Term-Substitution-SubstVFresh.html#prettyLSubstVFresh",
          "type": "function"
        },
        "index": {
          "description": "Pretty print substitution with logical variables",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "prettyLSubstVFresh",
          "normalized": "LSubstVFresh a-\u003eb",
          "package": "tamarin-prover-term",
          "partial": "LSubst VFresh",
          "signature": "LSubstVFresh c-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:prettyLSubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a substitution.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "prettySubst",
          "package": "tamarin-prover-term",
          "signature": "(v -\u003e d) -\u003e (Lit c v -\u003e d) -\u003e Subst c v -\u003e [d]",
          "source": "src/Term-Substitution-SubstVFree.html#prettySubst",
          "type": "function"
        },
        "index": {
          "description": "Pretty print substitution",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "prettySubst",
          "normalized": "(a-\u003eb)-\u003e(Lit c a-\u003eb)-\u003eSubst c a-\u003e[b]",
          "package": "tamarin-prover-term",
          "partial": "Subst",
          "signature": "(v-\u003ed)-\u003e(Lit c v-\u003ed)-\u003eSubst c v-\u003e[d]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:prettySubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a substitution.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "prettySubstVFresh",
          "package": "tamarin-prover-term",
          "signature": "(v -\u003e d) -\u003e (Lit c v -\u003e d) -\u003e SubstVFresh c v -\u003e [d]",
          "source": "src/Term-Substitution-SubstVFresh.html#prettySubstVFresh",
          "type": "function"
        },
        "index": {
          "description": "Pretty print substitution",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "prettySubstVFresh",
          "normalized": "(a-\u003eb)-\u003e(Lit c a-\u003eb)-\u003eSubstVFresh c a-\u003e[b]",
          "package": "tamarin-prover-term",
          "partial": "Subst VFresh",
          "signature": "(v-\u003ed)-\u003e(Lit c v-\u003ed)-\u003eSubstVFresh c v-\u003e[d]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:prettySubstVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erange subst\u003c/code\u003e returns the range of the substitution \u003ccode\u003esubsts\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "range",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e [VTerm c v]",
          "source": "src/Term-Substitution-SubstVFree.html#range",
          "type": "function"
        },
        "index": {
          "description": "range subst returns the range of the substitution substs",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "range",
          "normalized": "Subst a b-\u003e[VTerm a b]",
          "package": "tamarin-prover-term",
          "signature": "Subst c v-\u003e[VTerm c v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:range"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erangeVFresh subst\u003c/code\u003e returns the range of the substitution \u003ccode\u003esubsts\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "rangeVFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c v -\u003e [VTerm c v]",
          "source": "src/Term-Substitution-SubstVFresh.html#rangeVFresh",
          "type": "function"
        },
        "index": {
          "description": "rangeVFresh subst returns the range of the substitution substs",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "rangeVFresh",
          "normalized": "SubstVFresh a b-\u003e[VTerm a b]",
          "package": "tamarin-prover-term",
          "partial": "VFresh",
          "signature": "SubstVFresh c v-\u003e[VTerm c v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:rangeVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eremoveRenamings s\u003c/code\u003e removes all renamings (see \u003ccode\u003eisRenamedVar\u003c/code\u003e) from \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "removeRenamings",
          "package": "tamarin-prover-term",
          "signature": "LSubstVFresh c -\u003e LSubstVFresh c",
          "source": "src/Term-Substitution-SubstVFresh.html#removeRenamings",
          "type": "function"
        },
        "index": {
          "description": "removeRenamings removes all renamings see isRenamedVar from",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "removeRenamings",
          "normalized": "LSubstVFresh a-\u003eLSubstVFresh a",
          "package": "tamarin-prover-term",
          "partial": "Renamings",
          "signature": "LSubstVFresh c-\u003eLSubstVFresh c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:removeRenamings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erenameFresh s\u003c/code\u003e  renames the fresh variables in \u003ccode\u003es\u003c/code\u003e using fresh variables.\n   This function can be used to prevent overshadowing which might\n   make output hard to read.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "renameFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c LVar -\u003e m (SubstVFresh c LVar)",
          "source": "src/Term-Substitution-SubstVFresh.html#renameFresh",
          "type": "function"
        },
        "index": {
          "description": "renameFresh renames the fresh variables in using fresh variables This function can be used to prevent overshadowing which might make output hard to read",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "renameFresh",
          "normalized": "SubstVFresh a LVar-\u003eb(SubstVFresh a LVar)",
          "package": "tamarin-prover-term",
          "partial": "Fresh",
          "signature": "SubstVFresh c LVar-\u003em(SubstVFresh c LVar)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:renameFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erenameFreshAvoiding s t\u003c/code\u003e renames the fresh variables in the range of \u003ccode\u003es\u003c/code\u003e away from\n   variables that are free in \u003ccode\u003et\u003c/code\u003e. This is an internal function.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "renameFreshAvoiding",
          "package": "tamarin-prover-term",
          "signature": "LSubstVFresh c -\u003e t -\u003e SubstVFresh c LVar",
          "source": "src/Term-Substitution-SubstVFresh.html#renameFreshAvoiding",
          "type": "function"
        },
        "index": {
          "description": "renameFreshAvoiding renames the fresh variables in the range of away from variables that are free in This is an internal function",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "renameFreshAvoiding",
          "normalized": "LSubstVFresh a-\u003eb-\u003eSubstVFresh a LVar",
          "package": "tamarin-prover-term",
          "partial": "Fresh Avoiding",
          "signature": "LSubstVFresh c-\u003et-\u003eSubstVFresh c LVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:renameFreshAvoiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erestrict vars subst\u003c/code\u003e restricts the domain of the substitution \u003ccode\u003esubst\u003c/code\u003e to \u003ccode\u003evars\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "restrict",
          "package": "tamarin-prover-term",
          "signature": "[v] -\u003e Subst c v -\u003e Subst c v",
          "source": "src/Term-Substitution-SubstVFree.html#restrict",
          "type": "function"
        },
        "index": {
          "description": "restrict vars subst restricts the domain of the substitution subst to vars",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "restrict",
          "normalized": "[a]-\u003eSubst b a-\u003eSubst b a",
          "package": "tamarin-prover-term",
          "signature": "[v]-\u003eSubst c v-\u003eSubst c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:restrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erestrictVFresh vars subst\u003c/code\u003e restricts the domain of the substitution \u003ccode\u003esubst\u003c/code\u003e to \u003ccode\u003evars\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "restrictVFresh",
          "package": "tamarin-prover-term",
          "signature": "[v] -\u003e SubstVFresh c v -\u003e SubstVFresh c v",
          "source": "src/Term-Substitution-SubstVFresh.html#restrictVFresh",
          "type": "function"
        },
        "index": {
          "description": "restrictVFresh vars subst restricts the domain of the substitution subst to vars",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "restrictVFresh",
          "normalized": "[a]-\u003eSubstVFresh b a-\u003eSubstVFresh b a",
          "package": "tamarin-prover-term",
          "partial": "VFresh",
          "signature": "[v]-\u003eSubstVFresh c v-\u003eSubstVFresh c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:restrictVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Substitution",
          "name": "sMap",
          "package": "tamarin-prover-term",
          "signature": "Map v (VTerm c v)",
          "source": "src/Term-Substitution-SubstVFree.html#Subst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "sMap",
          "package": "tamarin-prover-term",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:sMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list to a substitution. The \u003ccode\u003ex/x\u003c/code\u003e mappings are removed.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "substFromList",
          "package": "tamarin-prover-term",
          "signature": "[(v, VTerm c v)] -\u003e Subst c v",
          "source": "src/Term-Substitution-SubstVFree.html#substFromList",
          "type": "function"
        },
        "index": {
          "description": "Convert list to substitution The mappings are removed",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "substFromList",
          "normalized": "[(a,VTerm b a)]-\u003eSubst b a",
          "package": "tamarin-prover-term",
          "partial": "From List",
          "signature": "[(v,VTerm c v)]-\u003eSubst c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:substFromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list of mappings to a fresh substitution.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "substFromListVFresh",
          "package": "tamarin-prover-term",
          "signature": "[(v, VTerm c v)] -\u003e SubstVFresh c v",
          "source": "src/Term-Substitution-SubstVFresh.html#substFromListVFresh",
          "type": "function"
        },
        "index": {
          "description": "Convert list of mappings to fresh substitution",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "substFromListVFresh",
          "normalized": "[(a,VTerm b a)]-\u003eSubstVFresh b a",
          "package": "tamarin-prover-term",
          "partial": "From List VFresh",
          "signature": "[(v,VTerm c v)]-\u003eSubstVFresh c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:substFromListVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a map to a substitution. The \u003ccode\u003ex/x\u003c/code\u003e mappings are removed.\n FIXME: implement directly, use substFromMap for substFromList.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "substFromMap",
          "package": "tamarin-prover-term",
          "signature": "Map v (VTerm c v) -\u003e Subst c v",
          "source": "src/Term-Substitution-SubstVFree.html#substFromMap",
          "type": "function"
        },
        "index": {
          "description": "Convert map to substitution The mappings are removed FIXME implement directly use substFromMap for substFromList",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "substFromMap",
          "normalized": "Map a(VTerm b a)-\u003eSubst b a",
          "package": "tamarin-prover-term",
          "partial": "From Map",
          "signature": "Map v(VTerm c v)-\u003eSubst c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:substFromMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert substitution to list.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "substToList",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e [(v, VTerm c v)]",
          "source": "src/Term-Substitution-SubstVFree.html#substToList",
          "type": "function"
        },
        "index": {
          "description": "Convert substitution to list",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "substToList",
          "normalized": "Subst a b-\u003e[(b,VTerm a b)]",
          "package": "tamarin-prover-term",
          "partial": "To List",
          "signature": "Subst c v-\u003e[(v,VTerm c v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:substToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esubstToPairOn vs sigma\u003c/code\u003e converts the list of variables \u003ccode\u003e[x1,..,xk]\u003c/code\u003e to\n   \u003ccode\u003e[sigma(x1),..,sigma(xk)]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "substToListOn",
          "package": "tamarin-prover-term",
          "signature": "[v] -\u003e Subst c v -\u003e [VTerm c v]",
          "source": "src/Term-Substitution-SubstVFree.html#substToListOn",
          "type": "function"
        },
        "index": {
          "description": "substToPairOn vs sigma converts the list of variables x1 xk to sigma x1 sigma xk",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "substToListOn",
          "normalized": "[a]-\u003eSubst b a-\u003e[VTerm b a]",
          "package": "tamarin-prover-term",
          "partial": "To List On",
          "signature": "[v]-\u003eSubst c v-\u003e[VTerm c v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:substToListOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert substitution to list.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "substToListVFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c v -\u003e [(v, VTerm c v)]",
          "source": "src/Term-Substitution-SubstVFresh.html#substToListVFresh",
          "type": "function"
        },
        "index": {
          "description": "Convert substitution to list",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "substToListVFresh",
          "normalized": "SubstVFresh a b-\u003e[(b,VTerm a b)]",
          "package": "tamarin-prover-term",
          "partial": "To List VFresh",
          "signature": "SubstVFresh c v-\u003e[(v,VTerm c v)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:substToListVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Substitution",
          "name": "svMap",
          "package": "tamarin-prover-term",
          "signature": "Map v (VTerm c v)",
          "source": "src/Term-Substitution-SubstVFresh.html#SubstVFresh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "svMap",
          "package": "tamarin-prover-term",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:svMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evarsRange subst\u003c/code\u003e returns all variables in the range of the substitution.\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "varsRange",
          "package": "tamarin-prover-term",
          "signature": "Subst c v -\u003e [v]",
          "source": "src/Term-Substitution-SubstVFree.html#varsRange",
          "type": "function"
        },
        "index": {
          "description": "varsRange subst returns all variables in the range of the substitution",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "varsRange",
          "normalized": "Subst a b-\u003e[b]",
          "package": "tamarin-prover-term",
          "partial": "Range",
          "signature": "Subst c v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:varsRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evarsRangeVFresh subst\u003c/code\u003e returns all variables in the range of the substitution\n\u003c/p\u003e",
          "module": "Term.Substitution",
          "name": "varsRangeVFresh",
          "package": "tamarin-prover-term",
          "signature": "SubstVFresh c v -\u003e [v]",
          "source": "src/Term-Substitution-SubstVFresh.html#varsRangeVFresh",
          "type": "function"
        },
        "index": {
          "description": "varsRangeVFresh subst returns all variables in the range of the substitution",
          "hierarchy": "Term Substitution",
          "module": "Term.Substitution",
          "name": "varsRangeVFresh",
          "normalized": "SubstVFresh a b-\u003e[b]",
          "package": "tamarin-prover-term",
          "partial": "Range VFresh",
          "signature": "SubstVFresh c v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Substitution.html#v:varsRangeVFresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSubsumption of terms and substitutions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Subsumption",
          "name": "Subsumption",
          "package": "tamarin-prover-term",
          "source": "src/Term-Subsumption.html",
          "type": "module"
        },
        "index": {
          "description": "Subsumption of terms and substitutions",
          "hierarchy": "Term Subsumption",
          "module": "Term.Subsumption",
          "name": "Subsumption",
          "package": "tamarin-prover-term",
          "partial": "Subsumption",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Subsumption.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a substitution that is equivalent modulo renaming to the given substitution.\n\u003c/p\u003e",
          "module": "Term.Subsumption",
          "name": "canonizeSubst",
          "package": "tamarin-prover-term",
          "signature": "LNSubstVFresh -\u003e LNSubstVFresh",
          "source": "src/Term-Subsumption.html#canonizeSubst",
          "type": "function"
        },
        "index": {
          "description": "Returns substitution that is equivalent modulo renaming to the given substitution",
          "hierarchy": "Term Subsumption",
          "module": "Term.Subsumption",
          "name": "canonizeSubst",
          "normalized": "LNSubstVFresh-\u003eLNSubstVFresh",
          "package": "tamarin-prover-term",
          "partial": "Subst",
          "signature": "LNSubstVFresh-\u003eLNSubstVFresh",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Subsumption.html#v:canonizeSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare terms \u003ccode\u003et1\u003c/code\u003e and \u003ccode\u003et2\u003c/code\u003e with respect to the subsumption order modulo AC.\n\u003c/p\u003e",
          "module": "Term.Subsumption",
          "name": "compareTermSubs",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LNTerm -\u003e WithMaude (Maybe Ordering)",
          "source": "src/Term-Subsumption.html#compareTermSubs",
          "type": "function"
        },
        "index": {
          "description": "Compare terms t1 and t2 with respect to the subsumption order modulo AC",
          "hierarchy": "Term Subsumption",
          "module": "Term.Subsumption",
          "name": "compareTermSubs",
          "normalized": "LNTerm-\u003eLNTerm-\u003eWithMaude(Maybe Ordering)",
          "package": "tamarin-prover-term",
          "partial": "Term Subs",
          "signature": "LNTerm-\u003eLNTerm-\u003eWithMaude(Maybe Ordering)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Subsumption.html#v:compareTermSubs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns True if \u003ccode\u003es1\u003c/code\u003e and \u003ccode\u003es2\u003c/code\u003e are equal with respect to the subsumption order modulo AC.\n\u003c/p\u003e",
          "module": "Term.Subsumption",
          "name": "eqTermSubs",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LNTerm -\u003e WithMaude Bool",
          "source": "src/Term-Subsumption.html#eqTermSubs",
          "type": "function"
        },
        "index": {
          "description": "Returns True if s1 and s2 are equal with respect to the subsumption order modulo AC",
          "hierarchy": "Term Subsumption",
          "module": "Term.Subsumption",
          "name": "eqTermSubs",
          "normalized": "LNTerm-\u003eLNTerm-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "partial": "Term Subs",
          "signature": "LNTerm-\u003eLNTerm-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Subsumption.html#v:eqTermSubs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Subsumption",
          "name": "factorSubstVia",
          "package": "tamarin-prover-term",
          "signature": "[LVar] -\u003e LNSubst -\u003e LNSubst -\u003e WithMaude [LNSubst]",
          "source": "src/Term-Subsumption.html#factorSubstVia",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Subsumption",
          "module": "Term.Subsumption",
          "name": "factorSubstVia",
          "normalized": "[LVar]-\u003eLNSubst-\u003eLNSubst-\u003eWithMaude[LNSubst]",
          "package": "tamarin-prover-term",
          "partial": "Subst Via",
          "signature": "[LVar]-\u003eLNSubst-\u003eLNSubst-\u003eWithMaude[LNSubst]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Subsumption.html#v:factorSubstVia"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSubterm rewriting rules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.SubtermRule",
          "name": "SubtermRule",
          "package": "tamarin-prover-term",
          "source": "src/Term-SubtermRule.html",
          "type": "module"
        },
        "index": {
          "description": "Subterm rewriting rules",
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "SubtermRule",
          "package": "tamarin-prover-term",
          "partial": "Subterm Rule",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe righthand-side of a subterm rewrite rule.\n   Does not enforce that the term for RhsGround must be ground.\n\u003c/p\u003e",
          "module": "Term.SubtermRule",
          "name": "StRhs",
          "package": "tamarin-prover-term",
          "source": "src/Term-SubtermRule.html#StRhs",
          "type": "data"
        },
        "index": {
          "description": "The righthand-side of subterm rewrite rule Does not enforce that the term for RhsGround must be ground",
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "StRhs",
          "package": "tamarin-prover-term",
          "partial": "St Rhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#t:StRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA subterm rewrite rule.\n\u003c/p\u003e",
          "module": "Term.SubtermRule",
          "name": "StRule",
          "package": "tamarin-prover-term",
          "source": "src/Term-SubtermRule.html#StRule",
          "type": "data"
        },
        "index": {
          "description": "subterm rewrite rule",
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "StRule",
          "package": "tamarin-prover-term",
          "partial": "St Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#t:StRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.SubtermRule",
          "name": "RhsGround",
          "package": "tamarin-prover-term",
          "signature": "RhsGround LNTerm",
          "source": "src/Term-SubtermRule.html#StRhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "RhsGround",
          "package": "tamarin-prover-term",
          "partial": "Rhs Ground",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#v:RhsGround"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.SubtermRule",
          "name": "RhsPosition",
          "package": "tamarin-prover-term",
          "signature": "RhsPosition Position",
          "source": "src/Term-SubtermRule.html#StRhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "RhsPosition",
          "package": "tamarin-prover-term",
          "partial": "Rhs Position",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#v:RhsPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.SubtermRule",
          "name": "StRule",
          "package": "tamarin-prover-term",
          "signature": "StRule LNTerm StRhs",
          "source": "src/Term-SubtermRule.html#StRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "StRule",
          "package": "tamarin-prover-term",
          "partial": "St Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#v:StRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print an \u003ccode\u003e\u003ca\u003eStRule\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Term.SubtermRule",
          "name": "prettyStRule",
          "package": "tamarin-prover-term",
          "signature": "StRule -\u003e d",
          "source": "src/Term-SubtermRule.html#prettyStRule",
          "type": "function"
        },
        "index": {
          "description": "Pretty print an StRule",
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "prettyStRule",
          "normalized": "StRule-\u003ea",
          "package": "tamarin-prover-term",
          "partial": "St Rule",
          "signature": "StRule-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#v:prettyStRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a rewrite rule to a subterm rewrite rule if possible.\n\u003c/p\u003e",
          "module": "Term.SubtermRule",
          "name": "rRuleToStRule",
          "package": "tamarin-prover-term",
          "signature": "RRule LNTerm -\u003e Maybe StRule",
          "source": "src/Term-SubtermRule.html#rRuleToStRule",
          "type": "function"
        },
        "index": {
          "description": "Convert rewrite rule to subterm rewrite rule if possible",
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "rRuleToStRule",
          "normalized": "RRule LNTerm-\u003eMaybe StRule",
          "package": "tamarin-prover-term",
          "partial": "Rule To St Rule",
          "signature": "RRule LNTerm-\u003eMaybe StRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#v:rRuleToStRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a subterm rewrite rule to a rewrite rule.\n\u003c/p\u003e",
          "module": "Term.SubtermRule",
          "name": "stRuleToRRule",
          "package": "tamarin-prover-term",
          "signature": "StRule -\u003e RRule LNTerm",
          "source": "src/Term-SubtermRule.html#stRuleToRRule",
          "type": "function"
        },
        "index": {
          "description": "Convert subterm rewrite rule to rewrite rule",
          "hierarchy": "Term SubtermRule",
          "module": "Term.SubtermRule",
          "name": "stRuleToRRule",
          "normalized": "StRule-\u003eRRule LNTerm",
          "package": "tamarin-prover-term",
          "partial": "Rule To RRule",
          "signature": "StRule-\u003eRRule LNTerm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-SubtermRule.html#v:stRuleToRRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAC unification based on maude and free unification.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.Unification",
          "name": "Unification",
          "package": "tamarin-prover-term",
          "source": "src/Term-Unification.html",
          "type": "module"
        },
        "index": {
          "description": "AC unification based on maude and free unification",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "Unification",
          "package": "tamarin-prover-term",
          "partial": "Unification",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA handle to a Maude process. It requires the Maude path for Signatures to\n be serializable. If we also add the string for the Maude config file, then\n it would even be serializable on its own.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "MaudeHandle",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Process.html#MaudeHandle",
          "type": "data"
        },
        "index": {
          "description": "handle to Maude process It requires the Maude path for Signatures to be serializable If we also add the string for the Maude config file then it would even be serializable on its own",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "MaudeHandle",
          "package": "tamarin-prover-term",
          "partial": "Maude Handle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#t:MaudeHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe required information to define a \u003ccode\u003eMaude functional module\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "MaudeSig",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Signature.html#MaudeSig",
          "type": "data"
        },
        "index": {
          "description": "The required information to define Maude functional module",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "MaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#t:MaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eValues that depend on a \u003ccode\u003e\u003ca\u003eMaudeHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "WithMaude",
          "package": "tamarin-prover-term",
          "source": "src/Term-Maude-Process.html#WithMaude",
          "type": "type"
        },
        "index": {
          "description": "Values that depend on MaudeHandle",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "WithMaude",
          "package": "tamarin-prover-term",
          "partial": "With Maude",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#t:WithMaude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an \u003ccode\u003e\u003ca\u003eLVar\u003c/a\u003e\u003c/code\u003e term to an \u003ccode\u003e\u003ca\u003eLVar\u003c/a\u003e\u003c/code\u003e pattern.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "matchLVar",
          "package": "tamarin-prover-term",
          "signature": "LVar -\u003e LVar -\u003e Match (LTerm c)",
          "source": "src/Term-Unification.html#matchLVar",
          "type": "function"
        },
        "index": {
          "description": "Match an LVar term to an LVar pattern",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "matchLVar",
          "normalized": "LVar-\u003eLVar-\u003eMatch(LTerm a)",
          "package": "tamarin-prover-term",
          "partial": "LVar",
          "signature": "LVar-\u003eLVar-\u003eMatch(LTerm c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:matchLVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Unification",
          "name": "mhFilePath",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e FilePath",
          "source": "src/Term-Maude-Process.html#mhFilePath",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "mhFilePath",
          "normalized": "MaudeHandle-\u003eFilePath",
          "package": "tamarin-prover-term",
          "partial": "File Path",
          "signature": "MaudeHandle-\u003eFilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:mhFilePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.Unification",
          "name": "mhMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e MaudeSig",
          "source": "src/Term-Maude-Process.html#mhMaudeSig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "mhMaudeSig",
          "normalized": "MaudeHandle-\u003eMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "signature": "MaudeHandle-\u003eMaudeSig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:mhMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esolveMatchLNTerm eqs\u003c/code\u003e returns a complete set of matchers for \u003ccode\u003eeqs\u003c/code\u003e\n modulo AC.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "solveMatchLNTerm",
          "package": "tamarin-prover-term",
          "signature": "Match LNTerm -\u003e WithMaude [Subst Name LVar]",
          "source": "src/Term-Unification.html#solveMatchLNTerm",
          "type": "function"
        },
        "index": {
          "description": "solveMatchLNTerm eqs returns complete set of matchers for eqs modulo AC",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "solveMatchLNTerm",
          "normalized": "Match LNTerm-\u003eWithMaude[Subst Name LVar]",
          "package": "tamarin-prover-term",
          "partial": "Match LNTerm",
          "signature": "Match LNTerm-\u003eWithMaude[Subst Name LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:solveMatchLNTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esolveMatchLNTerm sortOf eqs\u003c/code\u003e returns a complete set of matchers for\n \u003ccode\u003eeqs\u003c/code\u003e modulo AC.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "solveMatchLTerm",
          "package": "tamarin-prover-term",
          "signature": "(c -\u003e LSort) -\u003e Match (LTerm c) -\u003e WithMaude [Subst c LVar]",
          "source": "src/Term-Unification.html#solveMatchLTerm",
          "type": "function"
        },
        "index": {
          "description": "solveMatchLNTerm sortOf eqs returns complete set of matchers for eqs modulo AC",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "solveMatchLTerm",
          "normalized": "(a-\u003eLSort)-\u003eMatch(LTerm a)-\u003eWithMaude[Subst a LVar]",
          "package": "tamarin-prover-term",
          "partial": "Match LTerm",
          "signature": "(c-\u003eLSort)-\u003eMatch(LTerm c)-\u003eWithMaude[Subst c LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:solveMatchLTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff the terms are unifiable.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "unifiableLNTerms",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e LNTerm -\u003e WithMaude Bool",
          "source": "src/Term-Unification.html#unifiableLNTerms",
          "type": "function"
        },
        "index": {
          "description": "True iff the terms are unifiable",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "unifiableLNTerms",
          "normalized": "LNTerm-\u003eLNTerm-\u003eWithMaude Bool",
          "package": "tamarin-prover-term",
          "partial": "LNTerms",
          "signature": "LNTerm-\u003eLNTerm-\u003eWithMaude Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:unifiableLNTerms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunifyLNTerm eqs\u003c/code\u003e returns a complete set of unifiers for \u003ccode\u003eeqs\u003c/code\u003e modulo AC.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "unifyLNTerm",
          "package": "tamarin-prover-term",
          "signature": "[Equal LNTerm] -\u003e WithMaude [SubstVFresh Name LVar]",
          "source": "src/Term-Unification.html#unifyLNTerm",
          "type": "function"
        },
        "index": {
          "description": "unifyLNTerm eqs returns complete set of unifiers for eqs modulo AC",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "unifyLNTerm",
          "normalized": "[Equal LNTerm]-\u003eWithMaude[SubstVFresh Name LVar]",
          "package": "tamarin-prover-term",
          "partial": "LNTerm",
          "signature": "[Equal LNTerm]-\u003eWithMaude[SubstVFresh Name LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:unifyLNTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunifyLTerm sortOf eqs\u003c/code\u003e returns a complete set of unifiers for \u003ccode\u003eeqs\u003c/code\u003e modulo AC.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "unifyLNTermFactored",
          "package": "tamarin-prover-term",
          "signature": "[Equal LNTerm] -\u003e WithMaude (LNSubst, [SubstVFresh Name LVar])",
          "source": "src/Term-Unification.html#unifyLNTermFactored",
          "type": "function"
        },
        "index": {
          "description": "unifyLTerm sortOf eqs returns complete set of unifiers for eqs modulo AC",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "unifyLNTermFactored",
          "normalized": "[Equal LNTerm]-\u003eWithMaude(LNSubst,[SubstVFresh Name LVar])",
          "package": "tamarin-prover-term",
          "partial": "LNTerm Factored",
          "signature": "[Equal LNTerm]-\u003eWithMaude(LNSubst,[SubstVFresh Name LVar])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:unifyLNTermFactored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunifyLNTerm eqs\u003c/code\u003e returns a complete set of unifiers for \u003ccode\u003eeqs\u003c/code\u003e modulo AC.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "unifyLTerm",
          "package": "tamarin-prover-term",
          "signature": "(c -\u003e LSort) -\u003e [Equal (LTerm c)] -\u003e WithMaude [SubstVFresh c LVar]",
          "source": "src/Term-Unification.html#unifyLTerm",
          "type": "function"
        },
        "index": {
          "description": "unifyLNTerm eqs returns complete set of unifiers for eqs modulo AC",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "unifyLTerm",
          "normalized": "(a-\u003eLSort)-\u003e[Equal(LTerm a)]-\u003eWithMaude[SubstVFresh a LVar]",
          "package": "tamarin-prover-term",
          "partial": "LTerm",
          "signature": "(c-\u003eLSort)-\u003e[Equal(LTerm c)]-\u003eWithMaude[SubstVFresh c LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:unifyLTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunifyLTerm sortOf eqs\u003c/code\u003e returns a complete set of unifiers for \u003ccode\u003eeqs\u003c/code\u003e modulo AC.\n\u003c/p\u003e",
          "module": "Term.Unification",
          "name": "unifyLTermFactored",
          "package": "tamarin-prover-term",
          "signature": "(c -\u003e LSort) -\u003e [Equal (LTerm c)] -\u003e WithMaude (LSubst c, [SubstVFresh c LVar])",
          "source": "src/Term-Unification.html#unifyLTermFactored",
          "type": "function"
        },
        "index": {
          "description": "unifyLTerm sortOf eqs returns complete set of unifiers for eqs modulo AC",
          "hierarchy": "Term Unification",
          "module": "Term.Unification",
          "name": "unifyLTermFactored",
          "normalized": "(a-\u003eLSort)-\u003e[Equal(LTerm a)]-\u003eWithMaude(LSubst a,[SubstVFresh a LVar])",
          "package": "tamarin-prover-term",
          "partial": "LTerm Factored",
          "signature": "(c-\u003eLSort)-\u003e[Equal(LTerm c)]-\u003eWithMaude(LSubst c,[SubstVFresh c LVar])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-Unification.html#v:unifyLTermFactored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnit tests for the functions dealing with term algebra and related notions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.UnitTests",
          "name": "UnitTests",
          "package": "tamarin-prover-term",
          "source": "src/Term-UnitTests.html",
          "type": "module"
        },
        "index": {
          "description": "Unit tests for the functions dealing with term algebra and related notions",
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "UnitTests",
          "package": "tamarin-prover-term",
          "partial": "Unit Tests",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaude signatures with all builtin symbols.\n\u003c/p\u003e",
          "module": "Term.UnitTests",
          "name": "allMaudeSig",
          "package": "tamarin-prover-term",
          "signature": "MaudeSig",
          "source": "src/Term-UnitTests.html#allMaudeSig",
          "type": "function"
        },
        "index": {
          "description": "Maude signatures with all builtin symbols",
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "allMaudeSig",
          "package": "tamarin-prover-term",
          "partial": "Maude Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:allMaudeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "bigTerm",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-UnitTests.html#bigTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "bigTerm",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:bigTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "expo",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-UnitTests.html#expo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "expo",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:expo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "inv",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Term a",
          "source": "src/Term-UnitTests.html#inv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "inv",
          "normalized": "Term a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "Term a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "mult",
          "package": "tamarin-prover-term",
          "signature": "[Term a] -\u003e Term a",
          "source": "src/Term-UnitTests.html#mult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "mult",
          "normalized": "[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:mult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "normBigTerm",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-UnitTests.html#normBigTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "normBigTerm",
          "package": "tamarin-prover-term",
          "partial": "Big Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:normBigTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "one",
          "package": "tamarin-prover-term",
          "signature": "Term a",
          "source": "src/Term-UnitTests.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "one",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "pair",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-UnitTests.html#pair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "pair",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "ppLSubst",
          "package": "tamarin-prover-term",
          "signature": "LNSubst -\u003e String",
          "source": "src/Term-UnitTests.html#ppLSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "ppLSubst",
          "normalized": "LNSubst-\u003eString",
          "package": "tamarin-prover-term",
          "partial": "LSubst",
          "signature": "LNSubst-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:ppLSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "ppLTerm",
          "package": "tamarin-prover-term",
          "signature": "LNTerm -\u003e String",
          "source": "src/Term-UnitTests.html#ppLTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "ppLTerm",
          "normalized": "LNTerm-\u003eString",
          "package": "tamarin-prover-term",
          "partial": "LTerm",
          "signature": "LNTerm-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:ppLTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "propMatchSound",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e LNTerm -\u003e LNTerm -\u003e Bool",
          "source": "src/Term-UnitTests.html#propMatchSound",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "propMatchSound",
          "normalized": "MaudeHandle-\u003eLNTerm-\u003eLNTerm-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Match Sound",
          "signature": "MaudeHandle-\u003eLNTerm-\u003eLNTerm-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:propMatchSound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "propSubtermReplace",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Position -\u003e (Term a, Term a)",
          "source": "src/Term-UnitTests.html#propSubtermReplace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "propSubtermReplace",
          "normalized": "Term a-\u003ePosition-\u003e(Term a,Term a)",
          "package": "tamarin-prover-term",
          "partial": "Subterm Replace",
          "signature": "Term a-\u003ePosition-\u003e(Term a,Term a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:propSubtermReplace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "propUnifySound",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e LNTerm -\u003e LNTerm -\u003e Bool",
          "source": "src/Term-UnitTests.html#propUnifySound",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "propUnifySound",
          "normalized": "MaudeHandle-\u003eLNTerm-\u003eLNTerm-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Unify Sound",
          "signature": "MaudeHandle-\u003eLNTerm-\u003eLNTerm-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:propUnifySound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "runTest",
          "package": "tamarin-prover-term",
          "signature": "WithMaude a -\u003e IO a",
          "source": "src/Term-UnitTests.html#runTest",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "runTest",
          "normalized": "WithMaude a-\u003eIO a",
          "package": "tamarin-prover-term",
          "partial": "Test",
          "signature": "WithMaude a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:runTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "sub4",
          "package": "tamarin-prover-term",
          "signature": "LNSubstVFresh",
          "source": "src/Term-UnitTests.html#sub4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "sub4",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:sub4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "sub4'",
          "package": "tamarin-prover-term",
          "signature": "LNSubst",
          "source": "src/Term-UnitTests.html#sub4%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "sub4'",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:sub4-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "sub6",
          "package": "tamarin-prover-term",
          "signature": "LNSubstVFresh",
          "source": "src/Term-UnitTests.html#sub6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "sub6",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:sub6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "sub6'",
          "package": "tamarin-prover-term",
          "signature": "LNSubst",
          "source": "src/Term-UnitTests.html#sub6%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "sub6'",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:sub6-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "tcompare",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e Test",
          "source": "src/Term-UnitTests.html#tcompare",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "tcompare",
          "normalized": "MaudeHandle-\u003eTest",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:tcompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "te",
          "package": "tamarin-prover-term",
          "signature": "LNTerm",
          "source": "src/Term-UnitTests.html#te",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "te",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:te"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testEqual",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e a -\u003e a -\u003e Test",
          "source": "src/Term-UnitTests.html#testEqual",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testEqual",
          "normalized": "String-\u003ea-\u003ea-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "Equal",
          "signature": "String-\u003ea-\u003ea-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testTrue",
          "package": "tamarin-prover-term",
          "signature": "String -\u003e Bool -\u003e Test",
          "source": "src/Term-UnitTests.html#testTrue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testTrue",
          "normalized": "String-\u003eBool-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "True",
          "signature": "String-\u003eBool-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll unification infrastructure unit tests.\n\u003c/p\u003e",
          "module": "Term.UnitTests",
          "name": "tests",
          "package": "tamarin-prover-term",
          "signature": "FilePath -\u003e IO Test",
          "source": "src/Term-UnitTests.html#tests",
          "type": "function"
        },
        "index": {
          "description": "All unification infrastructure unit tests",
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "tests",
          "normalized": "FilePath-\u003eIO Test",
          "package": "tamarin-prover-term",
          "signature": "FilePath-\u003eIO Test",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:tests"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsMatching",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e Test",
          "source": "src/Term-UnitTests.html#testsMatching",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsMatching",
          "normalized": "MaudeHandle-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "Matching",
          "signature": "MaudeHandle-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsMatching"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsNorm",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e Test",
          "source": "src/Term-UnitTests.html#testsNorm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsNorm",
          "normalized": "MaudeHandle-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "Norm",
          "signature": "MaudeHandle-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsNorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsSimple",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e Test",
          "source": "src/Term-UnitTests.html#testsSimple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsSimple",
          "normalized": "MaudeHandle-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "Simple",
          "signature": "MaudeHandle-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsSubs",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e Test",
          "source": "src/Term-UnitTests.html#testsSubs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsSubs",
          "normalized": "MaudeHandle-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "Subs",
          "signature": "MaudeHandle-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsSubs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsSubst",
          "package": "tamarin-prover-term",
          "signature": "Test",
          "source": "src/Term-UnitTests.html#testsSubst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsSubst",
          "package": "tamarin-prover-term",
          "partial": "Subst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsSubst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsTerm",
          "package": "tamarin-prover-term",
          "signature": "Test",
          "source": "src/Term-UnitTests.html#testsTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsTerm",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsUnify",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e Test",
          "source": "src/Term-UnitTests.html#testsUnify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsUnify",
          "normalized": "MaudeHandle-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "Unify",
          "signature": "MaudeHandle-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsUnify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "testsVariant",
          "package": "tamarin-prover-term",
          "signature": "MaudeHandle -\u003e Test",
          "source": "src/Term-UnitTests.html#testsVariant",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "testsVariant",
          "normalized": "MaudeHandle-\u003eTest",
          "package": "tamarin-prover-term",
          "partial": "Variant",
          "signature": "MaudeHandle-\u003eTest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:testsVariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "tevs",
          "package": "tamarin-prover-term",
          "signature": "[LVar]",
          "source": "src/Term-UnitTests.html#tevs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "tevs",
          "normalized": "[LVar]",
          "package": "tamarin-prover-term",
          "signature": "[LVar]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:tevs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.UnitTests",
          "name": "union",
          "package": "tamarin-prover-term",
          "signature": "[Term a] -\u003e Term a",
          "source": "src/Term-UnitTests.html#union",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term UnitTests",
          "module": "Term.UnitTests",
          "name": "union",
          "normalized": "[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-UnitTests.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTerms with variables and constants.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Term.VTerm",
          "name": "VTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-VTerm.html",
          "type": "module"
        },
        "index": {
          "description": "Terms with variables and constants",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "VTerm",
          "package": "tamarin-prover-term",
          "partial": "VTerm",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAC function symbols.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "ACSym",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-FunctionSymbols.html#ACSym",
          "type": "data"
        },
        "index": {
          "description": "AC function symbols",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "ACSym",
          "package": "tamarin-prover-term",
          "partial": "ACSym",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:ACSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC(ommutative) function symbols\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "CSym",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-FunctionSymbols.html#CSym",
          "type": "data"
        },
        "index": {
          "description": "ommutative function symbols",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "CSym",
          "package": "tamarin-prover-term",
          "partial": "CSym",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:CSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction signatures.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "FunSig",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-FunctionSymbols.html#FunSig",
          "type": "type"
        },
        "index": {
          "description": "Function signatures",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:FunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction symbols\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "FunSym",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-FunctionSymbols.html#FunSym",
          "type": "data"
        },
        "index": {
          "description": "Function symbols",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FunSym",
          "package": "tamarin-prover-term",
          "partial": "Fun Sym",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:FunSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecollect class constraints for constants\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "IsConst",
          "package": "tamarin-prover-term",
          "source": "src/Term-VTerm.html#IsConst",
          "type": "class"
        },
        "index": {
          "description": "collect class constraints for constants",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "IsConst",
          "package": "tamarin-prover-term",
          "partial": "Is Const",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:IsConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecollect class constraints for variables\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "IsVar",
          "package": "tamarin-prover-term",
          "source": "src/Term-VTerm.html#IsVar",
          "type": "class"
        },
        "index": {
          "description": "collect class constraints for variables",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "IsVar",
          "package": "tamarin-prover-term",
          "partial": "Is Var",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:IsVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Lit is either a constant or a variable. (\u003ccode\u003eConst\u003c/code\u003e is taken by Control.Applicative)\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "Lit",
          "package": "tamarin-prover-term",
          "source": "src/Term-VTerm.html#Lit",
          "type": "data"
        },
        "index": {
          "description": "Lit is either constant or variable Const is taken by Control.Applicative",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Lit",
          "package": "tamarin-prover-term",
          "partial": "Lit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNoEq function signatures.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "NoEqFunSig",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-FunctionSymbols.html#NoEqFunSig",
          "type": "type"
        },
        "index": {
          "description": "NoEq function signatures",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "NoEqFunSig",
          "package": "tamarin-prover-term",
          "partial": "No Eq Fun Sig",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:NoEqFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNoEq function symbols (with respect to the background theory).\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "NoEqSym",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-FunctionSymbols.html#NoEqSym",
          "type": "type"
        },
        "index": {
          "description": "NoEq function symbols with respect to the background theory",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "NoEqSym",
          "package": "tamarin-prover-term",
          "partial": "No Eq Sym",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:NoEqSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function symbol can be either Private (unknown to adversary) or Public.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "Privacy",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-FunctionSymbols.html#Privacy",
          "type": "data"
        },
        "index": {
          "description": "function symbol can be either Private unknown to adversary or Public",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Privacy",
          "package": "tamarin-prover-term",
          "partial": "Privacy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:Privacy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Sized",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-Classes.html#Sized",
          "type": "class"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Sized",
          "package": "tamarin-prover-term",
          "partial": "Sized",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:Sized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA term in T(Sigma,a). Its constructors are kept abstract. Use \u003ccode\u003e\u003ca\u003eviewTerm\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eviewTerm2\u003c/a\u003e\u003c/code\u003e to inspect it.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "Term",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-Raw.html#Term",
          "type": "data"
        },
        "index": {
          "description": "term in Sigma Its constructors are kept abstract Use viewTerm or viewTerm2 to inspect it",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Term",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:Term"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView on terms that corresponds to representation.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "TermView",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-Raw.html#TermView",
          "type": "data"
        },
        "index": {
          "description": "View on terms that corresponds to representation",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "TermView",
          "package": "tamarin-prover-term",
          "partial": "Term View",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:TermView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView on terms that distinguishes function application of builtin symbols like exp.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "TermView2",
          "package": "tamarin-prover-term",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "data"
        },
        "index": {
          "description": "View on terms that distinguishes function application of builtin symbols like exp",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "TermView2",
          "package": "tamarin-prover-term",
          "partial": "Term View",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:TermView2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA VTerm is a term with constants and variables\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "VTerm",
          "package": "tamarin-prover-term",
          "source": "src/Term-VTerm.html#VTerm",
          "type": "type"
        },
        "index": {
          "description": "VTerm is term with constants and variables",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "VTerm",
          "package": "tamarin-prover-term",
          "partial": "VTerm",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#t:VTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean AC function symbol, can be used n-ary\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "AC",
          "package": "tamarin-prover-term",
          "signature": "AC ACSym",
          "source": "src/Term-Term-FunctionSymbols.html#FunSym",
          "type": "function"
        },
        "index": {
          "description": "an AC function symbol can be used n-ary",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "AC",
          "package": "tamarin-prover-term",
          "partial": "AC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:AC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea C function symbol of a given arity\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "C",
          "package": "tamarin-prover-term",
          "signature": "C CSym",
          "source": "src/Term-Term-FunctionSymbols.html#FunSym",
          "type": "function"
        },
        "index": {
          "description": "function symbol of given arity",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "C",
          "package": "tamarin-prover-term",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:C"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Con",
          "package": "tamarin-prover-term",
          "signature": "Con c",
          "source": "src/Term-VTerm.html#Lit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Con",
          "package": "tamarin-prover-term",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "EMap",
          "package": "tamarin-prover-term",
          "signature": "EMap",
          "source": "src/Term-Term-FunctionSymbols.html#CSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "EMap",
          "package": "tamarin-prover-term",
          "partial": "EMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:EMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FApp",
          "package": "tamarin-prover-term",
          "signature": "FApp FunSym [Term a]",
          "source": "src/Term-Term-Raw.html#TermView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FApp",
          "normalized": "FApp FunSym[Term a]",
          "package": "tamarin-prover-term",
          "partial": "FApp",
          "signature": "FApp FunSym[Term a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FAppC",
          "package": "tamarin-prover-term",
          "signature": "FAppC CSym [Term a]",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FAppC",
          "normalized": "FAppC CSym[Term a]",
          "package": "tamarin-prover-term",
          "partial": "FApp",
          "signature": "FAppC CSym[Term a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FAppC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FAppNoEq",
          "package": "tamarin-prover-term",
          "signature": "FAppNoEq NoEqSym [Term a]",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FAppNoEq",
          "normalized": "FAppNoEq NoEqSym[Term a]",
          "package": "tamarin-prover-term",
          "partial": "FApp No Eq",
          "signature": "FAppNoEq NoEqSym[Term a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FAppNoEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FEMap",
          "package": "tamarin-prover-term",
          "signature": "FEMap (Term a) (Term a)",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FEMap",
          "package": "tamarin-prover-term",
          "partial": "FEMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FEMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FExp",
          "package": "tamarin-prover-term",
          "signature": "FExp (Term a) (Term a)",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FExp",
          "package": "tamarin-prover-term",
          "partial": "FExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FInv",
          "package": "tamarin-prover-term",
          "signature": "FInv (Term a)",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FInv",
          "package": "tamarin-prover-term",
          "partial": "FInv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FList",
          "package": "tamarin-prover-term",
          "signature": "FList [Term a]",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FList",
          "normalized": "FList[Term a]",
          "package": "tamarin-prover-term",
          "partial": "FList",
          "signature": "FList[Term a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FMult",
          "package": "tamarin-prover-term",
          "signature": "FMult [Term a]",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FMult",
          "normalized": "FMult[Term a]",
          "package": "tamarin-prover-term",
          "partial": "FMult",
          "signature": "FMult[Term a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FPMult",
          "package": "tamarin-prover-term",
          "signature": "FPMult (Term a) (Term a)",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FPMult",
          "package": "tamarin-prover-term",
          "partial": "FPMult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FPMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FPair",
          "package": "tamarin-prover-term",
          "signature": "FPair (Term a) (Term a)",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FPair",
          "package": "tamarin-prover-term",
          "partial": "FPair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "FUnion",
          "package": "tamarin-prover-term",
          "signature": "FUnion [Term a]",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "FUnion",
          "normalized": "FUnion[Term a]",
          "package": "tamarin-prover-term",
          "partial": "FUnion",
          "signature": "FUnion[Term a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:FUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea free n-ary function symbol of TOP sort\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "List",
          "package": "tamarin-prover-term",
          "signature": "List",
          "source": "src/Term-Term-FunctionSymbols.html#FunSym",
          "type": "function"
        },
        "index": {
          "description": "free n-ary function symbol of TOP sort",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "List",
          "package": "tamarin-prover-term",
          "partial": "List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Lit",
          "package": "tamarin-prover-term",
          "signature": "Lit a",
          "source": "src/Term-Term-Raw.html#TermView",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Lit",
          "package": "tamarin-prover-term",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Lit2",
          "package": "tamarin-prover-term",
          "signature": "Lit2 a",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Lit2",
          "package": "tamarin-prover-term",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Lit2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Mult",
          "package": "tamarin-prover-term",
          "signature": "Mult",
          "source": "src/Term-Term-FunctionSymbols.html#ACSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Mult",
          "package": "tamarin-prover-term",
          "partial": "Mult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Mult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea free function function symbol of a given arity\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "NoEq",
          "package": "tamarin-prover-term",
          "signature": "NoEq NoEqSym",
          "source": "src/Term-Term-FunctionSymbols.html#FunSym",
          "type": "function"
        },
        "index": {
          "description": "free function function symbol of given arity",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "NoEq",
          "package": "tamarin-prover-term",
          "partial": "No Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:NoEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "One",
          "package": "tamarin-prover-term",
          "signature": "One",
          "source": "src/Term-Term-Raw.html#TermView2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "One",
          "package": "tamarin-prover-term",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Private",
          "package": "tamarin-prover-term",
          "signature": "Private",
          "source": "src/Term-Term-FunctionSymbols.html#Privacy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Private",
          "package": "tamarin-prover-term",
          "partial": "Private",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Private"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Public",
          "package": "tamarin-prover-term",
          "signature": "Public",
          "source": "src/Term-Term-FunctionSymbols.html#Privacy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Public",
          "package": "tamarin-prover-term",
          "partial": "Public",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Public"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Union",
          "package": "tamarin-prover-term",
          "signature": "Union",
          "source": "src/Term-Term-FunctionSymbols.html#ACSym",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Union",
          "package": "tamarin-prover-term",
          "partial": "Union",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "Var",
          "package": "tamarin-prover-term",
          "signature": "Var v",
          "source": "src/Term-VTerm.html#Lit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "Var",
          "package": "tamarin-prover-term",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "bindTerm",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e (a -\u003e Term b) -\u003e Term b",
          "source": "src/Term-Term-Raw.html#bindTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "bindTerm",
          "normalized": "Term a-\u003e(a-\u003eTerm b)-\u003eTerm b",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "Term a-\u003e(a-\u003eTerm b)-\u003eTerm b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:bindTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for the bilinear pairing function symbols.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "bpFunSig",
          "package": "tamarin-prover-term",
          "signature": "FunSig",
          "source": "src/Term-Term-FunctionSymbols.html#bpFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for the bilinear pairing function symbols",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "bpFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:bpFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReducible function symbols for BP.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "bpReducibleFunSig",
          "package": "tamarin-prover-term",
          "signature": "FunSig",
          "source": "src/Term-Term-FunctionSymbols.html#bpReducibleFunSig",
          "type": "function"
        },
        "index": {
          "description": "Reducible function symbols for BP",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "bpReducibleFunSig",
          "package": "tamarin-prover-term",
          "partial": "Reducible Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:bpReducibleFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003econstTerm c\u003c/code\u003e is the \u003ccode\u003e\u003ca\u003eVTerm\u003c/a\u003e\u003c/code\u003e with the const \u003ccode\u003ec\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "constTerm",
          "package": "tamarin-prover-term",
          "signature": "c -\u003e VTerm c v",
          "source": "src/Term-VTerm.html#constTerm",
          "type": "function"
        },
        "index": {
          "description": "constTerm is the VTerm with the const",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "constTerm",
          "normalized": "a-\u003eVTerm a b",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "c-\u003eVTerm c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:constTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003econstsVTerm t\u003c/code\u003e returns a duplicate-free list of constants that occur in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "constsVTerm",
          "package": "tamarin-prover-term",
          "signature": "VTerm c v -\u003e [c]",
          "source": "src/Term-VTerm.html#constsVTerm",
          "type": "function"
        },
        "index": {
          "description": "constsVTerm returns duplicate-free list of constants that occur in",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "constsVTerm",
          "normalized": "VTerm a b-\u003e[a]",
          "package": "tamarin-prover-term",
          "partial": "VTerm",
          "signature": "VTerm c v-\u003e[c]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:constsVTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for Diffie-Hellman function symbols.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "dhFunSig",
          "package": "tamarin-prover-term",
          "signature": "FunSig",
          "source": "src/Term-Term-FunctionSymbols.html#dhFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for Diffie-Hellman function symbols",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "dhFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:dhFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReducible function symbols for DH.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "dhReducibleFunSig",
          "package": "tamarin-prover-term",
          "signature": "FunSig",
          "source": "src/Term-Term-FunctionSymbols.html#dhReducibleFunSig",
          "type": "function"
        },
        "index": {
          "description": "Reducible function symbols for DH",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "dhReducibleFunSig",
          "package": "tamarin-prover-term",
          "partial": "Reducible Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:dhReducibleFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "emapSymString",
          "package": "tamarin-prover-term",
          "signature": "ByteString",
          "source": "src/Term-Term-FunctionSymbols.html#emapSymString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "emapSymString",
          "package": "tamarin-prover-term",
          "partial": "Sym String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:emapSymString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExponentiation.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "expSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Term-FunctionSymbols.html#expSym",
          "type": "function"
        },
        "index": {
          "description": "Exponentiation",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "expSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:expSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "expSymString",
          "package": "tamarin-prover-term",
          "signature": "ByteString",
          "source": "src/Term-Term-FunctionSymbols.html#expSymString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "expSymString",
          "package": "tamarin-prover-term",
          "partial": "Sym String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:expSymString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efApp fsym as\u003c/code\u003e creates an application of \u003ccode\u003efsym\u003c/code\u003e to \u003ccode\u003eas\u003c/code\u003e. The function\n ensures that the resulting term is in AC-normal-form.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fApp",
          "package": "tamarin-prover-term",
          "signature": "FunSym -\u003e [Term a] -\u003e Term a",
          "source": "src/Term-Term-Raw.html#fApp",
          "type": "function"
        },
        "index": {
          "description": "fApp fsym as creates an application of fsym to as The function ensures that the resulting term is in AC-normal-form",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fApp",
          "normalized": "FunSym-\u003e[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App",
          "signature": "FunSym-\u003e[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructor for AC terms.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppAC",
          "package": "tamarin-prover-term",
          "signature": "ACSym -\u003e [Term a] -\u003e Term a",
          "source": "src/Term-Term-Raw.html#fAppAC",
          "type": "function"
        },
        "index": {
          "description": "Smart constructor for AC terms",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppAC",
          "normalized": "ACSym-\u003e[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App AC",
          "signature": "ACSym-\u003e[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppAC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructor for C terms.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppC",
          "package": "tamarin-prover-term",
          "signature": "CSym -\u003e [Term a] -\u003e Term a",
          "source": "src/Term-Term-Raw.html#fAppC",
          "type": "function"
        },
        "index": {
          "description": "Smart constructor for terms",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppC",
          "normalized": "CSym-\u003e[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App",
          "signature": "CSym-\u003e[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for pair, exp, pmult, and emap.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppEMap",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Term.html#fAppEMap",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for pair exp pmult and emap",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppEMap",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App EMap",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppEMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for pair, exp, pmult, and emap.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppExp",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Term.html#fAppExp",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for pair exp pmult and emap",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppExp",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App Exp",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for inv, fst, and snd.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppFst",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Term a",
          "source": "src/Term-Term.html#fAppFst",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for inv fst and snd",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppFst",
          "normalized": "Term a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App Fst",
          "signature": "Term a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for inv, fst, and snd.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppInv",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Term a",
          "source": "src/Term-Term.html#fAppInv",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for inv fst and snd",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppInv",
          "normalized": "Term a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App Inv",
          "signature": "Term a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppInv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructor for list terms.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppList",
          "package": "tamarin-prover-term",
          "signature": "[Term a] -\u003e Term a",
          "source": "src/Term-Term-Raw.html#fAppList",
          "type": "function"
        },
        "index": {
          "description": "Smart constructor for list terms",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppList",
          "normalized": "[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App List",
          "signature": "[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructor for non-AC/C terms.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppNoEq",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym -\u003e [Term a] -\u003e Term a",
          "source": "src/Term-Term-Raw.html#fAppNoEq",
          "type": "function"
        },
        "index": {
          "description": "Smart constructor for non-AC terms",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppNoEq",
          "normalized": "NoEqSym-\u003e[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App No Eq",
          "signature": "NoEqSym-\u003e[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppNoEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for one, zero.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppOne",
          "package": "tamarin-prover-term",
          "signature": "Term a",
          "source": "src/Term-Term.html#fAppOne",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for one zero",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppOne",
          "package": "tamarin-prover-term",
          "partial": "App One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for pair, exp, pmult, and emap.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppPMult",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Term.html#fAppPMult",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for pair exp pmult and emap",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppPMult",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App PMult",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppPMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for pair, exp, pmult, and emap.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppPair",
          "package": "tamarin-prover-term",
          "signature": "(Term a, Term a) -\u003e Term a",
          "source": "src/Term-Term.html#fAppPair",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for pair exp pmult and emap",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppPair",
          "normalized": "(Term a,Term a)-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App Pair",
          "signature": "(Term a,Term a)-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSmart constructors for inv, fst, and snd.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "fAppSnd",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Term a",
          "source": "src/Term-Term.html#fAppSnd",
          "type": "function"
        },
        "index": {
          "description": "Smart constructors for inv fst and snd",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fAppSnd",
          "normalized": "Term a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App Snd",
          "signature": "Term a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fAppSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "fmapTerm",
          "package": "tamarin-prover-term",
          "signature": "(a -\u003e b) -\u003e Term a -\u003e Term b",
          "source": "src/Term-Term-Raw.html#fmapTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "fmapTerm",
          "normalized": "(a-\u003eb)-\u003eTerm a-\u003eTerm b",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "(a-\u003eb)-\u003eTerm a-\u003eTerm b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:fmapTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit function symbols.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "implicitFunSig",
          "package": "tamarin-prover-term",
          "signature": "FunSig",
          "source": "src/Term-Term-FunctionSymbols.html#implicitFunSig",
          "type": "function"
        },
        "index": {
          "description": "Implicit function symbols",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "implicitFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:implicitFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "invSymString",
          "package": "tamarin-prover-term",
          "signature": "ByteString",
          "source": "src/Term-Term-FunctionSymbols.html#invSymString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "invSymString",
          "package": "tamarin-prover-term",
          "partial": "Sym String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:invSymString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff the term is a well-formed emap.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "isEMap",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Bool",
          "source": "src/Term-Term.html#isEMap",
          "type": "function"
        },
        "index": {
          "description": "True iff the term is well-formed emap",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isEMap",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "EMap",
          "signature": "Term a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isEMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff the term is a well-formed inverse.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "isInverse",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Bool",
          "source": "src/Term-Term.html#isInverse",
          "type": "function"
        },
        "index": {
          "description": "True iff the term is well-formed inverse",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isInverse",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Inverse",
          "signature": "Term a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isInverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff the term is a nullary, public function.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "isNullaryPublicFunction",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Bool",
          "source": "src/Term-Term.html#isNullaryPublicFunction",
          "type": "function"
        },
        "index": {
          "description": "True iff the term is nullary public function",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isNullaryPublicFunction",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Nullary Public Function",
          "signature": "Term a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isNullaryPublicFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff the term is a well-formed pair.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "isPair",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Bool",
          "source": "src/Term-Term.html#isPair",
          "type": "function"
        },
        "index": {
          "description": "True iff the term is well-formed pair",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isPair",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Pair",
          "signature": "Term a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "isPrivateFunction",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Bool",
          "source": "src/Term-Term.html#isPrivateFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isPrivateFunction",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Private Function",
          "signature": "Term a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isPrivateFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff the term is a well-formed product.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "isProduct",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Bool",
          "source": "src/Term-Term.html#isProduct",
          "type": "function"
        },
        "index": {
          "description": "True iff the term is well-formed product",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isProduct",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Product",
          "signature": "Term a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isProduct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e iff the term is a well-formed union.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "isUnion",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e Bool",
          "source": "src/Term-Term.html#isUnion",
          "type": "function"
        },
        "index": {
          "description": "True iff the term is well-formed union",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isUnion",
          "normalized": "Term a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Union",
          "signature": "Term a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isUnion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "isVar",
          "package": "tamarin-prover-term",
          "signature": "VTerm c v -\u003e Bool",
          "source": "src/Term-VTerm.html#isVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "isVar",
          "normalized": "VTerm a b-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "Var",
          "signature": "VTerm c v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:isVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elit l\u003c/code\u003e creates a term from the literal \u003ccode\u003el\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "lit",
          "package": "tamarin-prover-term",
          "signature": "a -\u003e Term a",
          "source": "src/Term-Term-Raw.html#lit",
          "type": "function"
        },
        "index": {
          "description": "lit creates term from the literal",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "lit",
          "normalized": "a-\u003eTerm a",
          "package": "tamarin-prover-term",
          "signature": "a-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elits t\u003c/code\u003e returns all literals that occur in term \u003ccode\u003et\u003c/code\u003e. List can contain duplicates.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "lits",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e [a]",
          "source": "src/Term-Term.html#lits",
          "type": "function"
        },
        "index": {
          "description": "lits returns all literals that occur in term List can contain duplicates",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "lits",
          "normalized": "Term a-\u003e[a]",
          "package": "tamarin-prover-term",
          "signature": "Term a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:lits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for the multiset function symbols.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "msetFunSig",
          "package": "tamarin-prover-term",
          "signature": "FunSig",
          "source": "src/Term-Term-FunctionSymbols.html#msetFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for the multiset function symbols",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "msetFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:msetFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eoccurs v t\u003c/code\u003e returns \u003ccode\u003eTrue\u003c/code\u003e if \u003ccode\u003ev\u003c/code\u003e occurs in \u003ccode\u003et\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "occursVTerm",
          "package": "tamarin-prover-term",
          "signature": "v -\u003e VTerm c v -\u003e Bool",
          "source": "src/Term-VTerm.html#occursVTerm",
          "type": "function"
        },
        "index": {
          "description": "occurs returns True if occurs in",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "occursVTerm",
          "normalized": "a-\u003eVTerm b a-\u003eBool",
          "package": "tamarin-prover-term",
          "partial": "VTerm",
          "signature": "v-\u003eVTerm c v-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:occursVTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe signature for pairing.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "pairFunSig",
          "package": "tamarin-prover-term",
          "signature": "NoEqFunSig",
          "source": "src/Term-Term-FunctionSymbols.html#pairFunSig",
          "type": "function"
        },
        "index": {
          "description": "The signature for pairing",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "pairFunSig",
          "package": "tamarin-prover-term",
          "partial": "Fun Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:pairFunSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiplication of points (in G1) on elliptic curve by scalars.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "pmultSym",
          "package": "tamarin-prover-term",
          "signature": "NoEqSym",
          "source": "src/Term-Term-FunctionSymbols.html#pmultSym",
          "type": "function"
        },
        "index": {
          "description": "Multiplication of points in G1 on elliptic curve by scalars",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "pmultSym",
          "package": "tamarin-prover-term",
          "partial": "Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:pmultSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "pmultSymString",
          "package": "tamarin-prover-term",
          "signature": "ByteString",
          "source": "src/Term-Term-FunctionSymbols.html#pmultSymString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "pmultSymString",
          "package": "tamarin-prover-term",
          "partial": "Sym String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:pmultSymString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a term.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "prettyTerm",
          "package": "tamarin-prover-term",
          "signature": "(l -\u003e d) -\u003e Term l -\u003e d",
          "source": "src/Term-Term.html#prettyTerm",
          "type": "function"
        },
        "index": {
          "description": "Pretty print term",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "prettyTerm",
          "normalized": "(a-\u003eb)-\u003eTerm a-\u003eb",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "(l-\u003ed)-\u003eTerm l-\u003ed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:prettyTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a function symbol to its name.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "showFunSymName",
          "package": "tamarin-prover-term",
          "signature": "FunSym -\u003e String",
          "source": "src/Term-Term.html#showFunSymName",
          "type": "function"
        },
        "index": {
          "description": "Convert function symbol to its name",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "showFunSymName",
          "normalized": "FunSym-\u003eString",
          "package": "tamarin-prover-term",
          "partial": "Fun Sym Name",
          "signature": "FunSym-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:showFunSymName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "size",
          "package": "tamarin-prover-term",
          "signature": "a -\u003e Int",
          "source": "src/Term-Term-Classes.html#size",
          "type": "method"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "size",
          "normalized": "a-\u003eInt",
          "package": "tamarin-prover-term",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract just the variable from a term that may be variable.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "termVar",
          "package": "tamarin-prover-term",
          "signature": "VTerm c v -\u003e Maybe v",
          "source": "src/Term-VTerm.html#termVar",
          "type": "function"
        },
        "index": {
          "description": "Extract just the variable from term that may be variable",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "termVar",
          "normalized": "VTerm a b-\u003eMaybe b",
          "package": "tamarin-prover-term",
          "partial": "Var",
          "signature": "VTerm c v-\u003eMaybe v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:termVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract just the variable from a term that must be variable, throw an\n error if this fails.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "termVar'",
          "package": "tamarin-prover-term",
          "signature": "VTerm c v -\u003e v",
          "source": "src/Term-VTerm.html#termVar%27",
          "type": "function"
        },
        "index": {
          "description": "Extract just the variable from term that must be variable throw an error if this fails",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "termVar'",
          "normalized": "VTerm a b-\u003eb",
          "package": "tamarin-prover-term",
          "partial": "Var'",
          "signature": "VTerm c v-\u003ev",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:termVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "traverseTerm",
          "package": "tamarin-prover-term",
          "signature": "(a -\u003e f b) -\u003e Term a -\u003e f (Term b)",
          "source": "src/Term-Term-Raw.html#traverseTerm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "traverseTerm",
          "normalized": "(a-\u003eb c)-\u003eTerm a-\u003eb(Term c)",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "(a-\u003ef b)-\u003eTerm a-\u003ef(Term b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:traverseTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Term.VTerm",
          "name": "unionSymString",
          "package": "tamarin-prover-term",
          "signature": "ByteString",
          "source": "src/Term-Term-FunctionSymbols.html#unionSymString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "unionSymString",
          "package": "tamarin-prover-term",
          "partial": "Sym String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:unionSymString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eunsafefApp fsym as\u003c/code\u003e creates an application of \u003ccode\u003efsym\u003c/code\u003e to as. The\n   caller has to ensure that the resulting term is in AC-normal-form.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "unsafefApp",
          "package": "tamarin-prover-term",
          "signature": "FunSym -\u003e [Term a] -\u003e Term a",
          "source": "src/Term-Term-Raw.html#unsafefApp",
          "type": "function"
        },
        "index": {
          "description": "unsafefApp fsym as creates an application of fsym to as The caller has to ensure that the resulting term is in AC-normal-form",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "unsafefApp",
          "normalized": "FunSym-\u003e[Term a]-\u003eTerm a",
          "package": "tamarin-prover-term",
          "partial": "App",
          "signature": "FunSym-\u003e[Term a]-\u003eTerm a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:unsafefApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evarTerm v\u003c/code\u003e is the \u003ccode\u003e\u003ca\u003eVTerm\u003c/a\u003e\u003c/code\u003e with the variable \u003ccode\u003ev\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "varTerm",
          "package": "tamarin-prover-term",
          "signature": "v -\u003e VTerm c v",
          "source": "src/Term-VTerm.html#varTerm",
          "type": "function"
        },
        "index": {
          "description": "varTerm is the VTerm with the variable",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "varTerm",
          "normalized": "a-\u003eVTerm b a",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "v-\u003eVTerm c v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:varTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003evars t\u003c/code\u003e returns a duplicate-free list of variables that occur in \u003ccode\u003et\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "varsVTerm",
          "package": "tamarin-prover-term",
          "signature": "VTerm c v -\u003e [v]",
          "source": "src/Term-VTerm.html#varsVTerm",
          "type": "function"
        },
        "index": {
          "description": "vars returns duplicate-free list of variables that occur in",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "varsVTerm",
          "normalized": "VTerm a b-\u003e[b]",
          "package": "tamarin-prover-term",
          "partial": "VTerm",
          "signature": "VTerm c v-\u003e[v]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:varsVTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the \u003ccode\u003e\u003ca\u003eTermView\u003c/a\u003e\u003c/code\u003e of the given term.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "viewTerm",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e TermView a",
          "source": "src/Term-Term-Raw.html#viewTerm",
          "type": "function"
        },
        "index": {
          "description": "Return the TermView of the given term",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "viewTerm",
          "normalized": "Term a-\u003eTermView a",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "Term a-\u003eTermView a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:viewTerm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the \u003ccode\u003e\u003ca\u003eTermView2\u003c/a\u003e\u003c/code\u003e of the given term.\n\u003c/p\u003e",
          "module": "Term.VTerm",
          "name": "viewTerm2",
          "package": "tamarin-prover-term",
          "signature": "Term a -\u003e TermView2 a",
          "source": "src/Term-Term-Raw.html#viewTerm2",
          "type": "function"
        },
        "index": {
          "description": "Returns the TermView2 of the given term",
          "hierarchy": "Term VTerm",
          "module": "Term.VTerm",
          "name": "viewTerm2",
          "normalized": "Term a-\u003eTermView a",
          "package": "tamarin-prover-term",
          "partial": "Term",
          "signature": "Term a-\u003eTermView a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/tamarin-prover-term/docs/Term-VTerm.html#v:viewTerm2"
      }
    }
  ]
]