[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "swish"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport interning URIs.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Interned.URI",
          "name": "URI",
          "package": "swish",
          "source": "src/Data-Interned-URI.html",
          "type": "module"
        },
        "index": {
          "description": "Support interning URIs",
          "hierarchy": "Data Interned URI",
          "module": "Data.Interned.URI",
          "name": "URI",
          "package": "swish",
          "partial": "URI",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Interned-URI.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn interned URI. The hashing is based on the\n reversed URI (as a string).\n\u003c/p\u003e",
          "module": "Data.Interned.URI",
          "name": "InternedURI",
          "package": "swish",
          "source": "src/Data-Interned-URI.html#InternedURI",
          "type": "data"
        },
        "index": {
          "description": "An interned URI The hashing is based on the reversed URI as string",
          "hierarchy": "Data Interned URI",
          "module": "Data.Interned.URI",
          "name": "InternedURI",
          "package": "swish",
          "partial": "Interned URI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Interned-URI.html#t:InternedURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides methods to support operations on partially ordered\n  collections.  The partial ordering relationship is represented by\n  \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThanks to members of the haskell-cafe mailing list -\n    Robert (rvollmert-lists@gmx.net) and\n    Tom Pledger (Tom.Pledger@peace.com) -\n  who suggested key ideas on which some of the code in this module is based.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Ord.Partial",
          "name": "Partial",
          "package": "swish",
          "source": "src/Data-Ord-Partial.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides methods to support operations on partially ordered collections The partial ordering relationship is represented by Maybe Ordering Thanks to members of the haskell-cafe mailing list Robert rvollmert-lists@gmx.net and Tom Pledger Tom.Pledger@peace.com who suggested key ideas on which some of the code in this module is based",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "Partial",
          "package": "swish",
          "partial": "Partial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartial comparison function.\n\u003c/p\u003e",
          "module": "Data.Ord.Partial",
          "name": "PartCompare",
          "package": "swish",
          "source": "src/Data-Ord-Partial.html#PartCompare",
          "type": "type"
        },
        "index": {
          "description": "Partial comparison function",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "PartCompare",
          "package": "swish",
          "partial": "Part Compare",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#t:PartCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function finds the maxima in a list of partially\n  ordered values, preserving the sequence of retained\n  values from the supplied list.\n\u003c/p\u003e\u003cp\u003eIt returns all those values in the supplied list\n  for which there is no larger element in the list.\n\u003c/p\u003e",
          "module": "Data.Ord.Partial",
          "name": "maxima",
          "package": "swish",
          "signature": "PartCompare a -\u003e [a] -\u003e [a]",
          "source": "src/Data-Ord-Partial.html#maxima",
          "type": "function"
        },
        "index": {
          "description": "This function finds the maxima in list of partially ordered values preserving the sequence of retained values from the supplied list It returns all those values in the supplied list for which there is no larger element in the list",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "maxima",
          "normalized": "PartCompare a-\u003e[a]-\u003e[a]",
          "package": "swish",
          "signature": "PartCompare a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#v:maxima"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function finds the minima in a list of partially\n  ordered values, preserving the sequence of retained\n  values from the supplied list.\n\u003c/p\u003e\u003cp\u003eIt returns all those values in the supplied list\n  for which there is no smaller element in the list.\n\u003c/p\u003e",
          "module": "Data.Ord.Partial",
          "name": "minima",
          "package": "swish",
          "signature": "PartCompare a -\u003e [a] -\u003e [a]",
          "source": "src/Data-Ord-Partial.html#minima",
          "type": "function"
        },
        "index": {
          "description": "This function finds the minima in list of partially ordered values preserving the sequence of retained values from the supplied list It returns all those values in the supplied list for which there is no smaller element in the list",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "minima",
          "normalized": "PartCompare a-\u003e[a]-\u003e[a]",
          "package": "swish",
          "signature": "PartCompare a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#v:minima"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartial ordering for Eq values\n\u003c/p\u003e",
          "module": "Data.Ord.Partial",
          "name": "partCompareEq",
          "package": "swish",
          "signature": "PartCompare a",
          "source": "src/Data-Ord-Partial.html#partCompareEq",
          "type": "function"
        },
        "index": {
          "description": "Partial ordering for Eq values",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "partCompareEq",
          "package": "swish",
          "partial": "Compare Eq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#v:partCompareEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePart-ordering comparison on lists of Maybe values.\n\u003c/p\u003e",
          "module": "Data.Ord.Partial",
          "name": "partCompareListMaybe",
          "package": "swish",
          "signature": "[Maybe a] -\u003e [Maybe a] -\u003e Maybe Ordering",
          "source": "src/Data-Ord-Partial.html#partCompareListMaybe",
          "type": "function"
        },
        "index": {
          "description": "Part-ordering comparison on lists of Maybe values",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "partCompareListMaybe",
          "normalized": "[Maybe a]-\u003e[Maybe a]-\u003eMaybe Ordering",
          "package": "swish",
          "partial": "Compare List Maybe",
          "signature": "[Maybe a]-\u003e[Maybe a]-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#v:partCompareListMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePart-ordering comparison on lists based on subset relationship\n\u003c/p\u003e",
          "module": "Data.Ord.Partial",
          "name": "partCompareListSubset",
          "package": "swish",
          "signature": "[a] -\u003e [a] -\u003e Maybe Ordering",
          "source": "src/Data-Ord-Partial.html#partCompareListSubset",
          "type": "function"
        },
        "index": {
          "description": "Part-ordering comparison on lists based on subset relationship",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "partCompareListSubset",
          "normalized": "[a]-\u003e[a]-\u003eMaybe Ordering",
          "package": "swish",
          "partial": "Compare List Subset",
          "signature": "[a]-\u003e[a]-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#v:partCompareListSubset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePart-ordering comparison on pairs of values,\n  where each has a part-ordering relationship\n\u003c/p\u003e",
          "module": "Data.Ord.Partial",
          "name": "partComparePair",
          "package": "swish",
          "signature": "PartCompare a -\u003e PartCompare b -\u003e (a, b) -\u003e (a, b) -\u003e Maybe Ordering",
          "source": "src/Data-Ord-Partial.html#partComparePair",
          "type": "function"
        },
        "index": {
          "description": "Part-ordering comparison on pairs of values where each has part-ordering relationship",
          "hierarchy": "Data Ord Partial",
          "module": "Data.Ord.Partial",
          "name": "partComparePair",
          "normalized": "PartCompare a-\u003ePartCompare b-\u003e(a,b)-\u003e(a,b)-\u003eMaybe Ordering",
          "package": "swish",
          "partial": "Compare Pair",
          "signature": "PartCompare a-\u003ePartCompare b-\u003e(a,b)-\u003e(a,b)-\u003eMaybe Ordering",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-Ord-Partial.html#v:partComparePair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines an extension of the \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e class for displaying\n  multi-line values.  It serves the following purposes:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e provides a method with greater layout control of multiline values,\n\u003c/li\u003e\u003cli\u003e provides a possibility to override the default \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e behaviour\n      for programs that use the extended \u003ccode\u003e\u003ca\u003eShowLines\u003c/a\u003e\u003c/code\u003e interface, and\n\u003c/li\u003e\u003cli\u003e uses a \u003ccode\u003e\u003ca\u003eShowS\u003c/a\u003e\u003c/code\u003e intermediate value to avoid unnecessary\n      concatenation of long strings.\n\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e",
          "module": "Data.String.ShowLines",
          "name": "ShowLines",
          "package": "swish",
          "source": "src/Data-String-ShowLines.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines an extension of the Show class for displaying multi-line values It serves the following purposes provides method with greater layout control of multiline values provides possibility to override the default Show behaviour for programs that use the extended ShowLines interface and uses ShowS intermediate value to avoid unnecessary concatenation of long strings",
          "hierarchy": "Data String ShowLines",
          "module": "Data.String.ShowLines",
          "name": "ShowLines",
          "package": "swish",
          "partial": "Show Lines",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-String-ShowLines.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShowLines is a type class for values that may be formatted in\n  multi-line displays.\n\u003c/p\u003e",
          "module": "Data.String.ShowLines",
          "name": "ShowLines",
          "package": "swish",
          "source": "src/Data-String-ShowLines.html#ShowLines",
          "type": "class"
        },
        "index": {
          "description": "ShowLines is type class for values that may be formatted in multi-line displays",
          "hierarchy": "Data String ShowLines",
          "module": "Data.String.ShowLines",
          "name": "ShowLines",
          "package": "swish",
          "partial": "Show Lines",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-String-ShowLines.html#t:ShowLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMulti-line value display method\n\u003c/p\u003e\u003cp\u003eCreate a multiline displayable form of a value, returned\n  as a \u003ccode\u003e\u003ca\u003eShowS\u003c/a\u003e\u003c/code\u003e value.  The default implementation behaves just\n  like a normal instance of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function is intended to allow the calling function some control\n  of multiline displays by providing:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e the first line of the value is not preceded by any text, so\n      it may be appended to some preceding text on the same line,\n\u003c/li\u003e\u003cli\u003e the supplied line break string is used to separate lines of the\n      formatted text, and may include any desired indentation, and\n\u003c/li\u003e\u003cli\u003e no newline is output following the final line of text.\n\u003c/li\u003e\u003c/ol\u003e",
          "module": "Data.String.ShowLines",
          "name": "showls",
          "package": "swish",
          "signature": "String -\u003e sh -\u003e ShowS",
          "source": "src/Data-String-ShowLines.html#showls",
          "type": "method"
        },
        "index": {
          "description": "Multi-line value display method Create multiline displayable form of value returned as ShowS value The default implementation behaves just like normal instance of Show This function is intended to allow the calling function some control of multiline displays by providing the first line of the value is not preceded by any text so it may be appended to some preceding text on the same line the supplied line break string is used to separate lines of the formatted text and may include any desired indentation and no newline is output following the final line of text",
          "hierarchy": "Data String ShowLines",
          "module": "Data.String.ShowLines",
          "name": "showls",
          "normalized": "String-\u003ea-\u003eShowS",
          "package": "swish",
          "signature": "String-\u003esh-\u003eShowS",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Data-String-ShowLines.html#v:showls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvide an ordering for URIs (that is, an \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instance for\n  \u003ccode\u003eURI\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThis instance is provided so that URIs can be used as the\n  key of a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e. Case is relevant for the ordering,\n  and no attempt is made to decode percent-encoded values (i.e.\n  the comparison does \u003cem\u003enot\u003c/em\u003e use a canonical or normalized form).\n\u003c/p\u003e\u003cp\u003eFor \u003ccode\u003enetwork\u003c/code\u003e version \u003ccode\u003e2.4.0.0\u003c/code\u003e and higher, this module is a no-op,\n  since \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e now defines these instances.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.URI.Ord",
          "name": "Ord",
          "package": "swish",
          "source": "src/Network-URI-Ord.html",
          "type": "module"
        },
        "index": {
          "description": "Provide an ordering for URIs that is an Ord instance for URI This instance is provided so that URIs can be used as the key of Map Case is relevant for the ordering and no attempt is made to decode percent-encoded values i.e the comparison does not use canonical or normalized form For network version and higher this module is no-op since URI now defines these instances",
          "hierarchy": "Network URI Ord",
          "module": "Network.URI.Ord",
          "name": "Ord",
          "package": "swish",
          "partial": "Ord",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Network-URI-Ord.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions to deal with indivudual Swish command options.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Commands",
          "name": "Commands",
          "package": "swish",
          "source": "src/Swish-Commands.html",
          "type": "module"
        },
        "index": {
          "description": "Functions to deal with indivudual Swish command options",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "Commands",
          "package": "swish",
          "partial": "Commands",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet (or clear) the base URI.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishBase",
          "package": "swish",
          "signature": "Maybe QName -\u003e SwishStateIO ()",
          "source": "src/Swish-Commands.html#swishBase",
          "type": "function"
        },
        "index": {
          "description": "Set or clear the base URI",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishBase",
          "normalized": "Maybe QName-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Base",
          "signature": "Maybe QName-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead in a graph and compare it with the current graph.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishCompare",
          "package": "swish",
          "signature": "Maybe String-\u003e SwishStateIO ()",
          "type": "function"
        },
        "index": {
          "description": "Read in graph and compare it with the current graph",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishCompare",
          "normalized": "Maybe String-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Compare",
          "signature": "Maybe String-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the file format.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishFormat",
          "package": "swish",
          "signature": "SwishFormat -\u003e SwishStateIO ()",
          "source": "src/Swish-Commands.html#swishFormat",
          "type": "function"
        },
        "index": {
          "description": "Set the file format",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishFormat",
          "normalized": "SwishFormat-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Format",
          "signature": "SwishFormat-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead in a graph and display the differences to the current\n graph to standard output.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishGraphDiff",
          "package": "swish",
          "signature": "Maybe String-\u003e SwishStateIO ()",
          "type": "function"
        },
        "index": {
          "description": "Read in graph and display the differences to the current graph to standard output",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishGraphDiff",
          "normalized": "Maybe String-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Graph Diff",
          "signature": "Maybe String-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishGraphDiff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead in a graph and make it the current graph.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishInput",
          "package": "swish",
          "signature": "Maybe String-\u003e SwishStateIO ()",
          "type": "function"
        },
        "index": {
          "description": "Read in graph and make it the current graph",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishInput",
          "normalized": "Maybe String-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Input",
          "signature": "Maybe String-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead in a graph and merge it with the current graph.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishMerge",
          "package": "swish",
          "signature": "Maybe String-\u003e SwishStateIO ()",
          "type": "function"
        },
        "index": {
          "description": "Read in graph and merge it with the current graph",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishMerge",
          "normalized": "Maybe String-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Merge",
          "signature": "Maybe String-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishMerge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite out the current graph.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishOutput",
          "package": "swish",
          "signature": "Maybe String-\u003e SwishStateIO ()",
          "type": "function"
        },
        "index": {
          "description": "Write out the current graph",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishOutput",
          "normalized": "Maybe String-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Output",
          "signature": "Maybe String-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishOutput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead in a script and execute it.\n\u003c/p\u003e",
          "module": "Swish.Commands",
          "name": "swishScript",
          "package": "swish",
          "signature": "Maybe String-\u003e SwishStateIO ()",
          "type": "function"
        },
        "index": {
          "description": "Read in script and execute it",
          "hierarchy": "Swish Commands",
          "module": "Swish.Commands",
          "name": "swishScript",
          "normalized": "Maybe String-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Script",
          "signature": "Maybe String-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Commands.html#v:swishScript"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the structures used to represent and\n  manipulate datatypes.  It is designed as a basis for handling datatyped\n  RDF literals, but the functions in this module are more generic.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Datatype",
          "name": "Datatype",
          "package": "swish",
          "source": "src/Swish-Datatype.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the structures used to represent and manipulate datatypes It is designed as basis for handling datatyped RDF literals but the functions in this module are more generic",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "Datatype",
          "package": "swish",
          "partial": "Datatype",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of function used to apply a data value modifier to specified\n  variables in a supplied variable binding.  It also accepts the\n  name of the datatype modifier and carries it into the resulting\n  variable binding modifier.\n\u003c/p\u003e\u003cp\u003e(Note that \u003ccode\u003evn\u003c/code\u003e is not necessarily the same as \u003ccode\u003evt\u003c/code\u003e, the datatype value\n  type:  the modifier functions may be lifted or otherwise adapted\n  to operate on some other type from which the raw data values are\n  extracted.)\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "ApplyModifier",
          "package": "swish",
          "source": "src/Swish-Datatype.html#ApplyModifier",
          "type": "type"
        },
        "index": {
          "description": "Type of function used to apply data value modifier to specified variables in supplied variable binding It also accepts the name of the datatype modifier and carries it into the resulting variable binding modifier Note that vn is not necessarily the same as vt the datatype value type the modifier functions may be lifted or otherwise adapted to operate on some other type from which the raw data values are extracted",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "ApplyModifier",
          "package": "swish",
          "partial": "Apply Modifier",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:ApplyModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary function with provision for indicating\n  inconsistent supplied values:  function applicator type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "BinMaybeFnApply",
          "package": "swish",
          "source": "src/Swish-Datatype.html#BinMaybeFnApply",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for binary function with provision for indicating inconsistent supplied values function applicator type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "BinMaybeFnApply",
          "package": "swish",
          "partial": "Bin Maybe Fn Apply",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:BinMaybeFnApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary function with provision for indicating\n  inconsistent supplied values:  function descriptor type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "BinMaybeFnDescr",
          "package": "swish",
          "source": "src/Swish-Datatype.html#BinMaybeFnDescr",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for binary function with provision for indicating inconsistent supplied values function descriptor type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "BinMaybeFnDescr",
          "package": "swish",
          "partial": "Bin Maybe Fn Descr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:BinMaybeFnDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary function with provision for indicating\n  inconsistent supplied values:  function descriptor table type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "BinMaybeFnTable",
          "package": "swish",
          "source": "src/Swish-Datatype.html#BinMaybeFnTable",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for binary function with provision for indicating inconsistent supplied values function descriptor table type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "BinMaybeFnTable",
          "package": "swish",
          "partial": "Bin Maybe Fn Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:BinMaybeFnTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary functions: function applicator type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "BinaryFnApply",
          "package": "swish",
          "source": "src/Swish-Datatype.html#BinaryFnApply",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for binary functions function applicator type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "BinaryFnApply",
          "package": "swish",
          "partial": "Binary Fn Apply",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:BinaryFnApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary functions: function descriptor type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "BinaryFnDescr",
          "package": "swish",
          "source": "src/Swish-Datatype.html#BinaryFnDescr",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for binary functions function descriptor type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "BinaryFnDescr",
          "package": "swish",
          "partial": "Binary Fn Descr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:BinaryFnDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary functions: function descriptor table type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "BinaryFnTable",
          "package": "swish",
          "source": "src/Swish-Datatype.html#BinaryFnTable",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for binary functions function descriptor table type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "BinaryFnTable",
          "package": "swish",
          "partial": "Binary Fn Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:BinaryFnTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype wraps a \u003ccode\u003e\u003ca\u003eDatatypeVal\u003c/a\u003e\u003c/code\u003e value, hiding the value type that\n  is used only in implementations of the datatype.\n  Users see just the datatype name and associated ruleset.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "Datatype",
          "package": "swish",
          "source": "src/Swish-Datatype.html#Datatype",
          "type": "data"
        },
        "index": {
          "description": "Datatype wraps DatatypeVal value hiding the value type that is used only in implementations of the datatype Users see just the datatype name and associated ruleset",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "Datatype",
          "package": "swish",
          "partial": "Datatype",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:Datatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatypeMap consists of methods that perform lexical-to-value\n  and value-to-canonical-lexical mappings for a datatype.\n\u003c/p\u003e\u003cp\u003eThe datatype mappings apply to string lexical forms which\n  are stored as \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "DatatypeMap",
          "package": "swish",
          "source": "src/Swish-Datatype.html#DatatypeMap",
          "type": "data"
        },
        "index": {
          "description": "DatatypeMap consists of methods that perform lexical-to-value and value-to-canonical-lexical mappings for datatype The datatype mappings apply to string lexical forms which are stored as Text",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeMap",
          "package": "swish",
          "partial": "Datatype Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:DatatypeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper for data type variable binding modifier included in\n  a datatype value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "DatatypeMod",
          "package": "swish",
          "source": "src/Swish-Datatype.html#DatatypeMod",
          "type": "data"
        },
        "index": {
          "description": "Wrapper for data type variable binding modifier included in datatype value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeMod",
          "package": "swish",
          "partial": "Datatype Mod",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:DatatypeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype for a named relation on values of a datatype.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "DatatypeRel",
          "package": "swish",
          "source": "src/Swish-Datatype.html#DatatypeRel",
          "type": "data"
        },
        "index": {
          "description": "Datatype for named relation on values of datatype",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeRel",
          "package": "swish",
          "partial": "Datatype Rel",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:DatatypeRel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for a datatype relation inference function.\n\u003c/p\u003e\u003cp\u003eA datatype relation defines tuples of values that satisfy some\n  relation.  A datatype relation inference function calculates\n  values that complete a relation with values supplied.\n\u003c/p\u003e\u003cp\u003eThe function accepts a list of \u003ccode\u003eMaybe vt\u003c/code\u003e, where vt is the\n  datatype value type.  It returns one of:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Just a list of lists, where each inner list returned is a\n      complete set of values, including the values supplied, that\n      are in the relation.\n\u003c/li\u003e\u003cli\u003e Just an empty list is returned if the supplied values are\n      insufficient to compute any complete sets of values in the\n      relation.\n\u003c/li\u003e\u003cli\u003e Nothing if the supplied values are not consistent with\n      the relation.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Swish.Datatype",
          "name": "DatatypeRelFn",
          "package": "swish",
          "source": "src/Swish-Datatype.html#DatatypeRelFn",
          "type": "type"
        },
        "index": {
          "description": "Type for datatype relation inference function datatype relation defines tuples of values that satisfy some relation datatype relation inference function calculates values that complete relation with values supplied The function accepts list of Maybe vt where vt is the datatype value type It returns one of Just list of lists where each inner list returned is complete set of values including the values supplied that are in the relation Just an empty list is returned if the supplied values are insufficient to compute any complete sets of values in the relation Nothing if the supplied values are not consistent with the relation",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeRelFn",
          "package": "swish",
          "partial": "Datatype Rel Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:DatatypeRelFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for datatype relation predicate:  accepts a list of values\n  and determines whether or not they satisfy the relation.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "DatatypeRelPr",
          "package": "swish",
          "source": "src/Swish-Datatype.html#DatatypeRelPr",
          "type": "type"
        },
        "index": {
          "description": "Type for datatype relation predicate accepts list of values and determines whether or not they satisfy the relation",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeRelPr",
          "package": "swish",
          "partial": "Datatype Rel Pr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:DatatypeRelPr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribe a subtype/supertype relationship between a pair of datatypes.\n\u003c/p\u003e\u003cp\u003eOriginally, I had this as a supertype field of the DatatypeVal structure,\n  but that suffered from some problems:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e supertypes may be introduced retrospectively,\n\u003c/li\u003e\u003cli\u003e the relationship expressed with respect to a single datatype\n      cannot indicate how to do injections/restrictions between the\n      underlying value types.\n\u003c/li\u003e\u003c/ul\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eex\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e      is the type of expression with which the datatype may be used.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003elb\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e      is the type of the variable labels used.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003evn\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e      is the type of value node used to contain a datatyped value\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003esupvt\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e   is the internal value type of the super-datatype\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003esubvt\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e   is the internal value type of the sub-datatype\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Swish.Datatype",
          "name": "DatatypeSub",
          "package": "swish",
          "source": "src/Swish-Datatype.html#DatatypeSub",
          "type": "data"
        },
        "index": {
          "description": "Describe subtype supertype relationship between pair of datatypes Originally had this as supertype field of the DatatypeVal structure but that suffered from some problems supertypes may be introduced retrospectively the relationship expressed with respect to single datatype cannot indicate how to do injections restrictions between the underlying value types ex is the type of expression with which the datatype may be used lb is the type of the variable labels used vn is the type of value node used to contain datatyped value supvt is the internal value type of the super-datatype subvt is the internal value type of the sub-datatype",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeSub",
          "package": "swish",
          "partial": "Datatype Sub",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:DatatypeSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatypeVal is a structure that defines a number of functions\n  and values that characterize the behaviour of a datatype.\n\u003c/p\u003e\u003cp\u003eA datatype is specified with respect to (polymophic in) a given\n  type of (syntactic) expression with which it may be used, and\n  a value type (whose existence is hidden as an existential type\n  within \u003ccode\u003e\u003ca\u003eDatatypeMap\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003e(I tried hiding the value type with an internal existential\n  declaration, but that wouldn't wash.  Hence this two-part\n  structure with \u003ccode\u003e\u003ca\u003eDatatype\u003c/a\u003e\u003c/code\u003e in which the internal detail\n  of the value type is hidden from users of the \u003ccode\u003e\u003ca\u003eDatatype\u003c/a\u003e\u003c/code\u003e class.)\n\u003c/p\u003e\u003cp\u003eThe datatype characteristic functions have two goals:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e to support the general datatype entailment rules defined by\n      the RDF semantics specification, and\n\u003c/li\u003e\u003cli\u003e to define additional datatype-specific inference patterns by\n      means of which provide additional base functionality to\n      applications based on RDF inference.\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eDatatype-specific inferences are provided using the \u003ccode\u003e\u003ca\u003eDatatypeRel\u003c/a\u003e\u003c/code\u003e\n  structure for a datatype, which allows a number of named relations\n  to be defined on datatype values, and provides mechanisms to\n  calculate missing values in a partially-specified member of\n  a relation.\n\u003c/p\u003e\u003cp\u003eNote that rules and variable binding modifiers that deal with\n  combined values of more than one datatype may be defined\n  separately.  Definitions in this module are generally applicable\n  only when using a single datatype.\n\u003c/p\u003e\u003cp\u003eAn alternative model for datatype value calculations is inspired\n  by that introduced by CWM for arithmetic operations, e.g.\n\u003c/p\u003e\u003cpre\u003e     (1 2 3) math:sum ?x =\u003e ?x rdf:value 6\n\u003c/pre\u003e\u003cp\u003e(where the bare integer \u003ccode\u003en\u003c/code\u003e here is shorthand for \u003ccode\u003e\"n\"^^xsd:integer\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eDatatype-specific inference patterns are provided in two ways:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e by variable binding modifiers that can be combined with the\n    query results during forward- for backward-chaining of\n    inference rules, and\n\u003c/li\u003e\u003cli\u003e by the definition of inference rulesets that involve\n    datatype values.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eI believe the first method to be more flexible than the second,\n  in that it more readily supports forward and backward chaining,\n  but can be used only through the definition of new rules.\n\u003c/p\u003e\u003cp\u003eType parameters:\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eex\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e is the type of expression with which the datatype may be used.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003evt\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e is the internal value type with which the labels are associated.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003elb\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e is the type of label that may be used as a variable in an\n         expression or rule.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003evn\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e is the type of node that may be used to carry a value in an\n         expression or rule.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Swish.Datatype",
          "name": "DatatypeVal",
          "package": "swish",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "data"
        },
        "index": {
          "description": "DatatypeVal is structure that defines number of functions and values that characterize the behaviour of datatype datatype is specified with respect to polymophic in given type of syntactic expression with which it may be used and value type whose existence is hidden as an existential type within DatatypeMap tried hiding the value type with an internal existential declaration but that wouldn wash Hence this two-part structure with Datatype in which the internal detail of the value type is hidden from users of the Datatype class The datatype characteristic functions have two goals to support the general datatype entailment rules defined by the RDF semantics specification and to define additional datatype-specific inference patterns by means of which provide additional base functionality to applications based on RDF inference Datatype-specific inferences are provided using the DatatypeRel structure for datatype which allows number of named relations to be defined on datatype values and provides mechanisms to calculate missing values in partially-specified member of relation Note that rules and variable binding modifiers that deal with combined values of more than one datatype may be defined separately Definitions in this module are generally applicable only when using single datatype An alternative model for datatype value calculations is inspired by that introduced by CWM for arithmetic operations e.g math sum rdf value where the bare integer here is shorthand for xsd integer Datatype-specific inference patterns are provided in two ways by variable binding modifiers that can be combined with the query results during forward for backward-chaining of inference rules and by the definition of inference rulesets that involve datatype values believe the first method to be more flexible than the second in that it more readily supports forward and backward chaining but can be used only through the definition of new rules Type parameters ex is the type of expression with which the datatype may be used vt is the internal value type with which the labels are associated lb is the type of label that may be used as variable in an expression or rule vn is the type of node that may be used to carry value in an expression or rule",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeVal",
          "package": "swish",
          "partial": "Datatype Val",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:DatatypeVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for list functions:  function applicator type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "ListFnApply",
          "package": "swish",
          "source": "src/Swish-Datatype.html#ListFnApply",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for list functions function applicator type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "ListFnApply",
          "package": "swish",
          "partial": "List Fn Apply",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:ListFnApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for list functions (e.g. sum over list of args),\n  where first element of list is a fold over the rest of the list,\n  and remaining elements of list can be calculated in terms\n  of the result of the fold and the remaining elements\n\u003c/p\u003e\u003cp\u003eList function descriptor is\n\u003c/p\u003e\u003cp\u003e(a) list-fold function, f  (e.g. (+)\n\u003c/p\u003e\u003cp\u003e(b) list-fold identity, z  (e.g. 0)\n\u003c/p\u003e\u003cp\u003e(c) list-fold-function inverse, g (e.g. (-))\n\u003c/p\u003e\u003cp\u003e(d) index of element to evaluate\n\u003c/p\u003e\u003cp\u003esuch that:\n\u003c/p\u003e\u003cpre\u003e    (a `f` z) == (z `f` a) == a\n    (a `g` c) == b \u003c=\u003e a == b `f` c\n    (a `g` z) == a\n    (a `g` a) == z\n\u003c/pre\u003e\u003cp\u003eand the result of the folded function does not depend on\n  the order that the list elements are processed.\n\u003c/p\u003e\u003cp\u003eNOTE:  the list of \u003ccode\u003e\u003ca\u003eListFnDescr\u003c/a\u003e\u003c/code\u003e values supplied to \u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e must\n  be at least as long as the argument list.  In many cases, Haskell\n  lazy evaluation can be used to supply an arbitrarily long list.\n  See test cases in spike-altargs.hs for an example.\n\u003c/p\u003e\u003cp\u003eFunction descriptor type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "ListFnDescr",
          "package": "swish",
          "source": "src/Swish-Datatype.html#ListFnDescr",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for list functions e.g sum over list of args where first element of list is fold over the rest of the list and remaining elements of list can be calculated in terms of the result of the fold and the remaining elements List function descriptor is list-fold function e.g list-fold identity e.g list-fold-function inverse e.g index of element to evaluate such that and the result of the folded function does not depend on the order that the list elements are processed NOTE the list of ListFnDescr values supplied to altArgs must be at least as long as the argument list In many cases Haskell lazy evaluation can be used to supply an arbitrarily long list See test cases in spike-altargs.hs for an example Function descriptor type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "ListFnDescr",
          "package": "swish",
          "partial": "List Fn Descr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:ListFnDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction table type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "ListFnTable",
          "package": "swish",
          "source": "src/Swish-Datatype.html#ListFnTable",
          "type": "type"
        },
        "index": {
          "description": "Function table type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "ListFnTable",
          "package": "swish",
          "partial": "List Fn Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:ListFnTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype value modifier functions type\n\u003c/p\u003e\u003cp\u003eEach function accepts a list of values and returns a list of values.\n  The exact significance of the different values supplied and returned\n  depends on the variable binding pattern used (cf. \u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e),\n  but in all cases an empty list returned means that the corresponding\n  inputs are not consistent with the function and cannot be used.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "ModifierFn",
          "package": "swish",
          "source": "src/Swish-Datatype.html#ModifierFn",
          "type": "type"
        },
        "index": {
          "description": "Datatype value modifier functions type Each function accepts list of values and returns list of values The exact significance of the different values supplied and returned depends on the variable binding pattern used cf ApplyModifier but in all cases an empty list returned means that the corresponding inputs are not consistent with the function and cannot be used",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "ModifierFn",
          "package": "swish",
          "partial": "Modifier Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:ModifierFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for unary functions: function applicator type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "UnaryFnApply",
          "package": "swish",
          "source": "src/Swish-Datatype.html#UnaryFnApply",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for unary functions function applicator type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "UnaryFnApply",
          "package": "swish",
          "partial": "Unary Fn Apply",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:UnaryFnApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for unary functions: function descriptor type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "UnaryFnDescr",
          "package": "swish",
          "source": "src/Swish-Datatype.html#UnaryFnDescr",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for unary functions function descriptor type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "UnaryFnDescr",
          "package": "swish",
          "partial": "Unary Fn Descr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:UnaryFnDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for unary functions: function descriptor table type\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "UnaryFnTable",
          "package": "swish",
          "source": "src/Swish-Datatype.html#UnaryFnTable",
          "type": "type"
        },
        "index": {
          "description": "altArgs support for unary functions function descriptor table type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "UnaryFnTable",
          "package": "swish",
          "partial": "Unary Fn Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#t:UnaryFnTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "Datatype",
          "package": "swish",
          "signature": "forall vt . Datatype (DatatypeVal ex vt lb vn)",
          "source": "src/Swish-Datatype.html#Datatype",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "Datatype",
          "package": "swish",
          "partial": "Datatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:Datatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "DatatypeMap",
          "package": "swish",
          "signature": "DatatypeMap",
          "source": "src/Swish-Datatype.html#DatatypeMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeMap",
          "package": "swish",
          "partial": "Datatype Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:DatatypeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "DatatypeMod",
          "package": "swish",
          "signature": "DatatypeMod",
          "source": "src/Swish-Datatype.html#DatatypeMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeMod",
          "package": "swish",
          "partial": "Datatype Mod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:DatatypeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "DatatypeRel",
          "package": "swish",
          "signature": "DatatypeRel",
          "source": "src/Swish-Datatype.html#DatatypeRel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeRel",
          "package": "swish",
          "partial": "Datatype Rel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:DatatypeRel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "DatatypeSub",
          "package": "swish",
          "signature": "DatatypeSub",
          "source": "src/Swish-Datatype.html#DatatypeSub",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeSub",
          "package": "swish",
          "partial": "Datatype Sub",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:DatatypeSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "DatatypeVal",
          "package": "swish",
          "signature": "DatatypeVal",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "DatatypeVal",
          "package": "swish",
          "partial": "Datatype Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:DatatypeVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of argument values and a list of functions for\n  calculating new values from supplied values, return a list\n  of argument values, or \u003ccode\u003eNothing\u003c/code\u003e if the supplied values are\n  inconsistent with the calculations specified.\n\u003c/p\u003e\u003cp\u003eEach list of values returned corresponds to a set of values that\n  satisfy the relation, consistent with the values supplied.\n\u003c/p\u003e\u003cp\u003eFunctions are described as tuple consisting of:\n\u003c/p\u003e\u003cp\u003e(a) a predicate that the argument is required to satisfy\n\u003c/p\u003e\u003cp\u003e(b) a function to apply,\n\u003c/p\u003e\u003cp\u003e(c) a function to apply function (b) to a list of arguments\n\u003c/p\u003e\u003cp\u003e(d) argument list index values to which the function is applied.\n\u003c/p\u003e\u003cp\u003eEach supplied argument is of the form \u003ccode\u003eMaybe a\u003c/code\u003e, where the argument\n  has value type a.  \u003ccode\u003eNothing\u003c/code\u003e indicates arguments of unknown value.\n\u003c/p\u003e\u003cp\u003eThe basic idea is that, for each argument position in the relation,\n  a function may be supplied to calculate that argument's possible values\n  from some combination of the other arguments.  The results calculated\n  in this way are compared with the original arguments provided:\n  if the values conflict then the relation is presumed to be\n  unsatisfiable with the supplied values, and \u003ccode\u003eNothing\u003c/code\u003e is returned;\n  if there are any calculated values for arguments supplied without\n  any values, then tbe calculated values are used.\n  If there are any arguments for which no values are supplied or\n  calculated, then the relation is presumed to be underdetermined,\n  and \u003ccode\u003eJust []\u003c/code\u003e is returned.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "altArgs",
          "package": "swish",
          "signature": "DatatypeRelPr vt-\u003e [(vt -\u003e Bool, [b])]-\u003e ((vt -\u003e Bool) -\u003e b -\u003e [Maybe vt] -\u003e Maybe [vt])-\u003e DatatypeRelFn vt",
          "type": "function"
        },
        "index": {
          "description": "Given list of argument values and list of functions for calculating new values from supplied values return list of argument values or Nothing if the supplied values are inconsistent with the calculations specified Each list of values returned corresponds to set of values that satisfy the relation consistent with the values supplied Functions are described as tuple consisting of predicate that the argument is required to satisfy function to apply function to apply function to list of arguments argument list index values to which the function is applied Each supplied argument is of the form Maybe where the argument has value type Nothing indicates arguments of unknown value The basic idea is that for each argument position in the relation function may be supplied to calculate that argument possible values from some combination of the other arguments The results calculated in this way are compared with the original arguments provided if the values conflict then the relation is presumed to be unsatisfiable with the supplied values and Nothing is returned if there are any calculated values for arguments supplied without any values then tbe calculated values are used If there are any arguments for which no values are supplied or calculated then the relation is presumed to be underdetermined and Just is returned",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "altArgs",
          "normalized": "DatatypeRelPr a-\u003e[(a-\u003eBool,[b])]-\u003e((a-\u003eBool)-\u003eb-\u003e[Maybe a]-\u003eMaybe[a])-\u003eDatatypeRelFn a",
          "package": "swish",
          "partial": "Args",
          "signature": "DatatypeRelPr vt-\u003e[(vt-\u003eBool,[b])]-\u003e((vt-\u003eBool)-\u003eb-\u003e[Maybe vt]-\u003eMaybe[vt])-\u003eDatatypeRelFn vt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:altArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary function with provision for indicating\n  inconsistent supplied values:  function applicator\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "binMaybeFnApp",
          "package": "swish",
          "signature": "BinMaybeFnApply a",
          "source": "src/Swish-Datatype.html#binMaybeFnApp",
          "type": "function"
        },
        "index": {
          "description": "altArgs support for binary function with provision for indicating inconsistent supplied values function applicator",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "binMaybeFnApp",
          "package": "swish",
          "partial": "Maybe Fn App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:binMaybeFnApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for binary functions: function applicator\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "binaryFnApp",
          "package": "swish",
          "signature": "BinaryFnApply a",
          "source": "src/Swish-Datatype.html#binaryFnApp",
          "type": "function"
        },
        "index": {
          "description": "altArgs support for binary functions function applicator",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "binaryFnApp",
          "package": "swish",
          "partial": "Fn App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:binaryFnApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "dmAppf",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#DatatypeMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "dmAppf",
          "package": "swish",
          "partial": "Appf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:dmAppf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "dmModf",
          "package": "swish",
          "signature": "[ModifierFn vt]",
          "source": "src/Swish-Datatype.html#DatatypeMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "dmModf",
          "normalized": "[ModifierFn a]",
          "package": "swish",
          "partial": "Modf",
          "signature": "[ModifierFn vt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:dmModf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "dmName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-Datatype.html#DatatypeMod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "dmName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:dmName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "dtRelFunc",
          "package": "swish",
          "signature": "DatatypeRelFn vt",
          "source": "src/Swish-Datatype.html#DatatypeRel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "dtRelFunc",
          "package": "swish",
          "partial": "Rel Func",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:dtRelFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Datatype",
          "name": "dtRelName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-Datatype.html#DatatypeRel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "dtRelName",
          "package": "swish",
          "partial": "Rel Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:dtRelName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the named datatype value modifier, if it exists.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "getDTMod",
          "package": "swish",
          "signature": "ScopedName -\u003e DatatypeVal ex vt lb vn -\u003e Maybe (DatatypeMod vt lb vn)",
          "source": "src/Swish-Datatype.html#getDTMod",
          "type": "function"
        },
        "index": {
          "description": "Return the named datatype value modifier if it exists",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "getDTMod",
          "normalized": "ScopedName-\u003eDatatypeVal a b c d-\u003eMaybe(DatatypeMod b c d)",
          "package": "swish",
          "partial": "DTMod",
          "signature": "ScopedName-\u003eDatatypeVal ex vt lb vn-\u003eMaybe(DatatypeMod vt lb vn)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:getDTMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the named datatype relation, if it exists.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "getDTRel",
          "package": "swish",
          "signature": "ScopedName -\u003e DatatypeVal ex vt lb vn -\u003e Maybe (DatatypeRel vt)",
          "source": "src/Swish-Datatype.html#getDTRel",
          "type": "function"
        },
        "index": {
          "description": "Return the named datatype relation if it exists",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "getDTRel",
          "normalized": "ScopedName-\u003eDatatypeVal a b c d-\u003eMaybe(DatatypeRel b)",
          "package": "swish",
          "partial": "DTRel",
          "signature": "ScopedName-\u003eDatatypeVal ex vt lb vn-\u003eMaybe(DatatypeRel vt)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:getDTRel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the named axiom from a Datatype value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "getTypeAxiom",
          "package": "swish",
          "signature": "ScopedName -\u003e Datatype ex lb vn -\u003e Maybe (Formula ex)",
          "source": "src/Swish-Datatype.html#getTypeAxiom",
          "type": "function"
        },
        "index": {
          "description": "Get the named axiom from Datatype value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "getTypeAxiom",
          "normalized": "ScopedName-\u003eDatatype a b c-\u003eMaybe(Formula a)",
          "package": "swish",
          "partial": "Type Axiom",
          "signature": "ScopedName-\u003eDatatype ex lb vn-\u003eMaybe(Formula ex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:getTypeAxiom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the named rule from a Datatype value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "getTypeRule",
          "package": "swish",
          "signature": "ScopedName -\u003e Datatype ex lb vn -\u003e Maybe (Rule ex)",
          "source": "src/Swish-Datatype.html#getTypeRule",
          "type": "function"
        },
        "index": {
          "description": "Get the named rule from Datatype value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "getTypeRule",
          "normalized": "ScopedName-\u003eDatatype a b c-\u003eMaybe(Rule a)",
          "package": "swish",
          "partial": "Type Rule",
          "signature": "ScopedName-\u003eDatatype ex lb vn-\u003eMaybe(Rule ex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:getTypeRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for list functions:  function applicator\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "listFnApp",
          "package": "swish",
          "signature": "ListFnApply a",
          "source": "src/Swish-Datatype.html#listFnApp",
          "type": "function"
        },
        "index": {
          "description": "altArgs support for list functions function applicator",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "listFnApp",
          "package": "swish",
          "partial": "Fn App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:listFnApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e function for use with \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e in cases when\n  the value mapping is a non-invertable \u003ccode\u003e1-\u003e1\u003c/code\u003e injection, such as\n  absolute value.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003enam\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e is the name from the \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e value that is carried into\n          the resulting variable binding modifier.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003efns\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e are functions used to implement details of the variable\n          binding modifier:\n\u003c/dd\u003e\u003c/dl\u003e\u003col\u003e\u003cli\u003e is \u003ccode\u003e[x,y] -\u003e [?]\u003c/code\u003e, used as a filter (i.e. not creating any\n              new variable bindings), returning a non-empty list if \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e\n              are in the appropriate relationship.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[x]\u003c/code\u003e -\u003e \u003ccode\u003e[y]\u003c/code\u003e, used to perform the calculation.\n\u003c/li\u003e\u003c/ol\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003elbs\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e is a list of specific label values for which a variable binding\n          modifier will be generated.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eNote: an irrefutable pattern match for \u003ccode\u003elbs\u003c/code\u003e is used so that a name\n  for the \u003ccode\u003e\u003ca\u003eVarBindingModify\u003c/a\u003e\u003c/code\u003e value can be extracted using an undefined\n  label value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "makeVmod11",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#makeVmod11",
          "type": "function"
        },
        "index": {
          "description": "ApplyModifier function for use with DatatypeMod in cases when the value mapping is non-invertable injection such as absolute value nam is the name from the DatatypeMod value that is carried into the resulting variable binding modifier fns are functions used to implement details of the variable binding modifier is used as filter i.e not creating any new variable bindings returning non-empty list if and are in the appropriate relationship is used to perform the calculation lbs is list of specific label values for which variable binding modifier will be generated Note an irrefutable pattern match for lbs is used so that name for the VarBindingModify value can be extracted using an undefined label value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "makeVmod11",
          "package": "swish",
          "partial": "Vmod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:makeVmod11"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e function for use with \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e in cases\n  when the value mapping is a \u003ccode\u003e1-\u003e1\u003c/code\u003e function and inverse, such\n  as negate.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003enam\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is the name from the \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e value that is carried into\n          the resulting variable binding modifier.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003efns\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     are functions used to implement details of the variable\n          binding modifier:\n\u003c/dd\u003e\u003c/dl\u003e\u003col\u003e\u003cli\u003e is \u003ccode\u003e[x,y] -\u003e [?]\u003c/code\u003e, used as a filter (i.e. not creating any\n              new variable bindings), returning a non-empty list if \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e\n              are in the appropriate relationship.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[y] -\u003e [x]\u003c/code\u003e, used to perform the calculation in a forward\n              direction.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[x] -\u003e [y]\u003c/code\u003e, used to perform the calculation in a backward\n              direction.  This may be the same as (2) (e.g. for negation)\n              or may be different (e.g. increment).\n\u003c/li\u003e\u003c/ol\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003elbs\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is a list of specific label values for which a variable binding\n          modifier will be generated.  (The intent is that a variable-free\n          value can be generated as a Curried function, and instantiated\n          for particular variables as required.)\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eNote: an irrefutable pattern match for \u003ccode\u003elbs\u003c/code\u003e is used so that a name\n  for the \u003ccode\u003e\u003ca\u003eVarBindingModify\u003c/a\u003e\u003c/code\u003e value can be extracted using an undefined\n  label value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "makeVmod11inv",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#makeVmod11inv",
          "type": "function"
        },
        "index": {
          "description": "ApplyModifier function for use with DatatypeMod in cases when the value mapping is function and inverse such as negate nam is the name from the DatatypeMod value that is carried into the resulting variable binding modifier fns are functions used to implement details of the variable binding modifier is used as filter i.e not creating any new variable bindings returning non-empty list if and are in the appropriate relationship is used to perform the calculation in forward direction is used to perform the calculation in backward direction This may be the same as e.g for negation or may be different e.g increment lbs is list of specific label values for which variable binding modifier will be generated The intent is that variable-free value can be generated as Curried function and instantiated for particular variables as required Note an irrefutable pattern match for lbs is used so that name for the VarBindingModify value can be extracted using an undefined label value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "makeVmod11inv",
          "package": "swish",
          "partial": "Vmod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:makeVmod11inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e function for use with \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e in cases\n  when the value mapping is a simple comparson of two values.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003enam\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is the name from the \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e value that is carried into\n          the resulting variable binding modifier.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003efns\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     are functions used to implement details of the variable\n          binding modifier:\n\u003c/dd\u003e\u003c/dl\u003e\u003col\u003e\u003cli\u003e is \u003ccode\u003e[x,y] -\u003e [?]\u003c/code\u003e, used as a filter (i.e. not creating any\n              new variable bindings), returning a non-empty list if\n              \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e are in the appropriate relationship.\n\u003c/li\u003e\u003c/ol\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003elbs\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is a list of specific label values for which a variable binding\n          modifier will be generated.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eNote: an irrefutable pattern match for \u003ccode\u003elbs\u003c/code\u003e is used so that a name\n  for the \u003ccode\u003e\u003ca\u003eVarBindingModify\u003c/a\u003e\u003c/code\u003e value can be extracted using an undefined\n  label value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "makeVmod20",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#makeVmod20",
          "type": "function"
        },
        "index": {
          "description": "ApplyModifier function for use with DatatypeMod in cases when the value mapping is simple comparson of two values nam is the name from the DatatypeMod value that is carried into the resulting variable binding modifier fns are functions used to implement details of the variable binding modifier is used as filter i.e not creating any new variable bindings returning non-empty list if and are in the appropriate relationship lbs is list of specific label values for which variable binding modifier will be generated Note an irrefutable pattern match for lbs is used so that name for the VarBindingModify value can be extracted using an undefined label value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "makeVmod20",
          "package": "swish",
          "partial": "Vmod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:makeVmod20"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e function for use with \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e in cases\n  when the value mapping is a \u003ccode\u003e2-\u003e1\u003c/code\u003e non-invertable function, such as\n  logical \u003ccode\u003eAND\u003c/code\u003e or \u003ccode\u003eOR\u003c/code\u003e.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003enam\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is the name from the \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e value that is carried into\n          the resulting variable binding modifier.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003efns\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     are functions used to implement details of the variable\n          binding modifier:\n\u003c/dd\u003e\u003c/dl\u003e\u003col\u003e\u003cli\u003e is \u003ccode\u003e[x,y,z] -\u003e [?]\u003c/code\u003e, used as a filter (i.e. not creating any\n              new variable bindings), returning a non-empty list if\n              \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e and \u003ccode\u003ez\u003c/code\u003e are in the appropriate relationship.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[y,z] -\u003e [x]\u003c/code\u003e, used to perform the calculation in a\n              forward direction.\n\u003c/li\u003e\u003c/ol\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003elbs\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is a list of specific label values for which a variable binding\n          modifier will be generated.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eNote: an irrefutable pattern match for \u003ccode\u003elbs\u003c/code\u003e is used so that a name\n  for the \u003ccode\u003e\u003ca\u003eVarBindingModify\u003c/a\u003e\u003c/code\u003e value can be extracted using an undefined\n  label value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "makeVmod21",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#makeVmod21",
          "type": "function"
        },
        "index": {
          "description": "ApplyModifier function for use with DatatypeMod in cases when the value mapping is non-invertable function such as logical AND or OR nam is the name from the DatatypeMod value that is carried into the resulting variable binding modifier fns are functions used to implement details of the variable binding modifier is used as filter i.e not creating any new variable bindings returning non-empty list if and are in the appropriate relationship is used to perform the calculation in forward direction lbs is list of specific label values for which variable binding modifier will be generated Note an irrefutable pattern match for lbs is used so that name for the VarBindingModify value can be extracted using an undefined label value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "makeVmod21",
          "package": "swish",
          "partial": "Vmod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:makeVmod21"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e function for use with \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e in cases\n  when the value mapping is a \u003ccode\u003e2-\u003e1\u003c/code\u003e invertable function, such as\n  addition or subtraction.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003enam\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is the name from the \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e value that is carried into\n          the resulting variable binding modifier.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003efns\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     are functions used to implement details of the variable\n          binding modifier:\n\u003c/dd\u003e\u003c/dl\u003e\u003col\u003e\u003cli\u003e is \u003ccode\u003e[x,y,z] -\u003e [?]\u003c/code\u003e, used as a filter (i.e. not creating any\n              new variable bindings), returning a non-empty list if\n              \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e and \u003ccode\u003ez\u003c/code\u003e are in the appropriate relationship.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[y,z] -\u003e [x]\u003c/code\u003e, used to perform the calculation in a\n              forward direction.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[x,z] -\u003e [y]\u003c/code\u003e, used to run the calculation backwards to\n              determine the first input argument\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[x,y] -\u003e [z]\u003c/code\u003e, used to run the calculation backwards to\n              determine the second input argument\n\u003c/li\u003e\u003c/ol\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003elbs\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is a list of specific label values for which a variable binding\n          modifier will be generated.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eNote: an irrefutable pattern match for \u003ccode\u003elbs\u003c/code\u003e is used so that a name\n  for the \u003ccode\u003e\u003ca\u003eVarBindingModify\u003c/a\u003e\u003c/code\u003e value can be extracted using an undefined\n  label value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "makeVmod21inv",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#makeVmod21inv",
          "type": "function"
        },
        "index": {
          "description": "ApplyModifier function for use with DatatypeMod in cases when the value mapping is invertable function such as addition or subtraction nam is the name from the DatatypeMod value that is carried into the resulting variable binding modifier fns are functions used to implement details of the variable binding modifier is used as filter i.e not creating any new variable bindings returning non-empty list if and are in the appropriate relationship is used to perform the calculation in forward direction is used to run the calculation backwards to determine the first input argument is used to run the calculation backwards to determine the second input argument lbs is list of specific label values for which variable binding modifier will be generated Note an irrefutable pattern match for lbs is used so that name for the VarBindingModify value can be extracted using an undefined label value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "makeVmod21inv",
          "package": "swish",
          "partial": "Vmod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:makeVmod21inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e function for use with \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e in cases\n  when the value mapping is a \u003ccode\u003e2-\u003e2\u003c/code\u003e non-invertable function, such as\n  quotient/remainder\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003enam\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is the name from the \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e value that is carried into\n          the resulting variable binding modifier.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003efns\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     are functions used to implement details of the variable\n          binding modifier:\n\u003c/dd\u003e\u003c/dl\u003e\u003col\u003e\u003cli\u003e is \u003ccode\u003e[w,x,y,z] -\u003e [?]\u003c/code\u003e, used as a filter (i.e. not creating\n              any new variable bindings), returning a non-empty list if\n              \u003ccode\u003ew\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e and \u003ccode\u003ez\u003c/code\u003e are in the appropriate relationship.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[y,z] -\u003e [w,x]\u003c/code\u003e, used to perform the calculation given\n              two input values.\n\u003c/li\u003e\u003c/ol\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003elbs\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is a list of specific label values for which a variable binding\n          modifier will be generated.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eNote: an irrefutable pattern match for \u003ccode\u003elbs\u003c/code\u003e is used so that a name\n  for the \u003ccode\u003e\u003ca\u003eVarBindingModify\u003c/a\u003e\u003c/code\u003e value can be extracted using an undefined\n  label value.\n\u003c/p\u003e\u003cp\u003eNOTE: this might be generalized to allow one of \u003ccode\u003ew\u003c/code\u003e or \u003ccode\u003ex\u003c/code\u003e to be\n  specified, and return null if it doesn't match the calculated value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "makeVmod22",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#makeVmod22",
          "type": "function"
        },
        "index": {
          "description": "ApplyModifier function for use with DatatypeMod in cases when the value mapping is non-invertable function such as quotient remainder nam is the name from the DatatypeMod value that is carried into the resulting variable binding modifier fns are functions used to implement details of the variable binding modifier is used as filter i.e not creating any new variable bindings returning non-empty list if and are in the appropriate relationship is used to perform the calculation given two input values lbs is list of specific label values for which variable binding modifier will be generated Note an irrefutable pattern match for lbs is used so that name for the VarBindingModify value can be extracted using an undefined label value NOTE this might be generalized to allow one of or to be specified and return null if it doesn match the calculated value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "makeVmod22",
          "package": "swish",
          "partial": "Vmod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:makeVmod22"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplyModifier\u003c/a\u003e\u003c/code\u003e function for use with \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e in cases\n  when the value mapping is a \u003ccode\u003eN-\u003e1\u003c/code\u003e function,\n  such as Sigma (sum) of a vector.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003enam\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is the name from the \u003ccode\u003e\u003ca\u003eDatatypeMod\u003c/a\u003e\u003c/code\u003e value that is carried into\n          the resulting variable binding modifier.\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003efns\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     are functions used to implement details of the variable\n          binding modifier:\n\u003c/dd\u003e\u003c/dl\u003e\u003col\u003e\u003cli\u003e is \u003ccode\u003e[x,y...] -\u003e [?]\u003c/code\u003e, used as a filter (i.e. not creating\n              any new variable bindings), returning a non-empty list if\n              \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey...\u003c/code\u003e are in the appropriate relationship.\n\u003c/li\u003e\u003cli\u003e is \u003ccode\u003e[y...] -\u003e [x]\u003c/code\u003e, used to perform the calculation.\n\u003c/li\u003e\u003c/ol\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003elbs\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e     is a list of specific label values for which a variable binding\n          modifier will be generated.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eNote: an irrefutable pattern match for \u003ccode\u003elbs\u003c/code\u003e is used so that a name\n  for the \u003ccode\u003e\u003ca\u003eVarBindingModify\u003c/a\u003e\u003c/code\u003e value can be extracted using an undefined\n  label value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "makeVmodN1",
          "package": "swish",
          "signature": "ApplyModifier lb vn",
          "source": "src/Swish-Datatype.html#makeVmodN1",
          "type": "function"
        },
        "index": {
          "description": "ApplyModifier function for use with DatatypeMod in cases when the value mapping is function such as Sigma sum of vector nam is the name from the DatatypeMod value that is carried into the resulting variable binding modifier fns are functions used to implement details of the variable binding modifier is used as filter i.e not creating any new variable bindings returning non-empty list if and are in the appropriate relationship is used to perform the calculation lbs is list of specific label values for which variable binding modifier will be generated Note an irrefutable pattern match for lbs is used so that name for the VarBindingModify value can be extracted using an undefined label value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "makeVmodN1",
          "package": "swish",
          "partial": "Vmod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:makeVmodN1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to map a lexical string to\n   the datatype value.  This effectively\n   defines the lexical space of the\n   datatype to be all strings for which\n   yield a value other than \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "mapL2V",
          "package": "swish",
          "signature": "Text -\u003e Maybe vt",
          "source": "src/Swish-Datatype.html#DatatypeMap",
          "type": "function"
        },
        "index": {
          "description": "Function to map lexical string to the datatype value This effectively defines the lexical space of the datatype to be all strings for which yield value other than Nothing",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "mapL2V",
          "normalized": "Text-\u003eMaybe a",
          "package": "swish",
          "signature": "Text-\u003eMaybe vt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:mapL2V"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to map a value to its canonical\n   lexical form, if it has such.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "mapV2L",
          "package": "swish",
          "signature": "vt -\u003e Maybe Text",
          "source": "src/Swish-Datatype.html#DatatypeMap",
          "type": "function"
        },
        "index": {
          "description": "Function to map value to its canonical lexical form if it has such",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "mapV2L",
          "normalized": "a-\u003eMaybe Text",
          "package": "swish",
          "signature": "vt-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:mapV2L"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNull datatype value modifier\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "nullDatatypeMod",
          "package": "swish",
          "signature": "DatatypeMod vt lb vn",
          "source": "src/Swish-Datatype.html#nullDatatypeMod",
          "type": "function"
        },
        "index": {
          "description": "Null datatype value modifier",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "nullDatatypeMod",
          "package": "swish",
          "partial": "Datatype Mod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:nullDatatypeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype that is a subtype of \u003ccode\u003etrelSup\u003c/code\u003e,\n   having value space \u003ccode\u003esupvt\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "trelSub",
          "package": "swish",
          "signature": "DatatypeVal ex subvt lb vn",
          "source": "src/Swish-Datatype.html#DatatypeSub",
          "type": "function"
        },
        "index": {
          "description": "Datatype that is subtype of trelSup having value space supvt",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "trelSub",
          "package": "swish",
          "partial": "Sub",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:trelSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype that is a supertype of \u003ccode\u003etrelSub\u003c/code\u003e,\n   having value space \u003ccode\u003esupvt\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "trelSup",
          "package": "swish",
          "signature": "DatatypeVal ex supvt lb vn",
          "source": "src/Swish-Datatype.html#DatatypeSub",
          "type": "function"
        },
        "index": {
          "description": "Datatype that is supertype of trelSub having value space supvt",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "trelSup",
          "package": "swish",
          "partial": "Sup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:trelSup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction that maps supertype value to\n   corresponding subtype value, if there\n   is such a value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "trelToSub",
          "package": "swish",
          "signature": "supvt -\u003e Maybe subvt",
          "source": "src/Swish-Datatype.html#DatatypeSub",
          "type": "function"
        },
        "index": {
          "description": "Function that maps supertype value to corresponding subtype value if there is such value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "trelToSub",
          "normalized": "a-\u003eMaybe b",
          "package": "swish",
          "partial": "To Sub",
          "signature": "supvt-\u003eMaybe subvt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:trelToSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction that maps subtype value to\n   corresponding supertype value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "trelToSup",
          "package": "swish",
          "signature": "subvt -\u003e supvt",
          "source": "src/Swish-Datatype.html#DatatypeSub",
          "type": "function"
        },
        "index": {
          "description": "Function that maps subtype value to corresponding supertype value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "trelToSup",
          "normalized": "a-\u003eb",
          "package": "swish",
          "partial": "To Sup",
          "signature": "subvt-\u003esupvt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:trelToSup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexical to value mapping, where \u003ccode\u003evt\u003c/code\u003e is\n  a datatype used within a Haskell program\n  to represent and manipulate values in\n  the datatype's value space\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalMap",
          "package": "swish",
          "signature": "DatatypeMap vt",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "description": "Lexical to value mapping where vt is datatype used within Haskell program to represent and manipulate values in the datatype value space",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalMap",
          "package": "swish",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the canonical form of a datatype value, or \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalMkCanonicalForm",
          "package": "swish",
          "signature": "DatatypeVal ex vt lb vn -\u003e Text -\u003e Maybe Text",
          "source": "src/Swish-Datatype.html#tvalMkCanonicalForm",
          "type": "function"
        },
        "index": {
          "description": "Get the canonical form of datatype value or Nothing",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalMkCanonicalForm",
          "normalized": "DatatypeVal a b c d-\u003eText-\u003eMaybe Text",
          "package": "swish",
          "partial": "Mk Canonical Form",
          "signature": "DatatypeVal ex vt lb vn-\u003eText-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalMkCanonicalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs a list of open variable\n  binding modifiers based on tvalMod,\n  but hiding the actual value type.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalMkMods",
          "package": "swish",
          "signature": "[OpenVarBindingModify lb vn]",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "description": "Constructs list of open variable binding modifiers based on tvalMod but hiding the actual value type",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalMkMods",
          "normalized": "[OpenVarBindingModify a b]",
          "package": "swish",
          "partial": "Mk Mods",
          "signature": "[OpenVarBindingModify lb vn]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalMkMods"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function that accepts an expression\n  and devives some datatype-dependent\n  rules from it.  This is provided as a\n  hook for creating datatyped class\n  restriction rules.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalMkRules",
          "package": "swish",
          "signature": "ex -\u003e [Rule ex]",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "description": "function that accepts an expression and devives some datatype-dependent rules from it This is provided as hook for creating datatyped class restriction rules",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalMkRules",
          "normalized": "a-\u003e[Rule a]",
          "package": "swish",
          "partial": "Mk Rules",
          "signature": "ex-\u003e[Rule ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalMkRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of named values that are used to\n  construct variable binding modifiers, which\n  in turn may be used by a rule definition.\n\u003c/p\u003e\u003cp\u003eTODO: In due course, this value may be\n  calculated automatically from the supplied\n  value for \u003ccode\u003etvalRel\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalMod",
          "package": "swish",
          "signature": "[DatatypeMod vt lb vn]",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "description": "list of named values that are used to construct variable binding modifiers which in turn may be used by rule definition TODO In due course this value may be calculated automatically from the supplied value for tvalRel",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalMod",
          "normalized": "[DatatypeMod a b c]",
          "package": "swish",
          "partial": "Mod",
          "signature": "[DatatypeMod vt lb vn]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentifies the datatype, and also\n  its value space class.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "description": "Identifies the datatype and also its value space class",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of named relations on datatype\n  values.  Each relation accepts a list\n  of \u003ccode\u003eMaybe vt\u003c/code\u003e, and computes any\n  unspecified values that are in the\n  relation with values supplied.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalRel",
          "package": "swish",
          "signature": "[DatatypeRel vt]",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "description": "set of named relations on datatype values Each relation accepts list of Maybe vt and computes any unspecified values that are in the relation with values supplied",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalRel",
          "normalized": "[DatatypeRel a]",
          "package": "swish",
          "partial": "Rel",
          "signature": "[DatatypeRel vt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalRel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of named expressions and rules\n  that are valid in in any theory that\n  recognizes the current datatype.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "tvalRules",
          "package": "swish",
          "signature": "Ruleset ex",
          "source": "src/Swish-Datatype.html#DatatypeVal",
          "type": "function"
        },
        "index": {
          "description": "set of named expressions and rules that are valid in in any theory that recognizes the current datatype",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "tvalRules",
          "package": "swish",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:tvalRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the canonical form of a datatype value.\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "typeMkCanonicalForm",
          "package": "swish",
          "signature": "Datatype ex lb vn -\u003e Text -\u003e Maybe Text",
          "source": "src/Swish-Datatype.html#typeMkCanonicalForm",
          "type": "function"
        },
        "index": {
          "description": "Get the canonical form of datatype value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "typeMkCanonicalForm",
          "normalized": "Datatype a b c-\u003eText-\u003eMaybe Text",
          "package": "swish",
          "partial": "Mk Canonical Form",
          "signature": "Datatype ex lb vn-\u003eText-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:typeMkCanonicalForm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake variable binding modifiers based on values supplied\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "typeMkModifiers",
          "package": "swish",
          "signature": "Datatype ex lb vn -\u003e [OpenVarBindingModify lb vn]",
          "source": "src/Swish-Datatype.html#typeMkModifiers",
          "type": "function"
        },
        "index": {
          "description": "Make variable binding modifiers based on values supplied",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "typeMkModifiers",
          "normalized": "Datatype a b c-\u003e[OpenVarBindingModify b c]",
          "package": "swish",
          "partial": "Mk Modifiers",
          "signature": "Datatype ex lb vn-\u003e[OpenVarBindingModify lb vn]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:typeMkModifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake rules for Datatype value based on supplied expression\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "typeMkRules",
          "package": "swish",
          "signature": "Datatype ex lb vn -\u003e ex -\u003e [Rule ex]",
          "source": "src/Swish-Datatype.html#typeMkRules",
          "type": "function"
        },
        "index": {
          "description": "Make rules for Datatype value based on supplied expression",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "typeMkRules",
          "normalized": "Datatype a b c-\u003ea-\u003e[Rule a]",
          "package": "swish",
          "partial": "Mk Rules",
          "signature": "Datatype ex lb vn-\u003eex-\u003e[Rule ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:typeMkRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet type name from Datatype value\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "typeName",
          "package": "swish",
          "signature": "Datatype ex lb vn -\u003e ScopedName",
          "source": "src/Swish-Datatype.html#typeName",
          "type": "function"
        },
        "index": {
          "description": "Get type name from Datatype value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "typeName",
          "normalized": "Datatype a b c-\u003eScopedName",
          "package": "swish",
          "partial": "Name",
          "signature": "Datatype ex lb vn-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:typeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet static rules from Datatype value\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "typeRules",
          "package": "swish",
          "signature": "Datatype ex lb vn -\u003e Ruleset ex",
          "source": "src/Swish-Datatype.html#typeRules",
          "type": "function"
        },
        "index": {
          "description": "Get static rules from Datatype value",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "typeRules",
          "normalized": "Datatype a b c-\u003eRuleset a",
          "package": "swish",
          "partial": "Rules",
          "signature": "Datatype ex lb vn-\u003eRuleset ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:typeRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealtArgs\u003c/a\u003e\u003c/code\u003e support for unary functions: function applicator\n\u003c/p\u003e",
          "module": "Swish.Datatype",
          "name": "unaryFnApp",
          "package": "swish",
          "signature": "UnaryFnApply a",
          "source": "src/Swish-Datatype.html#unaryFnApp",
          "type": "function"
        },
        "index": {
          "description": "altArgs support for unary functions function applicator",
          "hierarchy": "Swish Datatype",
          "module": "Swish.Datatype",
          "name": "unaryFnApp",
          "package": "swish",
          "partial": "Fn App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Datatype.html#v:unaryFnApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a Labelled Directed Graph and Label classes,\n  and the Arc datatype.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.GraphClass",
          "name": "GraphClass",
          "package": "swish",
          "source": "src/Swish-GraphClass.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines Labelled Directed Graph and Label classes and the Arc datatype",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "GraphClass",
          "package": "swish",
          "partial": "Graph Class",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArc type.\n\u003c/p\u003e\u003cp\u003ePrior to \u003ccode\u003e0.7.0.0\u003c/code\u003e you could also use \u003ccode\u003easubj\u003c/code\u003e, \u003ccode\u003eapred\u003c/code\u003e and \u003ccode\u003eaobj\u003c/code\u003e\n to access the elements of the arc.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "Arc",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#Arc",
          "type": "data"
        },
        "index": {
          "description": "Arc type Prior to you could also use asubj apred and aobj to access the elements of the arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "Arc",
          "package": "swish",
          "partial": "Arc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#t:Arc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set - or graph - of arcs.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "ArcSet",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#ArcSet",
          "type": "type"
        },
        "index": {
          "description": "set or graph of arcs",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "ArcSet",
          "package": "swish",
          "partial": "Arc Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#t:ArcSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabelled Directed Graph class.\n\u003c/p\u003e\u003cp\u003eMinimum required implementation: \n\u003ccode\u003e\u003ca\u003eemptyGraph\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esetArcs\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003egetArcs\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "LDGraph",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#LDGraph",
          "type": "class"
        },
        "index": {
          "description": "Labelled Directed Graph class Minimum required implementation emptyGraph setArcs and getArcs",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "LDGraph",
          "package": "swish",
          "partial": "LDGraph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#t:LDGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabel class.\n\u003c/p\u003e\u003cp\u003eA label may have a fixed binding, which means that the label identifies (is) a\n  particular graph node, and different such labels are always distinct nodes.\n  Alternatively, a label may be unbound (variable), which means that it is a\n  placeholder for an unknown node label.  Unbound node labels are used as\n  graph-local identifiers for indicating when the same node appears in\n  several arcs.\n\u003c/p\u003e\u003cp\u003eFor the purposes of graph-isomorphism testing, fixed labels are matched when they\n  are the same.  Variable labels may be matched with any other variable label.\n  Our definition of isomorphism (for RDF graphs) does not match variable labels\n  with fixed labels.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "Label",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#Label",
          "type": "class"
        },
        "index": {
          "description": "Label class label may have fixed binding which means that the label identifies is particular graph node and different such labels are always distinct nodes Alternatively label may be unbound variable which means that it is placeholder for an unknown node label Unbound node labels are used as graph-local identifiers for indicating when the same node appears in several arcs For the purposes of graph-isomorphism testing fixed labels are matched when they are the same Variable labels may be matched with any other variable label Our definition of isomorphism for RDF graphs does not match variable labels with fixed labels",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "Label",
          "package": "swish",
          "partial": "Label",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#t:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentify arcs.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "Selector",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#Selector",
          "type": "type"
        },
        "index": {
          "description": "Identify arcs",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "Selector",
          "package": "swish",
          "partial": "Selector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#t:Selector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Swish.GraphClass\",\"Swish.RDF.Graph\"]",
          "name": "Arc",
          "package": "swish",
          "signature": "Arc",
          "source": "src/Swish-GraphClass.html#Arc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:Arc\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:Arc\"]"
        },
        "index": {
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "Arc",
          "package": "swish",
          "partial": "Arc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:Arc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd the two graphs\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "addGraphs",
          "package": "swish",
          "signature": "lg lb -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#addGraphs",
          "type": "method"
        },
        "index": {
          "description": "Add the two graphs",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "addGraphs",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "swish",
          "partial": "Graphs",
          "signature": "lg lb-\u003elg lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:addGraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an arc.\n\u003c/p\u003e",
          "module": "[\"Swish.GraphClass\",\"Swish.RDF.Graph\"]",
          "name": "arc",
          "package": "swish",
          "signature": "lb-\u003e lb-\u003e lb-\u003e Arc lb",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arc\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:arc\"]"
        },
        "index": {
          "description": "Create an arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "arc",
          "normalized": "a-\u003ea-\u003ea-\u003eArc a",
          "package": "swish",
          "signature": "lb-\u003elb-\u003elb-\u003eArc lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an Arc from a tuple.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "arcFromTriple",
          "package": "swish",
          "signature": "(lb, lb, lb) -\u003e Arc lb",
          "source": "src/Swish-GraphClass.html#arcFromTriple",
          "type": "function"
        },
        "index": {
          "description": "Create an Arc from tuple",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "arcFromTriple",
          "normalized": "(a,a,a)-\u003eArc a",
          "package": "swish",
          "partial": "From Triple",
          "signature": "(lb,lb,lb)-\u003eArc lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcFromTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all the labels in an arc.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "arcLabels",
          "package": "swish",
          "signature": "Arc lb -\u003e [lb]",
          "source": "src/Swish-GraphClass.html#arcLabels",
          "type": "function"
        },
        "index": {
          "description": "Return all the labels in an arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "arcLabels",
          "normalized": "Arc a-\u003e[a]",
          "package": "swish",
          "partial": "Labels",
          "signature": "Arc lb-\u003e[lb]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe object of the arc.\n\u003c/p\u003e",
          "module": "[\"Swish.GraphClass\",\"Swish.RDF.Graph\"]",
          "name": "arcObj",
          "package": "swish",
          "signature": "lb",
          "source": "src/Swish-GraphClass.html#Arc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcObj\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:arcObj\"]"
        },
        "index": {
          "description": "The object of the arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "arcObj",
          "package": "swish",
          "partial": "Obj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe predicate (property) of the arc.\n\u003c/p\u003e",
          "module": "[\"Swish.GraphClass\",\"Swish.RDF.Graph\"]",
          "name": "arcPred",
          "package": "swish",
          "signature": "lb",
          "source": "src/Swish-GraphClass.html#Arc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcPred\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:arcPred\"]"
        },
        "index": {
          "description": "The predicate property of the arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "arcPred",
          "package": "swish",
          "partial": "Pred",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcPred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe subject of the arc.\n\u003c/p\u003e",
          "module": "[\"Swish.GraphClass\",\"Swish.RDF.Graph\"]",
          "name": "arcSubj",
          "package": "swish",
          "signature": "lb",
          "source": "src/Swish-GraphClass.html#Arc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcSubj\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:arcSubj\"]"
        },
        "index": {
          "description": "The subject of the arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "arcSubj",
          "package": "swish",
          "partial": "Subj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcSubj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an Arc into a tuple.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "arcToTriple",
          "package": "swish",
          "signature": "Arc lb -\u003e (lb, lb, lb)",
          "source": "src/Swish-GraphClass.html#arcToTriple",
          "type": "function"
        },
        "index": {
          "description": "Convert an Arc into tuple",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "arcToTriple",
          "normalized": "Arc a-\u003e(a,a,a)",
          "package": "swish",
          "partial": "To Triple",
          "signature": "Arc lb-\u003e(lb,lb,lb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:arcToTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove those arcs in the first graph from the second\n graph\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "delete",
          "package": "swish",
          "signature": "delete",
          "source": "src/Swish-GraphClass.html#delete",
          "type": "method"
        },
        "index": {
          "description": "Remove those arcs in the first graph from the second graph",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "delete",
          "package": "swish",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the empty graph.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "emptyGraph",
          "package": "swish",
          "signature": "lg lb",
          "source": "src/Swish-GraphClass.html#emptyGraph",
          "type": "method"
        },
        "index": {
          "description": "Create the empty graph",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "emptyGraph",
          "package": "swish",
          "partial": "Graph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:emptyGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract those arcs that match the given \u003ccode\u003e\u003ca\u003eSelector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "extract",
          "package": "swish",
          "signature": "Selector lb -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#extract",
          "type": "method"
        },
        "index": {
          "description": "Extract those arcs that match the given Selector",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "extract",
          "normalized": "Selector a-\u003eb a-\u003eb a",
          "package": "swish",
          "signature": "Selector lb-\u003elg lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:extract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract all the arcs from a graph\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "getArcs",
          "package": "swish",
          "signature": "lg lb -\u003e ArcSet lb",
          "source": "src/Swish-GraphClass.html#getArcs",
          "type": "method"
        },
        "index": {
          "description": "Extract all the arcs from graph",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "getArcs",
          "normalized": "a b-\u003eArcSet b",
          "package": "swish",
          "partial": "Arcs",
          "signature": "lg lb-\u003eArcSet lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:getArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract components from a set.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "getComponents",
          "package": "swish",
          "signature": "(a -\u003e [b]) -\u003e Set a -\u003e Set b",
          "source": "src/Swish-GraphClass.html#getComponents",
          "type": "function"
        },
        "index": {
          "description": "Extract components from set",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "getComponents",
          "normalized": "(a-\u003e[b])-\u003eSet a-\u003eSet b",
          "package": "swish",
          "partial": "Components",
          "signature": "(a-\u003e[b])-\u003eSet a-\u003eSet b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:getComponents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the local id from a variable node.                 \n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "getLocal",
          "package": "swish",
          "signature": "lb -\u003e String",
          "source": "src/Swish-GraphClass.html#getLocal",
          "type": "method"
        },
        "index": {
          "description": "Extract the local id from variable node",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "getLocal",
          "normalized": "a-\u003eString",
          "package": "swish",
          "partial": "Local",
          "signature": "lb-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:getLocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the arc contain the label in any position (subject, predicate, or object)?\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "hasLabel",
          "package": "swish",
          "signature": "lb -\u003e Arc lb -\u003e Bool",
          "source": "src/Swish-GraphClass.html#hasLabel",
          "type": "function"
        },
        "index": {
          "description": "Does the arc contain the label in any position subject predicate or object",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "hasLabel",
          "normalized": "a-\u003eArc a-\u003eBool",
          "package": "swish",
          "partial": "Label",
          "signature": "lb-\u003eArc lb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:hasLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the hash of the label using the supplied seed.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "labelHash",
          "package": "swish",
          "signature": "Int -\u003e lb -\u003e Int",
          "source": "src/Swish-GraphClass.html#labelHash",
          "type": "method"
        },
        "index": {
          "description": "Calculate the hash of the label using the supplied seed",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "labelHash",
          "normalized": "Int-\u003ea-\u003eInt",
          "package": "swish",
          "partial": "Hash",
          "signature": "Int-\u003elb-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:labelHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this node have a variable binding?\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "labelIsVar",
          "package": "swish",
          "signature": "lb -\u003e Bool",
          "source": "src/Swish-GraphClass.html#labelIsVar",
          "type": "method"
        },
        "index": {
          "description": "Does this node have variable binding",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "labelIsVar",
          "normalized": "a-\u003eBool",
          "package": "swish",
          "partial": "Is Var",
          "signature": "lb-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:labelIsVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerate the distinct labels contained in a graph;\n that is, any label that appears in the subject,\n predicate or object position of an \u003ccode\u003e\u003ca\u003eArc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "labels",
          "package": "swish",
          "signature": "lg lb -\u003e Set lb",
          "source": "src/Swish-GraphClass.html#labels",
          "type": "method"
        },
        "index": {
          "description": "Enumerate the distinct labels contained in graph that is any label that appears in the subject predicate or object position of an Arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "labels",
          "normalized": "a b-\u003eSet b",
          "package": "swish",
          "signature": "lg lb-\u003eSet lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:labels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a label value from a local id.  \n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "makeLabel",
          "package": "swish",
          "signature": "String -\u003e lb",
          "source": "src/Swish-GraphClass.html#makeLabel",
          "type": "method"
        },
        "index": {
          "description": "Make label value from local id",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "makeLabel",
          "normalized": "String-\u003ea",
          "package": "swish",
          "partial": "Label",
          "signature": "String-\u003elb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:makeLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerate the distinct nodes contained in a graph;\n that is, any label that appears in the subject\n or object position of an \u003ccode\u003e\u003ca\u003eArc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "nodes",
          "package": "swish",
          "signature": "lg lb -\u003e Set lb",
          "source": "src/Swish-GraphClass.html#nodes",
          "type": "method"
        },
        "index": {
          "description": "Enumerate the distinct nodes contained in graph that is any label that appears in the subject or object position of an Arc",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "nodes",
          "normalized": "a b-\u003eSet b",
          "package": "swish",
          "signature": "lg lb-\u003eSet lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:nodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the existing arcs in the graph.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "setArcs",
          "package": "swish",
          "signature": "lg lb -\u003e ArcSet lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#setArcs",
          "type": "method"
        },
        "index": {
          "description": "Replace the existing arcs in the graph",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "setArcs",
          "normalized": "a b-\u003eArcSet b-\u003ea b",
          "package": "swish",
          "partial": "Arcs",
          "signature": "lg lb-\u003eArcSet lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:setArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the arcs in a graph using a supplied function.\n\u003c/p\u003e",
          "module": "Swish.GraphClass",
          "name": "update",
          "package": "swish",
          "signature": "(ArcSet lb -\u003e ArcSet lb) -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#update",
          "type": "method"
        },
        "index": {
          "description": "Update the arcs in graph using supplied function",
          "hierarchy": "Swish GraphClass",
          "module": "Swish.GraphClass",
          "name": "update",
          "normalized": "(ArcSet a-\u003eArcSet a)-\u003eb a-\u003eb a",
          "package": "swish",
          "signature": "(ArcSet lb-\u003eArcSet lb)-\u003elg lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphClass.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains graph-matching logic.\n\u003c/p\u003e\u003cp\u003eThe algorithm used is derived from a paper on RDF graph matching\n  by Jeremy Carroll \u003ca\u003ehttp://www.hpl.hp.com/techreports/2001/HPL-2001-293.html\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.GraphMatch",
          "name": "GraphMatch",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains graph-matching logic The algorithm used is derived from paper on RDF graph matching by Jeremy Carroll http www.hpl.hp.com techreports HPL-2001-293.html",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "GraphMatch",
          "package": "swish",
          "partial": "Graph Match",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for equivalence class description\n  (An equivalence class is a collection of labels with\n  the same \u003ccode\u003e\u003ca\u003eLabelIndex\u003c/a\u003e\u003c/code\u003e value.)\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "EquivalenceClass",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html#EquivalenceClass",
          "type": "type"
        },
        "index": {
          "description": "Type for equivalence class description An equivalence class is collection of labels with the same LabelIndex value",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "EquivalenceClass",
          "package": "swish",
          "partial": "Equivalence Class",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#t:EquivalenceClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Mapping between a label and a value (e.g. an index\n value).\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "GenLabelEntry",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html#GenLabelEntry",
          "type": "data"
        },
        "index": {
          "description": "Mapping between label and value e.g an index value",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "GenLabelEntry",
          "package": "swish",
          "partial": "Gen Label Entry",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#t:GenLabelEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for label-\u003eindex lookup table\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "GenLabelMap",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html#GenLabelMap",
          "type": "data"
        },
        "index": {
          "description": "Type for label index lookup table",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "GenLabelMap",
          "package": "swish",
          "partial": "Gen Label Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#t:GenLabelMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA label associated with a \u003ccode\u003e\u003ca\u003eLabelIndex\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "LabelEntry",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html#LabelEntry",
          "type": "type"
        },
        "index": {
          "description": "label associated with LabelIndex",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "LabelEntry",
          "package": "swish",
          "partial": "Label Entry",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#t:LabelEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabelIndex is a unique value assigned to each label, such that\n  labels with different values are definitely different values\n  in the graph;  e.g. do not map to each other in the graph\n  bijection.  The first member is a generation counter that\n  ensures new values are distinct from earlier passes.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "LabelIndex",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html#LabelIndex",
          "type": "type"
        },
        "index": {
          "description": "LabelIndex is unique value assigned to each label such that labels with different values are definitely different values in the graph e.g do not map to each other in the graph bijection The first member is generation counter that ensures new values are distinct from earlier passes",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "LabelIndex",
          "package": "swish",
          "partial": "Label Index",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#t:LabelIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA label lookup table specialized to \u003ccode\u003e\u003ca\u003eLabelIndex\u003c/a\u003e\u003c/code\u003e indices.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "LabelMap",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html#LabelMap",
          "type": "type"
        },
        "index": {
          "description": "label lookup table specialized to LabelIndex indices",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "LabelMap",
          "package": "swish",
          "partial": "Label Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#t:LabelMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis instance of class label adds a graph identifier to\n  each variable label, so that variable labels from\n  different graphs are always seen as distinct values.\n\u003c/p\u003e\u003cp\u003eThe essential logic added by this class instance is embodied\n  in the eq and hash functions.  Note that variable label hashes\n  depend only on the graph in which they appear, and non-variable\n  label hashes depend only on the variable.  Label hash values are\n  used when initializing a label equivalence-class map (and, for\n  non-variable labels, also for resolving hash collisions).\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "ScopedLabel",
          "package": "swish",
          "source": "src/Swish-GraphMatch.html#ScopedLabel",
          "type": "data"
        },
        "index": {
          "description": "This instance of class label adds graph identifier to each variable label so that variable labels from different graphs are always seen as distinct values The essential logic added by this class instance is embodied in the eq and hash functions Note that variable label hashes depend only on the graph in which they appear and non-variable label hashes depend only on the variable Label hash values are used when initializing label equivalence-class map and for non-variable labels also for resolving hash collisions",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "ScopedLabel",
          "package": "swish",
          "partial": "Scoped Label",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#t:ScopedLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphMatch",
          "name": "LabelEntry",
          "package": "swish",
          "signature": "LabelEntry lb lv",
          "source": "src/Swish-GraphMatch.html#GenLabelEntry",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "LabelEntry",
          "package": "swish",
          "partial": "Label Entry",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:LabelEntry"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphMatch",
          "name": "LabelMap",
          "package": "swish",
          "signature": "LabelMap Word32 (Map lb lv)",
          "source": "src/Swish-GraphMatch.html#GenLabelMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "LabelMap",
          "package": "swish",
          "partial": "Label Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:LabelMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphMatch",
          "name": "ScopedLabel",
          "package": "swish",
          "signature": "ScopedLabel Int lb",
          "source": "src/Swish-GraphMatch.html#ScopedLabel",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "ScopedLabel",
          "package": "swish",
          "partial": "Scoped Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:ScopedLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan label list, assigning initial label map values,\n  adding new values to the label map supplied.\n\u003c/p\u003e\u003cp\u003eLabel map values are assigned on the basis of the\n  label alone, without regard for it's connectivity in\n  the graph.  (cf. \u003ccode\u003e\u003ca\u003ereclassify\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eAll variable node labels are assigned the same initial\n  value, as they may be matched with each other.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "assignLabelMap",
          "package": "swish",
          "signature": "Set lb -\u003e LabelMap lb -\u003e LabelMap lb",
          "source": "src/Swish-GraphMatch.html#assignLabelMap",
          "type": "function"
        },
        "index": {
          "description": "Scan label list assigning initial label map values adding new values to the label map supplied Label map values are assigned on the basis of the label alone without regard for it connectivity in the graph cf reclassify All variable node labels are assigned the same initial value as they may be matched with each other",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "assignLabelMap",
          "normalized": "Set a-\u003eLabelMap a-\u003eLabelMap a",
          "package": "swish",
          "partial": "Label Map",
          "signature": "Set lb-\u003eLabelMap lb-\u003eLabelMap lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:assignLabelMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty label map table.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "emptyMap",
          "package": "swish",
          "signature": "LabelMap lb",
          "source": "src/Swish-GraphMatch.html#emptyMap",
          "type": "function"
        },
        "index": {
          "description": "The empty label map table",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "emptyMap",
          "package": "swish",
          "partial": "Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:emptyMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the equivalence classes of the supplied nodes \n using the label map.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "equivalenceClasses",
          "package": "swish",
          "signature": "LabelMap lb-\u003e Set lb-\u003e [EquivalenceClass lb]",
          "type": "function"
        },
        "index": {
          "description": "Return the equivalence classes of the supplied nodes using the label map",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "equivalenceClasses",
          "normalized": "LabelMap a-\u003eSet a-\u003e[EquivalenceClass a]",
          "package": "swish",
          "partial": "Classes",
          "signature": "LabelMap lb-\u003eSet lb-\u003e[EquivalenceClass lb]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:equivalenceClasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the set of distinct labels used in the graph.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "graphLabels",
          "package": "swish",
          "signature": "ArcSet lb -\u003e Set lb",
          "source": "src/Swish-GraphMatch.html#graphLabels",
          "type": "function"
        },
        "index": {
          "description": "Return the set of distinct labels used in the graph",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "graphLabels",
          "normalized": "ArcSet a-\u003eSet a",
          "package": "swish",
          "partial": "Labels",
          "signature": "ArcSet lb-\u003eSet lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:graphLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph matching function accepting two lists of arcs and\n  returning a node map if successful\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "graphMatch",
          "package": "swish",
          "signature": "(lb -\u003e lb -\u003e Bool)-\u003e ArcSet lb-\u003e ArcSet lb-\u003e (Bool, LabelMap (ScopedLabel lb))",
          "type": "function"
        },
        "index": {
          "description": "Graph matching function accepting two lists of arcs and returning node map if successful",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "graphMatch",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eArcSet a-\u003eArcSet a-\u003e(Bool,LabelMap(ScopedLabel a))",
          "package": "swish",
          "partial": "Match",
          "signature": "(lb-\u003elb-\u003eBool)-\u003eArcSet lb-\u003eArcSet lb-\u003e(Bool,LabelMap(ScopedLabel lb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:graphMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecursive graph matching function\n\u003c/p\u003e\u003cp\u003eThis function assumes that no variable label appears in both graphs.\n  (Function \u003ccode\u003e\u003ca\u003egraphMatch\u003c/a\u003e\u003c/code\u003e, which calls this, ensures that all variable\n  labels are distinct.)\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "graphMatch1",
          "package": "swish",
          "signature": "Bool-\u003e (lb -\u003e lb -\u003e Bool)-\u003e ArcSet lb-\u003e ArcSet lb-\u003e LabelMap lb-\u003e [(EquivalenceClass lb, EquivalenceClass lb)]-\u003e (Bool, LabelMap lb)",
          "type": "function"
        },
        "index": {
          "description": "Recursive graph matching function This function assumes that no variable label appears in both graphs Function graphMatch which calls this ensures that all variable labels are distinct",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "graphMatch1",
          "normalized": "Bool-\u003e(a-\u003ea-\u003eBool)-\u003eArcSet a-\u003eArcSet a-\u003eLabelMap a-\u003e[(EquivalenceClass a,EquivalenceClass a)]-\u003e(Bool,LabelMap a)",
          "package": "swish",
          "partial": "Match",
          "signature": "Bool-\u003e(lb-\u003elb-\u003eBool)-\u003eArcSet lb-\u003eArcSet lb-\u003eLabelMap lb-\u003e[(EquivalenceClass lb,EquivalenceClass lb)]-\u003e(Bool,LabelMap lb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:graphMatch1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAuxiliary graph matching function\n\u003c/p\u003e\u003cp\u003eThis function is called when deterministic decomposition of node\n  mapping equivalence classes has run its course.\n\u003c/p\u003e\u003cp\u003eIt picks a pair of equivalence classes in ecpairs, and arbitrarily matches\n  pairs of nodes in those equivalence classes, recursively calling the\n  graph matching function until a suitable node mapping is discovered\n  (success), or until all such pairs have been tried (failure).\n\u003c/p\u003e\u003cp\u003eThis function represents a point to which arbitrary choices are backtracked.\n  The list comprehension \u003ccode\u003eglp\u003c/code\u003e represents the alternative choices at the\n  point of backtracking\n\u003c/p\u003e\u003cp\u003eThe selected pair of nodes are placed in a new equivalence class based on their\n  original equivalence class value, but with a new NodeVal generation number.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "graphMatch2",
          "package": "swish",
          "signature": "(lb -\u003e lb -\u003e Bool) -\u003e ArcSet lb -\u003e ArcSet lb -\u003e LabelMap lb -\u003e [(EquivalenceClass lb, EquivalenceClass lb)] -\u003e (Bool, LabelMap lb)",
          "source": "src/Swish-GraphMatch.html#graphMatch2",
          "type": "function"
        },
        "index": {
          "description": "Auxiliary graph matching function This function is called when deterministic decomposition of node mapping equivalence classes has run its course It picks pair of equivalence classes in ecpairs and arbitrarily matches pairs of nodes in those equivalence classes recursively calling the graph matching function until suitable node mapping is discovered success or until all such pairs have been tried failure This function represents point to which arbitrary choices are backtracked The list comprehension glp represents the alternative choices at the point of backtracking The selected pair of nodes are placed in new equivalence class based on their original equivalence class value but with new NodeVal generation number",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "graphMatch2",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eArcSet a-\u003eArcSet a-\u003eLabelMap a-\u003e[(EquivalenceClass a,EquivalenceClass a)]-\u003e(Bool,LabelMap a)",
          "package": "swish",
          "partial": "Match",
          "signature": "(lb-\u003elb-\u003eBool)-\u003eArcSet lb-\u003eArcSet lb-\u003eLabelMap lb-\u003e[(EquivalenceClass lb,EquivalenceClass lb)]-\u003e(Bool,LabelMap lb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:graphMatch2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the hash of the label using the supplied seed.\n\u003c/p\u003e",
          "module": "[\"Swish.GraphMatch\",\"Swish.GraphMem\"]",
          "name": "labelHash",
          "package": "swish",
          "signature": "Int -\u003e lb -\u003e Int",
          "source": "src/Swish-GraphClass.html#labelHash",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:labelHash\",\"http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:labelHash\"]"
        },
        "index": {
          "description": "Calculate the hash of the label using the supplied seed",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "labelHash",
          "normalized": "Int-\u003ea-\u003eInt",
          "package": "swish",
          "partial": "Hash",
          "signature": "Int-\u003elb-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:labelHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this node have a variable binding?\n\u003c/p\u003e",
          "module": "[\"Swish.GraphMatch\",\"Swish.GraphMem\"]",
          "name": "labelIsVar",
          "package": "swish",
          "signature": "lb -\u003e Bool",
          "source": "src/Swish-GraphClass.html#labelIsVar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:labelIsVar\",\"http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:labelIsVar\"]"
        },
        "index": {
          "description": "Does this node have variable binding",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "labelIsVar",
          "normalized": "a-\u003eBool",
          "package": "swish",
          "partial": "Is Var",
          "signature": "lb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:labelIsVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an arc containining a scoped label with the given identifier.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "makeScopedArc",
          "package": "swish",
          "signature": "Int -\u003e Arc lb -\u003e Arc (ScopedLabel lb)",
          "source": "src/Swish-GraphMatch.html#makeScopedArc",
          "type": "function"
        },
        "index": {
          "description": "Create an arc containining scoped label with the given identifier",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "makeScopedArc",
          "normalized": "Int-\u003eArc a-\u003eArc(ScopedLabel a)",
          "package": "swish",
          "partial": "Scoped Arc",
          "signature": "Int-\u003eArc lb-\u003eArc(ScopedLabel lb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:makeScopedArc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a scoped label given an identifier and label.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "makeScopedLabel",
          "package": "swish",
          "signature": "Int -\u003e lb -\u003e ScopedLabel lb",
          "source": "src/Swish-GraphMatch.html#makeScopedLabel",
          "type": "function"
        },
        "index": {
          "description": "Create scoped label given an identifier and label",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "makeScopedLabel",
          "normalized": "Int-\u003ea-\u003eScopedLabel a",
          "package": "swish",
          "partial": "Scoped Label",
          "signature": "Int-\u003elb-\u003eScopedLabel lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:makeScopedLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a label to its corresponding label index value in the\n   supplied LabelMap.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "mapLabelIndex",
          "package": "swish",
          "signature": "LabelMap lb -\u003e lb -\u003e LabelIndex",
          "source": "src/Swish-GraphMatch.html#mapLabelIndex",
          "type": "function"
        },
        "index": {
          "description": "Map label to its corresponding label index value in the supplied LabelMap",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "mapLabelIndex",
          "normalized": "LabelMap a-\u003ea-\u003eLabelIndex",
          "package": "swish",
          "partial": "Label Index",
          "signature": "LabelMap lb-\u003elb-\u003eLabelIndex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:mapLabelIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the generation of the label map.\n\u003c/p\u003e\u003cp\u003eReturns a new label map identical to the supplied value\n  but with an incremented generation number.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "newGenerationMap",
          "package": "swish",
          "signature": "LabelMap lb -\u003e LabelMap lb",
          "source": "src/Swish-GraphMatch.html#newGenerationMap",
          "type": "function"
        },
        "index": {
          "description": "Increment the generation of the label map Returns new label map identical to the supplied value but with an incremented generation number",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "newGenerationMap",
          "normalized": "LabelMap a-\u003eLabelMap a",
          "package": "swish",
          "partial": "Generation Map",
          "signature": "LabelMap lb-\u003eLabelMap lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:newGenerationMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace selected values in a label map with new values from the supplied\n  list of labels and new label index values.  The generation number is\n  supplied from the current label map.  The generation number in the\n  resulting label map is incremented.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "newLabelMap",
          "package": "swish",
          "signature": "LabelMap lb -\u003e [(lb, Word32)] -\u003e LabelMap lb",
          "source": "src/Swish-GraphMatch.html#newLabelMap",
          "type": "function"
        },
        "index": {
          "description": "Replace selected values in label map with new values from the supplied list of labels and new label index values The generation number is supplied from the current label map The generation number in the resulting label map is incremented",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "newLabelMap",
          "normalized": "LabelMap a-\u003e[(a,Word)]-\u003eLabelMap a",
          "package": "swish",
          "partial": "Label Map",
          "signature": "LabelMap lb-\u003e[(lb,Word)]-\u003eLabelMap lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:newLabelMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe null, or empty, index value.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "nullLabelVal",
          "package": "swish",
          "signature": "LabelIndex",
          "source": "src/Swish-GraphMatch.html#nullLabelVal",
          "type": "function"
        },
        "index": {
          "description": "The null or empty index value",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "nullLabelVal",
          "package": "swish",
          "partial": "Label Val",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:nullLabelVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReclassify labels\n\u003c/p\u003e\u003cp\u003eExamines the supplied label equivalence classes (based on the supplied\n  label map), and evaluates new equivalence subclasses based on node\n  values and adjacency (for variable nodes) and rehashing\n  (for non-variable nodes).\n\u003c/p\u003e\u003cp\u003eNote, assumes that all all equivalence classes supplied are\n  non-singletons;  i.e. contain more than one label.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "reclassify",
          "package": "swish",
          "signature": "ArcSet lb-\u003e ArcSet lb-\u003e LabelMap lb-\u003e [(EquivalenceClass lb, EquivalenceClass lb)]-\u003e (LabelMap lb, [(EquivalenceClass lb, EquivalenceClass lb)], Bool, Bool)",
          "type": "function"
        },
        "index": {
          "description": "Reclassify labels Examines the supplied label equivalence classes based on the supplied label map and evaluates new equivalence subclasses based on node values and adjacency for variable nodes and rehashing for non-variable nodes Note assumes that all all equivalence classes supplied are non-singletons i.e contain more than one label",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "reclassify",
          "normalized": "ArcSet a-\u003eArcSet a-\u003eLabelMap a-\u003e[(EquivalenceClass a,EquivalenceClass a)]-\u003e(LabelMap a,[(EquivalenceClass a,EquivalenceClass a)],Bool,Bool)",
          "package": "swish",
          "signature": "ArcSet lb-\u003eArcSet lb-\u003eLabelMap lb-\u003e[(EquivalenceClass lb,EquivalenceClass lb)]-\u003e(LabelMap lb,[(EquivalenceClass lb,EquivalenceClass lb)],Bool,Bool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:reclassify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a label and its associated value in a label map\n  with a new value using the supplied hash value and the current\n  \u003ccode\u003e\u003ca\u003eLabelMap\u003c/a\u003e\u003c/code\u003e generation number.  If the key is not found, then no change\n  is made to the label map.\n\u003c/p\u003e",
          "module": "Swish.GraphMatch",
          "name": "setLabelHash",
          "package": "swish",
          "signature": "LabelMap lb -\u003e (lb, Word32) -\u003e LabelMap lb",
          "source": "src/Swish-GraphMatch.html#setLabelHash",
          "type": "function"
        },
        "index": {
          "description": "Replace label and its associated value in label map with new value using the supplied hash value and the current LabelMap generation number If the key is not found then no change is made to the label map",
          "hierarchy": "Swish GraphMatch",
          "module": "Swish.GraphMatch",
          "name": "setLabelHash",
          "normalized": "LabelMap a-\u003e(a,Word)-\u003eLabelMap a",
          "package": "swish",
          "partial": "Label Hash",
          "signature": "LabelMap lb-\u003e(lb,Word)-\u003eLabelMap lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMatch.html#v:setLabelHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a simple memory-based graph instance.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.GraphMem",
          "name": "GraphMem",
          "package": "swish",
          "source": "src/Swish-GraphMem.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines simple memory-based graph instance",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "GraphMem",
          "package": "swish",
          "partial": "Graph Mem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple memory-based graph type. \n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "GraphMem",
          "package": "swish",
          "source": "src/Swish-GraphMem.html#GraphMem",
          "type": "data"
        },
        "index": {
          "description": "Simple memory-based graph type",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "GraphMem",
          "package": "swish",
          "partial": "Graph Mem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#t:GraphMem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal graph label value - for testing\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "LabelMem",
          "package": "swish",
          "source": "src/Swish-GraphMem.html#LabelMem",
          "type": "data"
        },
        "index": {
          "description": "Minimal graph label value for testing",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "LabelMem",
          "package": "swish",
          "partial": "Label Mem",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#t:LabelMem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphMem",
          "name": "GraphMem",
          "package": "swish",
          "signature": "GraphMem",
          "source": "src/Swish-GraphMem.html#GraphMem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "GraphMem",
          "package": "swish",
          "partial": "Graph Mem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:GraphMem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphMem",
          "name": "LF",
          "package": "swish",
          "signature": "LF String",
          "source": "src/Swish-GraphMem.html#LabelMem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "LF",
          "package": "swish",
          "partial": "LF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:LF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphMem",
          "name": "LV",
          "package": "swish",
          "signature": "LV String",
          "source": "src/Swish-GraphMem.html#LabelMem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "LV",
          "package": "swish",
          "partial": "LV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:LV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd the two graphs\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "addGraphs",
          "package": "swish",
          "signature": "lg lb -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#addGraphs",
          "type": "function"
        },
        "index": {
          "description": "Add the two graphs",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "addGraphs",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "swish",
          "partial": "Graphs",
          "signature": "lg lb-\u003elg lb-\u003elg lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:addGraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphMem",
          "name": "arcs",
          "package": "swish",
          "signature": "ArcSet lb",
          "source": "src/Swish-GraphMem.html#GraphMem",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "arcs",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:arcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove those arcs in the first graph from the second\n graph\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "delete",
          "package": "swish",
          "signature": "lg lb-\u003e lg lb-\u003e lg lb",
          "type": "function"
        },
        "index": {
          "description": "Remove those arcs in the first graph from the second graph",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "delete",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "swish",
          "signature": "lg lb-\u003elg lb-\u003elg lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract those arcs that match the given \u003ccode\u003e\u003ca\u003eSelector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "extract",
          "package": "swish",
          "signature": "Selector lb -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#extract",
          "type": "function"
        },
        "index": {
          "description": "Extract those arcs that match the given Selector",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "extract",
          "normalized": "Selector a-\u003eb a-\u003eb a",
          "package": "swish",
          "signature": "Selector lb-\u003elg lb-\u003elg lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:extract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract all the arcs from a graph\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "getArcs",
          "package": "swish",
          "signature": "lg lb -\u003e ArcSet lb",
          "source": "src/Swish-GraphClass.html#getArcs",
          "type": "function"
        },
        "index": {
          "description": "Extract all the arcs from graph",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "getArcs",
          "normalized": "a b-\u003eArcSet b",
          "package": "swish",
          "partial": "Arcs",
          "signature": "lg lb-\u003eArcSet lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:getArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerate the distinct labels contained in a graph;\n that is, any label that appears in the subject,\n predicate or object position of an \u003ccode\u003e\u003ca\u003eArc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "labels",
          "package": "swish",
          "signature": "lg lb -\u003e Set lb",
          "source": "src/Swish-GraphClass.html#labels",
          "type": "function"
        },
        "index": {
          "description": "Enumerate the distinct labels contained in graph that is any label that appears in the subject predicate or object position of an Arc",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "labels",
          "normalized": "a b-\u003eSet b",
          "package": "swish",
          "signature": "lg lb-\u003eSet lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:labels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraphMem matching function accepting GraphMem value and returning\n  node map if successful\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "matchGraphMem",
          "package": "swish",
          "signature": "GraphMem lb-\u003e GraphMem lb-\u003e (Bool, LabelMap (ScopedLabel lb))",
          "type": "function"
        },
        "index": {
          "description": "GraphMem matching function accepting GraphMem value and returning node map if successful",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "matchGraphMem",
          "normalized": "GraphMem a-\u003eGraphMem a-\u003e(Bool,LabelMap(ScopedLabel a))",
          "package": "swish",
          "partial": "Graph Mem",
          "signature": "GraphMem lb-\u003eGraphMem lb-\u003e(Bool,LabelMap(ScopedLabel lb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:matchGraphMem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the existing arcs in the graph.\n\u003c/p\u003e",
          "module": "Swish.GraphMem",
          "name": "setArcs",
          "package": "swish",
          "signature": "lg lb -\u003e ArcSet lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#setArcs",
          "type": "function"
        },
        "index": {
          "description": "Replace the existing arcs in the graph",
          "hierarchy": "Swish GraphMem",
          "module": "Swish.GraphMem",
          "name": "setArcs",
          "normalized": "a b-\u003eArcSet b-\u003ea b",
          "package": "swish",
          "partial": "Arcs",
          "signature": "lg lb-\u003eArcSet lb-\u003elg lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphMem.html#v:setArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains functions for partitioning a graph into subgraphs\n  that rooted from different subject nodes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.GraphPartition",
          "name": "GraphPartition",
          "package": "swish",
          "source": "src/Swish-GraphPartition.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains functions for partitioning graph into subgraphs that rooted from different subject nodes",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "GraphPartition",
          "package": "swish",
          "partial": "Graph Partition",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresent a partition of a graph by a node and (optional) contents.\n\u003c/p\u003e",
          "module": "Swish.GraphPartition",
          "name": "GraphPartition",
          "package": "swish",
          "source": "src/Swish-GraphPartition.html#GraphPartition",
          "type": "data"
        },
        "index": {
          "description": "Represent partition of graph by node and optional contents",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "GraphPartition",
          "package": "swish",
          "partial": "Graph Partition",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#t:GraphPartition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresentation of a graph as a collection of (possibly nested)\n  partitions.  Each node in the graph appears at least once as the\n  root value of a \u003ccode\u003e\u003ca\u003eGraphPartition\u003c/a\u003e\u003c/code\u003e value:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Nodes that are the subject of at least one statement appear as\n    the first value of exactly one \u003ccode\u003e\u003ca\u003ePartSub\u003c/a\u003e\u003c/code\u003e constructor, and may\n    also appear in any number of \u003ccode\u003e\u003ca\u003ePartObj\u003c/a\u003e\u003c/code\u003e constructors.\n\u003c/li\u003e\u003cli\u003e Nodes appearing only as objects of statements appear only in\n    \u003ccode\u003e\u003ca\u003ePartObj\u003c/a\u003e\u003c/code\u003e constructors.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Swish.GraphPartition",
          "name": "PartitionedGraph",
          "package": "swish",
          "source": "src/Swish-GraphPartition.html#PartitionedGraph",
          "type": "data"
        },
        "index": {
          "description": "Representation of graph as collection of possibly nested partitions Each node in the graph appears at least once as the root value of GraphPartition value Nodes that are the subject of at least one statement appear as the first value of exactly one PartSub constructor and may also appear in any number of PartObj constructors Nodes appearing only as objects of statements appear only in PartObj constructors",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "PartitionedGraph",
          "package": "swish",
          "partial": "Partitioned Graph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#t:PartitionedGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphPartition",
          "name": "PartObj",
          "package": "swish",
          "signature": "PartObj lb",
          "source": "src/Swish-GraphPartition.html#GraphPartition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "PartObj",
          "package": "swish",
          "partial": "Part Obj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:PartObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphPartition",
          "name": "PartSub",
          "package": "swish",
          "signature": "PartSub lb (NonEmpty (lb, GraphPartition lb))",
          "source": "src/Swish-GraphPartition.html#GraphPartition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "PartSub",
          "normalized": "PartSub a(NonEmpty(a,GraphPartition a))",
          "package": "swish",
          "partial": "Part Sub",
          "signature": "PartSub lb(NonEmpty(lb,GraphPartition lb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:PartSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.GraphPartition",
          "name": "PartitionedGraph",
          "package": "swish",
          "signature": "PartitionedGraph [GraphPartition lb]",
          "source": "src/Swish-GraphPartition.html#PartitionedGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "PartitionedGraph",
          "normalized": "PartitionedGraph[GraphPartition a]",
          "package": "swish",
          "partial": "Partitioned Graph",
          "signature": "PartitionedGraph[GraphPartition lb]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:PartitionedGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a list of pairs of corresponding Partitions that\n  are unequal.\n\u003c/p\u003e",
          "module": "Swish.GraphPartition",
          "name": "comparePartitions",
          "package": "swish",
          "signature": "PartitionedGraph lb -\u003e PartitionedGraph lb -\u003e [(Maybe (GraphPartition lb), Maybe (GraphPartition lb))]",
          "source": "src/Swish-GraphPartition.html#comparePartitions",
          "type": "function"
        },
        "index": {
          "description": "Create list of pairs of corresponding Partitions that are unequal",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "comparePartitions",
          "normalized": "PartitionedGraph a-\u003ePartitionedGraph a-\u003e[(Maybe(GraphPartition a),Maybe(GraphPartition a))]",
          "package": "swish",
          "partial": "Partitions",
          "signature": "PartitionedGraph lb-\u003ePartitionedGraph lb-\u003e[(Maybe(GraphPartition lb),Maybe(GraphPartition lb))]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:comparePartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all the arcs in the partitioned graph.\n\u003c/p\u003e",
          "module": "Swish.GraphPartition",
          "name": "getArcs",
          "package": "swish",
          "signature": "PartitionedGraph lb -\u003e [Arc lb]",
          "source": "src/Swish-GraphPartition.html#getArcs",
          "type": "function"
        },
        "index": {
          "description": "Returns all the arcs in the partitioned graph",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "getArcs",
          "normalized": "PartitionedGraph a-\u003e[Arc a]",
          "package": "swish",
          "partial": "Arcs",
          "signature": "PartitionedGraph lb-\u003e[Arc lb]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:getArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a list of partitions.\n\u003c/p\u003e",
          "module": "Swish.GraphPartition",
          "name": "getPartitions",
          "package": "swish",
          "signature": "PartitionedGraph lb -\u003e [GraphPartition lb]",
          "source": "src/Swish-GraphPartition.html#getPartitions",
          "type": "function"
        },
        "index": {
          "description": "Returns list of partitions",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "getPartitions",
          "normalized": "PartitionedGraph a-\u003e[GraphPartition a]",
          "package": "swish",
          "partial": "Partitions",
          "signature": "PartitionedGraph lb-\u003e[GraphPartition lb]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:getPartitions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the node for the partition.\n\u003c/p\u003e",
          "module": "Swish.GraphPartition",
          "name": "node",
          "package": "swish",
          "signature": "GraphPartition lb -\u003e lb",
          "source": "src/Swish-GraphPartition.html#node",
          "type": "function"
        },
        "index": {
          "description": "Returns the node for the partition",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "node",
          "normalized": "GraphPartition a-\u003ea",
          "package": "swish",
          "signature": "GraphPartition lb-\u003elb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurning a partitioned graph into a flat graph is easy.\n  The interesting challenge is to turn a flat graph into a\n  partitioned graph that is more useful for certain purposes.\n  Currently, I'm interested in:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e isolating differences between graphs\n\u003c/li\u003e\u003cli\u003e pretty-printing graphs\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eFor (1), the goal is to separate subgraphs that are known\n  to be equivalent from subgraphs that are known to be different,\n  such that: \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e different sub-graphs are minimized,\n\u003c/li\u003e\u003cli\u003e different\n  sub-graphs are placed into 1:1 correspondence (possibly with null\n  subgraphs), and\n\u003c/li\u003e\u003cli\u003e only deterministic matching decisions are made.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor (2), the goal is to decide when a subgraph is to be treated\n  as nested in another partition, or treated as a new top-level partition.\n  If a subgraph is referenced by exactly one graph partition, it should\n  be nested in that partition, otherwise it should be a new top-level\n  partition.\n\u003c/p\u003e\u003cp\u003eStrategy.  Examining just subject and object nodes:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e all non-blank subject nodes are the root of a top-level partition\n\u003c/li\u003e\u003cli\u003e blank subject nodes that are not the object of exactly one statement\n     are the root of a top-level partition.\n\u003c/li\u003e\u003cli\u003e blank nodes referenced as the object of exactly 1 statement\n     of an existing partition are the root of a sub-partition of the\n     refering partition.\n\u003c/li\u003e\u003cli\u003e what remain are circular chains of blank nodes not referenced\n     elsewhere:  for each such chain, pick a root node arbitrarily.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Swish.GraphPartition",
          "name": "partitionGraph",
          "package": "swish",
          "signature": "[Arc lb] -\u003e PartitionedGraph lb",
          "source": "src/Swish-GraphPartition.html#partitionGraph",
          "type": "function"
        },
        "index": {
          "description": "Turning partitioned graph into flat graph is easy The interesting challenge is to turn flat graph into partitioned graph that is more useful for certain purposes Currently interested in isolating differences between graphs pretty-printing graphs For the goal is to separate subgraphs that are known to be equivalent from subgraphs that are known to be different such that different sub-graphs are minimized different sub-graphs are placed into correspondence possibly with null subgraphs and only deterministic matching decisions are made For the goal is to decide when subgraph is to be treated as nested in another partition or treated as new top-level partition If subgraph is referenced by exactly one graph partition it should be nested in that partition otherwise it should be new top-level partition Strategy Examining just subject and object nodes all non-blank subject nodes are the root of top-level partition blank subject nodes that are not the object of exactly one statement are the root of top-level partition blank nodes referenced as the object of exactly statement of an existing partition are the root of sub-partition of the refering partition what remain are circular chains of blank nodes not referenced elsewhere for each such chain pick root node arbitrarily",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "partitionGraph",
          "normalized": "[Arc a]-\u003ePartitionedGraph a",
          "package": "swish",
          "partial": "Graph",
          "signature": "[Arc lb]-\u003ePartitionedGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:partitionGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a partition into a string with a leading separator string.\n\u003c/p\u003e",
          "module": "Swish.GraphPartition",
          "name": "partitionShowP",
          "package": "swish",
          "signature": "String -\u003e GraphPartition lb -\u003e String",
          "source": "src/Swish-GraphPartition.html#partitionShowP",
          "type": "function"
        },
        "index": {
          "description": "Convert partition into string with leading separator string",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "partitionShowP",
          "normalized": "String-\u003eGraphPartition a-\u003eString",
          "package": "swish",
          "partial": "Show",
          "signature": "String-\u003eGraphPartition lb-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:partitionShowP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a list of arcs from the partition. The empty\n list is returned for \u003ccode\u003e\u003ca\u003ePartObj\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.GraphPartition",
          "name": "toArcs",
          "package": "swish",
          "signature": "GraphPartition lb -\u003e [Arc lb]",
          "source": "src/Swish-GraphPartition.html#toArcs",
          "type": "function"
        },
        "index": {
          "description": "Creates list of arcs from the partition The empty list is returned for PartObj",
          "hierarchy": "Swish GraphPartition",
          "module": "Swish.GraphPartition",
          "name": "toArcs",
          "normalized": "GraphPartition a-\u003e[Arc a]",
          "package": "swish",
          "partial": "Arcs",
          "signature": "GraphPartition lb-\u003e[Arc lb]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-GraphPartition.html#v:toArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eComposed state and IO monad for Swish\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Monad",
          "name": "Monad",
          "package": "swish",
          "source": "src/Swish-Monad.html",
          "type": "module"
        },
        "index": {
          "description": "Composed state and IO monad for Swish",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "Monad",
          "package": "swish",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA LookupMap for the graphs dictionary.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "NamedGraphMap",
          "package": "swish",
          "source": "src/Swish-Monad.html#NamedGraphMap",
          "type": "type"
        },
        "index": {
          "description": "LookupMap for the graphs dictionary",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "NamedGraphMap",
          "package": "swish",
          "partial": "Named Graph Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#t:NamedGraphMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe supported input and output formats.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "SwishFormat",
          "package": "swish",
          "source": "src/Swish-Monad.html#SwishFormat",
          "type": "data"
        },
        "index": {
          "description": "The supported input and output formats",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishFormat",
          "package": "swish",
          "partial": "Swish Format",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#t:SwishFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe State for a Swish \"program\".\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "SwishState",
          "package": "swish",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "data"
        },
        "index": {
          "description": "The State for Swish program",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishState",
          "package": "swish",
          "partial": "Swish State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#t:SwishState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe state monad used in executing Swish programs.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "SwishStateIO",
          "package": "swish",
          "source": "src/Swish-Monad.html#SwishStateIO",
          "type": "type"
        },
        "index": {
          "description": "The state monad used in executing Swish programs",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishStateIO",
          "package": "swish",
          "partial": "Swish State IO",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#t:SwishStateIO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatus of the processor\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "SwishStatus",
          "package": "swish",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "data"
        },
        "index": {
          "description": "Status of the processor",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishStatus",
          "package": "swish",
          "partial": "Swish Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#t:SwishStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eN3 format\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "N3",
          "package": "swish",
          "signature": "N3",
          "source": "src/Swish-Monad.html#SwishFormat",
          "type": "function"
        },
        "index": {
          "description": "N3 format",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "N3",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:N3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNTriples format\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "NT",
          "package": "swish",
          "signature": "NT",
          "source": "src/Swish-Monad.html#SwishFormat",
          "type": "function"
        },
        "index": {
          "description": "NTriples format",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "NT",
          "package": "swish",
          "partial": "NT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:NT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecommand-line argument error\n\u003c/p\u003e",
          "module": "[\"Swish.Monad\",\"Swish\"]",
          "name": "SwishArgumentError",
          "package": "swish",
          "signature": "SwishArgumentError",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishArgumentError\",\"http://hackage.haskell.org/package/swish/docs/Swish.html#v:SwishArgumentError\"]"
        },
        "index": {
          "description": "command-line argument error",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishArgumentError",
          "package": "swish",
          "partial": "Swish Argument Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishArgumentError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata access error\n\u003c/p\u003e",
          "module": "[\"Swish.Monad\",\"Swish\"]",
          "name": "SwishDataAccessError",
          "package": "swish",
          "signature": "SwishDataAccessError",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishDataAccessError\",\"http://hackage.haskell.org/package/swish/docs/Swish.html#v:SwishDataAccessError\"]"
        },
        "index": {
          "description": "data access error",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishDataAccessError",
          "package": "swish",
          "partial": "Swish Data Access Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishDataAccessError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einput data problem (ie format/syntax)\n\u003c/p\u003e",
          "module": "[\"Swish.Monad\",\"Swish\"]",
          "name": "SwishDataInputError",
          "package": "swish",
          "signature": "SwishDataInputError",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishDataInputError\",\"http://hackage.haskell.org/package/swish/docs/Swish.html#v:SwishDataInputError\"]"
        },
        "index": {
          "description": "input data problem ie format syntax",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishDataInputError",
          "package": "swish",
          "partial": "Swish Data Input Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishDataInputError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror executing a Swish script\n\u003c/p\u003e",
          "module": "[\"Swish.Monad\",\"Swish\"]",
          "name": "SwishExecutionError",
          "package": "swish",
          "signature": "SwishExecutionError",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishExecutionError\",\"http://hackage.haskell.org/package/swish/docs/Swish.html#v:SwishExecutionError\"]"
        },
        "index": {
          "description": "error executing Swish script",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishExecutionError",
          "package": "swish",
          "partial": "Swish Execution Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishExecutionError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egraphs do not compare\n\u003c/p\u003e",
          "module": "[\"Swish.Monad\",\"Swish\"]",
          "name": "SwishGraphCompareError",
          "package": "swish",
          "signature": "SwishGraphCompareError",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishGraphCompareError\",\"http://hackage.haskell.org/package/swish/docs/Swish.html#v:SwishGraphCompareError\"]"
        },
        "index": {
          "description": "graphs do not compare",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishGraphCompareError",
          "package": "swish",
          "partial": "Swish Graph Compare Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishGraphCompareError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Monad",
          "name": "SwishState",
          "package": "swish",
          "signature": "SwishState",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishState",
          "package": "swish",
          "partial": "Swish State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esuccessful run\n\u003c/p\u003e",
          "module": "[\"Swish.Monad\",\"Swish\"]",
          "name": "SwishSuccess",
          "package": "swish",
          "signature": "SwishSuccess",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishSuccess\",\"http://hackage.haskell.org/package/swish/docs/Swish.html#v:SwishSuccess\"]"
        },
        "index": {
          "description": "successful run",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "SwishSuccess",
          "package": "swish",
          "partial": "Swish Success",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:SwishSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurtle format\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "Turtle",
          "package": "swish",
          "signature": "Turtle",
          "source": "src/Swish-Monad.html#SwishFormat",
          "type": "function"
        },
        "index": {
          "description": "Turtle format",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "Turtle",
          "package": "swish",
          "partial": "Turtle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:Turtle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebase to use rather than file name\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "base",
          "package": "swish",
          "signature": "Maybe QName",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "base to use rather than file name",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "base",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default state for Swish: no loaded graphs or rules, and format\n set to \u003ccode\u003e\u003ca\u003eN3\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "emptyState",
          "package": "swish",
          "signature": "SwishState",
          "source": "src/Swish-Monad.html#emptyState",
          "type": "function"
        },
        "index": {
          "description": "The default state for Swish no loaded graphs or rules and format set to N3",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "emptyState",
          "package": "swish",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:emptyState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eerror message, or Nothing\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "errormsg",
          "package": "swish",
          "signature": "Maybe String",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "error message or Nothing",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "errormsg",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:errormsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent status\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "exitcode",
          "package": "swish",
          "signature": "SwishStatus",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "current status",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "exitcode",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:exitcode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a data type declaration.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "findDatatype",
          "package": "swish",
          "signature": "ScopedName -\u003e SwishState -\u003e Maybe RDFDatatype",
          "source": "src/Swish-Monad.html#findDatatype",
          "type": "function"
        },
        "index": {
          "description": "Find data type declaration",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "findDatatype",
          "normalized": "ScopedName-\u003eSwishState-\u003eMaybe RDFDatatype",
          "package": "swish",
          "partial": "Datatype",
          "signature": "ScopedName-\u003eSwishState-\u003eMaybe RDFDatatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:findDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a formula. The search is first made in the named graphs\n and then, if not found, the rulesets.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "findFormula",
          "package": "swish",
          "signature": "ScopedName -\u003e SwishState -\u003e Maybe RDFFormula",
          "source": "src/Swish-Monad.html#findFormula",
          "type": "function"
        },
        "index": {
          "description": "Find formula The search is first made in the named graphs and then if not found the rulesets",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "findFormula",
          "normalized": "ScopedName-\u003eSwishState-\u003eMaybe RDFFormula",
          "package": "swish",
          "partial": "Formula",
          "signature": "ScopedName-\u003eSwishState-\u003eMaybe RDFFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:findFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named graph.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "findGraph",
          "package": "swish",
          "signature": "ScopedName -\u003e SwishState -\u003e Maybe [RDFGraph]",
          "source": "src/Swish-Monad.html#findGraph",
          "type": "function"
        },
        "index": {
          "description": "Find named graph",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "findGraph",
          "normalized": "ScopedName-\u003eSwishState-\u003eMaybe[RDFGraph]",
          "package": "swish",
          "partial": "Graph",
          "signature": "ScopedName-\u003eSwishState-\u003eMaybe[RDFGraph]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:findGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a modify rule.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "findOpenVarModify",
          "package": "swish",
          "signature": "ScopedName -\u003e SwishState -\u003e Maybe RDFOpenVarBindingModify",
          "source": "src/Swish-Monad.html#findOpenVarModify",
          "type": "function"
        },
        "index": {
          "description": "Find modify rule",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "findOpenVarModify",
          "normalized": "ScopedName-\u003eSwishState-\u003eMaybe RDFOpenVarBindingModify",
          "package": "swish",
          "partial": "Open Var Modify",
          "signature": "ScopedName-\u003eSwishState-\u003eMaybe RDFOpenVarBindingModify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:findOpenVarModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named rule.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "findRule",
          "package": "swish",
          "signature": "ScopedName -\u003e SwishState -\u003e Maybe RDFRule",
          "source": "src/Swish-Monad.html#findRule",
          "type": "function"
        },
        "index": {
          "description": "Find named rule",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "findRule",
          "normalized": "ScopedName-\u003eSwishState-\u003eMaybe RDFRule",
          "package": "swish",
          "partial": "Rule",
          "signature": "ScopedName-\u003eSwishState-\u003eMaybe RDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:findRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a rule set.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "findRuleset",
          "package": "swish",
          "signature": "ScopedName -\u003e SwishState -\u003e Maybe RDFRuleset",
          "source": "src/Swish-Monad.html#findRuleset",
          "type": "function"
        },
        "index": {
          "description": "Find rule set",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "findRuleset",
          "normalized": "ScopedName-\u003eSwishState-\u003eMaybe RDFRuleset",
          "package": "swish",
          "partial": "Ruleset",
          "signature": "ScopedName-\u003eSwishState-\u003eMaybe RDFRuleset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:findRuleset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eformat to use for I/O\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "format",
          "package": "swish",
          "signature": "SwishFormat",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "format to use for",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "format",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:format"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent graph\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "graph",
          "package": "swish",
          "signature": "RDFGraph",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "current graph",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "graph",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escript processor named graphs\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "graphs",
          "package": "swish",
          "signature": "NamedGraphMap",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "script processor named graphs",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "graphs",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:graphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einformation message, or Nothing\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "infomsg",
          "package": "swish",
          "signature": "Maybe String",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "information message or Nothing",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "infomsg",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:infomsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the named graphs.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "modGraphs",
          "package": "swish",
          "signature": "(NamedGraphMap -\u003e NamedGraphMap) -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#modGraphs",
          "type": "function"
        },
        "index": {
          "description": "Modify the named graphs",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "modGraphs",
          "normalized": "(NamedGraphMap-\u003eNamedGraphMap)-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Graphs",
          "signature": "(NamedGraphMap-\u003eNamedGraphMap)-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:modGraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the named rules.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "modRules",
          "package": "swish",
          "signature": "(RDFRuleMap -\u003e RDFRuleMap) -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#modRules",
          "type": "function"
        },
        "index": {
          "description": "Modify the named rules",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "modRules",
          "normalized": "(RDFRuleMap-\u003eRDFRuleMap)-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Rules",
          "signature": "(RDFRuleMap-\u003eRDFRuleMap)-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:modRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the rule sets.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "modRulesets",
          "package": "swish",
          "signature": "(RDFRulesetMap -\u003e RDFRulesetMap) -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#modRulesets",
          "type": "function"
        },
        "index": {
          "description": "Modify the rule sets",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "modRulesets",
          "normalized": "(RDFRulesetMap-\u003eRDFRulesetMap)-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Rulesets",
          "signature": "(RDFRulesetMap-\u003eRDFRulesetMap)-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:modRulesets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutput the text to the standard error stream (a new line is\n added to the output).\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "reportLine",
          "package": "swish",
          "signature": "String -\u003e SwishStateIO ()",
          "source": "src/Swish-Monad.html#reportLine",
          "type": "function"
        },
        "index": {
          "description": "Output the text to the standard error stream new line is added to the output",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "reportLine",
          "normalized": "String-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Line",
          "signature": "String-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:reportLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear the error message.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "resetError",
          "package": "swish",
          "signature": "SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#resetError",
          "type": "function"
        },
        "index": {
          "description": "Clear the error message",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "resetError",
          "normalized": "SwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Error",
          "signature": "SwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:resetError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear the information message.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "resetInfo",
          "package": "swish",
          "signature": "SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#resetInfo",
          "type": "function"
        },
        "index": {
          "description": "Clear the information message",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "resetInfo",
          "normalized": "SwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Info",
          "signature": "SwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:resetInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escript processor named rules\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "rules",
          "package": "swish",
          "signature": "RDFRuleMap",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "script processor named rules",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "rules",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:rules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escript processor rulesets\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "rulesets",
          "package": "swish",
          "signature": "RDFRulesetMap",
          "source": "src/Swish-Monad.html#SwishState",
          "type": "function"
        },
        "index": {
          "description": "script processor rulesets",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "rulesets",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:rulesets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange (or remove) the base URI.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "setBase",
          "package": "swish",
          "signature": "Maybe QName -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#setBase",
          "type": "function"
        },
        "index": {
          "description": "Change or remove the base URI",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "setBase",
          "normalized": "Maybe QName-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Base",
          "signature": "Maybe QName-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:setBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the error message.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "setError",
          "package": "swish",
          "signature": "String -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#setError",
          "type": "function"
        },
        "index": {
          "description": "Set the error message",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "setError",
          "normalized": "String-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Error",
          "signature": "String-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:setError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the format.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "setFormat",
          "package": "swish",
          "signature": "SwishFormat -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#setFormat",
          "type": "function"
        },
        "index": {
          "description": "Change the format",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "setFormat",
          "normalized": "SwishFormat-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Format",
          "signature": "SwishFormat-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:setFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the current graph.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "setGraph",
          "package": "swish",
          "signature": "RDFGraph -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#setGraph",
          "type": "function"
        },
        "index": {
          "description": "Change the current graph",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "setGraph",
          "normalized": "RDFGraph-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Graph",
          "signature": "RDFGraph-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:setGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the information message.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "setInfo",
          "package": "swish",
          "signature": "String -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#setInfo",
          "type": "function"
        },
        "index": {
          "description": "Set the information message",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "setInfo",
          "normalized": "String-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Info",
          "signature": "String-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:setInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the status.\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "setStatus",
          "package": "swish",
          "signature": "SwishStatus -\u003e SwishState -\u003e SwishState",
          "source": "src/Swish-Monad.html#setStatus",
          "type": "function"
        },
        "index": {
          "description": "Set the status",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "setStatus",
          "normalized": "SwishStatus-\u003eSwishState-\u003eSwishState",
          "package": "swish",
          "partial": "Status",
          "signature": "SwishStatus-\u003eSwishState-\u003eSwishState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:setStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReport error and set exit status code\n\u003c/p\u003e",
          "module": "Swish.Monad",
          "name": "swishError",
          "package": "swish",
          "signature": "String -\u003e SwishStatus -\u003e SwishStateIO ()",
          "source": "src/Swish-Monad.html#swishError",
          "type": "function"
        },
        "index": {
          "description": "Report error and set exit status code",
          "hierarchy": "Swish Monad",
          "module": "Swish.Monad",
          "name": "swishError",
          "normalized": "String-\u003eSwishStatus-\u003eSwishStateIO()",
          "package": "swish",
          "partial": "Error",
          "signature": "String-\u003eSwishStatus-\u003eSwishStateIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Monad.html#v:swishError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines algebraic datatypes for namespaces and scoped names.\n\u003c/p\u003e\u003cp\u003eFor these purposes, a namespace is a prefix and URI used to identify\n  a namespace (cf. XML namespaces), and a scoped name is a name that\n  is scoped by a specified namespace.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Namespace",
          "name": "Namespace",
          "package": "swish",
          "source": "src/Swish-Namespace.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines algebraic datatypes for namespaces and scoped names For these purposes namespace is prefix and URI used to identify namespace cf XML namespaces and scoped name is name that is scoped by specified namespace",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "Namespace",
          "package": "swish",
          "partial": "Namespace",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA NameSpace value consists of an optional prefix and a corresponding URI.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "Namespace",
          "package": "swish",
          "source": "src/Swish-Namespace.html#Namespace",
          "type": "data"
        },
        "index": {
          "description": "NameSpace value consists of an optional prefix and corresponding URI",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "Namespace",
          "package": "swish",
          "partial": "Namespace",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#t:Namespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA full ScopedName value has a QName prefix, namespace URI\n  and a local part.  ScopedName values may omit the prefix\n  (see \u003ccode\u003e\u003ca\u003eNamespace\u003c/a\u003e\u003c/code\u003e) or the local part.\n\u003c/p\u003e\u003cp\u003eSome applications may handle null namespace URIs as meaning\n  the local part is relative to some base URI.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "ScopedName",
          "package": "swish",
          "source": "src/Swish-Namespace.html#ScopedName",
          "type": "data"
        },
        "index": {
          "description": "full ScopedName value has QName prefix namespace URI and local part ScopedName values may omit the prefix see Namespace or the local part Some applications may handle null namespace URIs as meaning the local part is relative to some base URI",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "ScopedName",
          "package": "swish",
          "partial": "Scoped Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#t:ScopedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the prefix stored in the name space.                 \n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getNamespacePrefix",
          "package": "swish",
          "signature": "Namespace -\u003e Maybe Text",
          "source": "src/Swish-Namespace.html#getNamespacePrefix",
          "type": "function"
        },
        "index": {
          "description": "Returns the prefix stored in the name space",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getNamespacePrefix",
          "normalized": "Namespace-\u003eMaybe Text",
          "package": "swish",
          "partial": "Namespace Prefix",
          "signature": "Namespace-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getNamespacePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the name space to a (prefix, URI) tuple.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getNamespaceTuple",
          "package": "swish",
          "signature": "Namespace -\u003e (Maybe Text, URI)",
          "source": "src/Swish-Namespace.html#getNamespaceTuple",
          "type": "function"
        },
        "index": {
          "description": "Convert the name space to prefix URI tuple",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getNamespaceTuple",
          "normalized": "Namespace-\u003e(Maybe Text,URI)",
          "package": "swish",
          "partial": "Namespace Tuple",
          "signature": "Namespace-\u003e(Maybe Text,URI)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getNamespaceTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the URI stored in the name space.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getNamespaceURI",
          "package": "swish",
          "signature": "Namespace -\u003e URI",
          "source": "src/Swish-Namespace.html#getNamespaceURI",
          "type": "function"
        },
        "index": {
          "description": "Returns the URI stored in the name space",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getNamespaceURI",
          "normalized": "Namespace-\u003eURI",
          "package": "swish",
          "partial": "Namespace URI",
          "signature": "Namespace-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getNamespaceURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the QName corresponding to a scoped name.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getQName",
          "package": "swish",
          "signature": "ScopedName -\u003e QName",
          "source": "src/Swish-Namespace.html#getQName",
          "type": "function"
        },
        "index": {
          "description": "Get the QName corresponding to scoped name",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getQName",
          "normalized": "ScopedName-\u003eQName",
          "package": "swish",
          "partial": "QName",
          "signature": "ScopedName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the local part.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getScopeLocal",
          "package": "swish",
          "signature": "ScopedName -\u003e LName",
          "source": "src/Swish-Namespace.html#getScopeLocal",
          "type": "function"
        },
        "index": {
          "description": "Returns the local part",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getScopeLocal",
          "normalized": "ScopedName-\u003eLName",
          "package": "swish",
          "partial": "Scope Local",
          "signature": "ScopedName-\u003eLName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getScopeLocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the namespace.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getScopeNamespace",
          "package": "swish",
          "signature": "ScopedName -\u003e Namespace",
          "source": "src/Swish-Namespace.html#getScopeNamespace",
          "type": "function"
        },
        "index": {
          "description": "Returns the namespace",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getScopeNamespace",
          "normalized": "ScopedName-\u003eNamespace",
          "package": "swish",
          "partial": "Scope Namespace",
          "signature": "ScopedName-\u003eNamespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getScopeNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the prefix of the namespace, if set.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getScopePrefix",
          "package": "swish",
          "signature": "ScopedName -\u003e Maybe Text",
          "source": "src/Swish-Namespace.html#getScopePrefix",
          "type": "function"
        },
        "index": {
          "description": "Returns the prefix of the namespace if set",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getScopePrefix",
          "normalized": "ScopedName-\u003eMaybe Text",
          "package": "swish",
          "partial": "Scope Prefix",
          "signature": "ScopedName-\u003eMaybe Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getScopePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the URI of the namespace.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getScopeURI",
          "package": "swish",
          "signature": "ScopedName -\u003e URI",
          "source": "src/Swish-Namespace.html#getScopeURI",
          "type": "function"
        },
        "index": {
          "description": "Returns the URI of the namespace",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getScopeURI",
          "normalized": "ScopedName-\u003eURI",
          "package": "swish",
          "partial": "Scope URI",
          "signature": "ScopedName-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getScopeURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet URI corresponding to a scoped name (using RDF conventions).\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "getScopedNameURI",
          "package": "swish",
          "signature": "ScopedName -\u003e URI",
          "source": "src/Swish-Namespace.html#getScopedNameURI",
          "type": "function"
        },
        "index": {
          "description": "Get URI corresponding to scoped name using RDF conventions",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "getScopedNameURI",
          "normalized": "ScopedName-\u003eURI",
          "package": "swish",
          "partial": "Scoped Name URI",
          "signature": "ScopedName-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:getScopedNameURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a ScopedName.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "makeNSScopedName",
          "package": "swish",
          "signature": "Namespace-\u003e LName-\u003e ScopedName",
          "type": "function"
        },
        "index": {
          "description": "Construct ScopedName",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "makeNSScopedName",
          "normalized": "Namespace-\u003eLName-\u003eScopedName",
          "package": "swish",
          "partial": "NSScoped Name",
          "signature": "Namespace-\u003eLName-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:makeNSScopedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a name space from a URI and an optional prefix label.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "makeNamespace",
          "package": "swish",
          "signature": "Maybe Text-\u003e URI-\u003e Namespace",
          "type": "function"
        },
        "index": {
          "description": "Create name space from URI and an optional prefix label",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "makeNamespace",
          "normalized": "Maybe Text-\u003eURI-\u003eNamespace",
          "package": "swish",
          "partial": "Namespace",
          "signature": "Maybe Text-\u003eURI-\u003eNamespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:makeNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a qualified name by combining the URI from\n the name space with a local component.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "makeNamespaceQName",
          "package": "swish",
          "signature": "Namespace-\u003e LName-\u003e QName",
          "type": "function"
        },
        "index": {
          "description": "Create qualified name by combining the URI from the name space with local component",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "makeNamespaceQName",
          "normalized": "Namespace-\u003eLName-\u003eQName",
          "package": "swish",
          "partial": "Namespace QName",
          "signature": "Namespace-\u003eLName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:makeNamespaceQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a ScopedName from a QName.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "makeQNameScopedName",
          "package": "swish",
          "signature": "Maybe Text-\u003e QName-\u003e ScopedName",
          "type": "function"
        },
        "index": {
          "description": "Construct ScopedName from QName",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "makeQNameScopedName",
          "normalized": "Maybe Text-\u003eQName-\u003eScopedName",
          "package": "swish",
          "partial": "QName Scoped Name",
          "signature": "Maybe Text-\u003eQName-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:makeQNameScopedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a ScopedName.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "makeScopedName",
          "package": "swish",
          "signature": "Maybe Text-\u003e URI-\u003e LName-\u003e ScopedName",
          "type": "function"
        },
        "index": {
          "description": "Construct ScopedName",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "makeScopedName",
          "normalized": "Maybe Text-\u003eURI-\u003eLName-\u003eScopedName",
          "package": "swish",
          "partial": "Scoped Name",
          "signature": "Maybe Text-\u003eURI-\u003eLName-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:makeScopedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a ScopedName for a bare URI (the label is set to \"\").\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "makeURIScopedName",
          "package": "swish",
          "signature": "URI -\u003e ScopedName",
          "source": "src/Swish-Namespace.html#makeURIScopedName",
          "type": "function"
        },
        "index": {
          "description": "Construct ScopedName for bare URI the label is set to",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "makeURIScopedName",
          "normalized": "URI-\u003eScopedName",
          "package": "swish",
          "partial": "URIScoped Name",
          "signature": "URI-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:makeURIScopedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied string matches the display form of a\n  scoped name.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "matchName",
          "package": "swish",
          "signature": "String -\u003e ScopedName -\u003e Bool",
          "source": "src/Swish-Namespace.html#matchName",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied string matches the display form of scoped name",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "matchName",
          "normalized": "String-\u003eScopedName-\u003eBool",
          "package": "swish",
          "partial": "Name",
          "signature": "String-\u003eScopedName-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:matchName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUtility routine to create a @prefix line (matching N3/Turtle)\n   grammar for this namespace.\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "namespaceToBuilder",
          "package": "swish",
          "signature": "Namespace -\u003e Builder",
          "source": "src/Swish-Namespace.html#namespaceToBuilder",
          "type": "function"
        },
        "index": {
          "description": "Utility routine to create prefix line matching N3 Turtle grammar for this namespace",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "namespaceToBuilder",
          "normalized": "Namespace-\u003eBuilder",
          "package": "swish",
          "partial": "To Builder",
          "signature": "Namespace-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:namespaceToBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis should never appear as a valid name\n\u003c/p\u003e",
          "module": "Swish.Namespace",
          "name": "nullScopedName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-Namespace.html#nullScopedName",
          "type": "function"
        },
        "index": {
          "description": "This should never appear as valid name",
          "hierarchy": "Swish Namespace",
          "module": "Swish.Namespace",
          "name": "nullScopedName",
          "package": "swish",
          "partial": "Scoped Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Namespace.html#v:nullScopedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a framework for constructing proofs\n  over some expression form.  It is intended to be used\n  with RDF graphs, but the structures aim to be quite\n  generic with respect to the expression forms allowed.\n\u003c/p\u003e\u003cp\u003eIt does not define any proof-finding strategy.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Proof",
          "name": "Proof",
          "package": "swish",
          "source": "src/Swish-Proof.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines framework for constructing proofs over some expression form It is intended to be used with RDF graphs but the structures aim to be quite generic with respect to the expression forms allowed It does not define any proof-finding strategy",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "Proof",
          "package": "swish",
          "partial": "Proof",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProof is a structure that presents a chain of rule applications\n  that yield a result expression from a given expression\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "Proof",
          "package": "swish",
          "source": "src/Swish-Proof.html#Proof",
          "type": "data"
        },
        "index": {
          "description": "Proof is structure that presents chain of rule applications that yield result expression from given expression",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "Proof",
          "package": "swish",
          "partial": "Proof",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#t:Proof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStep in proof chain\n\u003c/p\u003e\u003cp\u003eThe display name for a proof step comes from the display name of its\n  consequence formula.\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "Step",
          "package": "swish",
          "source": "src/Swish-Proof.html#Step",
          "type": "data"
        },
        "index": {
          "description": "Step in proof chain The display name for proof step comes from the display name of its consequence formula",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "Step",
          "package": "swish",
          "partial": "Step",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#t:Step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Proof",
          "name": "Proof",
          "package": "swish",
          "signature": "Proof",
          "source": "src/Swish-Proof.html#Proof",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "Proof",
          "package": "swish",
          "partial": "Proof",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:Proof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Proof",
          "name": "Step",
          "package": "swish",
          "signature": "Step",
          "source": "src/Swish-Proof.html#Step",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "Step",
          "package": "swish",
          "partial": "Step",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:Step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck consistency of given proof.\n  The supplied rules and axioms are assumed to be correct.\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "checkProof",
          "package": "swish",
          "signature": "Proof ex -\u003e Bool",
          "source": "src/Swish-Proof.html#checkProof",
          "type": "function"
        },
        "index": {
          "description": "Check consistency of given proof The supplied rules and axioms are assumed to be correct",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "checkProof",
          "normalized": "Proof a-\u003eBool",
          "package": "swish",
          "partial": "Proof",
          "signature": "Proof ex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:checkProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA proof step is valid if rule is in list of rules\n  and the antecedents are sufficient to obtain the conclusion\n  and the antecedents are in the list of formulae already proven.\n\u003c/p\u003e\u003cp\u003eNote:  this function depends on the ruleName of any rule being\n  unique among all rules.  In particular the name of the step rule\n  being in correspondence with the name of one of the indicated\n  valid rules of inference.\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "checkStep",
          "package": "swish",
          "signature": "[Rule ex]-\u003e [ex]-\u003e Step ex-\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "proof step is valid if rule is in list of rules and the antecedents are sufficient to obtain the conclusion and the antecedents are in the list of formulae already proven Note this function depends on the ruleName of any rule being unique among all rules In particular the name of the step rule being in correspondence with the name of one of the indicated valid rules of inference",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "checkStep",
          "normalized": "[Rule a]-\u003e[a]-\u003eStep a-\u003eBool",
          "package": "swish",
          "partial": "Step",
          "signature": "[Rule ex]-\u003e[ex]-\u003eStep ex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:checkStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck proof. If there is an error then return information\n about the failing step.\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "explainProof",
          "package": "swish",
          "signature": "Proof ex -\u003e Maybe String",
          "source": "src/Swish-Proof.html#explainProof",
          "type": "function"
        },
        "index": {
          "description": "Check proof If there is an error then return information about the failing step",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "explainProof",
          "normalized": "Proof a-\u003eMaybe String",
          "package": "swish",
          "partial": "Proof",
          "signature": "Proof ex-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:explainProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChain of inference rule applications\n   progressing from input to result\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "proofChain",
          "package": "swish",
          "signature": "[Step ex]",
          "source": "src/Swish-Proof.html#Proof",
          "type": "function"
        },
        "index": {
          "description": "Chain of inference rule applications progressing from input to result",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "proofChain",
          "normalized": "[Step a]",
          "package": "swish",
          "partial": "Chain",
          "signature": "[Step ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:proofChain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProof context:  list of rulesets,\n   each of which provides a number of\n   axioms and rules.\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "proofContext",
          "package": "swish",
          "signature": "[Ruleset ex]",
          "source": "src/Swish-Proof.html#Proof",
          "type": "function"
        },
        "index": {
          "description": "Proof context list of rulesets each of which provides number of axioms and rules",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "proofContext",
          "normalized": "[Ruleset a]",
          "package": "swish",
          "partial": "Context",
          "signature": "[Ruleset ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:proofContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven expression\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "proofInput",
          "package": "swish",
          "signature": "Formula ex",
          "source": "src/Swish-Proof.html#Proof",
          "type": "function"
        },
        "index": {
          "description": "Given expression",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "proofInput",
          "package": "swish",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:proofInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eResult expression\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "proofResult",
          "package": "swish",
          "signature": "Formula ex",
          "source": "src/Swish-Proof.html#Proof",
          "type": "function"
        },
        "index": {
          "description": "Result expression",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "proofResult",
          "package": "swish",
          "partial": "Result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:proofResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a simple string representation of a proof.\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "showProof",
          "package": "swish",
          "signature": "String-\u003e Proof ex-\u003e String",
          "type": "function"
        },
        "index": {
          "description": "Returns simple string representation of proof",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "showProof",
          "normalized": "String-\u003eProof a-\u003eString",
          "package": "swish",
          "partial": "Proof",
          "signature": "String-\u003eProof ex-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:showProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a displayable form of a labelled formula\n\u003c/p\u003e",
          "module": "[\"Swish.Proof\",\"Swish.Rule\"]",
          "name": "showsFormula",
          "package": "swish",
          "signature": "String-\u003e Formula ex-\u003e ShowS",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:showsFormula\",\"http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:showsFormula\"]"
        },
        "index": {
          "description": "Create displayable form of labelled formula",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "showsFormula",
          "normalized": "String-\u003eFormula a-\u003eShowS",
          "package": "swish",
          "partial": "Formula",
          "signature": "String-\u003eFormula ex-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:showsFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a displayable form of a proof, returned as a \u003ccode\u003e\u003ca\u003eShowS\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e\u003cp\u003eThis function is intended to allow the calling function some control\n  of multiline displays by providing:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e the first line of the proof is not preceded by any text, so\n      it may be appended to some preceding text on the same line,\n\u003c/li\u003e\u003cli\u003e the supplied newline string is used to separate lines of the\n      formatted text, and may include any desired indentation, and\n\u003c/li\u003e\u003cli\u003e no newline is output following the final line of text.\n\u003c/li\u003e\u003c/ol\u003e",
          "module": "Swish.Proof",
          "name": "showsProof",
          "package": "swish",
          "signature": "String-\u003e Proof ex-\u003e ShowS",
          "type": "function"
        },
        "index": {
          "description": "Create displayable form of proof returned as ShowS value This function is intended to allow the calling function some control of multiline displays by providing the first line of the proof is not preceded by any text so it may be appended to some preceding text on the same line the supplied newline string is used to separate lines of the formatted text and may include any desired indentation and no newline is output following the final line of text",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "showsProof",
          "normalized": "String-\u003eProof a-\u003eShowS",
          "package": "swish",
          "partial": "Proof",
          "signature": "String-\u003eProof ex-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:showsProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAntecedents of inference rule\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "stepAnt",
          "package": "swish",
          "signature": "[Formula ex]",
          "source": "src/Swish-Proof.html#Step",
          "type": "function"
        },
        "index": {
          "description": "Antecedents of inference rule",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "stepAnt",
          "normalized": "[Formula a]",
          "package": "swish",
          "partial": "Ant",
          "signature": "[Formula ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:stepAnt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamed consequence of inference rule\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "stepCon",
          "package": "swish",
          "signature": "Formula ex",
          "source": "src/Swish-Proof.html#Step",
          "type": "function"
        },
        "index": {
          "description": "Named consequence of inference rule",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "stepCon",
          "package": "swish",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:stepCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInference rule used\n\u003c/p\u003e",
          "module": "Swish.Proof",
          "name": "stepRule",
          "package": "swish",
          "signature": "Rule ex",
          "source": "src/Swish-Proof.html#Step",
          "type": "function"
        },
        "index": {
          "description": "Inference rule used",
          "hierarchy": "Swish Proof",
          "module": "Swish.Proof",
          "name": "stepRule",
          "package": "swish",
          "partial": "Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Proof.html#v:stepRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines an algebraic datatype for qualified names (QNames),\n  which represents a \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e as the combination of a namespace \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e\n  and a local component (\u003ccode\u003e\u003ca\u003eLName\u003c/a\u003e\u003c/code\u003e), which can be empty.\n\u003c/p\u003e\u003cp\u003eAlthough RDF supports using IRIs, the use of \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e here precludes this,\n  which means that, for instance, \u003ccode\u003e\u003ca\u003eLName\u003c/a\u003e\u003c/code\u003e only accepts a subset of valid\n  characters. There is currently no attempt to convert from an IRI into a URI.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.QName",
          "name": "QName",
          "package": "swish",
          "source": "src/Swish-QName.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines an algebraic datatype for qualified names QNames which represents URI as the combination of namespace URI and local component LName which can be empty Although RDF supports using IRIs the use of URI here precludes this which means that for instance LName only accepts subset of valid characters There is currently no attempt to convert from an IRI into URI",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "QName",
          "package": "swish",
          "partial": "QName",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA local name, which can be empty.\n\u003c/p\u003e\u003cp\u003eAt present, the local name can not contain a space character and can only\ncontain ascii characters (those that match \u003ccode\u003e\u003ca\u003eisAscii\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eIn version \u003ccode\u003e0.9.0.3\u003c/code\u003e and earlier, the following characters were not\nallowed in local names: '#', ':', or '/' characters.\n\u003c/p\u003e\u003cp\u003eThis is all rather experimental.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "LName",
          "package": "swish",
          "source": "src/Swish-QName.html#LName",
          "type": "data"
        },
        "index": {
          "description": "local name which can be empty At present the local name can not contain space character and can only contain ascii characters those that match isAscii In version and earlier the following characters were not allowed in local names or characters This is all rather experimental",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "LName",
          "package": "swish",
          "partial": "LName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#t:LName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA qualified name, consisting of a namespace URI\nand the local part of the identifier, which can be empty.\nThe serialisation of a QName is formed by concatanating the\ntwo components.\n\u003c/p\u003e\u003cpre\u003e Prelude\u003e :set prompt \"swish\u003e \"\n swish\u003e :set -XOverloadedStrings\n swish\u003e :m + Swish.QName\n swish\u003e let qn1 = \"http://example.com/\" :: QName\n swish\u003e let qn2 = \"http://example.com/bob\" :: QName\n swish\u003e let qn3 = \"http://example.com/bob/fred\" :: QName\n swish\u003e let qn4 = \"http://example.com/bob/fred#x\" :: QName\n swish\u003e let qn5 = \"http://example.com/bob/fred:joe\" :: QName\n swish\u003e map getLocalName [qn1, qn2, qn3, qn4, qn5]\n [\"\",\"bob\",\"fred\",\"x\",\"fred:joe\"]\n swish\u003e getNamespace qn1\n http://example.com/\n swish\u003e getNamespace qn2\n http://example.com/\n swish\u003e getNamespace qn3\n http://example.com/bob/\n swish\u003e getNamespace qn4\n http://example.com/bob/fred#\n\u003c/pre\u003e",
          "module": "Swish.QName",
          "name": "QName",
          "package": "swish",
          "source": "src/Swish-QName.html#QName",
          "type": "data"
        },
        "index": {
          "description": "qualified name consisting of namespace URI and the local part of the identifier which can be empty The serialisation of QName is formed by concatanating the two components Prelude set prompt swish swish set XOverloadedStrings swish Swish.QName swish let qn1 http example.com QName swish let qn2 http example.com bob QName swish let qn3 http example.com bob fred QName swish let qn4 http example.com bob fred QName swish let qn5 http example.com bob fred joe QName swish map getLocalName qn1 qn2 qn3 qn4 qn5 bob fred fred joe swish getNamespace qn1 http example.com swish getNamespace qn2 http example.com swish getNamespace qn3 http example.com bob swish getNamespace qn4 http example.com bob fred",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "QName",
          "package": "swish",
          "partial": "QName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#t:QName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty local name.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "emptyLName",
          "package": "swish",
          "signature": "LName",
          "source": "src/Swish-QName.html#emptyLName",
          "type": "function"
        },
        "index": {
          "description": "The empty local name",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "emptyLName",
          "package": "swish",
          "partial": "LName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:emptyLName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the local name.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "getLName",
          "package": "swish",
          "signature": "LName -\u003e Text",
          "source": "src/Swish-QName.html#getLName",
          "type": "function"
        },
        "index": {
          "description": "Extract the local name",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "getLName",
          "normalized": "LName-\u003eText",
          "package": "swish",
          "partial": "LName",
          "signature": "LName-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:getLName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the local component of the QName.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "getLocalName",
          "package": "swish",
          "signature": "QName -\u003e LName",
          "source": "src/Swish-QName.html#getLocalName",
          "type": "function"
        },
        "index": {
          "description": "Return the local component of the QName",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "getLocalName",
          "normalized": "QName-\u003eLName",
          "package": "swish",
          "partial": "Local Name",
          "signature": "QName-\u003eLName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:getLocalName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the URI of the namespace stored in the QName.\n This does not contain the local component.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "getNamespace",
          "package": "swish",
          "signature": "QName -\u003e URI",
          "source": "src/Swish-QName.html#getNamespace",
          "type": "function"
        },
        "index": {
          "description": "Return the URI of the namespace stored in the QName This does not contain the local component",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "getNamespace",
          "normalized": "QName-\u003eURI",
          "package": "swish",
          "partial": "Namespace",
          "signature": "QName-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:getNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the full URI of the QName (ie the combination of the\n namespace and local components).\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "getQNameURI",
          "package": "swish",
          "signature": "QName -\u003e URI",
          "source": "src/Swish-QName.html#getQNameURI",
          "type": "function"
        },
        "index": {
          "description": "Returns the full URI of the QName ie the combination of the namespace and local components",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "getQNameURI",
          "normalized": "QName-\u003eURI",
          "package": "swish",
          "partial": "QName URI",
          "signature": "QName-\u003eURI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:getQNameURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a local name.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "newLName",
          "package": "swish",
          "signature": "Text -\u003e Maybe LName",
          "source": "src/Swish-QName.html#newLName",
          "type": "function"
        },
        "index": {
          "description": "Create local name",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "newLName",
          "normalized": "Text-\u003eMaybe LName",
          "package": "swish",
          "partial": "LName",
          "signature": "Text-\u003eMaybe LName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:newLName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new qualified name with an explicit local component.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "newQName",
          "package": "swish",
          "signature": "URI-\u003e LName-\u003e QName",
          "type": "function"
        },
        "index": {
          "description": "Create new qualified name with an explicit local component",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "newQName",
          "normalized": "URI-\u003eLName-\u003eQName",
          "package": "swish",
          "partial": "QName",
          "signature": "URI-\u003eLName-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:newQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a filepath to a file: URI stored in a QName. If the\ninput file path is relative then the current working directory is used\nto convert it into an absolute path.\n\u003c/p\u003e\u003cp\u003eIf the input represents a directory then it *must* end in \nthe directory separator - so for Posix systems use \n\u003ccode\u003e\"/foo/bar/\"\u003c/code\u003e rather than \n\u003ccode\u003e\"/foo/bar\"\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis has not been tested on Windows.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "qnameFromFilePath",
          "package": "swish",
          "signature": "FilePath -\u003e IO QName",
          "source": "src/Swish-QName.html#qnameFromFilePath",
          "type": "function"
        },
        "index": {
          "description": "Convert filepath to file URI stored in QName If the input file path is relative then the current working directory is used to convert it into an absolute path If the input represents directory then it must end in the directory separator so for Posix systems use foo bar rather than foo bar This has not been tested on Windows",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "qnameFromFilePath",
          "normalized": "FilePath-\u003eIO QName",
          "package": "swish",
          "partial": "From File Path",
          "signature": "FilePath-\u003eIO QName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:qnameFromFilePath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new qualified name.\n\u003c/p\u003e",
          "module": "Swish.QName",
          "name": "qnameFromURI",
          "package": "swish",
          "signature": "URI-\u003e Maybe QName",
          "type": "function"
        },
        "index": {
          "description": "Create new qualified name",
          "hierarchy": "Swish QName",
          "module": "Swish.QName",
          "name": "qnameFromURI",
          "normalized": "URI-\u003eMaybe QName",
          "package": "swish",
          "partial": "From URI",
          "signature": "URI-\u003eMaybe QName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-QName.html#v:qnameFromURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module collects references and provides access to all of the\n  datatypes built in to Swish.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.BuiltIn.Datatypes",
          "name": "Datatypes",
          "package": "swish",
          "source": "src/Swish-RDF-BuiltIn-Datatypes.html",
          "type": "module"
        },
        "index": {
          "description": "This module collects references and provides access to all of the datatypes built in to Swish",
          "hierarchy": "Swish RDF BuiltIn Datatypes",
          "module": "Swish.RDF.BuiltIn.Datatypes",
          "name": "Datatypes",
          "package": "swish",
          "partial": "Datatypes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Datatypes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAl the data type declarations built into Swish.\n\u003c/p\u003e",
          "module": "Swish.RDF.BuiltIn.Datatypes",
          "name": "allDatatypes",
          "package": "swish",
          "signature": "[RDFDatatype]",
          "source": "src/Swish-RDF-BuiltIn-Datatypes.html#allDatatypes",
          "type": "function"
        },
        "index": {
          "description": "Al the data type declarations built into Swish",
          "hierarchy": "Swish RDF BuiltIn Datatypes",
          "module": "Swish.RDF.BuiltIn.Datatypes",
          "name": "allDatatypes",
          "normalized": "[RDFDatatype]",
          "package": "swish",
          "partial": "Datatypes",
          "signature": "[RDFDatatype]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Datatypes.html#v:allDatatypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLook up a data type declaration.\n\u003c/p\u003e",
          "module": "[\"Swish.RDF.BuiltIn.Datatypes\",\"Swish.RDF.BuiltIn\"]",
          "name": "findRDFDatatype",
          "package": "swish",
          "signature": "ScopedName -\u003e Maybe RDFDatatype",
          "source": "src/Swish-RDF-BuiltIn-Datatypes.html#findRDFDatatype",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Datatypes.html#v:findRDFDatatype\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn.html#v:findRDFDatatype\"]"
        },
        "index": {
          "description": "Look up data type declaration",
          "hierarchy": "Swish RDF BuiltIn Datatypes",
          "module": "Swish.RDF.BuiltIn.Datatypes",
          "name": "findRDFDatatype",
          "normalized": "ScopedName-\u003eMaybe RDFDatatype",
          "package": "swish",
          "partial": "RDFDatatype",
          "signature": "ScopedName-\u003eMaybe RDFDatatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Datatypes.html#v:findRDFDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module collects references and provides access to all of the\n  rulesets, variable binding modifiers and variable binding filters\n  built in to Swish.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.BuiltIn.Rules",
          "name": "Rules",
          "package": "swish",
          "source": "src/Swish-RDF-BuiltIn-Rules.html",
          "type": "module"
        },
        "index": {
          "description": "This module collects references and provides access to all of the rulesets variable binding modifiers and variable binding filters built in to Swish",
          "hierarchy": "Swish RDF BuiltIn Rules",
          "module": "Swish.RDF.BuiltIn.Rules",
          "name": "Rules",
          "package": "swish",
          "partial": "Rules",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe data type rule sets known to Swish.\n\u003c/p\u003e",
          "module": "[\"Swish.RDF.BuiltIn.Rules\",\"Swish.RDF.BuiltIn\"]",
          "name": "allDatatypeRulesets",
          "package": "swish",
          "signature": "[RDFRuleset]",
          "source": "src/Swish-RDF-BuiltIn-Rules.html#allDatatypeRulesets",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:allDatatypeRulesets\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn.html#v:allDatatypeRulesets\"]"
        },
        "index": {
          "description": "The data type rule sets known to Swish",
          "hierarchy": "Swish RDF BuiltIn Rules",
          "module": "Swish.RDF.BuiltIn.Rules",
          "name": "allDatatypeRulesets",
          "normalized": "[RDFRuleset]",
          "package": "swish",
          "partial": "Datatype Rulesets",
          "signature": "[RDFRuleset]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:allDatatypeRulesets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll the rule sets known to Swish.\n\u003c/p\u003e",
          "module": "[\"Swish.RDF.BuiltIn.Rules\",\"Swish.RDF.BuiltIn\"]",
          "name": "allRulesets",
          "package": "swish",
          "signature": "[RDFRuleset]",
          "source": "src/Swish-RDF-BuiltIn-Rules.html#allRulesets",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:allRulesets\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn.html#v:allRulesets\"]"
        },
        "index": {
          "description": "All the rule sets known to Swish",
          "hierarchy": "Swish RDF BuiltIn Rules",
          "module": "Swish.RDF.BuiltIn.Rules",
          "name": "allRulesets",
          "normalized": "[RDFRuleset]",
          "package": "swish",
          "partial": "Rulesets",
          "signature": "[RDFRuleset]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:allRulesets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the named open variable binding modifier.\n\u003c/p\u003e",
          "module": "[\"Swish.RDF.BuiltIn.Rules\",\"Swish.RDF.BuiltIn\"]",
          "name": "findRDFOpenVarBindingModifier",
          "package": "swish",
          "signature": "ScopedName -\u003e Maybe RDFOpenVarBindingModify",
          "source": "src/Swish-RDF-BuiltIn-Rules.html#findRDFOpenVarBindingModifier",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:findRDFOpenVarBindingModifier\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn.html#v:findRDFOpenVarBindingModifier\"]"
        },
        "index": {
          "description": "Find the named open variable binding modifier",
          "hierarchy": "Swish RDF BuiltIn Rules",
          "module": "Swish.RDF.BuiltIn.Rules",
          "name": "findRDFOpenVarBindingModifier",
          "normalized": "ScopedName-\u003eMaybe RDFOpenVarBindingModify",
          "package": "swish",
          "partial": "RDFOpen Var Binding Modifier",
          "signature": "ScopedName-\u003eMaybe RDFOpenVarBindingModify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:findRDFOpenVarBindingModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003eLookupMap\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eallRulesets\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Swish.RDF.BuiltIn.Rules\",\"Swish.RDF.BuiltIn\"]",
          "name": "rdfRulesetMap",
          "package": "swish",
          "signature": "RDFRulesetMap",
          "source": "src/Swish-RDF-BuiltIn-Rules.html#rdfRulesetMap",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:rdfRulesetMap\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn.html#v:rdfRulesetMap\"]"
        },
        "index": {
          "description": "LookupMap of allRulesets",
          "hierarchy": "Swish RDF BuiltIn Rules",
          "module": "Swish.RDF.BuiltIn.Rules",
          "name": "rdfRulesetMap",
          "package": "swish",
          "partial": "Ruleset Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn-Rules.html#v:rdfRulesetMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module collects references and provides access to all of the\n  datatypes, variable binding modifiers and variable binding filters\n  built in to Swish.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.BuiltIn",
          "name": "BuiltIn",
          "package": "swish",
          "source": "src/Swish-RDF-BuiltIn.html",
          "type": "module"
        },
        "index": {
          "description": "This module collects references and provides access to all of the datatypes variable binding modifiers and variable binding filters built in to Swish",
          "hierarchy": "Swish RDF BuiltIn",
          "module": "Swish.RDF.BuiltIn",
          "name": "BuiltIn",
          "package": "swish",
          "partial": "Built In",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-BuiltIn.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements an inference rule based on a restruction on class\n  membership of one or more values.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestrictionRule",
          "package": "swish",
          "source": "src/Swish-RDF-ClassRestrictionRule.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements an inference rule based on restruction on class membership of one or more values",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestrictionRule",
          "package": "swish",
          "partial": "Class Restriction Rule",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype for named class restriction\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestriction",
          "package": "swish",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#ClassRestriction",
          "type": "data"
        },
        "index": {
          "description": "Datatype for named class restriction",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestriction",
          "package": "swish",
          "partial": "Class Restriction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#t:ClassRestriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of function that evaluates missing node values in a\n  restriction from those supplied.\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestrictionFn",
          "package": "swish",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#ClassRestrictionFn",
          "type": "type"
        },
        "index": {
          "description": "Type of function that evaluates missing node values in restriction from those supplied",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestrictionFn",
          "package": "swish",
          "partial": "Class Restriction Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#t:ClassRestrictionFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestriction",
          "package": "swish",
          "signature": "ClassRestriction",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#ClassRestriction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "ClassRestriction",
          "package": "swish",
          "partial": "Class Restriction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:ClassRestriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "crFunc",
          "package": "swish",
          "signature": "ClassRestrictionFn",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#ClassRestriction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "crFunc",
          "package": "swish",
          "partial": "Func",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:crFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "crName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#ClassRestriction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "crName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:crName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe graph\n\u003c/p\u003e\u003cpre\u003e _:a \u003chttp://id.ninebynine.org/2003/rdfext/rdfd#false\u003e _:b .\n\u003c/pre\u003e\u003cp\u003eExported for testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "falseGraph",
          "package": "swish",
          "signature": "RDFGraph",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#falseGraph",
          "type": "function"
        },
        "index": {
          "description": "The graph http id.ninebynine.org rdfext rdfd false Exported for testing",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "falseGraph",
          "package": "swish",
          "partial": "Graph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:falseGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExported for testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "falseGraphStr",
          "package": "swish",
          "signature": "Builder",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#falseGraphStr",
          "type": "function"
        },
        "index": {
          "description": "Exported for testing",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "falseGraphStr",
          "package": "swish",
          "partial": "Graph Str",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:falseGraphStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a class restriction from a datatype relation.\n\u003c/p\u003e\u003cp\u003eThis lifts application of the datatype relation to operate\n  on \u003ccode\u003e\u003ca\u003eRDFLabel\u003c/a\u003e\u003c/code\u003e values, which are presumed to contain appropriately\n  datatyped values.\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeDatatypeRestriction",
          "package": "swish",
          "signature": "RDFDatatypeVal vt -\u003e DatatypeRel vt -\u003e ClassRestriction",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#makeDatatypeRestriction",
          "type": "function"
        },
        "index": {
          "description": "Make class restriction from datatype relation This lifts application of the datatype relation to operate on RDFLabel values which are presumed to contain appropriately datatyped values",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeDatatypeRestriction",
          "normalized": "RDFDatatypeVal a-\u003eDatatypeRel a-\u003eClassRestriction",
          "package": "swish",
          "partial": "Datatype Restriction",
          "signature": "RDFDatatypeVal vt-\u003eDatatypeRel vt-\u003eClassRestriction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:makeDatatypeRestriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a class restriction function from a datatype relation function.\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeDatatypeRestrictionFn",
          "package": "swish",
          "signature": "RDFDatatypeVal vt -\u003e DatatypeRelFn vt -\u003e ClassRestrictionFn",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#makeDatatypeRestrictionFn",
          "type": "function"
        },
        "index": {
          "description": "Make class restriction function from datatype relation function",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeDatatypeRestrictionFn",
          "normalized": "RDFDatatypeVal a-\u003eDatatypeRelFn a-\u003eClassRestrictionFn",
          "package": "swish",
          "partial": "Datatype Restriction Fn",
          "signature": "RDFDatatypeVal vt-\u003eDatatypeRelFn vt-\u003eClassRestrictionFn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:makeDatatypeRestrictionFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a list of class restriction rules given a list of class restriction\n  values and a graph containing one or more class restriction definitions.\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeRDFClassRestrictionRules",
          "package": "swish",
          "signature": "[ClassRestriction] -\u003e RDFGraph -\u003e [RDFRule]",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#makeRDFClassRestrictionRules",
          "type": "function"
        },
        "index": {
          "description": "Make list of class restriction rules given list of class restriction values and graph containing one or more class restriction definitions",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeRDFClassRestrictionRules",
          "normalized": "[ClassRestriction]-\u003eRDFGraph-\u003e[RDFRule]",
          "package": "swish",
          "partial": "RDFClass Restriction Rules",
          "signature": "[ClassRestriction]-\u003eRDFGraph-\u003e[RDFRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:makeRDFClassRestrictionRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake restriction rules from the supplied datatype and graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeRDFDatatypeRestrictionRules",
          "package": "swish",
          "signature": "RDFDatatypeVal vt -\u003e RDFGraph -\u003e [RDFRule]",
          "source": "src/Swish-RDF-ClassRestrictionRule.html#makeRDFDatatypeRestrictionRules",
          "type": "function"
        },
        "index": {
          "description": "Make restriction rules from the supplied datatype and graph",
          "hierarchy": "Swish RDF ClassRestrictionRule",
          "module": "Swish.RDF.ClassRestrictionRule",
          "name": "makeRDFDatatypeRestrictionRules",
          "normalized": "RDFDatatypeVal a-\u003eRDFGraph-\u003e[RDFRule]",
          "package": "swish",
          "partial": "RDFDatatype Restriction Rules",
          "signature": "RDFDatatypeVal vt-\u003eRDFGraph-\u003e[RDFRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ClassRestrictionRule.html#v:makeRDFDatatypeRestrictionRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the structures used to represent and\n  manipulate RDF \u003ccode\u003exsd:decimal\u003c/code\u003e datatyped literals.\n\u003c/p\u003e\u003cp\u003eNote that in versions \u003ccode\u003e0.6.4\u003c/code\u003e and \u003ccode\u003e0.6.5\u003c/code\u003e, this module was a mixture\n  of support for \u003ccode\u003exsd:decimal\u003c/code\u003e and \u003ccode\u003exsd:double\u003c/code\u003e. In \u003ccode\u003e0.7.0\u003c/code\u003e the module\n  has been changed to \u003ccode\u003exsd:decimal\u003c/code\u003e, but this may change.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "Decimal",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype-XSD-Decimal.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the structures used to represent and manipulate RDF xsd decimal datatyped literals Note that in versions and this module was mixture of support for xsd decimal and xsd double In the module has been changed to xsd decimal but this may change",
          "hierarchy": "Swish RDF Datatype XSD Decimal",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "Decimal",
          "package": "swish",
          "partial": "Decimal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Decimal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe axioms for \u003ccode\u003exsd:decimal\u003c/code\u003e, which are\n\u003c/p\u003e\u003cpre\u003e xsd:decimal a rdfs:Datatype .\n\u003c/pre\u003e",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "axiomsXsdDecimal",
          "package": "swish",
          "signature": "[RDFFormula]",
          "source": "src/Swish-RDF-Datatype-XSD-Decimal.html#axiomsXsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "The axioms for xsd decimal which are xsd decimal rdfs Datatype",
          "hierarchy": "Swish RDF Datatype XSD Decimal",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "axiomsXsdDecimal",
          "normalized": "[RDFFormula]",
          "package": "swish",
          "partial": "Xsd Decimal",
          "signature": "[RDFFormula]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Decimal.html#v:axiomsXsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace for \u003ccode\u003exsd:decimal\u003c/code\u003e datatype functions.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "namespaceXsdDecimal",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Datatype-XSD-Decimal.html#namespaceXsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "Namespace for xsd decimal datatype functions",
          "hierarchy": "Swish RDF Datatype XSD Decimal",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "namespaceXsdDecimal",
          "package": "swish",
          "partial": "Xsd Decimal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Decimal.html#v:namespaceXsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine Datatype value for \u003ccode\u003exsd:decimal\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMembers of this datatype decimal values.\n\u003c/p\u003e\u003cp\u003eThe lexical form consists of an optional \u003ccode\u003e+\u003c/code\u003e or \u003ccode\u003e-\u003c/code\u003e\n  followed by a sequence of decimal digits, an optional\n  decimal point and a sequence of decimal digits.\n\u003c/p\u003e\u003cp\u003eThe canonical lexical form has leading zeros and \u003ccode\u003e+\u003c/code\u003e sign removed.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "rdfDatatypeValXsdDecimal",
          "package": "swish",
          "signature": "RDFDatatypeVal Double",
          "source": "src/Swish-RDF-Datatype-XSD-Decimal.html#rdfDatatypeValXsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "Define Datatype value for xsd decimal Members of this datatype decimal values The lexical form consists of an optional or followed by sequence of decimal digits an optional decimal point and sequence of decimal digits The canonical lexical form has leading zeros and sign removed",
          "hierarchy": "Swish RDF Datatype XSD Decimal",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "rdfDatatypeValXsdDecimal",
          "package": "swish",
          "partial": "Datatype Val Xsd Decimal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Decimal.html#v:rdfDatatypeValXsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe RDFDatatype value for \u003ccode\u003exsd:decimal\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "rdfDatatypeXsdDecimal",
          "package": "swish",
          "signature": "RDFDatatype",
          "source": "src/Swish-RDF-Datatype-XSD-Decimal.html#rdfDatatypeXsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "The RDFDatatype value for xsd decimal",
          "hierarchy": "Swish RDF Datatype XSD Decimal",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "rdfDatatypeXsdDecimal",
          "package": "swish",
          "partial": "Datatype Xsd Decimal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Decimal.html#v:rdfDatatypeXsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rules for \u003ccode\u003exsd:decimal\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "rulesXsdDecimal",
          "package": "swish",
          "signature": "[RDFRule]",
          "source": "src/Swish-RDF-Datatype-XSD-Decimal.html#rulesXsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "The rules for xsd decimal",
          "hierarchy": "Swish RDF Datatype XSD Decimal",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "rulesXsdDecimal",
          "normalized": "[RDFRule]",
          "package": "swish",
          "partial": "Xsd Decimal",
          "signature": "[RDFRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Decimal.html#v:rulesXsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType name for \u003ccode\u003exsd:decimal\u003c/code\u003e datatype.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "typeNameXsdDecimal",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Datatype-XSD-Decimal.html#typeNameXsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "Type name for xsd decimal datatype",
          "hierarchy": "Swish RDF Datatype XSD Decimal",
          "module": "Swish.RDF.Datatype.XSD.Decimal",
          "name": "typeNameXsdDecimal",
          "package": "swish",
          "partial": "Name Xsd Decimal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Decimal.html#v:typeNameXsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the structures used to represent and\n  manipulate RDF \u003ccode\u003exsd:integer\u003c/code\u003e datatyped literals.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "Integer",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype-XSD-Integer.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the structures used to represent and manipulate RDF xsd integer datatyped literals",
          "hierarchy": "Swish RDF Datatype XSD Integer",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "Integer",
          "package": "swish",
          "partial": "Integer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Integer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe axioms for \u003ccode\u003exsd:integer\u003c/code\u003e, which are\n\u003c/p\u003e\u003cpre\u003e xsd:integer a rdfs:Datatype .\n\u003c/pre\u003e",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "axiomsXsdInteger",
          "package": "swish",
          "signature": "[RDFFormula]",
          "source": "src/Swish-RDF-Datatype-XSD-Integer.html#axiomsXsdInteger",
          "type": "function"
        },
        "index": {
          "description": "The axioms for xsd integer which are xsd integer rdfs Datatype",
          "hierarchy": "Swish RDF Datatype XSD Integer",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "axiomsXsdInteger",
          "normalized": "[RDFFormula]",
          "package": "swish",
          "partial": "Xsd Integer",
          "signature": "[RDFFormula]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Integer.html#v:axiomsXsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace for \u003ccode\u003exsd:integer\u003c/code\u003e datatype functions.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "namespaceXsdInteger",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Datatype-XSD-Integer.html#namespaceXsdInteger",
          "type": "function"
        },
        "index": {
          "description": "Namespace for xsd integer datatype functions",
          "hierarchy": "Swish RDF Datatype XSD Integer",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "namespaceXsdInteger",
          "package": "swish",
          "partial": "Xsd Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Integer.html#v:namespaceXsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine Datatype value for \u003ccode\u003exsd:integer\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMembers of this datatype are positive or negative integer values.\n\u003c/p\u003e\u003cp\u003eThe lexical form consists of an optional \u003ccode\u003e+\u003c/code\u003e or \u003ccode\u003e-\u003c/code\u003e\n  followed by a sequence of decimal digits.\n\u003c/p\u003e\u003cp\u003eThe canonical lexical form has leading zeros and \u003ccode\u003e+\u003c/code\u003e sign removed.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "rdfDatatypeValXsdInteger",
          "package": "swish",
          "signature": "RDFDatatypeVal Integer",
          "source": "src/Swish-RDF-Datatype-XSD-Integer.html#rdfDatatypeValXsdInteger",
          "type": "function"
        },
        "index": {
          "description": "Define Datatype value for xsd integer Members of this datatype are positive or negative integer values The lexical form consists of an optional or followed by sequence of decimal digits The canonical lexical form has leading zeros and sign removed",
          "hierarchy": "Swish RDF Datatype XSD Integer",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "rdfDatatypeValXsdInteger",
          "package": "swish",
          "partial": "Datatype Val Xsd Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Integer.html#v:rdfDatatypeValXsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe RDFDatatype value for \u003ccode\u003exsd:integer\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "rdfDatatypeXsdInteger",
          "package": "swish",
          "signature": "RDFDatatype",
          "source": "src/Swish-RDF-Datatype-XSD-Integer.html#rdfDatatypeXsdInteger",
          "type": "function"
        },
        "index": {
          "description": "The RDFDatatype value for xsd integer",
          "hierarchy": "Swish RDF Datatype XSD Integer",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "rdfDatatypeXsdInteger",
          "package": "swish",
          "partial": "Datatype Xsd Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Integer.html#v:rdfDatatypeXsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rules for \u003ccode\u003exsd:integer\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "rulesXsdInteger",
          "package": "swish",
          "signature": "[RDFRule]",
          "source": "src/Swish-RDF-Datatype-XSD-Integer.html#rulesXsdInteger",
          "type": "function"
        },
        "index": {
          "description": "The rules for xsd integer",
          "hierarchy": "Swish RDF Datatype XSD Integer",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "rulesXsdInteger",
          "normalized": "[RDFRule]",
          "package": "swish",
          "partial": "Xsd Integer",
          "signature": "[RDFRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Integer.html#v:rulesXsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType name for \u003ccode\u003exsd:integer\u003c/code\u003e datatype.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "typeNameXsdInteger",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Datatype-XSD-Integer.html#typeNameXsdInteger",
          "type": "function"
        },
        "index": {
          "description": "Type name for xsd integer datatype",
          "hierarchy": "Swish RDF Datatype XSD Integer",
          "module": "Swish.RDF.Datatype.XSD.Integer",
          "name": "typeNameXsdInteger",
          "package": "swish",
          "partial": "Name Xsd Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-Integer.html#v:typeNameXsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the datatytpe mapping and relation values\n  used for RDF dataype \u003ccode\u003exsd:decimal\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Datatype.XSD.MapDecimal",
          "name": "MapDecimal",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype-XSD-MapDecimal.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the datatytpe mapping and relation values used for RDF dataype xsd decimal",
          "hierarchy": "Swish RDF Datatype XSD MapDecimal",
          "module": "Swish.RDF.Datatype.XSD.MapDecimal",
          "name": "MapDecimal",
          "package": "swish",
          "partial": "Map Decimal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-MapDecimal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctions that perform lexical-to-value\n  and value-to-canonical-lexical mappings for \u003ccode\u003exsd:decimal\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.MapDecimal",
          "name": "mapXsdDecimal",
          "package": "swish",
          "signature": "DatatypeMap Double",
          "source": "src/Swish-RDF-Datatype-XSD-MapDecimal.html#mapXsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "Functions that perform lexical-to-value and value-to-canonical-lexical mappings for xsd decimal values",
          "hierarchy": "Swish RDF Datatype XSD MapDecimal",
          "module": "Swish.RDF.Datatype.XSD.MapDecimal",
          "name": "mapXsdDecimal",
          "package": "swish",
          "partial": "Xsd Decimal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-MapDecimal.html#v:mapXsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the datatytpe mapping and relation values\n  used for RDF dataype \u003ccode\u003exsd:integer\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Datatype.XSD.MapInteger",
          "name": "MapInteger",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype-XSD-MapInteger.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the datatytpe mapping and relation values used for RDF dataype xsd integer",
          "hierarchy": "Swish RDF Datatype XSD MapInteger",
          "module": "Swish.RDF.Datatype.XSD.MapInteger",
          "name": "MapInteger",
          "package": "swish",
          "partial": "Map Integer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-MapInteger.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctions that perform lexical-to-value\n  and value-to-canonical-lexical mappings for \u003ccode\u003exsd:integer\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.MapInteger",
          "name": "mapXsdInteger",
          "package": "swish",
          "signature": "DatatypeMap Integer",
          "source": "src/Swish-RDF-Datatype-XSD-MapInteger.html#mapXsdInteger",
          "type": "function"
        },
        "index": {
          "description": "Functions that perform lexical-to-value and value-to-canonical-lexical mappings for xsd integer values",
          "hierarchy": "Swish RDF Datatype XSD MapInteger",
          "module": "Swish.RDF.Datatype.XSD.MapInteger",
          "name": "mapXsdInteger",
          "package": "swish",
          "partial": "Xsd Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-MapInteger.html#v:mapXsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the structures used to represent and\n  manipulate RDF \u003ccode\u003exsd:string\u003c/code\u003e datatyped literals.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "String",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype-XSD-String.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the structures used to represent and manipulate RDF xsd string datatyped literals",
          "hierarchy": "Swish RDF Datatype XSD String",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "String",
          "package": "swish",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe axioms for \u003ccode\u003exsd:string\u003c/code\u003e, which are\n\u003c/p\u003e\u003cpre\u003e xsd:string a rdfs:Datatype .\n\u003c/pre\u003e",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "axiomsXsdString",
          "package": "swish",
          "signature": "[RDFFormula]",
          "source": "src/Swish-RDF-Datatype-XSD-String.html#axiomsXsdString",
          "type": "function"
        },
        "index": {
          "description": "The axioms for xsd string which are xsd string rdfs Datatype",
          "hierarchy": "Swish RDF Datatype XSD String",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "axiomsXsdString",
          "normalized": "[RDFFormula]",
          "package": "swish",
          "partial": "Xsd String",
          "signature": "[RDFFormula]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-String.html#v:axiomsXsdString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace for \u003ccode\u003exsd:string\u003c/code\u003e datatype functions\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "namespaceXsdString",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Datatype-XSD-String.html#namespaceXsdString",
          "type": "function"
        },
        "index": {
          "description": "Namespace for xsd string datatype functions",
          "hierarchy": "Swish RDF Datatype XSD String",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "namespaceXsdString",
          "package": "swish",
          "partial": "Xsd String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-String.html#v:namespaceXsdString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine Datatype value for \u003ccode\u003exsd:string\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "rdfDatatypeValXsdString",
          "package": "swish",
          "signature": "RDFDatatypeVal Text",
          "source": "src/Swish-RDF-Datatype-XSD-String.html#rdfDatatypeValXsdString",
          "type": "function"
        },
        "index": {
          "description": "Define Datatype value for xsd string",
          "hierarchy": "Swish RDF Datatype XSD String",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "rdfDatatypeValXsdString",
          "package": "swish",
          "partial": "Datatype Val Xsd String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-String.html#v:rdfDatatypeValXsdString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe RDFDatatype value for \u003ccode\u003exsd:string\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "rdfDatatypeXsdString",
          "package": "swish",
          "signature": "RDFDatatype",
          "source": "src/Swish-RDF-Datatype-XSD-String.html#rdfDatatypeXsdString",
          "type": "function"
        },
        "index": {
          "description": "The RDFDatatype value for xsd string",
          "hierarchy": "Swish RDF Datatype XSD String",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "rdfDatatypeXsdString",
          "package": "swish",
          "partial": "Datatype Xsd String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-String.html#v:rdfDatatypeXsdString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rules for \u003ccode\u003exsd:string\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "rulesXsdString",
          "package": "swish",
          "signature": "[RDFRule]",
          "source": "src/Swish-RDF-Datatype-XSD-String.html#rulesXsdString",
          "type": "function"
        },
        "index": {
          "description": "The rules for xsd string",
          "hierarchy": "Swish RDF Datatype XSD String",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "rulesXsdString",
          "normalized": "[RDFRule]",
          "package": "swish",
          "partial": "Xsd String",
          "signature": "[RDFRule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-String.html#v:rulesXsdString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType name for \u003ccode\u003exsd:string\u003c/code\u003e datatype\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "typeNameXsdString",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Datatype-XSD-String.html#typeNameXsdString",
          "type": "function"
        },
        "index": {
          "description": "Type name for xsd string datatype",
          "hierarchy": "Swish RDF Datatype XSD String",
          "module": "Swish.RDF.Datatype.XSD.String",
          "name": "typeNameXsdString",
          "package": "swish",
          "partial": "Name Xsd String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype-XSD-String.html#v:typeNameXsdString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the structures used by Swish to represent and\n  manipulate RDF datatypes.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "Datatype",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the structures used by Swish to represent and manipulate RDF datatypes",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "Datatype",
          "package": "swish",
          "partial": "Datatype",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF value modifier application function type\n\u003c/p\u003e\u003cp\u003eThis indicates a function that applies RDFModifierFn functions.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "RDFApplyModifier",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype.html#RDFApplyModifier",
          "type": "type"
        },
        "index": {
          "description": "RDF value modifier application function type This indicates function that applies RDFModifierFn functions",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "RDFApplyModifier",
          "package": "swish",
          "partial": "RDFApply Modifier",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#t:RDFApplyModifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF datatype wrapper used with RDF graph values\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatype",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype.html#RDFDatatype",
          "type": "type"
        },
        "index": {
          "description": "RDF datatype wrapper used with RDF graph values",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatype",
          "package": "swish",
          "partial": "RDFDatatype",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#t:RDFDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF datatype modifier used with RDF graph values\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatypeMod",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype.html#RDFDatatypeMod",
          "type": "type"
        },
        "index": {
          "description": "RDF datatype modifier used with RDF graph values",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatypeMod",
          "package": "swish",
          "partial": "RDFDatatype Mod",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#t:RDFDatatypeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribe a subtype/supertype relationship between a pair\n  of RDF datatypes.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatypeSub",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype.html#RDFDatatypeSub",
          "type": "type"
        },
        "index": {
          "description": "Describe subtype supertype relationship between pair of RDF datatypes",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatypeSub",
          "package": "swish",
          "partial": "RDFDatatype Sub",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#t:RDFDatatypeSub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF datatype value used with RDF graph values\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatypeVal",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype.html#RDFDatatypeVal",
          "type": "type"
        },
        "index": {
          "description": "RDF datatype value used with RDF graph values",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "RDFDatatypeVal",
          "package": "swish",
          "partial": "RDFDatatype Val",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#t:RDFDatatypeVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF value modifier function type\n\u003c/p\u003e\u003cp\u003eThis indicates a modifier function that operates on \u003ccode\u003e\u003ca\u003eRDFLabel\u003c/a\u003e\u003c/code\u003e values.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "RDFModifierFn",
          "package": "swish",
          "source": "src/Swish-RDF-Datatype.html#RDFModifierFn",
          "type": "type"
        },
        "index": {
          "description": "RDF value modifier function type This indicates modifier function that operates on RDFLabel values",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "RDFModifierFn",
          "package": "swish",
          "partial": "RDFModifier Fn",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#t:RDFModifierFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a datatype modifier using supplied RDF labels to a supplied\n  RDF variable binding.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "applyRDFDatatypeMod",
          "package": "swish",
          "signature": "RDFDatatypeVal vt -\u003e RDFDatatypeMod vt -\u003e [RDFLabel] -\u003e [RDFVarBinding] -\u003e [RDFVarBinding]",
          "source": "src/Swish-RDF-Datatype.html#applyRDFDatatypeMod",
          "type": "function"
        },
        "index": {
          "description": "Apply datatype modifier using supplied RDF labels to supplied RDF variable binding",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "applyRDFDatatypeMod",
          "normalized": "RDFDatatypeVal a-\u003eRDFDatatypeMod a-\u003e[RDFLabel]-\u003e[RDFVarBinding]-\u003e[RDFVarBinding]",
          "package": "swish",
          "partial": "RDFDatatype Mod",
          "signature": "RDFDatatypeVal vt-\u003eRDFDatatypeMod vt-\u003e[RDFLabel]-\u003e[RDFVarBinding]-\u003e[RDFVarBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#v:applyRDFDatatypeMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from a typed literal to a Haskell value,\n with the possibility of failure.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "fromRDFLabel",
          "package": "swish",
          "signature": "RDFDatatypeVal vt -\u003e RDFLabel -\u003e Maybe vt",
          "source": "src/Swish-RDF-Datatype.html#fromRDFLabel",
          "type": "function"
        },
        "index": {
          "description": "Convert from typed literal to Haskell value with the possibility of failure",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "fromRDFLabel",
          "normalized": "RDFDatatypeVal a-\u003eRDFLabel-\u003eMaybe a",
          "package": "swish",
          "partial": "RDFLabel",
          "signature": "RDFDatatypeVal vt-\u003eRDFLabel-\u003eMaybe vt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#v:fromRDFLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a typed literal. No conversion is made to the\n string representation.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "makeDatatypedLiteral",
          "package": "swish",
          "signature": "ScopedName-\u003e Text-\u003e RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "Create typed literal No conversion is made to the string representation",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "makeDatatypedLiteral",
          "normalized": "ScopedName-\u003eText-\u003eRDFLabel",
          "package": "swish",
          "partial": "Datatyped Literal",
          "signature": "ScopedName-\u003eText-\u003eRDFLabel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#v:makeDatatypedLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate all RDFOpenVarBindingModify values for a given datatype value.\n  See \u003ccode\u003e\u003ca\u003emakeRdfDtOpenVarBindingModify\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "makeRdfDtOpenVarBindingModifiers",
          "package": "swish",
          "signature": "RDFDatatypeVal vt-\u003e [RDFOpenVarBindingModify]",
          "type": "function"
        },
        "index": {
          "description": "Create all RDFOpenVarBindingModify values for given datatype value See makeRdfDtOpenVarBindingModify",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "makeRdfDtOpenVarBindingModifiers",
          "normalized": "RDFDatatypeVal a-\u003e[RDFOpenVarBindingModify]",
          "package": "swish",
          "partial": "Rdf Dt Open Var Binding Modifiers",
          "signature": "RDFDatatypeVal vt-\u003e[RDFOpenVarBindingModify]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#v:makeRdfDtOpenVarBindingModifiers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an \u003ccode\u003e\u003ca\u003eRDFOpenVarBindingModify\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e\u003cp\u003eThe key purpose of this function is to lift the supplied\n  variable constraint functions from operating on data values directly\n  to a corresponding list of functions that operate on values contained\n  in RDF graph labels (i.e. RDF literal nodes).  It also applies\n  node type checking, such that if the actual RDF nodes supplied do\n  not contain appropriate values then the variable binding is not\n  accepted.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "makeRdfDtOpenVarBindingModify",
          "package": "swish",
          "signature": "RDFDatatypeVal vt-\u003e RDFDatatypeMod vt-\u003e RDFOpenVarBindingModify",
          "type": "function"
        },
        "index": {
          "description": "Create an RDFOpenVarBindingModify value The key purpose of this function is to lift the supplied variable constraint functions from operating on data values directly to corresponding list of functions that operate on values contained in RDF graph labels i.e RDF literal nodes It also applies node type checking such that if the actual RDF nodes supplied do not contain appropriate values then the variable binding is not accepted",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "makeRdfDtOpenVarBindingModify",
          "normalized": "RDFDatatypeVal a-\u003eRDFDatatypeMod a-\u003eRDFOpenVarBindingModify",
          "package": "swish",
          "partial": "Rdf Dt Open Var Binding Modify",
          "signature": "RDFDatatypeVal vt-\u003eRDFDatatypeMod vt-\u003eRDFOpenVarBindingModify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#v:makeRdfDtOpenVarBindingModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a Haskell value to a typed literal (label),\n with the possibility of failure.\n\u003c/p\u003e",
          "module": "Swish.RDF.Datatype",
          "name": "toRDFLabel",
          "package": "swish",
          "signature": "RDFDatatypeVal vt -\u003e vt -\u003e Maybe RDFLabel",
          "source": "src/Swish-RDF-Datatype.html#toRDFLabel",
          "type": "function"
        },
        "index": {
          "description": "Convert Haskell value to typed literal label with the possibility of failure",
          "hierarchy": "Swish RDF Datatype",
          "module": "Swish.RDF.Datatype",
          "name": "toRDFLabel",
          "normalized": "RDFDatatypeVal a-\u003ea-\u003eMaybe RDFLabel",
          "package": "swish",
          "partial": "RDFLabel",
          "signature": "RDFDatatypeVal vt-\u003evt-\u003eMaybe RDFLabel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Datatype.html#v:toRDFLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis Module implements a Notation 3 formatter\n  for an \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e\u003cp\u003eREFERENCES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"Notation3 (N3): A readable RDF syntax\",\n     W3C Team Submission 14 January 2008,\n     \u003ca\u003ehttp://www.w3.org/TeamSubmission/2008/SUBM-n3-20080114/\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Tim Berners-Lee's design issues series notes and description,\n     \u003ca\u003ehttp://www.w3.org/DesignIssues/Notation3.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Notation 3 Primer by Sean Palmer,\n      \u003ca\u003ehttp://www.w3.org/2000/10/swap/Primer.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTODO:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Initial prefix list to include nested formulae;\n      then don't need to update prefix list for these.\n\u003c/li\u003e\u003cli\u003e correct output of strings containing unsupported escape\n     characters (such as \u003ccode\u003e\\q\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e more flexible terminator generation for formatted formulae\n     (for inline blank nodes.)\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Formatter.N3",
          "name": "N3",
          "package": "swish",
          "source": "src/Swish-RDF-Formatter-N3.html",
          "type": "module"
        },
        "index": {
          "description": "This Module implements Notation formatter for an RDFGraph value REFERENCES Notation3 N3 readable RDF syntax W3C Team Submission January http www.w3.org TeamSubmission SUBM-n3-20080114 Tim Berners-Lee design issues series notes and description http www.w3.org DesignIssues Notation3.html Notation Primer by Sean Palmer http www.w3.org swap Primer.html TODO Initial prefix list to include nested formulae then don need to update prefix list for these correct output of strings containing unsupported escape characters such as more flexible terminator generation for formatted formulae for inline blank nodes",
          "hierarchy": "Swish RDF Formatter N3",
          "module": "Swish.RDF.Formatter.N3",
          "name": "N3",
          "package": "swish",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNode name generation state information that carries through\n  and is updated by nested formulae.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.N3",
          "name": "NodeGenLookupMap",
          "package": "swish",
          "source": "src/Swish-RDF-Formatter-Internal.html#NodeGenLookupMap",
          "type": "type"
        },
        "index": {
          "description": "Node name generation state information that carries through and is updated by nested formulae",
          "hierarchy": "Swish RDF Formatter N3",
          "module": "Swish.RDF.Formatter.N3",
          "name": "NodeGenLookupMap",
          "package": "swish",
          "partial": "Node Gen Lookup Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#t:NodeGenLookupMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the graph to a Builder.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphAsBuilder",
          "package": "swish",
          "signature": "RDFGraph -\u003e Builder",
          "source": "src/Swish-RDF-Formatter-N3.html#formatGraphAsBuilder",
          "type": "function"
        },
        "index": {
          "description": "Convert the graph to Builder",
          "hierarchy": "Swish RDF Formatter N3",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphAsBuilder",
          "normalized": "RDFGraph-\u003eBuilder",
          "package": "swish",
          "partial": "Graph As Builder",
          "signature": "RDFGraph-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#v:formatGraphAsBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the graph to text.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphAsLazyText",
          "package": "swish",
          "signature": "RDFGraph -\u003e Text",
          "source": "src/Swish-RDF-Formatter-N3.html#formatGraphAsLazyText",
          "type": "function"
        },
        "index": {
          "description": "Convert the graph to text",
          "hierarchy": "Swish RDF Formatter N3",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphAsLazyText",
          "normalized": "RDFGraph-\u003eText",
          "package": "swish",
          "partial": "Graph As Lazy Text",
          "signature": "RDFGraph-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#v:formatGraphAsLazyText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the graph to text.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphAsText",
          "package": "swish",
          "signature": "RDFGraph -\u003e Text",
          "source": "src/Swish-RDF-Formatter-N3.html#formatGraphAsText",
          "type": "function"
        },
        "index": {
          "description": "Convert the graph to text",
          "hierarchy": "Swish RDF Formatter N3",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphAsText",
          "normalized": "RDFGraph-\u003eText",
          "package": "swish",
          "partial": "Graph As Text",
          "signature": "RDFGraph-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#v:formatGraphAsText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormat graph and return additional information\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphDiag",
          "package": "swish",
          "signature": "Builder-\u003e Bool-\u003e RDFGraph-\u003e (Builder, NodeGenLookupMap, Word32, [String])",
          "type": "function"
        },
        "index": {
          "description": "Format graph and return additional information",
          "hierarchy": "Swish RDF Formatter N3",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphDiag",
          "normalized": "Builder-\u003eBool-\u003eRDFGraph-\u003e(Builder,NodeGenLookupMap,Word,[String])",
          "package": "swish",
          "partial": "Graph Diag",
          "signature": "Builder-\u003eBool-\u003eRDFGraph-\u003e(Builder,NodeGenLookupMap,Word,[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#v:formatGraphDiag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the graph to a builder using the given indentation text.\n\u003c/p\u003e",
          "module": "[\"Swish.RDF.Formatter.N3\",\"Swish.RDF.Formatter.Turtle\"]",
          "name": "formatGraphIndent",
          "package": "swish",
          "signature": "Builder-\u003e Bool-\u003e RDFGraph-\u003e Builder",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#v:formatGraphIndent\",\"http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-Turtle.html#v:formatGraphIndent\"]"
        },
        "index": {
          "description": "Convert the graph to builder using the given indentation text",
          "hierarchy": "Swish RDF Formatter N3",
          "module": "Swish.RDF.Formatter.N3",
          "name": "formatGraphIndent",
          "normalized": "Builder-\u003eBool-\u003eRDFGraph-\u003eBuilder",
          "package": "swish",
          "partial": "Graph Indent",
          "signature": "Builder-\u003eBool-\u003eRDFGraph-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-N3.html#v:formatGraphIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis Module implements a NTriples formatter for a \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eREFERENCES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"RDF Test Cases\",\n     W3C Recommendation 10 February 2004,\n     \u003ca\u003ehttp://www.w3.org/TR/rdf-testcases/#ntriples\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNOTES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Update to the document \"N-Triples. A line-based syntax for an RDF graph\"\n    W3C Working Group Note 09 April 2013,\n    \u003ca\u003ehttp://www.w3.org/TR/2013/NOTE-n-triples-20130409/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "NTriples",
          "package": "swish",
          "source": "src/Swish-RDF-Formatter-NTriples.html",
          "type": "module"
        },
        "index": {
          "description": "This Module implements NTriples formatter for RDFGraph REFERENCES RDF Test Cases W3C Recommendation February http www.w3.org TR rdf-testcases ntriples NOTES Update to the document N-Triples line-based syntax for an RDF graph W3C Working Group Note April http www.w3.org TR NOTE-n-triples-20130409",
          "hierarchy": "Swish RDF Formatter NTriples",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "NTriples",
          "package": "swish",
          "partial": "NTriples",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-NTriples.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a RDF graph to NTriples format.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "formatGraphAsBuilder",
          "package": "swish",
          "signature": "RDFGraph -\u003e Builder",
          "source": "src/Swish-RDF-Formatter-NTriples.html#formatGraphAsBuilder",
          "type": "function"
        },
        "index": {
          "description": "Convert RDF graph to NTriples format",
          "hierarchy": "Swish RDF Formatter NTriples",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "formatGraphAsBuilder",
          "normalized": "RDFGraph-\u003eBuilder",
          "package": "swish",
          "partial": "Graph As Builder",
          "signature": "RDFGraph-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-NTriples.html#v:formatGraphAsBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a RDF graph to NTriples format.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "formatGraphAsLazyText",
          "package": "swish",
          "signature": "RDFGraph -\u003e Text",
          "source": "src/Swish-RDF-Formatter-NTriples.html#formatGraphAsLazyText",
          "type": "function"
        },
        "index": {
          "description": "Convert RDF graph to NTriples format",
          "hierarchy": "Swish RDF Formatter NTriples",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "formatGraphAsLazyText",
          "normalized": "RDFGraph-\u003eText",
          "package": "swish",
          "partial": "Graph As Lazy Text",
          "signature": "RDFGraph-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-NTriples.html#v:formatGraphAsLazyText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a RDF graph to NTriples format.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "formatGraphAsText",
          "package": "swish",
          "signature": "RDFGraph -\u003e Text",
          "source": "src/Swish-RDF-Formatter-NTriples.html#formatGraphAsText",
          "type": "function"
        },
        "index": {
          "description": "Convert RDF graph to NTriples format",
          "hierarchy": "Swish RDF Formatter NTriples",
          "module": "Swish.RDF.Formatter.NTriples",
          "name": "formatGraphAsText",
          "normalized": "RDFGraph-\u003eText",
          "package": "swish",
          "partial": "Graph As Text",
          "signature": "RDFGraph-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-NTriples.html#v:formatGraphAsText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis Module implements a Turtle formatter \n  for an \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e\u003cp\u003eREFERENCES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"Turtle, Terse RDF Triple Language\",\n    W3C Working Draft 09 August 2011 (\u003ca\u003ehttp://www.w3.org/TR/2011/WD-turtle-20110809/\u003c/a\u003e)\n    \u003ca\u003ehttp://www.w3.org/TR/turtle/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNOTES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The formatter needs to be updated to the W3C\n    Candidate Recommendation (19 February 2013,\n    \u003ca\u003ehttp://www.w3.org/TR/2013/CR-turtle-20130219/\u003c/a\u003e).\n\u003c/li\u003e\u003cli\u003e Should literal strings (\u003ccode\u003eLit\u003c/code\u003e) be written out as \u003ccode\u003exsd:string\u003c/code\u003e, or\n    should \u003ccode\u003eTypedLit\u003c/code\u003e strings with a type of \u003ccode\u003exsd:string\u003c/code\u003e be written\n    out with no type? (e.g. see\n    \u003ca\u003ehttp://www.w3.org/TR/2011/WD-turtle-20110809/#terms\u003c/a\u003e).\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "Turtle",
          "package": "swish",
          "source": "src/Swish-RDF-Formatter-Turtle.html",
          "type": "module"
        },
        "index": {
          "description": "This Module implements Turtle formatter for an RDFGraph value REFERENCES Turtle Terse RDF Triple Language W3C Working Draft August http www.w3.org TR WD-turtle-20110809 http www.w3.org TR turtle NOTES The formatter needs to be updated to the W3C Candidate Recommendation February http www.w3.org TR CR-turtle-20130219 Should literal strings Lit be written out as xsd string or should TypedLit strings with type of xsd string be written out with no type e.g see http www.w3.org TR WD-turtle-20110809 terms",
          "hierarchy": "Swish RDF Formatter Turtle",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "Turtle",
          "package": "swish",
          "partial": "Turtle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-Turtle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNode name generation state information that carries through\n  and is updated by nested formulae.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "NodeGenLookupMap",
          "package": "swish",
          "source": "src/Swish-RDF-Formatter-Internal.html#NodeGenLookupMap",
          "type": "type"
        },
        "index": {
          "description": "Node name generation state information that carries through and is updated by nested formulae",
          "hierarchy": "Swish RDF Formatter Turtle",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "NodeGenLookupMap",
          "package": "swish",
          "partial": "Node Gen Lookup Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-Turtle.html#t:NodeGenLookupMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the graph to a Builder.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphAsBuilder",
          "package": "swish",
          "signature": "RDFGraph -\u003e Builder",
          "source": "src/Swish-RDF-Formatter-Turtle.html#formatGraphAsBuilder",
          "type": "function"
        },
        "index": {
          "description": "Convert the graph to Builder",
          "hierarchy": "Swish RDF Formatter Turtle",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphAsBuilder",
          "normalized": "RDFGraph-\u003eBuilder",
          "package": "swish",
          "partial": "Graph As Builder",
          "signature": "RDFGraph-\u003eBuilder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-Turtle.html#v:formatGraphAsBuilder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the graph to text.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphAsLazyText",
          "package": "swish",
          "signature": "RDFGraph -\u003e Text",
          "source": "src/Swish-RDF-Formatter-Turtle.html#formatGraphAsLazyText",
          "type": "function"
        },
        "index": {
          "description": "Convert the graph to text",
          "hierarchy": "Swish RDF Formatter Turtle",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphAsLazyText",
          "normalized": "RDFGraph-\u003eText",
          "package": "swish",
          "partial": "Graph As Lazy Text",
          "signature": "RDFGraph-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-Turtle.html#v:formatGraphAsLazyText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the graph to text.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphAsText",
          "package": "swish",
          "signature": "RDFGraph -\u003e Text",
          "source": "src/Swish-RDF-Formatter-Turtle.html#formatGraphAsText",
          "type": "function"
        },
        "index": {
          "description": "Convert the graph to text",
          "hierarchy": "Swish RDF Formatter Turtle",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphAsText",
          "normalized": "RDFGraph-\u003eText",
          "package": "swish",
          "partial": "Graph As Text",
          "signature": "RDFGraph-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-Turtle.html#v:formatGraphAsText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormat graph and return additional information.\n\u003c/p\u003e",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphDiag",
          "package": "swish",
          "signature": "Builder-\u003e Bool-\u003e RDFGraph-\u003e (Builder, NodeGenLookupMap, Word32, [String])",
          "type": "function"
        },
        "index": {
          "description": "Format graph and return additional information",
          "hierarchy": "Swish RDF Formatter Turtle",
          "module": "Swish.RDF.Formatter.Turtle",
          "name": "formatGraphDiag",
          "normalized": "Builder-\u003eBool-\u003eRDFGraph-\u003e(Builder,NodeGenLookupMap,Word,[String])",
          "package": "swish",
          "partial": "Graph Diag",
          "signature": "Builder-\u003eBool-\u003eRDFGraph-\u003e(Builder,NodeGenLookupMap,Word,[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Formatter-Turtle.html#v:formatGraphDiag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a memory-based RDF graph instance. At present only\n  RDF 1.0 is explicitly supported; I have not gone through the RDF 1.1\n  changes to see how the code needs to be updated. This means that you\n  can have untyped strings in your graph that do not match the same content\n  but with an explicit \u003ccode\u003exsd:string\u003c/code\u003e datatype.\n\u003c/p\u003e\u003cp\u003eNote that the identifiers for blank nodes may \u003cem\u003enot\u003c/em\u003e be propogated when\n  a graph is written out using one of the formatters, such as\n  \u003ccode\u003e\u003ca\u003eTurtle\u003c/a\u003e\u003c/code\u003e. There is limited support for\n  generating new blank nodes from an existing set of triples; e.g.\n  \u003ccode\u003e\u003ca\u003enewNode\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003enewNodes\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Graph",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines memory-based RDF graph instance At present only RDF is explicitly supported have not gone through the RDF changes to see how the code needs to be updated This means that you can have untyped strings in your graph that do not match the same content but with an explicit xsd string datatype Note that the identifiers for blank nodes may not be propogated when graph is written out using one of the formatters such as Turtle There is limited support for generating new blank nodes from an existing set of triples e.g newNode and newNodes",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Graph",
          "package": "swish",
          "partial": "Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArc type.\n\u003c/p\u003e\u003cp\u003ePrior to \u003ccode\u003e0.7.0.0\u003c/code\u003e you could also use \u003ccode\u003easubj\u003c/code\u003e, \u003ccode\u003eapred\u003c/code\u003e and \u003ccode\u003eaobj\u003c/code\u003e\n to access the elements of the arc.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Arc",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#Arc",
          "type": "data"
        },
        "index": {
          "description": "Arc type Prior to you could also use asubj apred and aobj to access the elements of the arc",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Arc",
          "package": "swish",
          "partial": "Arc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:Arc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA named formula.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Formula",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#Formula",
          "type": "type"
        },
        "index": {
          "description": "named formula",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Formula",
          "package": "swish",
          "partial": "Formula",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA map for named formulae.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "FormulaMap",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#FormulaMap",
          "type": "type"
        },
        "index": {
          "description": "map for named formulae",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "FormulaMap",
          "package": "swish",
          "partial": "Formula Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:FormulaMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type that can be converted from a RDF Label,\nwith the possibility of failure.\n\u003c/p\u003e\u003cp\u003eThe String instance converts from an untyped literal\n(so it can not be used with a string with a language tag).\n\u003c/p\u003e\u003cp\u003eThe following conversions are supported for common XSD\ntypes (out-of-band values result in \u003ccode\u003eNothing\u003c/code\u003e):\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003exsd:boolean\u003c/code\u003e to \u003ccode\u003eBool\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003exsd:integer\u003c/code\u003e to \u003ccode\u003eInt\u003c/code\u003e and \u003ccode\u003eInteger\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003exsd:float\u003c/code\u003e to \u003ccode\u003eFloat\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003exsd:double\u003c/code\u003e to \u003ccode\u003eDouble\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003exsd:dateTime\u003c/code\u003e to \u003ccode\u003eUTCTime\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003exsd:date\u003c/code\u003e to \u003ccode\u003eDay\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote that this is similar to\n\u003ccode\u003e\u003ca\u003efromRDFLabel\u003c/a\u003e\u003c/code\u003e; \nthe code should probably be combined at some point.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "FromRDFLabel",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#FromRDFLabel",
          "type": "class"
        },
        "index": {
          "description": "type that can be converted from RDF Label with the possibility of failure The String instance converts from an untyped literal so it can not be used with string with language tag The following conversions are supported for common XSD types out-of-band values result in Nothing xsd boolean to Bool xsd integer to Int and Integer xsd float to Float xsd double to Double xsd dateTime to UTCTime xsd date to Day Note that this is similar to fromRDFLabel the code should probably be combined at some point",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "FromRDFLabel",
          "package": "swish",
          "partial": "From RDFLabel",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:FromRDFLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabelled Directed Graph class.\n\u003c/p\u003e\u003cp\u003eMinimum required implementation: \n\u003ccode\u003e\u003ca\u003eemptyGraph\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003esetArcs\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003egetArcs\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "LDGraph",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#LDGraph",
          "type": "class"
        },
        "index": {
          "description": "Labelled Directed Graph class Minimum required implementation emptyGraph setArcs and getArcs",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "LDGraph",
          "package": "swish",
          "partial": "LDGraph",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:LDGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLabel class.\n\u003c/p\u003e\u003cp\u003eA label may have a fixed binding, which means that the label identifies (is) a\n  particular graph node, and different such labels are always distinct nodes.\n  Alternatively, a label may be unbound (variable), which means that it is a\n  placeholder for an unknown node label.  Unbound node labels are used as\n  graph-local identifiers for indicating when the same node appears in\n  several arcs.\n\u003c/p\u003e\u003cp\u003eFor the purposes of graph-isomorphism testing, fixed labels are matched when they\n  are the same.  Variable labels may be matched with any other variable label.\n  Our definition of isomorphism (for RDF graphs) does not match variable labels\n  with fixed labels.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Label",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#Label",
          "type": "class"
        },
        "index": {
          "description": "Label class label may have fixed binding which means that the label identifies is particular graph node and different such labels are always distinct nodes Alternatively label may be unbound variable which means that it is placeholder for an unknown node label Unbound node labels are used as graph-local identifiers for indicating when the same node appears in several arcs For the purposes of graph-isomorphism testing fixed labels are matched when they are the same Variable labels may be matched with any other variable label Our definition of isomorphism for RDF graphs does not match variable labels with fixed labels",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Label",
          "package": "swish",
          "partial": "Label",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:Label"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph formula entry\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "LookupFormula",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#LookupFormula",
          "type": "data"
        },
        "index": {
          "description": "Graph formula entry",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "LookupFormula",
          "package": "swish",
          "partial": "Lookup Formula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:LookupFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMemory-based graph with namespaces and subgraphs.\n\u003c/p\u003e\u003cp\u003eThe primary means for adding arcs to an existing graph\nare: \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003esetArcs\u003c/a\u003e\u003c/code\u003e from the \u003ccode\u003e\u003ca\u003eLDGraph\u003c/a\u003e\u003c/code\u003e instance, which replaces the \n    existing set of arcs and does not change the namespace \n    map.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eaddArc\u003c/a\u003e\u003c/code\u003e which checks that the arc is unknown before\n    adding it but does not change the namespace map or\n    re-label any blank nodes in the arc.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Swish.RDF.Graph",
          "name": "NSGraph",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#NSGraph",
          "type": "data"
        },
        "index": {
          "description": "Memory-based graph with namespaces and subgraphs The primary means for adding arcs to an existing graph are setArcs from the LDGraph instance which replaces the existing set of arcs and does not change the namespace map addArc which checks that the arc is unknown before adding it but does not change the namespace map or re-label any blank nodes in the arc",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "NSGraph",
          "package": "swish",
          "partial": "NSGraph",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:NSGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace prefix list entry\n\u003c/p\u003e\u003cp\u003eA map for name spaces (key is the prefix).\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "NamespaceMap",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#NamespaceMap",
          "type": "type"
        },
        "index": {
          "description": "Namespace prefix list entry map for name spaces key is the prefix",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "NamespaceMap",
          "package": "swish",
          "partial": "Namespace Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:NamespaceMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of RDF triples.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "RDFArcSet",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#RDFArcSet",
          "type": "type"
        },
        "index": {
          "description": "set of RDF triples",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "RDFArcSet",
          "package": "swish",
          "partial": "RDFArc Set",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:RDFArcSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMemory-based RDF graph type\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "RDFGraph",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#RDFGraph",
          "type": "type"
        },
        "index": {
          "description": "Memory-based RDF graph type",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "RDFGraph",
          "package": "swish",
          "partial": "RDFGraph",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:RDFGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF graph node values\n\u003c/p\u003e\u003cp\u003ecf. \u003ca\u003ehttp://www.w3.org/TR/rdf-concepts/#section-Graph-syntax\u003c/a\u003e version 1.0\n\u003c/p\u003e\u003cp\u003eThis is extended from the RDF abstract graph syntax in the\n  following ways:\n\u003c/p\u003e\u003cp\u003e(a) a graph can be part of a resource node or blank node\n      (cf. Notation3 formulae)\n\u003c/p\u003e\u003cp\u003e(b) a \"variable\" node option is distinguished from a\n      blank node.\n      I have found this useful for encoding and handling\n      queries, even though query variables can be expressed\n      as blank nodes.\n\u003c/p\u003e\u003cp\u003e(c) a \"NoNode\" option is defined.\n      This might otherwise be handled by \u003ccode\u003eMaybe (RDFLabel g)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ePrior to version \u003ccode\u003e0.7.0.0\u003c/code\u003e, literals were represented by a\n single constructor, \u003ccode\u003eLit\u003c/code\u003e, with an optional argument. Language\n codes for literals was also stored as a \u003ccode\u003e\u003ca\u003eScopedName\u003c/a\u003e\u003c/code\u003e rather than\n as a \u003ccode\u003e\u003ca\u003eLanguageTag\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "RDFLabel",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "data"
        },
        "index": {
          "description": "RDF graph node values cf http www.w3.org TR rdf-concepts section-Graph-syntax version This is extended from the RDF abstract graph syntax in the following ways graph can be part of resource node or blank node cf Notation3 formulae variable node option is distinguished from blank node have found this useful for encoding and handling queries even though query variables can be expressed as blank nodes NoNode option is defined This might otherwise be handled by Maybe RDFLabel Prior to version literals were represented by single constructor Lit with an optional argument Language codes for literals was also stored as ScopedName rather than as LanguageTag",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "RDFLabel",
          "package": "swish",
          "partial": "RDFLabel",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:RDFLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF Triple (statement)\n\u003c/p\u003e\u003cp\u003eAt present there is no check or type-level\n   constraint that stops the subject or\n   predicate of the triple from being a literal.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "RDFTriple",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#RDFTriple",
          "type": "type"
        },
        "index": {
          "description": "RDF Triple statement At present there is no check or type-level constraint that stops the subject or predicate of the triple from being literal",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "RDFTriple",
          "package": "swish",
          "partial": "RDFTriple",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:RDFTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentify arcs.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Selector",
          "package": "swish",
          "source": "src/Swish-GraphClass.html#Selector",
          "type": "type"
        },
        "index": {
          "description": "Identify arcs",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Selector",
          "package": "swish",
          "partial": "Selector",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:Selector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type that can be converted to a RDF Label.\n\u003c/p\u003e\u003cp\u003eThe String instance converts to an untyped literal\n(so no language tag is assumed).\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eUTCTime\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eDay\u003c/a\u003e\u003c/code\u003e instances assume values are in UTC.\n\u003c/p\u003e\u003cp\u003eThe conversion for XSD types attempts to use the\ncanonical form described in section 2.3.1 of\n\u003ca\u003ehttp://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#lexical-space\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eNote that this is similar to\n\u003ccode\u003e\u003ca\u003etoRDFLabel\u003c/a\u003e\u003c/code\u003e;\nthe code should probably be combined at some point.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "ToRDFLabel",
          "package": "swish",
          "source": "src/Swish-RDF-Graph.html#ToRDFLabel",
          "type": "class"
        },
        "index": {
          "description": "type that can be converted to RDF Label The String instance converts to an untyped literal so no language tag is assumed The UTCTime and Day instances assume values are in UTC The conversion for XSD types attempts to use the canonical form described in section of http www.w3.org TR REC-xmlschema-2-20041028 lexical-space Note that this is similar to toRDFLabel the code should probably be combined at some point",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "ToRDFLabel",
          "package": "swish",
          "partial": "To RDFLabel",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#t:ToRDFLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblank node\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Blank",
          "package": "swish",
          "signature": "Blank String",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "blank node",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Blank",
          "package": "swish",
          "partial": "Blank",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:Blank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Graph",
          "name": "Formula",
          "package": "swish",
          "signature": "Formula",
          "source": "src/Swish-RDF-Graph.html#LookupFormula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Formula",
          "package": "swish",
          "partial": "Formula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplain literal\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "LangLit",
          "package": "swish",
          "signature": "LangLit Text LanguageTag",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "plain literal",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "LangLit",
          "package": "swish",
          "partial": "Lang Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:LangLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplain literal (\u003ca\u003ehttp://www.w3.org/TR/rdf-concepts/#dfn-plain-literal\u003c/a\u003e)\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Lit",
          "package": "swish",
          "signature": "Lit Text",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "plain literal http www.w3.org TR rdf-concepts dfn-plain-literal",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Lit",
          "package": "swish",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Graph",
          "name": "NSGraph",
          "package": "swish",
          "signature": "NSGraph",
          "source": "src/Swish-RDF-Graph.html#NSGraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "NSGraph",
          "package": "swish",
          "partial": "NSGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:NSGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eno node  (not used in ordinary graphs)\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "NoNode",
          "package": "swish",
          "signature": "NoNode",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "no node not used in ordinary graphs",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "NoNode",
          "package": "swish",
          "partial": "No Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:NoNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eresource\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Res",
          "package": "swish",
          "signature": "Res ScopedName",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "resource",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Res",
          "package": "swish",
          "partial": "Res",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:Res"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etyped literal (\u003ca\u003ehttp://www.w3.org/TR/rdf-concepts/#dfn-typed-literal\u003c/a\u003e)\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "TypedLit",
          "package": "swish",
          "signature": "TypedLit Text ScopedName",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "typed literal http www.w3.org TR rdf-concepts dfn-typed-literal",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "TypedLit",
          "package": "swish",
          "partial": "Typed Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:TypedLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable (not used in ordinary graphs)\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "Var",
          "package": "swish",
          "signature": "Var String",
          "source": "src/Swish-RDF-Graph.html#RDFLabel",
          "type": "function"
        },
        "index": {
          "description": "variable not used in ordinary graphs",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "Var",
          "package": "swish",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an arc to the graph. It does not relabel any blank nodes in the input arc,\nnor does it change the namespace map, \nbut it does ensure that the arc is unknown before adding it.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "addArc",
          "package": "swish",
          "signature": "Arc lb -\u003e NSGraph lb -\u003e NSGraph lb",
          "source": "src/Swish-RDF-Graph.html#addArc",
          "type": "function"
        },
        "index": {
          "description": "Add an arc to the graph It does not relabel any blank nodes in the input arc nor does it change the namespace map but it does ensure that the arc is unknown before adding it",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "addArc",
          "normalized": "Arc a-\u003eNSGraph a-\u003eNSGraph a",
          "package": "swish",
          "partial": "Arc",
          "signature": "Arc lb-\u003eNSGraph lb-\u003eNSGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:addArc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd the two graphs\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "addGraphs",
          "package": "swish",
          "signature": "lg lb -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#addGraphs",
          "type": "method"
        },
        "index": {
          "description": "Add the two graphs",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "addGraphs",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "swish",
          "partial": "Graphs",
          "signature": "lg lb-\u003elg lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:addGraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn list of all labels (including properties) in the graph\n  satisfying a supplied filter predicate. This routine\n  includes the labels in any formulae.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "allLabels",
          "package": "swish",
          "signature": "(lb -\u003e Bool) -\u003e NSGraph lb -\u003e Set lb",
          "source": "src/Swish-RDF-Graph.html#allLabels",
          "type": "function"
        },
        "index": {
          "description": "Return list of all labels including properties in the graph satisfying supplied filter predicate This routine includes the labels in any formulae",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "allLabels",
          "normalized": "(a-\u003eBool)-\u003eNSGraph a-\u003eSet a",
          "package": "swish",
          "partial": "Labels",
          "signature": "(lb-\u003eBool)-\u003eNSGraph lb-\u003eSet lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:allLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn list of all subjects and objects in the graph\n  satisfying a supplied filter predicate.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "allNodes",
          "package": "swish",
          "signature": "(lb -\u003e Bool) -\u003e NSGraph lb -\u003e Set lb",
          "source": "src/Swish-RDF-Graph.html#allNodes",
          "type": "function"
        },
        "index": {
          "description": "Return list of all subjects and objects in the graph satisfying supplied filter predicate",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "allNodes",
          "normalized": "(a-\u003eBool)-\u003eNSGraph a-\u003eSet a",
          "package": "swish",
          "partial": "Nodes",
          "signature": "(lb-\u003eBool)-\u003eNSGraph lb-\u003eSet lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:allNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove those arcs in the first graph from the second\n graph\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "delete",
          "package": "swish",
          "signature": "delete",
          "source": "src/Swish-GraphClass.html#delete",
          "type": "method"
        },
        "index": {
          "description": "Remove those arcs in the first graph from the second graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "delete",
          "package": "swish",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an empty formula map.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "emptyFormulaMap",
          "package": "swish",
          "signature": "FormulaMap RDFLabel",
          "source": "src/Swish-RDF-Graph.html#emptyFormulaMap",
          "type": "function"
        },
        "index": {
          "description": "Create an empty formula map",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "emptyFormulaMap",
          "package": "swish",
          "partial": "Formula Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:emptyFormulaMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the empty graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "emptyGraph",
          "package": "swish",
          "signature": "lg lb",
          "source": "src/Swish-GraphClass.html#emptyGraph",
          "type": "method"
        },
        "index": {
          "description": "Create the empty graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "emptyGraph",
          "package": "swish",
          "partial": "Graph",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:emptyGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an empty namespace map.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "emptyNamespaceMap",
          "package": "swish",
          "signature": "NamespaceMap",
          "source": "src/Swish-RDF-Graph.html#emptyNamespaceMap",
          "type": "function"
        },
        "index": {
          "description": "Create an empty namespace map",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "emptyNamespaceMap",
          "package": "swish",
          "partial": "Namespace Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:emptyNamespaceMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new, empty RDF graph (it is just \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "emptyRDFGraph",
          "package": "swish",
          "signature": "RDFGraph",
          "source": "src/Swish-RDF-Graph.html#emptyRDFGraph",
          "type": "function"
        },
        "index": {
          "description": "Create new empty RDF graph it is just mempty",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "emptyRDFGraph",
          "package": "swish",
          "partial": "RDFGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:emptyRDFGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract those arcs that match the given \u003ccode\u003e\u003ca\u003eSelector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "extract",
          "package": "swish",
          "signature": "Selector lb -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#extract",
          "type": "method"
        },
        "index": {
          "description": "Extract those arcs that match the given Selector",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "extract",
          "normalized": "Selector a-\u003eb a-\u003eb a",
          "package": "swish",
          "signature": "Selector lb-\u003elg lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:extract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eNSGraph\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "fmapNSGraph",
          "package": "swish",
          "signature": "(lb -\u003e lb) -\u003e NSGraph lb -\u003e NSGraph lb",
          "source": "src/Swish-RDF-Graph.html#fmapNSGraph",
          "type": "function"
        },
        "index": {
          "description": "fmap for NSGraph instances",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "fmapNSGraph",
          "normalized": "(a-\u003ea)-\u003eNSGraph a-\u003eNSGraph a",
          "package": "swish",
          "partial": "NSGraph",
          "signature": "(lb-\u003elb)-\u003eNSGraph lb-\u003eNSGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:fmapNSGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe contents of the formula\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "formGraph",
          "package": "swish",
          "signature": "gr",
          "source": "src/Swish-RDF-Graph.html#LookupFormula",
          "type": "function"
        },
        "index": {
          "description": "The contents of the formula",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "formGraph",
          "package": "swish",
          "partial": "Graph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:formGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe label for the formula\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "formLabel",
          "package": "swish",
          "signature": "lb",
          "source": "src/Swish-RDF-Graph.html#LookupFormula",
          "type": "function"
        },
        "index": {
          "description": "The label for the formula",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "formLabel",
          "package": "swish",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:formLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eany associated formulae \n   (a.k.a. sub- or named- graps)\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "formulae",
          "package": "swish",
          "signature": "FormulaMap lb",
          "source": "src/Swish-RDF-Graph.html#NSGraph",
          "type": "function"
        },
        "index": {
          "description": "any associated formulae a.k.a sub or named graps",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "formulae",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:formulae"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Graph",
          "name": "fromRDFLabel",
          "package": "swish",
          "signature": "RDFLabel -\u003e Maybe a",
          "source": "src/Swish-RDF-Graph.html#fromRDFLabel",
          "type": "method"
        },
        "index": {
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "fromRDFLabel",
          "normalized": "RDFLabel-\u003eMaybe a",
          "package": "swish",
          "partial": "RDFLabel",
          "signature": "RDFLabel-\u003eMaybe a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:fromRDFLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the contents of a RDF triple.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003eSwish.RDF.GraphClass.arcToTriple\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "fromRDFTriple",
          "package": "swish",
          "signature": "RDFTriple-\u003e Maybe (s, p, o)",
          "type": "function"
        },
        "index": {
          "description": "Extract the contents of RDF triple See also Swish.RDF.GraphClass.arcToTriple",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "fromRDFTriple",
          "normalized": "RDFTriple-\u003eMaybe(a,b,c)",
          "package": "swish",
          "partial": "RDFTriple",
          "signature": "RDFTriple-\u003eMaybe(s,p,o)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:fromRDFTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract all the arcs from a graph\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "getArcs",
          "package": "swish",
          "signature": "lg lb -\u003e ArcSet lb",
          "source": "src/Swish-GraphClass.html#getArcs",
          "type": "method"
        },
        "index": {
          "description": "Extract all the arcs from graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "getArcs",
          "normalized": "a b-\u003eArcSet b",
          "package": "swish",
          "partial": "Arcs",
          "signature": "lg lb-\u003eArcSet lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:getArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a formula in the graph, if it exists.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "getFormula",
          "package": "swish",
          "signature": "NSGraph lb -\u003e lb -\u003e Maybe (NSGraph lb)",
          "source": "src/Swish-RDF-Graph.html#getFormula",
          "type": "function"
        },
        "index": {
          "description": "Find formula in the graph if it exists",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "getFormula",
          "normalized": "NSGraph a-\u003ea-\u003eMaybe(NSGraph a)",
          "package": "swish",
          "partial": "Formula",
          "signature": "NSGraph lb-\u003elb-\u003eMaybe(NSGraph lb)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:getFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the formulae in the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "getFormulae",
          "package": "swish",
          "signature": "NSGraph lb -\u003e FormulaMap lb",
          "source": "src/Swish-RDF-Graph.html#getFormulae",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the formulae in the graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "getFormulae",
          "normalized": "NSGraph a-\u003eFormulaMap a",
          "package": "swish",
          "partial": "Formulae",
          "signature": "NSGraph lb-\u003eFormulaMap lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:getFormulae"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract text value from a literal node (including the\n Language and Typed variants). The empty string is returned\n for other nodes.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "getLiteralText",
          "package": "swish",
          "signature": "RDFLabel -\u003e Text",
          "source": "src/Swish-RDF-Graph.html#getLiteralText",
          "type": "function"
        },
        "index": {
          "description": "Extract text value from literal node including the Language and Typed variants The empty string is returned for other nodes",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "getLiteralText",
          "normalized": "RDFLabel-\u003eText",
          "package": "swish",
          "partial": "Literal Text",
          "signature": "RDFLabel-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:getLiteralText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the local id from a variable node.                 \n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "getLocal",
          "package": "swish",
          "signature": "lb -\u003e String",
          "source": "src/Swish-GraphClass.html#getLocal",
          "type": "method"
        },
        "index": {
          "description": "Extract the local id from variable node",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "getLocal",
          "normalized": "a-\u003eString",
          "package": "swish",
          "partial": "Local",
          "signature": "lb-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:getLocal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the namespace map in the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "getNamespaces",
          "package": "swish",
          "signature": "NSGraph lb -\u003e NamespaceMap",
          "source": "src/Swish-RDF-Graph.html#getNamespaces",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the namespace map in the graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "getNamespaces",
          "normalized": "NSGraph a-\u003eNamespaceMap",
          "package": "swish",
          "partial": "Namespaces",
          "signature": "NSGraph lb-\u003eNamespaceMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:getNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the ScopedName value from a resource node (\u003ccode\u003e\u003ca\u003enullScopedName\u003c/a\u003e\u003c/code\u003e\n is returned for non-resource nodes).\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "getScopedName",
          "package": "swish",
          "signature": "RDFLabel -\u003e ScopedName",
          "source": "src/Swish-RDF-Graph.html#getScopedName",
          "type": "function"
        },
        "index": {
          "description": "Extract the ScopedName value from resource node nullScopedName is returned for non-resource nodes",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "getScopedName",
          "normalized": "RDFLabel-\u003eScopedName",
          "package": "swish",
          "partial": "Scoped Name",
          "signature": "RDFLabel-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:getScopedName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph equality.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "grEq",
          "package": "swish",
          "signature": "NSGraph lb -\u003e NSGraph lb -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#grEq",
          "type": "function"
        },
        "index": {
          "description": "Graph equality",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "grEq",
          "normalized": "NSGraph a-\u003eNSGraph a-\u003eBool",
          "package": "swish",
          "partial": "Eq",
          "signature": "NSGraph lb-\u003eNSGraph lb-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:grEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch graphs, returning \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if they are equivalent,\n with a map of labels to equivalence class identifiers\n (see \u003ccode\u003e\u003ca\u003egraphMatch\u003c/a\u003e\u003c/code\u003e for further details).\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "grMatchMap",
          "package": "swish",
          "signature": "NSGraph lb -\u003e NSGraph lb -\u003e (Bool, LabelMap (ScopedLabel lb))",
          "source": "src/Swish-RDF-Graph.html#grMatchMap",
          "type": "function"
        },
        "index": {
          "description": "Match graphs returning True if they are equivalent with map of labels to equivalence class identifiers see graphMatch for further details",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "grMatchMap",
          "normalized": "NSGraph a-\u003eNSGraph a-\u003e(Bool,LabelMap(ScopedLabel a))",
          "package": "swish",
          "partial": "Match Map",
          "signature": "NSGraph lb-\u003eNSGraph lb-\u003e(Bool,LabelMap(ScopedLabel lb))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:grMatchMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied labal is a blank node\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isBlank",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isBlank",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied labal is blank node",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isBlank",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Blank",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied label is a typed literal node of a given datatype\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isDatatyped",
          "package": "swish",
          "signature": "ScopedName -\u003e RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isDatatyped",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied label is typed literal node of given datatype",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isDatatyped",
          "normalized": "ScopedName-\u003eRDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Datatyped",
          "signature": "ScopedName-\u003eRDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isDatatyped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied labal is a literal node\n (\u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLangLit\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eTypedLit\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isLiteral",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied labal is literal node Lit LangLit or TypedLit",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isLiteral",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Literal",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied label is a container membership property\n\u003c/p\u003e\u003cp\u003eCheck for namespace is RDF namespace and\n  first character of local name is '_' and\n  remaining characters of local name are all digits\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isMemberProp",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isMemberProp",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied label is container membership property Check for namespace is RDF namespace and first character of local name is and remaining characters of local name are all digits",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isMemberProp",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Member Prop",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isMemberProp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied labal is a query variable\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isQueryVar",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isQueryVar",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied labal is query variable",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isQueryVar",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Query Var",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isQueryVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied labal is a typed literal node (\u003ccode\u003e\u003ca\u003eTypedLit\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isTypedLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isTypedLiteral",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied labal is typed literal node TypedLit",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isTypedLiteral",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Typed Literal",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isTypedLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied labal is an untyped literal node (either\n \u003ccode\u003e\u003ca\u003eLit\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLangLit\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isUntypedLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isUntypedLiteral",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied labal is an untyped literal node either Lit or LangLit",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isUntypedLiteral",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Untyped Literal",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isUntypedLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied labal is a URI resource node\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isUri",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isUri",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied labal is URI resource node",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isUri",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "Uri",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isUri"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if supplied labal is a XML literal node\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "isXMLLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e Bool",
          "source": "src/Swish-RDF-Graph.html#isXMLLiteral",
          "type": "function"
        },
        "index": {
          "description": "Test if supplied labal is XML literal node",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "isXMLLiteral",
          "normalized": "RDFLabel-\u003eBool",
          "package": "swish",
          "partial": "XMLLiteral",
          "signature": "RDFLabel-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:isXMLLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the hash of the label using the supplied seed.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "labelHash",
          "package": "swish",
          "signature": "Int -\u003e lb -\u003e Int",
          "source": "src/Swish-GraphClass.html#labelHash",
          "type": "method"
        },
        "index": {
          "description": "Calculate the hash of the label using the supplied seed",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "labelHash",
          "normalized": "Int-\u003ea-\u003eInt",
          "package": "swish",
          "partial": "Hash",
          "signature": "Int-\u003elb-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:labelHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes this node have a variable binding?\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "labelIsVar",
          "package": "swish",
          "signature": "lb -\u003e Bool",
          "source": "src/Swish-GraphClass.html#labelIsVar",
          "type": "method"
        },
        "index": {
          "description": "Does this node have variable binding",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "labelIsVar",
          "normalized": "a-\u003eBool",
          "package": "swish",
          "partial": "Is Var",
          "signature": "lb-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:labelIsVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerate the distinct labels contained in a graph;\n that is, any label that appears in the subject,\n predicate or object position of an \u003ccode\u003e\u003ca\u003eArc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "labels",
          "package": "swish",
          "signature": "lg lb -\u003e Set lb",
          "source": "src/Swish-GraphClass.html#labels",
          "type": "method"
        },
        "index": {
          "description": "Enumerate the distinct labels contained in graph that is any label that appears in the subject predicate or object position of an Arc",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "labels",
          "normalized": "a b-\u003eSet b",
          "package": "swish",
          "signature": "lg lb-\u003eSet lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:labels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a blank node from a supplied query variable,\n  or return the supplied label unchanged.\n  (Use this in when substituting an existential for an\n  unsubstituted query variable.)\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "makeBlank",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFLabel",
          "source": "src/Swish-RDF-Graph.html#makeBlank",
          "type": "function"
        },
        "index": {
          "description": "Make blank node from supplied query variable or return the supplied label unchanged Use this in when substituting an existential for an unsubstituted query variable",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "makeBlank",
          "normalized": "RDFLabel-\u003eRDFLabel",
          "package": "swish",
          "partial": "Blank",
          "signature": "RDFLabel-\u003eRDFLabel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:makeBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a label value from a local id.  \n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "makeLabel",
          "package": "swish",
          "signature": "String -\u003e lb",
          "source": "src/Swish-GraphClass.html#makeLabel",
          "type": "method"
        },
        "index": {
          "description": "Make label value from local id",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "makeLabel",
          "normalized": "String-\u003ea",
          "package": "swish",
          "partial": "Label",
          "signature": "String-\u003elb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:makeLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a list of (oldnode,newnode) values to be used for\n  graph label remapping.  The function operates recursively, adding\n  new nodes generated to the accumulator and also to the\n  list of nodes to be avoided.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "maplist",
          "package": "swish",
          "signature": "[lb]-\u003e [lb]-\u003e (lb -\u003e lb)-\u003e [(lb, lb)]-\u003e [(lb, lb)]",
          "type": "function"
        },
        "index": {
          "description": "Construct list of oldnode newnode values to be used for graph label remapping The function operates recursively adding new nodes generated to the accumulator and also to the list of nodes to be avoided",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "maplist",
          "normalized": "[a]-\u003e[a]-\u003e(a-\u003ea)-\u003e[(a,a)]-\u003e[(a,a)]",
          "package": "swish",
          "signature": "[lb]-\u003e[lb]-\u003e(lb-\u003elb)-\u003e[(lb,lb)]-\u003e[(lb,lb)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:maplist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemap a single graph node.\n\u003c/p\u003e\u003cp\u003eIf the node is not one of those to be remapped,\n  the supplied value is returned unchanged.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "mapnode",
          "package": "swish",
          "signature": "[lb] -\u003e [lb] -\u003e (lb -\u003e lb) -\u003e lb -\u003e lb",
          "source": "src/Swish-RDF-Graph.html#mapnode",
          "type": "function"
        },
        "index": {
          "description": "Remap single graph node If the node is not one of those to be remapped the supplied value is returned unchanged",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "mapnode",
          "normalized": "[a]-\u003e[a]-\u003e(a-\u003ea)-\u003ea-\u003ea",
          "package": "swish",
          "signature": "[lb]-\u003e[lb]-\u003e(lb-\u003elb)-\u003elb-\u003elb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:mapnode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerge RDF graphs, renaming blank and query variable nodes as\n  needed to neep variable nodes from the two graphs distinct in\n  the resulting graph.\n\u003c/p\u003e\u003cp\u003eCurrently formulae are not guaranteed to be preserved across a\n  merge.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "merge",
          "package": "swish",
          "signature": "NSGraph lb -\u003e NSGraph lb -\u003e NSGraph lb",
          "source": "src/Swish-RDF-Graph.html#merge",
          "type": "function"
        },
        "index": {
          "description": "Merge RDF graphs renaming blank and query variable nodes as needed to neep variable nodes from the two graphs distinct in the resulting graph Currently formulae are not guaranteed to be preserved across merge",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "merge",
          "normalized": "NSGraph a-\u003eNSGraph a-\u003eNSGraph a",
          "package": "swish",
          "signature": "NSGraph lb-\u003eNSGraph lb-\u003eNSGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe namespaces to use\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "namespaces",
          "package": "swish",
          "signature": "NamespaceMap",
          "source": "src/Swish-RDF-Graph.html#NSGraph",
          "type": "function"
        },
        "index": {
          "description": "the namespaces to use",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "namespaces",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:namespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a node and a list of existing nodes, find a new node for\n  the supplied node that does not clash with any existing node.\n  (Generates an non-terminating list of possible replacements, and\n  picks the first one that isn't already in use.)\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "newNode",
          "package": "swish",
          "signature": "lb -\u003e [lb] -\u003e lb",
          "source": "src/Swish-RDF-Graph.html#newNode",
          "type": "function"
        },
        "index": {
          "description": "Given node and list of existing nodes find new node for the supplied node that does not clash with any existing node Generates an non-terminating list of possible replacements and picks the first one that isn already in use",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "newNode",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "swish",
          "partial": "Node",
          "signature": "lb-\u003e[lb]-\u003elb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:newNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a node and a list of existing nodes, generate a list of new\n  nodes for the supplied node that do not clash with any existing node.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "newNodes",
          "package": "swish",
          "signature": "lb -\u003e [lb] -\u003e [lb]",
          "source": "src/Swish-RDF-Graph.html#newNodes",
          "type": "function"
        },
        "index": {
          "description": "Given node and list of existing nodes generate list of new nodes for the supplied node that do not clash with any existing node",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "newNodes",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "swish",
          "partial": "Nodes",
          "signature": "lb-\u003e[lb]-\u003e[lb]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:newNodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnumerate the distinct nodes contained in a graph;\n that is, any label that appears in the subject\n or object position of an \u003ccode\u003e\u003ca\u003eArc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "nodes",
          "package": "swish",
          "signature": "lg lb -\u003e Set lb",
          "source": "src/Swish-GraphClass.html#nodes",
          "type": "method"
        },
        "index": {
          "description": "Enumerate the distinct nodes contained in graph that is any label that appears in the subject or object position of an Arc",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "nodes",
          "normalized": "a b-\u003eSet b",
          "package": "swish",
          "signature": "lg lb-\u003eSet lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:nodes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurtle-style quoting rules for a string.\n\u003c/p\u003e\u003cp\u003eAt present the choice is between using one or three\n   double quote (\u003ccode\u003e\"\u003c/code\u003e) characters to surround the string; i.e. using\n   single quote (\u003ccode\u003e'\u003c/code\u003e)  characters is not supported.\n\u003c/p\u003e\u003cp\u003eAs of Swish 0.9.0.6, the \u003ccode\u003e\\f\u003c/code\u003e character is converted to\n   \u003ccode\u003e\\u000C\u003c/code\u003e rather than left as is to aid interoperability\n   with some other tools.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "quote",
          "package": "swish",
          "signature": "Bool-\u003e String-\u003e String",
          "type": "function"
        },
        "index": {
          "description": "Turtle-style quoting rules for string At present the choice is between using one or three double quote characters to surround the string i.e using single quote characters is not supported As of Swish the character is converted to u000C rather than left as is to aid interoperability with some other tools",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "quote",
          "normalized": "Bool-\u003eString-\u003eString",
          "package": "swish",
          "signature": "Bool-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:quote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee \u003ccode\u003e\u003ca\u003equote\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "quoteT",
          "package": "swish",
          "signature": "Bool -\u003e Text -\u003e Text",
          "source": "src/Swish-RDF-Graph.html#quoteT",
          "type": "function"
        },
        "index": {
          "description": "See quote",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "quoteT",
          "normalized": "Bool-\u003eText-\u003eText",
          "package": "swish",
          "signature": "Bool-\u003eText-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:quoteT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExternally callable function to construct a list of (old,new)\n  values to be used for graph label remapping.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "remapLabelList",
          "package": "swish",
          "signature": "[lb]-\u003e [lb]-\u003e [(lb, lb)]",
          "type": "function"
        },
        "index": {
          "description": "Externally callable function to construct list of old new values to be used for graph label remapping",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "remapLabelList",
          "normalized": "[a]-\u003e[a]-\u003e[(a,a)]",
          "package": "swish",
          "partial": "Label List",
          "signature": "[lb]-\u003e[lb]-\u003e[(lb,lb)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:remapLabelList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemap selected nodes in graph.\n\u003c/p\u003e\u003cp\u003eThis is the node renaming operation that prevents graph-scoped\n  variable nodes from being merged when two graphs are merged.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "remapLabels",
          "package": "swish",
          "signature": "[lb]-\u003e [lb]-\u003e (lb -\u003e lb)-\u003e NSGraph lb-\u003e NSGraph lb",
          "type": "function"
        },
        "index": {
          "description": "Remap selected nodes in graph This is the node renaming operation that prevents graph-scoped variable nodes from being merged when two graphs are merged",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "remapLabels",
          "normalized": "[a]-\u003e[a]-\u003e(a-\u003ea)-\u003eNSGraph a-\u003eNSGraph a",
          "package": "swish",
          "partial": "Labels",
          "signature": "[lb]-\u003e[lb]-\u003e(lb-\u003elb)-\u003eNSGraph lb-\u003eNSGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:remapLabels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elog:implies\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resLogImplies",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resLogImplies",
          "type": "function"
        },
        "index": {
          "description": "log implies",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resLogImplies",
          "package": "swish",
          "partial": "Log Implies",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resLogImplies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:sameAs\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resOwlSameAs",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resOwlSameAs",
          "type": "function"
        },
        "index": {
          "description": "owl sameAs",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resOwlSameAs",
          "package": "swish",
          "partial": "Owl Same As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resOwlSameAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:_1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdf1",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdf1",
          "type": "function"
        },
        "index": {
          "description": "rdf",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdf1",
          "package": "swish",
          "partial": "Rdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdf1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:_2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdf2",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdf2",
          "type": "function"
        },
        "index": {
          "description": "rdf",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdf2",
          "package": "swish",
          "partial": "Rdf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdf2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:about\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfAbout",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfAbout",
          "type": "function"
        },
        "index": {
          "description": "rdf about",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfAbout",
          "package": "swish",
          "partial": "Rdf About",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfAbout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Alt\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_alt\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfAlt",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfAlt",
          "type": "function"
        },
        "index": {
          "description": "rdf Alt from http www.w3.org TR rdf-schema ch alt",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfAlt",
          "package": "swish",
          "partial": "Rdf Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Bag\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_bag\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfBag",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfBag",
          "type": "function"
        },
        "index": {
          "description": "rdf Bag from http www.w3.org TR rdf-schema ch bag",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfBag",
          "package": "swish",
          "partial": "Rdf Bag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfBag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:datatype\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfDatatype",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfDatatype",
          "type": "function"
        },
        "index": {
          "description": "rdf datatype",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfDatatype",
          "package": "swish",
          "partial": "Rdf Datatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Description\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfDescription",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfDescription",
          "type": "function"
        },
        "index": {
          "description": "rdf Description",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfDescription",
          "package": "swish",
          "partial": "Rdf Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:first\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_first\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfFirst",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfFirst",
          "type": "function"
        },
        "index": {
          "description": "rdf first from http www.w3.org TR rdf-schema ch first",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfFirst",
          "package": "swish",
          "partial": "Rdf First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:ID\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfID",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfID",
          "type": "function"
        },
        "index": {
          "description": "rdf ID",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfID",
          "package": "swish",
          "partial": "Rdf ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:li\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfLi",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfLi",
          "type": "function"
        },
        "index": {
          "description": "rdf li",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfLi",
          "package": "swish",
          "partial": "Rdf Li",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfLi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:List\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_list\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfList",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfList",
          "type": "function"
        },
        "index": {
          "description": "rdf List from http www.w3.org TR rdf-schema ch list",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfList",
          "package": "swish",
          "partial": "Rdf List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:nil\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_nil\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfNil",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfNil",
          "type": "function"
        },
        "index": {
          "description": "rdf nil from http www.w3.org TR rdf-schema ch nil",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfNil",
          "package": "swish",
          "partial": "Rdf Nil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfNil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:nodeID\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfNodeID",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfNodeID",
          "type": "function"
        },
        "index": {
          "description": "rdf nodeID",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfNodeID",
          "package": "swish",
          "partial": "Rdf Node ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfNodeID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:object\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_object\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfObject",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfObject",
          "type": "function"
        },
        "index": {
          "description": "rdf object from http www.w3.org TR rdf-schema ch object",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfObject",
          "package": "swish",
          "partial": "Rdf Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:parseType\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfParseType",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfParseType",
          "type": "function"
        },
        "index": {
          "description": "rdf parseType",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfParseType",
          "package": "swish",
          "partial": "Rdf Parse Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfParseType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:predicate\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_predicate\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfPredicate",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfPredicate",
          "type": "function"
        },
        "index": {
          "description": "rdf predicate from http www.w3.org TR rdf-schema ch predicate",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfPredicate",
          "package": "swish",
          "partial": "Rdf Predicate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Property\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_property\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfProperty",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfProperty",
          "type": "function"
        },
        "index": {
          "description": "rdf Property from http www.w3.org TR rdf-schema ch property",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfProperty",
          "package": "swish",
          "partial": "Rdf Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:RDF\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfRDF",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfRDF",
          "type": "function"
        },
        "index": {
          "description": "rdf RDF",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfRDF",
          "package": "swish",
          "partial": "Rdf RDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfRDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:resource\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfResource",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfResource",
          "type": "function"
        },
        "index": {
          "description": "rdf resource",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfResource",
          "package": "swish",
          "partial": "Rdf Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:rest\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_rest\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfRest",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfRest",
          "type": "function"
        },
        "index": {
          "description": "rdf rest from http www.w3.org TR rdf-schema ch rest",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfRest",
          "package": "swish",
          "partial": "Rdf Rest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfRest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Seq\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_seq\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfSeq",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfSeq",
          "type": "function"
        },
        "index": {
          "description": "rdf Seq from http www.w3.org TR rdf-schema ch seq",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfSeq",
          "package": "swish",
          "partial": "Rdf Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Statement\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_statement\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfStatement",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfStatement",
          "type": "function"
        },
        "index": {
          "description": "rdf Statement from http www.w3.org TR rdf-schema ch statement",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfStatement",
          "package": "swish",
          "partial": "Rdf Statement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfStatement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:subject\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_subject\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfSubject",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfSubject",
          "type": "function"
        },
        "index": {
          "description": "rdf subject from http www.w3.org TR rdf-schema ch subject",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfSubject",
          "package": "swish",
          "partial": "Rdf Subject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfSubject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:type\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_type\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfType",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfType",
          "type": "function"
        },
        "index": {
          "description": "rdf type from http www.w3.org TR rdf-schema ch type",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfType",
          "package": "swish",
          "partial": "Rdf Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:value\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_value\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfValue",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfValue",
          "type": "function"
        },
        "index": {
          "description": "rdf value from http www.w3.org TR rdf-schema ch value",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfValue",
          "package": "swish",
          "partial": "Rdf Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:XMLLiteral\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_xmlliteral\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfXMLLiteral",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfXMLLiteral",
          "type": "function"
        },
        "index": {
          "description": "rdf XMLLiteral from http www.w3.org TR rdf-schema ch xmlliteral",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfXMLLiteral",
          "package": "swish",
          "partial": "Rdf XMLLiteral",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfXMLLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:constraint\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdConstraint",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfdConstraint",
          "type": "function"
        },
        "index": {
          "description": "rdfd constraint",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdConstraint",
          "package": "swish",
          "partial": "Rdfd Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfdConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:GeneralRestriction\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdGeneralRestriction",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfdGeneralRestriction",
          "type": "function"
        },
        "index": {
          "description": "rdfd GeneralRestriction",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdGeneralRestriction",
          "package": "swish",
          "partial": "Rdfd General Restriction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfdGeneralRestriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:maxCardinality\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdMaxCardinality",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfdMaxCardinality",
          "type": "function"
        },
        "index": {
          "description": "rdfd maxCardinality",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdMaxCardinality",
          "package": "swish",
          "partial": "Rdfd Max Cardinality",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfdMaxCardinality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:onProperties\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdOnProperties",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfdOnProperties",
          "type": "function"
        },
        "index": {
          "description": "rdfd onProperties",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfdOnProperties",
          "package": "swish",
          "partial": "Rdfd On Properties",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfdOnProperties"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003erdf:_n\u003c/code\u003e entity.\n\u003c/p\u003e\u003cp\u003eThere is no check that the argument is not \u003ccode\u003e0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfn",
          "package": "swish",
          "signature": "Word32 -\u003e RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfn",
          "type": "function"
        },
        "index": {
          "description": "Create rdf entity There is no check that the argument is not",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfn",
          "normalized": "Word-\u003eRDFLabel",
          "package": "swish",
          "partial": "Rdfn",
          "signature": "Word-\u003eRDFLabel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Class\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_class\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsClass",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsClass",
          "type": "function"
        },
        "index": {
          "description": "rdfs Class from http www.w3.org TR rdf-schema ch class",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsClass",
          "package": "swish",
          "partial": "Rdfs Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:comment\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_comment\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsComment",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsComment",
          "type": "function"
        },
        "index": {
          "description": "rdfs comment from http www.w3.org TR rdf-schema ch comment",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsComment",
          "package": "swish",
          "partial": "Rdfs Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Container\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_container\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsContainer",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsContainer",
          "type": "function"
        },
        "index": {
          "description": "rdfs Container from http www.w3.org TR rdf-schema ch container",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsContainer",
          "package": "swish",
          "partial": "Rdfs Container",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsContainer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:ContainerMembershipProperty\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_containermembershipproperty\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsContainerMembershipProperty",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsContainerMembershipProperty",
          "type": "function"
        },
        "index": {
          "description": "rdfs ContainerMembershipProperty from http www.w3.org TR rdf-schema ch containermembershipproperty",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsContainerMembershipProperty",
          "package": "swish",
          "partial": "Rdfs Container Membership Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsContainerMembershipProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Datatype\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_datatype\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsDatatype",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsDatatype",
          "type": "function"
        },
        "index": {
          "description": "rdfs Datatype from http www.w3.org TR rdf-schema ch datatype",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsDatatype",
          "package": "swish",
          "partial": "Rdfs Datatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:domain\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_domain\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsDomain",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsDomain",
          "type": "function"
        },
        "index": {
          "description": "rdfs domain from http www.w3.org TR rdf-schema ch domain",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsDomain",
          "package": "swish",
          "partial": "Rdfs Domain",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:isDefinedBy\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_isdefinedby\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsIsDefinedBy",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsIsDefinedBy",
          "type": "function"
        },
        "index": {
          "description": "rdfs isDefinedBy from http www.w3.org TR rdf-schema ch isdefinedby",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsIsDefinedBy",
          "package": "swish",
          "partial": "Rdfs Is Defined By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsIsDefinedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:label\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_label\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsLabel",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsLabel",
          "type": "function"
        },
        "index": {
          "description": "rdfs label from http www.w3.org TR rdf-schema ch label",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsLabel",
          "package": "swish",
          "partial": "Rdfs Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Literal\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_literal\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsLiteral",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsLiteral",
          "type": "function"
        },
        "index": {
          "description": "rdfs Literal from http www.w3.org TR rdf-schema ch literal",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsLiteral",
          "package": "swish",
          "partial": "Rdfs Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:member\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_member\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsMember",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsMember",
          "type": "function"
        },
        "index": {
          "description": "rdfs member from http www.w3.org TR rdf-schema ch member",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsMember",
          "package": "swish",
          "partial": "Rdfs Member",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:range\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_range\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsRange",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsRange",
          "type": "function"
        },
        "index": {
          "description": "rdfs range from http www.w3.org TR rdf-schema ch range",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsRange",
          "package": "swish",
          "partial": "Rdfs Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Resource\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_resource\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsResource",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsResource",
          "type": "function"
        },
        "index": {
          "description": "rdfs Resource from http www.w3.org TR rdf-schema ch resource",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsResource",
          "package": "swish",
          "partial": "Rdfs Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:seeAlso\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_seealso\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsSeeAlso",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsSeeAlso",
          "type": "function"
        },
        "index": {
          "description": "rdfs seeAlso from http www.w3.org TR rdf-schema ch seealso",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsSeeAlso",
          "package": "swish",
          "partial": "Rdfs See Also",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsSeeAlso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:subClassOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_subclassof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsSubClassOf",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsSubClassOf",
          "type": "function"
        },
        "index": {
          "description": "rdfs subClassOf from http www.w3.org TR rdf-schema ch subclassof",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsSubClassOf",
          "package": "swish",
          "partial": "Rdfs Sub Class Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsSubClassOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:subPropertyOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_subpropertyof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsSubPropertyOf",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Graph.html#resRdfsSubPropertyOf",
          "type": "function"
        },
        "index": {
          "description": "rdfs subPropertyOf from http www.w3.org TR rdf-schema ch subpropertyof",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "resRdfsSubPropertyOf",
          "package": "swish",
          "partial": "Rdfs Sub Property Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:resRdfsSubPropertyOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the existing arcs in the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "setArcs",
          "package": "swish",
          "signature": "lg lb -\u003e ArcSet lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#setArcs",
          "type": "method"
        },
        "index": {
          "description": "Replace the existing arcs in the graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "setArcs",
          "normalized": "a b-\u003eArcSet b-\u003ea b",
          "package": "swish",
          "partial": "Arcs",
          "signature": "lg lb-\u003eArcSet lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:setArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd (or replace) a formula.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "setFormula",
          "package": "swish",
          "signature": "Formula lb -\u003e NSGraph lb -\u003e NSGraph lb",
          "source": "src/Swish-RDF-Graph.html#setFormula",
          "type": "function"
        },
        "index": {
          "description": "Add or replace formula",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "setFormula",
          "normalized": "Formula a-\u003eNSGraph a-\u003eNSGraph a",
          "package": "swish",
          "partial": "Formula",
          "signature": "Formula lb-\u003eNSGraph lb-\u003eNSGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:setFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the formulae in the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "setFormulae",
          "package": "swish",
          "signature": "FormulaMap lb -\u003e NSGraph lb -\u003e NSGraph lb",
          "source": "src/Swish-RDF-Graph.html#setFormulae",
          "type": "function"
        },
        "index": {
          "description": "Replace the formulae in the graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "setFormulae",
          "normalized": "FormulaMap a-\u003eNSGraph a-\u003eNSGraph a",
          "package": "swish",
          "partial": "Formulae",
          "signature": "FormulaMap lb-\u003eNSGraph lb-\u003eNSGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:setFormulae"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the namespace information in the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "setNamespaces",
          "package": "swish",
          "signature": "NamespaceMap -\u003e NSGraph lb -\u003e NSGraph lb",
          "source": "src/Swish-RDF-Graph.html#setNamespaces",
          "type": "function"
        },
        "index": {
          "description": "Replace the namespace information in the graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "setNamespaces",
          "normalized": "NamespaceMap-\u003eNSGraph a-\u003eNSGraph a",
          "package": "swish",
          "partial": "Namespaces",
          "signature": "NamespaceMap-\u003eNSGraph lb-\u003eNSGraph lb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:setNamespaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe statements in the graph\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "statements",
          "package": "swish",
          "signature": "ArcSet lb",
          "source": "src/Swish-RDF-Graph.html#NSGraph",
          "type": "function"
        },
        "index": {
          "description": "the statements in the graph",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "statements",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:statements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new RDF graph from a supplied set of arcs.\n\u003c/p\u003e\u003cp\u003eThis version will attempt to fill up the namespace map\n of the graph based on the input labels (including datatypes\n on literals). For faster\n creation of a graph you can use:\n\u003c/p\u003e\u003cpre\u003e emptyRDFGraph { statements = arcs }\n\u003c/pre\u003e\u003cp\u003ewhich is how this routine was defined in version \u003ccode\u003e0.3.1.1\u003c/code\u003e\n and earlier.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "toRDFGraph",
          "package": "swish",
          "signature": "RDFArcSet -\u003e RDFGraph",
          "source": "src/Swish-RDF-Graph.html#toRDFGraph",
          "type": "function"
        },
        "index": {
          "description": "Create new RDF graph from supplied set of arcs This version will attempt to fill up the namespace map of the graph based on the input labels including datatypes on literals For faster creation of graph you can use emptyRDFGraph statements arcs which is how this routine was defined in version and earlier",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "toRDFGraph",
          "normalized": "RDFArcSet-\u003eRDFGraph",
          "package": "swish",
          "partial": "RDFGraph",
          "signature": "RDFArcSet-\u003eRDFGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:toRDFGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Graph",
          "name": "toRDFLabel",
          "package": "swish",
          "signature": "a -\u003e RDFLabel",
          "source": "src/Swish-RDF-Graph.html#toRDFLabel",
          "type": "method"
        },
        "index": {
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "toRDFLabel",
          "normalized": "a-\u003eRDFLabel",
          "package": "swish",
          "partial": "RDFLabel",
          "signature": "a-\u003eRDFLabel",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:toRDFLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert 3 RDF labels to a RDF triple.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003eSwish.RDF.GraphClass.arcFromTriple\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "toRDFTriple",
          "package": "swish",
          "signature": "s-\u003e p-\u003e o-\u003e RDFTriple",
          "type": "function"
        },
        "index": {
          "description": "Convert RDF labels to RDF triple See also Swish.RDF.GraphClass.arcFromTriple",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "toRDFTriple",
          "normalized": "a-\u003eb-\u003ec-\u003eRDFTriple",
          "package": "swish",
          "partial": "RDFTriple",
          "signature": "s-\u003ep-\u003eo-\u003eRDFTriple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:toRDFTriple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eNSGraph\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "traverseNSGraph",
          "package": "swish",
          "signature": "(a -\u003e f a) -\u003e NSGraph a -\u003e f (NSGraph a)",
          "source": "src/Swish-RDF-Graph.html#traverseNSGraph",
          "type": "function"
        },
        "index": {
          "description": "traverse for NSGraph instances",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "traverseNSGraph",
          "normalized": "(a-\u003eb a)-\u003eNSGraph a-\u003eb(NSGraph a)",
          "package": "swish",
          "partial": "NSGraph",
          "signature": "(a-\u003ef a)-\u003eNSGraph a-\u003ef(NSGraph a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:traverseNSGraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate the arcs in a graph using a supplied function.\n\u003c/p\u003e",
          "module": "Swish.RDF.Graph",
          "name": "update",
          "package": "swish",
          "signature": "(ArcSet lb -\u003e ArcSet lb) -\u003e lg lb -\u003e lg lb",
          "source": "src/Swish-GraphClass.html#update",
          "type": "method"
        },
        "index": {
          "description": "Update the arcs in graph using supplied function",
          "hierarchy": "Swish RDF Graph",
          "module": "Swish.RDF.Graph",
          "name": "update",
          "normalized": "(ArcSet a-\u003eArcSet a)-\u003eb a-\u003eb a",
          "package": "swish",
          "signature": "(ArcSet lb-\u003eArcSet lb)-\u003elg lb-\u003elg lb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Graph.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a \u003ccode\u003e\u003ca\u003eShowLines\u003c/a\u003e\u003c/code\u003e class instance for \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e, to be\n  used when displaying RDF Graph values as part of a proof sequence,\n  etc.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.GraphShowLines",
          "name": "GraphShowLines",
          "package": "swish",
          "source": "src/Swish-RDF-GraphShowLines.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines ShowLines class instance for RDFGraph to be used when displaying RDF Graph values as part of proof sequence etc",
          "hierarchy": "Swish RDF GraphShowLines",
          "module": "Swish.RDF.GraphShowLines",
          "name": "GraphShowLines",
          "package": "swish",
          "partial": "Graph Show Lines",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-GraphShowLines.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis Module implements a Notation 3 parser, returning a\n  new \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e consisting of triples and namespace information parsed from\n  the supplied N3 input string, or an error indication.\n\u003c/p\u003e\u003cp\u003eREFERENCES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"Notation3 (N3): A readable RDF syntax\",\n      W3C Team Submission 14 January 2008,\n      \u003ca\u003ehttp://www.w3.org/TeamSubmission/2008/SUBM-n3-20080114/\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Tim Berners-Lee's design issues series notes and description,\n      \u003ca\u003ehttp://www.w3.org/DesignIssues/Notation3.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Notation 3 Primer by Sean Palmer,\n      \u003ca\u003ehttp://www.w3.org/2000/10/swap/Primer.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNOTES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The parser needs to be updated to the latest version\n    (\"W3C Team Submission 28 March 2011\",\n    \u003ca\u003ehttp://www.w3.org/TeamSubmission/2011/SUBM-n3-20110328/\u003c/a\u003e)\n\u003c/li\u003e\u003cli\u003e UTF-8 handling is not really tested.\n\u003c/li\u003e\u003cli\u003e No performance testing has been applied.\n\u003c/li\u003e\u003cli\u003e Not all N3 grammar elements are supported, including:\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e@forSome\u003c/code\u003e (we read it in but ignore the arguments)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e@forAll\u003c/code\u003e  (this causes a parse error)\n\u003c/li\u003e\u003cli\u003e formulae are lightly tested\n\u003c/li\u003e\u003cli\u003e string support is incomplete (e.g. unrecognized escape characters\n      such as \u003ccode\u003e\\q\u003c/code\u003e are probably handled incorrectly)\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "N3",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-N3.html",
          "type": "module"
        },
        "index": {
          "description": "This Module implements Notation parser returning new RDFGraph consisting of triples and namespace information parsed from the supplied N3 input string or an error indication REFERENCES Notation3 N3 readable RDF syntax W3C Team Submission January http www.w3.org TeamSubmission SUBM-n3-20080114 Tim Berners-Lee design issues series notes and description http www.w3.org DesignIssues Notation3.html Notation Primer by Sean Palmer http www.w3.org swap Primer.html NOTES The parser needs to be updated to the latest version W3C Team Submission March http www.w3.org TeamSubmission SUBM-n3-20110328 UTF-8 handling is not really tested No performance testing has been applied Not all N3 grammar elements are supported including forSome we read it in but ignore the arguments forAll this causes parse error formulae are lightly tested string support is incomplete e.g unrecognized escape characters such as are probably handled incorrectly",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "N3",
          "package": "swish",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe N3 parser.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "N3Parser",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-N3.html#N3Parser",
          "type": "type"
        },
        "index": {
          "description": "The N3 parser",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "N3Parser",
          "package": "swish",
          "partial": "Parser",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#t:N3Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eN3 parser state\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "N3State",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "data"
        },
        "index": {
          "description": "N3 parser state",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "N3State",
          "package": "swish",
          "partial": "State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#t:N3State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of a parse, which is either an error message or a graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "ParseResult",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Utils.html#ParseResult",
          "type": "type"
        },
        "index": {
          "description": "The result of parse which is either an error message or graph",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "ParseResult",
          "package": "swish",
          "partial": "Parse Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for special name lookup table\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "SpecialMap",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Utils.html#SpecialMap",
          "type": "type"
        },
        "index": {
          "description": "Type for special name lookup table",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "SpecialMap",
          "package": "swish",
          "partial": "Special Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#t:SpecialMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "N3State",
          "package": "swish",
          "signature": "N3State",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "N3State",
          "package": "swish",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:N3State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "allowLocalNames",
          "package": "swish",
          "signature": "Bool",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "allowLocalNames",
          "package": "swish",
          "partial": "Local Names",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:allowLocalNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcess a N3 document, returning a graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "document",
          "package": "swish",
          "signature": "N3Parser RDFGraph",
          "source": "src/Swish-RDF-Parser-N3.html#document",
          "type": "function"
        },
        "index": {
          "description": "Process N3 document returning graph",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "document",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:document"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcess the remainder of an \u003ccode\u003e@prefix\u003c/code\u003e line (after this\n has been processed). The prefix value and URI are added to the parser\n state.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "getPrefix",
          "package": "swish",
          "signature": "N3Parser ()",
          "source": "src/Swish-RDF-Parser-N3.html#getPrefix",
          "type": "function"
        },
        "index": {
          "description": "Process the remainder of an prefix line after this has been processed The prefix value and URI are added to the parser state",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "getPrefix",
          "normalized": "N Parser()",
          "package": "swish",
          "partial": "Prefix",
          "signature": "N Parser()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:getPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "graphState",
          "package": "swish",
          "signature": "RDFGraph",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "graphState",
          "package": "swish",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:graphState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "keywordsList",
          "package": "swish",
          "signature": "[Text]",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "keywordsList",
          "normalized": "[Text]",
          "package": "swish",
          "partial": "List",
          "signature": "[Text]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:keywordsList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn explicitly given URI followed by white space.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "lexUriRef",
          "package": "swish",
          "signature": "N3Parser URI",
          "source": "src/Swish-RDF-Parser-N3.html#lexUriRef",
          "type": "function"
        },
        "index": {
          "description": "An explicitly given URI followed by white space",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "lexUriRef",
          "package": "swish",
          "partial": "Uri Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:lexUriRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a N3 symbol (an explicit URI or a QName)\n and convert it to a \u003ccode\u003e\u003ca\u003eScopedName\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "n3symbol",
          "package": "swish",
          "signature": "N3Parser ScopedName",
          "source": "src/Swish-RDF-Parser-N3.html#n3symbol",
          "type": "function"
        },
        "index": {
          "description": "Match N3 symbol an explicit URI or QName and convert it to ScopedName",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "n3symbol",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:n3symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new blank node.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "newBlankNode",
          "package": "swish",
          "signature": "N3Parser RDFLabel",
          "source": "src/Swish-RDF-Parser-N3.html#newBlankNode",
          "type": "function"
        },
        "index": {
          "description": "Create new blank node",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "newBlankNode",
          "package": "swish",
          "partial": "Blank Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:newBlankNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "nodeGen",
          "package": "swish",
          "signature": "Word32",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "nodeGen",
          "package": "swish",
          "partial": "Gen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:nodeGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseAbsURIrefFromText",
          "package": "swish",
          "signature": "Text -\u003e Either String URI",
          "source": "src/Swish-RDF-Parser-N3.html#parseAbsURIrefFromText",
          "type": "function"
        },
        "index": {
          "description": "Used in testing",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseAbsURIrefFromText",
          "normalized": "Text-\u003eEither String URI",
          "package": "swish",
          "partial": "Abs URIref From Text",
          "signature": "Text-\u003eEither String URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseAbsURIrefFromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseAltFromText",
          "package": "swish",
          "signature": "String -\u003e String -\u003e Text -\u003e Either String String",
          "source": "src/Swish-RDF-Parser-N3.html#parseAltFromText",
          "type": "function"
        },
        "index": {
          "description": "Used in testing",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseAltFromText",
          "normalized": "String-\u003eString-\u003eText-\u003eEither String String",
          "package": "swish",
          "partial": "Alt From Text",
          "signature": "String-\u003eString-\u003eText-\u003eEither String String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseAltFromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to supply initial context and parse supplied term.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseAnyfromText",
          "package": "swish",
          "signature": "N3Parser a-\u003e Maybe QName-\u003e Text-\u003e Either String a",
          "type": "function"
        },
        "index": {
          "description": "Function to supply initial context and parse supplied term",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseAnyfromText",
          "normalized": "N Parser a-\u003eMaybe QName-\u003eText-\u003eEither String a",
          "package": "swish",
          "partial": "Anyfrom Text",
          "signature": "N Parser a-\u003eMaybe QName-\u003eText-\u003eEither String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseAnyfromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseLexURIrefFromText",
          "package": "swish",
          "signature": "Text -\u003e Either String URI",
          "source": "src/Swish-RDF-Parser-N3.html#parseLexURIrefFromText",
          "type": "function"
        },
        "index": {
          "description": "Used in testing",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseLexURIrefFromText",
          "normalized": "Text-\u003eEither String URI",
          "package": "swish",
          "partial": "Lex URIref From Text",
          "signature": "Text-\u003eEither String URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseLexURIrefFromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string with an optional base URI.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003eparseN3fromString\u003c/code\u003e.            \n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseN3",
          "package": "swish",
          "signature": "Text-\u003e Maybe QName-\u003e ParseResult",
          "type": "function"
        },
        "index": {
          "description": "Parse string with an optional base URI See also parseN3fromString",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseN3",
          "normalized": "Text-\u003eMaybe QName-\u003eParseResult",
          "package": "swish",
          "signature": "Text-\u003eMaybe QName-\u003eParseResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseN3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string as N3 (with no real base URI).\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eparseN3\u003c/a\u003e\u003c/code\u003e if you need to provide a base URI.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseN3fromText",
          "package": "swish",
          "signature": "Text-\u003e ParseResult",
          "type": "function"
        },
        "index": {
          "description": "Parse string as N3 with no real base URI See parseN3 if you need to provide base URI",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseN3fromText",
          "normalized": "Text-\u003eParseResult",
          "package": "swish",
          "partial": "Text",
          "signature": "Text-\u003eParseResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseN3fromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseNameFromText",
          "package": "swish",
          "signature": "Text -\u003e Either String String",
          "source": "src/Swish-RDF-Parser-N3.html#parseNameFromText",
          "type": "function"
        },
        "index": {
          "description": "Used in testing",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseNameFromText",
          "normalized": "Text-\u003eEither String String",
          "package": "swish",
          "partial": "Name From Text",
          "signature": "Text-\u003eEither String String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseNameFromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseTextFromText",
          "package": "swish",
          "signature": "String -\u003e Text -\u003e Either String String",
          "source": "src/Swish-RDF-Parser-N3.html#parseTextFromText",
          "type": "function"
        },
        "index": {
          "description": "Used in testing",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseTextFromText",
          "normalized": "String-\u003eText-\u003eEither String String",
          "package": "swish",
          "partial": "Text From Text",
          "signature": "String-\u003eText-\u003eEither String String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseTextFromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in testing.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseURIref2FromText",
          "package": "swish",
          "signature": "Text -\u003e Either String ScopedName",
          "source": "src/Swish-RDF-Parser-N3.html#parseURIref2FromText",
          "type": "function"
        },
        "index": {
          "description": "Used in testing",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "parseURIref2FromText",
          "normalized": "Text-\u003eEither String ScopedName",
          "package": "swish",
          "partial": "URIref From Text",
          "signature": "Text-\u003eEither String ScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:parseURIref2FromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "prefixUris",
          "package": "swish",
          "signature": "NamespaceMap",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "prefixUris",
          "package": "swish",
          "partial": "Uris",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:prefixUris"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch \u003ccode\u003e?\u003ca\u003ename\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "quickVariable",
          "package": "swish",
          "signature": "N3Parser RDFLabel",
          "source": "src/Swish-RDF-Parser-N3.html#quickVariable",
          "type": "function"
        },
        "index": {
          "description": "Match name",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "quickVariable",
          "package": "swish",
          "partial": "Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:quickVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcess a sub graph and assign it to the given label.  \n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.N3",
          "name": "subgraph",
          "package": "swish",
          "signature": "RDFLabel -\u003e N3Parser RDFGraph",
          "source": "src/Swish-RDF-Parser-N3.html#subgraph",
          "type": "function"
        },
        "index": {
          "description": "Process sub graph and assign it to the given label",
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "subgraph",
          "normalized": "RDFLabel-\u003eN Parser RDFGraph",
          "package": "swish",
          "signature": "RDFLabel-\u003eN Parser RDFGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:subgraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "syntaxUris",
          "package": "swish",
          "signature": "SpecialMap",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "syntaxUris",
          "package": "swish",
          "partial": "Uris",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:syntaxUris"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Parser.N3",
          "name": "thisNode",
          "package": "swish",
          "signature": "RDFLabel",
          "source": "src/Swish-RDF-Parser-N3.html#N3State",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Parser N3",
          "module": "Swish.RDF.Parser.N3",
          "name": "thisNode",
          "package": "swish",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-N3.html#v:thisNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis Module implements a NTriples parser, returning a\n  new \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e consisting of triples and namespace information parsed from\n  the supplied NTriples input string, or an error indication.\n\u003c/p\u003e\u003cp\u003eREFERENCES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"RDF Test Cases\",\n    W3C Recommendation 10 February 2004,\n    \u003ca\u003ehttp://www.w3.org/TR/rdf-testcases/#ntriples\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNOTES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e If the URI is actually an IRI (Internationalized Resource Identifiers)\n    then the parser will fail since \u003ccode\u003e\u003ca\u003eparseURI\u003c/a\u003e\u003c/code\u003e fails.\n\u003c/li\u003e\u003cli\u003e The case of language tags is retained.\n\u003c/li\u003e\u003cli\u003e Update to the document \"N-Triples. A line-based syntax for an RDF graph\"\n    W3C Working Group Note 09 April 2013,\n    \u003ca\u003ehttp://www.w3.org/TR/2013/NOTE-n-triples-20130409/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Parser.NTriples",
          "name": "NTriples",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-NTriples.html",
          "type": "module"
        },
        "index": {
          "description": "This Module implements NTriples parser returning new RDFGraph consisting of triples and namespace information parsed from the supplied NTriples input string or an error indication REFERENCES RDF Test Cases W3C Recommendation February http www.w3.org TR rdf-testcases ntriples NOTES If the URI is actually an IRI Internationalized Resource Identifiers then the parser will fail since parseURI fails The case of language tags is retained Update to the document N-Triples line-based syntax for an RDF graph W3C Working Group Note April http www.w3.org TR NOTE-n-triples-20130409",
          "hierarchy": "Swish RDF Parser NTriples",
          "module": "Swish.RDF.Parser.NTriples",
          "name": "NTriples",
          "package": "swish",
          "partial": "NTriples",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-NTriples.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of a parse, which is either an error message or a graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.NTriples",
          "name": "ParseResult",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Utils.html#ParseResult",
          "type": "type"
        },
        "index": {
          "description": "The result of parse which is either an error message or graph",
          "hierarchy": "Swish RDF Parser NTriples",
          "module": "Swish.RDF.Parser.NTriples",
          "name": "ParseResult",
          "package": "swish",
          "partial": "Parse Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-NTriples.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.NTriples",
          "name": "parseNT",
          "package": "swish",
          "signature": "Text-\u003e ParseResult",
          "type": "function"
        },
        "index": {
          "description": "Parse string",
          "hierarchy": "Swish RDF Parser NTriples",
          "module": "Swish.RDF.Parser.NTriples",
          "name": "parseNT",
          "normalized": "Text-\u003eParseResult",
          "package": "swish",
          "partial": "NT",
          "signature": "Text-\u003eParseResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-NTriples.html#v:parseNT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis Module implements a Turtle parser, returning a\n  new \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e consisting of triples and namespace information parsed from\n  the supplied input string, or an error indication.\n\u003c/p\u003e\u003cp\u003eREFERENCES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \"Turtle, Terse RDF Triple Language\",\n    W3C Candidate Recommendation 19 February 2013 (\u003chttp:\u003cem/\u003ewww.w3.org\u003cem\u003eTR\u003c/em\u003e2013\u003cem\u003eCR-turtle-20130219\u003c/em\u003eL),\n    \u003ca\u003ehttp://www.w3.org/TR/turtle/\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNOTES:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Prior to version \u003ccode\u003e0.9.0.4\u003c/code\u003e, the parser followed the\n    W3C Working Draft 09 August 2011 (\u003ca\u003ehttp://www.w3.org/TR/2011/WD-turtle-20110809/\u003c/a\u003e)\n\u003c/li\u003e\u003cli\u003e Strings with no language tag are converted to a \u003ccode\u003eLitTag\u003c/code\u003e not a\n    \u003ccode\u003eTypedLitTag\u003c/code\u003e with a type of \u003ccode\u003exsd:string\u003c/code\u003e (e.g. see\n    \u003ca\u003ehttp://www.w3.org/TR/2011/WD-turtle-20110809/#terms\u003c/a\u003e).\n\u003c/li\u003e\u003cli\u003e If the URI is actually an IRI (Internationalized Resource Identifiers)\n    then the parser will fail since \u003ccode\u003e\u003ca\u003eparseURI\u003c/a\u003e\u003c/code\u003e fails.\n\u003c/li\u003e\u003cli\u003e The current (August 2013) Turtle test suite from\n    \u003ca\u003ehttp://www.w3.org/2013/TurtleTests/\u003c/a\u003e passes except for the four\n    tests with non-ASCII local names, namely:\n    \u003ccode\u003elocalName_with_assigned_nfc_bmp_PN_CHARS_BASE_character_boundaries\u003c/code\u003e,\n    \u003ccode\u003elocalName_with_assigned_nfc_PN_CHARS_BASE_character_boundaries\u003c/code\u003e,\n    \u003ccode\u003elocalName_with_nfc_PN_CHARS_BASE_character_boundaries\u003c/code\u003e,\n    and\n    \u003ccode\u003elocalName_with_non_leading_extras\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "Turtle",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Turtle.html",
          "type": "module"
        },
        "index": {
          "description": "This Module implements Turtle parser returning new RDFGraph consisting of triples and namespace information parsed from the supplied input string or an error indication REFERENCES Turtle Terse RDF Triple Language W3C Candidate Recommendation February http www.w3.org TR CR-turtle-20130219 http www.w3.org TR turtle NOTES Prior to version the parser followed the W3C Working Draft August http www.w3.org TR WD-turtle-20110809 Strings with no language tag are converted to LitTag not TypedLitTag with type of xsd string e.g see http www.w3.org TR WD-turtle-20110809 terms If the URI is actually an IRI Internationalized Resource Identifiers then the parser will fail since parseURI fails The current August Turtle test suite from http www.w3.org TurtleTests passes except for the four tests with non-ASCII local names namely localName with assigned nfc bmp PN CHARS BASE character boundaries localName with assigned nfc PN CHARS BASE character boundaries localName with nfc PN CHARS BASE character boundaries and localName with non leading extras",
          "hierarchy": "Swish RDF Parser Turtle",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "Turtle",
          "package": "swish",
          "partial": "Turtle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Turtle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of a parse, which is either an error message or a graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "ParseResult",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Utils.html#ParseResult",
          "type": "type"
        },
        "index": {
          "description": "The result of parse which is either an error message or graph",
          "hierarchy": "Swish RDF Parser Turtle",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "ParseResult",
          "package": "swish",
          "partial": "Parse Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Turtle.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string with an optional base URI.\n\u003c/p\u003e\u003cp\u003eUnlike \u003ccode\u003eparseN3\u003c/code\u003e we treat the base URI as a URI and not\n a QName.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "parseTurtle",
          "package": "swish",
          "signature": "Text-\u003e Maybe URI-\u003e ParseResult",
          "type": "function"
        },
        "index": {
          "description": "Parse string with an optional base URI Unlike parseN3 we treat the base URI as URI and not QName",
          "hierarchy": "Swish RDF Parser Turtle",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "parseTurtle",
          "normalized": "Text-\u003eMaybe URI-\u003eParseResult",
          "package": "swish",
          "partial": "Turtle",
          "signature": "Text-\u003eMaybe URI-\u003eParseResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Turtle.html#v:parseTurtle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse as Turtle (with no real base URI).\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eparseTurtle\u003c/a\u003e\u003c/code\u003e if you need to provide a base URI.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "parseTurtlefromText",
          "package": "swish",
          "signature": "Text-\u003e ParseResult",
          "type": "function"
        },
        "index": {
          "description": "Parse as Turtle with no real base URI See parseTurtle if you need to provide base URI",
          "hierarchy": "Swish RDF Parser Turtle",
          "module": "Swish.RDF.Parser.Turtle",
          "name": "parseTurtlefromText",
          "normalized": "Text-\u003eParseResult",
          "package": "swish",
          "partial": "Turtlefrom Text",
          "signature": "Text-\u003eParseResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Turtle.html#v:parseTurtlefromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSupport for the RDF Parsing modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "Utils",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "Support for the RDF Parsing modules",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "Utils",
          "package": "swish",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of a parse, which is either an error message or a graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "ParseResult",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Utils.html#ParseResult",
          "type": "type"
        },
        "index": {
          "description": "The result of parse which is either an error message or graph",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "ParseResult",
          "package": "swish",
          "partial": "Parse Result",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for special name lookup table\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "SpecialMap",
          "package": "swish",
          "source": "src/Swish-RDF-Parser-Utils.html#SpecialMap",
          "type": "type"
        },
        "index": {
          "description": "Type for special name lookup table",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "SpecialMap",
          "package": "swish",
          "partial": "Special Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#t:SpecialMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend the two URIs. Given the change in signature of\n   \u003ccode\u003e\u003ca\u003erelativeTo\u003c/a\u003e\u003c/code\u003e in versino \u003ccode\u003e2.4.0.0\u003c/code\u003e of \u003ccode\u003enetwork\u003c/code\u003e,\n   it is not clear that this function is necessary. At the\n   very lease, it will be changed to just return a \u003ccode\u003e\u003ca\u003eURI\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "appendURIs",
          "package": "swish",
          "signature": "URI-\u003e URI-\u003e Either String URI",
          "type": "function"
        },
        "index": {
          "description": "Append the two URIs Given the change in signature of relativeTo in versino of network it is not clear that this function is necessary At the very lease it will be changed to just return URI",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "appendURIs",
          "normalized": "URI-\u003eURI-\u003eEither String URI",
          "package": "swish",
          "partial": "URIs",
          "signature": "URI-\u003eURI-\u003eEither String URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:appendURIs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch the character.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "char",
          "package": "swish",
          "signature": "Char -\u003e Parser s Char",
          "source": "src/Swish-RDF-Parser-Utils.html#char",
          "type": "function"
        },
        "index": {
          "description": "Match the character",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "char",
          "normalized": "Char-\u003eParser a Char",
          "package": "swish",
          "signature": "Char-\u003eParser s Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch zero or more occurences of\n parser followed by separator.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "endBy",
          "package": "swish",
          "signature": "Parser s a-\u003e Parser s b-\u003e Parser s [a]",
          "type": "function"
        },
        "index": {
          "description": "Match zero or more occurences of parser followed by separator",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "endBy",
          "normalized": "Parser a b-\u003eParser a c-\u003eParser a[b]",
          "package": "swish",
          "partial": "By",
          "signature": "Parser s a-\u003eParser s b-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:endBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch the end-of-line sequence (\u003ccode\u003e\u003ca\u003e\\n\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003e\\r\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003e\\r\\n\u003c/a\u003e\u003c/code\u003e). \n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "eoln",
          "package": "swish",
          "signature": "Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#eoln",
          "type": "function"
        },
        "index": {
          "description": "Match the end-of-line sequence or",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "eoln",
          "normalized": "Parser a()",
          "package": "swish",
          "signature": "Parser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:eoln"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatches \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e.           \n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "fullStop",
          "package": "swish",
          "signature": "Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#fullStop",
          "type": "function"
        },
        "index": {
          "description": "Matches",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "fullStop",
          "normalized": "Parser a()",
          "package": "swish",
          "partial": "Stop",
          "signature": "Parser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:fullStop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA four-digit hex value (e.g. \u003ccode\u003e1a34\u003c/code\u003e or \u003ccode\u003e03F1\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "hex4",
          "package": "swish",
          "signature": "Parser a Char",
          "source": "src/Swish-RDF-Parser-Utils.html#hex4",
          "type": "function"
        },
        "index": {
          "description": "four-digit hex value e.g a34 or F1",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "hex4",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:hex4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn eight-digit hex value that has a maximum of \u003ccode\u003e0010FFFF\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "hex8",
          "package": "swish",
          "signature": "Parser a Char",
          "source": "src/Swish-RDF-Parser-Utils.html#hex8",
          "type": "function"
        },
        "index": {
          "description": "An eight-digit hex value that has maximum of FFFF",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "hex8",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:hex8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch the character, ignoring the result.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "ichar",
          "package": "swish",
          "signature": "Char -\u003e Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#ichar",
          "type": "function"
        },
        "index": {
          "description": "Match the character ignoring the result",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "ichar",
          "normalized": "Char-\u003eParser a()",
          "package": "swish",
          "signature": "Char-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:ichar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the parser and ignore the result.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "ignore",
          "package": "swish",
          "signature": "f a -\u003e f ()",
          "source": "src/Swish-RDF-Parser-Utils.html#ignore",
          "type": "function"
        },
        "index": {
          "description": "Run the parser and ignore the result",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "ignore",
          "normalized": "a b-\u003ea()",
          "package": "swish",
          "signature": "f a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:ignore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003esymbol\u003c/a\u003e\u003c/code\u003e but ignoring the result.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "isymbol",
          "package": "swish",
          "signature": "String -\u003e Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#isymbol",
          "type": "function"
        },
        "index": {
          "description": "As symbol but ignoring the result",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "isymbol",
          "normalized": "String-\u003eParser a()",
          "package": "swish",
          "signature": "String-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:isymbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a parser into one that also matches, and ignores,\n trailing \u003ccode\u003e\u003ca\u003ewhiteSpace\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "lexeme",
          "package": "swish",
          "signature": "Parser s a -\u003e Parser s a",
          "source": "src/Swish-RDF-Parser-Utils.html#lexeme",
          "type": "function"
        },
        "index": {
          "description": "Convert parser into one that also matches and ignores trailing whiteSpace",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "lexeme",
          "normalized": "Parser a b-\u003eParser a b",
          "package": "swish",
          "signature": "Parser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:lexeme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccept zero or more runs of the parser\n ending with the delimiter.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "manyTill",
          "package": "swish",
          "signature": "Parser s a-\u003e Parser s b-\u003e Parser s [a]",
          "type": "function"
        },
        "index": {
          "description": "Accept zero or more runs of the parser ending with the delimiter",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "manyTill",
          "normalized": "Parser a b-\u003eParser a c-\u003eParser a[b]",
          "package": "swish",
          "partial": "Till",
          "signature": "Parser s a-\u003eParser s b-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:manyTill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccept any character that is not a member of the given string.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "noneOf",
          "package": "swish",
          "signature": "String -\u003e Parser s Char",
          "source": "src/Swish-RDF-Parser-Utils.html#noneOf",
          "type": "function"
        },
        "index": {
          "description": "Accept any character that is not member of the given string",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "noneOf",
          "normalized": "String-\u003eParser a Char",
          "package": "swish",
          "partial": "Of",
          "signature": "String-\u003eParser s Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:noneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceed if the next character does not match the given function.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "notFollowedBy",
          "package": "swish",
          "signature": "(Char -\u003e Bool) -\u003e Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#notFollowedBy",
          "type": "function"
        },
        "index": {
          "description": "Succeed if the next character does not match the given function",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "notFollowedBy",
          "normalized": "(Char-\u003eBool)-\u003eParser a()",
          "package": "swish",
          "partial": "Followed By",
          "signature": "(Char-\u003eBool)-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:notFollowedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine default table of namespaces\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "prefixTable",
          "package": "swish",
          "signature": "[Namespace]",
          "source": "src/Swish-RDF-Parser-Utils.html#prefixTable",
          "type": "function"
        },
        "index": {
          "description": "Define default table of namespaces",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "prefixTable",
          "normalized": "[Namespace]",
          "package": "swish",
          "partial": "Table",
          "signature": "[Namespace]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:prefixTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the parser and return the successful parse or an error\n message which consists of the standard Polyparse error plus\n a fragment of the unparsed input to provide context.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "runParserWithError",
          "package": "swish",
          "signature": "Parser a b-\u003e a-\u003e Text-\u003e Either String b",
          "type": "function"
        },
        "index": {
          "description": "Run the parser and return the successful parse or an error message which consists of the standard Polyparse error plus fragment of the unparsed input to provide context",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "runParserWithError",
          "normalized": "Parser a b-\u003ea-\u003eText-\u003eEither String b",
          "package": "swish",
          "partial": "Parser With Error",
          "signature": "Parser a b-\u003ea-\u003eText-\u003eEither String b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:runParserWithError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch zero or more occurences of the parser followed\n by the separator.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "sepEndBy",
          "package": "swish",
          "signature": "Parser s a-\u003e Parser s b-\u003e Parser s [a]",
          "type": "function"
        },
        "index": {
          "description": "Match zero or more occurences of the parser followed by the separator",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "sepEndBy",
          "normalized": "Parser a b-\u003eParser a c-\u003eParser a[b]",
          "package": "swish",
          "partial": "End By",
          "signature": "Parser s a-\u003eParser s b-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:sepEndBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccept one or more occurences of the parser\n separated by the separator. Unlike \u003ccode\u003e\u003ca\u003eendBy\u003c/a\u003e\u003c/code\u003e the\n last separator is optional.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "sepEndBy1",
          "package": "swish",
          "signature": "Parser s a-\u003e Parser s b-\u003e Parser s [a]",
          "type": "function"
        },
        "index": {
          "description": "Accept one or more occurences of the parser separated by the separator Unlike endBy the last separator is optional",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "sepEndBy1",
          "normalized": "Parser a b-\u003eParser a c-\u003eParser a[b]",
          "package": "swish",
          "partial": "End By",
          "signature": "Parser s a-\u003eParser s b-\u003eParser s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:sepEndBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the parser \u003ccode\u003e\u003ca\u003emany\u003c/a\u003e\u003c/code\u003e times and ignore the result.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "skipMany",
          "package": "swish",
          "signature": "Parser s a -\u003e Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#skipMany",
          "type": "function"
        },
        "index": {
          "description": "Run the parser many times and ignore the result",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "skipMany",
          "normalized": "Parser a b-\u003eParser a()",
          "package": "swish",
          "partial": "Many",
          "signature": "Parser s a-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:skipMany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the parser \u003ccode\u003e\u003ca\u003emany1\u003c/a\u003e\u003c/code\u003e times and ignore the result.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "skipMany1",
          "package": "swish",
          "signature": "Parser s a -\u003e Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#skipMany1",
          "type": "function"
        },
        "index": {
          "description": "Run the parser many1 times and ignore the result",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "skipMany1",
          "normalized": "Parser a b-\u003eParser a()",
          "package": "swish",
          "partial": "Many",
          "signature": "Parser s a-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:skipMany1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine default special-URI table.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "specialTable",
          "package": "swish",
          "signature": "Maybe ScopedName-\u003e [(String, ScopedName)]",
          "type": "function"
        },
        "index": {
          "description": "Define default special-URI table",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "specialTable",
          "normalized": "Maybe ScopedName-\u003e[(String,ScopedName)]",
          "package": "swish",
          "partial": "Table",
          "signature": "Maybe ScopedName-\u003e[(String,ScopedName)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:specialTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch the text.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "string",
          "package": "swish",
          "signature": "String -\u003e Parser s String",
          "source": "src/Swish-RDF-Parser-Utils.html#string",
          "type": "function"
        },
        "index": {
          "description": "Match the text",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "string",
          "normalized": "String-\u003eParser a String",
          "package": "swish",
          "signature": "String-\u003eParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch the text.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "stringT",
          "package": "swish",
          "signature": "Text -\u003e Parser s Text",
          "source": "src/Swish-RDF-Parser-Utils.html#stringT",
          "type": "function"
        },
        "index": {
          "description": "Match the text",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "stringT",
          "normalized": "Text-\u003eParser a Text",
          "package": "swish",
          "signature": "Text-\u003eParser s Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:stringT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch the given string and any trailing \u003ccode\u003e\u003ca\u003ewhiteSpace\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "symbol",
          "package": "swish",
          "signature": "String -\u003e Parser s String",
          "source": "src/Swish-RDF-Parser-Utils.html#symbol",
          "type": "function"
        },
        "index": {
          "description": "Match the given string and any trailing whiteSpace",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "symbol",
          "normalized": "String-\u003eParser a String",
          "package": "swish",
          "signature": "String-\u003eParser s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch white space: a space or a comment (\u003ccode\u003e#\u003c/code\u003e character and anything following it\n up to to a new line).\n\u003c/p\u003e",
          "module": "Swish.RDF.Parser.Utils",
          "name": "whiteSpace",
          "package": "swish",
          "signature": "Parser s ()",
          "source": "src/Swish-RDF-Parser-Utils.html#whiteSpace",
          "type": "function"
        },
        "index": {
          "description": "Match white space space or comment character and anything following it up to to new line",
          "hierarchy": "Swish RDF Parser Utils",
          "module": "Swish.RDF.Parser.Utils",
          "name": "whiteSpace",
          "normalized": "Parser a()",
          "package": "swish",
          "partial": "Space",
          "signature": "Parser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Parser-Utils.html#v:whiteSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module instantiates the \u003ccode\u003e\u003ca\u003eProof\u003c/a\u003e\u003c/code\u003e framework for\n  constructing proofs over \u003ccode\u003e\u003ca\u003eRDFGraph\u003c/a\u003e\u003c/code\u003e expressions.\n  The intent is that this can be used to test some\n  correspondences between the RDF Model theory and\n  corresponding proof theory based on closure rules\n  applied to the graph, per \u003ca\u003ehttp://www.w3.org/TR/rdf-mt/\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Proof",
          "name": "Proof",
          "package": "swish",
          "source": "src/Swish-RDF-Proof.html",
          "type": "module"
        },
        "index": {
          "description": "This module instantiates the Proof framework for constructing proofs over RDFGraph expressions The intent is that this can be used to test some correspondences between the RDF Model theory and corresponding proof theory based on closure rules applied to the graph per http www.w3.org TR rdf-mt",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "Proof",
          "package": "swish",
          "partial": "Proof",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn RDF proof.\n\u003c/p\u003e",
          "module": "Swish.RDF.Proof",
          "name": "RDFProof",
          "package": "swish",
          "source": "src/Swish-RDF-Proof.html#RDFProof",
          "type": "type"
        },
        "index": {
          "description": "An RDF proof",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "RDFProof",
          "package": "swish",
          "partial": "RDFProof",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#t:RDFProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA step in an RDF proof.\n\u003c/p\u003e",
          "module": "Swish.RDF.Proof",
          "name": "RDFProofStep",
          "package": "swish",
          "source": "src/Swish-RDF-Proof.html#RDFProofStep",
          "type": "type"
        },
        "index": {
          "description": "step in an RDF proof",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "RDFProofStep",
          "package": "swish",
          "partial": "RDFProof Step",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#t:RDFProofStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake an RDF proof.\n\u003c/p\u003e",
          "module": "Swish.RDF.Proof",
          "name": "makeRDFProof",
          "package": "swish",
          "signature": "[RDFRuleset]-\u003e RDFFormula-\u003e RDFFormula-\u003e [RDFProofStep]-\u003e RDFProof",
          "type": "function"
        },
        "index": {
          "description": "Make an RDF proof",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "makeRDFProof",
          "normalized": "[RDFRuleset]-\u003eRDFFormula-\u003eRDFFormula-\u003e[RDFProofStep]-\u003eRDFProof",
          "package": "swish",
          "partial": "RDFProof",
          "signature": "[RDFRuleset]-\u003eRDFFormula-\u003eRDFFormula-\u003e[RDFProofStep]-\u003eRDFProof",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#v:makeRDFProof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake an RDF graph proof step.\n\u003c/p\u003e",
          "module": "Swish.RDF.Proof",
          "name": "makeRDFProofStep",
          "package": "swish",
          "signature": "RDFRule-\u003e [RDFFormula]-\u003e RDFFormula-\u003e RDFProofStep",
          "type": "function"
        },
        "index": {
          "description": "Make an RDF graph proof step",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "makeRDFProofStep",
          "normalized": "RDFRule-\u003e[RDFFormula]-\u003eRDFFormula-\u003eRDFProofStep",
          "package": "swish",
          "partial": "RDFProof Step",
          "signature": "RDFRule-\u003e[RDFFormula]-\u003eRDFFormula-\u003eRDFProofStep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#v:makeRDFProofStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake an inference rule dealing with RDF instance entailment;\n  i.e. entailments that are due to replacement of a URI or literal\n  node with a blank node.\n\u003c/p\u003e\u003cp\u003eThe part of this rule expected to be useful is \u003ccode\u003e\u003ca\u003echeckInference\u003c/a\u003e\u003c/code\u003e.\n  The \u003ccode\u003e\u003ca\u003efwdApply\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ebwdApply\u003c/a\u003e\u003c/code\u003e functions defined here may return\n  rather large results if applied to graphs with many variables or\n  a large vocabulary, and are defined for experimentation.\n\u003c/p\u003e\u003cp\u003eForward and backward chaining is performed with respect to a\n  specified vocabulary.  In the case of backward chaining, it would\n  otherwise be impossible to bound the options thus generated.\n  In the case of forward chaining, it is often not desirable to\n  have the properties generalized.  If forward or backward backward\n  chaining will not be used, supply an empty vocabulary.\n  Note:  graph method \u003ccode\u003e\u003ca\u003eallNodes\u003c/a\u003e\u003c/code\u003e can be used to obtain a list of all\n  the subjects and objects used in a  graph, not counting nested\n  formulae;  use a call of the form:\n\u003c/p\u003e\u003cpre\u003e  allNodes (not . labelIsVar) graph\n\u003c/pre\u003e",
          "module": "Swish.RDF.Proof",
          "name": "makeRdfInstanceEntailmentRule",
          "package": "swish",
          "signature": "ScopedName-\u003e [RDFLabel]-\u003e RDFRule",
          "type": "function"
        },
        "index": {
          "description": "Make an inference rule dealing with RDF instance entailment i.e entailments that are due to replacement of URI or literal node with blank node The part of this rule expected to be useful is checkInference The fwdApply and bwdApply functions defined here may return rather large results if applied to graphs with many variables or large vocabulary and are defined for experimentation Forward and backward chaining is performed with respect to specified vocabulary In the case of backward chaining it would otherwise be impossible to bound the options thus generated In the case of forward chaining it is often not desirable to have the properties generalized If forward or backward backward chaining will not be used supply an empty vocabulary Note graph method allNodes can be used to obtain list of all the subjects and objects used in graph not counting nested formulae use call of the form allNodes not labelIsVar graph",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "makeRdfInstanceEntailmentRule",
          "normalized": "ScopedName-\u003e[RDFLabel]-\u003eRDFRule",
          "package": "swish",
          "partial": "Rdf Instance Entailment Rule",
          "signature": "ScopedName-\u003e[RDFLabel]-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#v:makeRdfInstanceEntailmentRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake an inference rule dealing with RDF simple entailment.\n  The part of this rule expected to be useful is \u003ccode\u003e\u003ca\u003echeckInference\u003c/a\u003e\u003c/code\u003e.\n  The \u003ccode\u003e\u003ca\u003efwdApply\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ebwdApply\u003c/a\u003e\u003c/code\u003e functions defined return null\n  results, indicating that they are not useful for the purposes\n  of proof discovery.\n\u003c/p\u003e",
          "module": "Swish.RDF.Proof",
          "name": "makeRdfSimpleEntailmentRule",
          "package": "swish",
          "signature": "ScopedName -\u003e RDFRule",
          "source": "src/Swish-RDF-Proof.html#makeRdfSimpleEntailmentRule",
          "type": "function"
        },
        "index": {
          "description": "Make an inference rule dealing with RDF simple entailment The part of this rule expected to be useful is checkInference The fwdApply and bwdApply functions defined return null results indicating that they are not useful for the purposes of proof discovery",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "makeRdfSimpleEntailmentRule",
          "normalized": "ScopedName-\u003eRDFRule",
          "package": "swish",
          "partial": "Rdf Simple Entailment Rule",
          "signature": "ScopedName-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#v:makeRdfSimpleEntailmentRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake an inference rule dealing with RDF subgraph entailment.\n  The part of this rule expected to be useful is \u003ccode\u003e\u003ca\u003echeckInference\u003c/a\u003e\u003c/code\u003e.\n  The \u003ccode\u003e\u003ca\u003efwdApply\u003c/a\u003e\u003c/code\u003e function defined here may return rather large\n  results.  But in the name of completeness and experimentation\n  with the possibilities of lazy evaluation, it has been defined.\n\u003c/p\u003e\u003cp\u003eBackward chaining is not performed, as there is no reasonable way\n  to choose a meaningful supergraph of that supplied.\n\u003c/p\u003e",
          "module": "Swish.RDF.Proof",
          "name": "makeRdfSubgraphEntailmentRule",
          "package": "swish",
          "signature": "ScopedName -\u003e RDFRule",
          "source": "src/Swish-RDF-Proof.html#makeRdfSubgraphEntailmentRule",
          "type": "function"
        },
        "index": {
          "description": "Make an inference rule dealing with RDF subgraph entailment The part of this rule expected to be useful is checkInference The fwdApply function defined here may return rather large results But in the name of completeness and experimentation with the possibilities of lazy evaluation it has been defined Backward chaining is not performed as there is no reasonable way to choose meaningful supergraph of that supplied",
          "hierarchy": "Swish RDF Proof",
          "module": "Swish.RDF.Proof",
          "name": "makeRdfSubgraphEntailmentRule",
          "normalized": "ScopedName-\u003eRDFRule",
          "package": "swish",
          "partial": "Rdf Subgraph Entailment Rule",
          "signature": "ScopedName-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Proof.html#v:makeRdfSubgraphEntailmentRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains proof-context declarations based on\n  the RDF, RDFS, and RDF datatyping semantics specifications.\n  These definitions consist of namespaces (for identification\n  in proofs), axioms and inference rules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.ProofContext",
          "name": "ProofContext",
          "package": "swish",
          "source": "src/Swish-RDF-ProofContext.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains proof-context declarations based on the RDF RDFS and RDF datatyping semantics specifications These definitions consist of namespaces for identification in proofs axioms and inference rules",
          "hierarchy": "Swish RDF ProofContext",
          "module": "Swish.RDF.ProofContext",
          "name": "ProofContext",
          "package": "swish",
          "partial": "Proof Context",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ProofContext.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuleset for RDF inference.\n\u003c/p\u003e",
          "module": "Swish.RDF.ProofContext",
          "name": "rulesetRDF",
          "package": "swish",
          "signature": "RDFRuleset",
          "source": "src/Swish-RDF-ProofContext.html#rulesetRDF",
          "type": "function"
        },
        "index": {
          "description": "Ruleset for RDF inference",
          "hierarchy": "Swish RDF ProofContext",
          "module": "Swish.RDF.ProofContext",
          "name": "rulesetRDF",
          "package": "swish",
          "partial": "RDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ProofContext.html#v:rulesetRDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuleset for RDFD (datatyping) inference.\n\u003c/p\u003e",
          "module": "Swish.RDF.ProofContext",
          "name": "rulesetRDFD",
          "package": "swish",
          "signature": "RDFRuleset",
          "source": "src/Swish-RDF-ProofContext.html#rulesetRDFD",
          "type": "function"
        },
        "index": {
          "description": "Ruleset for RDFD datatyping inference",
          "hierarchy": "Swish RDF ProofContext",
          "module": "Swish.RDF.ProofContext",
          "name": "rulesetRDFD",
          "package": "swish",
          "partial": "RDFD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ProofContext.html#v:rulesetRDFD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuleset for RDFS inference.\n\u003c/p\u003e",
          "module": "Swish.RDF.ProofContext",
          "name": "rulesetRDFS",
          "package": "swish",
          "signature": "RDFRuleset",
          "source": "src/Swish-RDF-ProofContext.html#rulesetRDFS",
          "type": "function"
        },
        "index": {
          "description": "Ruleset for RDFS inference",
          "hierarchy": "Swish RDF ProofContext",
          "module": "Swish.RDF.ProofContext",
          "name": "rulesetRDFS",
          "package": "swish",
          "partial": "RDFS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-ProofContext.html#v:rulesetRDFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines functions for querying an RDF graph to obtain\n  a set of variable substitutions, and to apply a set of variable\n  substitutions to a query pattern to obtain a new graph.\n\u003c/p\u003e\u003cp\u003eIt also defines a few primitive graph access functions.\n\u003c/p\u003e\u003cp\u003eA minimal example is shown below, where we query a very simple\n  graph:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e:m + Swish.RDF Swish.RDF.Parser.N3 Swish.RDF.Query\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e:set -XOverloadedStrings\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet qparse = either error id . parseN3fromText\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet igr = qparse \"@prefix a: \u003chttp://example.com/\u003e. a:a a a:A ; a:foo a:bar. a:b a a:B ; a:foo a:bar.\"\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet qgr = qparse \"?node a ?type.\"\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erdfQueryFind qgr igr\n\u003c/code\u003e\u003c/strong\u003e[[(?type,a:B),(?node,a:b)],[(?type,a:A),(?node,a:a)]]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet bn = (toRDFLabel . Data.Maybe.fromJust . Network.URI.parseURI) \"http://example.com/B\"\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erdfFindArcs (rdfObjEq bn) igr\n\u003c/code\u003e\u003c/strong\u003e[(a:b,rdf:type,a:B)]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eData.Maybe.mapMaybe (flip Swish.RDF.VarBinding.vbMap (Var \"type\")) $ rdfQueryFind qgr igr\n\u003c/code\u003e\u003c/strong\u003e[a:B,a:A]\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Query",
          "name": "Query",
          "package": "swish",
          "source": "src/Swish-RDF-Query.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines functions for querying an RDF graph to obtain set of variable substitutions and to apply set of variable substitutions to query pattern to obtain new graph It also defines few primitive graph access functions minimal example is shown below where we query very simple graph Swish.RDF Swish.RDF.Parser.N3 Swish.RDF.Query set XOverloadedStrings let qparse either error id parseN3fromText let igr qparse prefix http example.com foo bar foo bar let qgr qparse node type rdfQueryFind qgr igr type node type node let bn toRDFLabel Data.Maybe.fromJust Network.URI.parseURI http example.com rdfFindArcs rdfObjEq bn igr rdf type Data.Maybe.mapMaybe flip Swish.RDF.VarBinding.vbMap Var type rdfQueryFind qgr igr",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "Query",
          "package": "swish",
          "partial": "Query",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if a value satisfies all predicates in a list\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "allp",
          "package": "swish",
          "signature": "[a -\u003e Bool] -\u003e a -\u003e Bool",
          "source": "src/Swish-RDF-Query.html#allp",
          "type": "function"
        },
        "index": {
          "description": "Test if value satisfies all predicates in list",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "allp",
          "normalized": "[a-\u003eBool]-\u003ea-\u003eBool",
          "package": "swish",
          "signature": "[a-\u003eBool]-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:allp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if a value satisfies any predicate in a list\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "anyp",
          "package": "swish",
          "signature": "[a -\u003e Bool] -\u003e a -\u003e Bool",
          "source": "src/Swish-RDF-Query.html#anyp",
          "type": "function"
        },
        "index": {
          "description": "Test if value satisfies any predicate in list",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "anyp",
          "normalized": "[a-\u003eBool]-\u003ea-\u003eBool",
          "package": "swish",
          "signature": "[a-\u003eBool]-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:anyp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake a predicate on an\n  RDF statement and a graph, and returns all statements in the graph\n  satisfying that predicate.\n\u003c/p\u003e\u003cp\u003eUse combinations of these as follows:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e find all statements with given subject:\n          \u003ccode\u003erdfFindArcs (rdfSubjEq s)\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e find all statements with given property:\n          \u003ccode\u003erdfFindArcs (rdfPredEq p)\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e find all statements with given object:\n          \u003ccode\u003erdfFindArcs (rdfObjEq  o)\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e find all statements matching conjunction of these conditions:\n          \u003ccode\u003erdfFindArcs (\u003ccode\u003e\u003ca\u003eallp\u003c/a\u003e\u003c/code\u003e [...])\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e find all statements matching disjunction of these conditions:\n          \u003ccode\u003erdfFindArcs (\u003ccode\u003e\u003ca\u003eanyp\u003c/a\u003e\u003c/code\u003e [...])\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eCustom predicates can also be used.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfFindArcs",
          "package": "swish",
          "signature": "(RDFTriple -\u003e Bool) -\u003e RDFGraph -\u003e [RDFTriple]",
          "source": "src/Swish-RDF-Query.html#rdfFindArcs",
          "type": "function"
        },
        "index": {
          "description": "Take predicate on an RDF statement and graph and returns all statements in the graph satisfying that predicate Use combinations of these as follows find all statements with given subject rdfFindArcs rdfSubjEq find all statements with given property rdfFindArcs rdfPredEq find all statements with given object rdfFindArcs rdfObjEq find all statements matching conjunction of these conditions rdfFindArcs allp find all statements matching disjunction of these conditions rdfFindArcs anyp Custom predicates can also be used",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfFindArcs",
          "normalized": "(RDFTriple-\u003eBool)-\u003eRDFGraph-\u003e[RDFTriple]",
          "package": "swish",
          "partial": "Find Arcs",
          "signature": "(RDFTriple-\u003eBool)-\u003eRDFGraph-\u003e[RDFTriple]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfFindArcs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of nodes that comprise an rdf:collection value,\n  given the head element of the collection.  If the list is\n  ill-formed then an arbitrary value is returned.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfFindList",
          "package": "swish",
          "signature": "RDFGraph -\u003e RDFLabel -\u003e [RDFLabel]",
          "source": "src/Swish-RDF-Query.html#rdfFindList",
          "type": "function"
        },
        "index": {
          "description": "Return list of nodes that comprise an rdf collection value given the head element of the collection If the list is ill-formed then an arbitrary value is returned",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfFindList",
          "normalized": "RDFGraph-\u003eRDFLabel-\u003e[RDFLabel]",
          "package": "swish",
          "partial": "Find List",
          "signature": "RDFGraph-\u003eRDFLabel-\u003e[RDFLabel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfFindList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind integer values of a given predicate for a given subject\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfFindPredInt",
          "package": "swish",
          "signature": "RDFLabel-\u003e RDFLabel-\u003e RDFGraph-\u003e [Integer]",
          "type": "function"
        },
        "index": {
          "description": "Find integer values of given predicate for given subject",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfFindPredInt",
          "normalized": "RDFLabel-\u003eRDFLabel-\u003eRDFGraph-\u003e[Integer]",
          "package": "swish",
          "partial": "Find Pred Int",
          "signature": "RDFLabel-\u003eRDFLabel-\u003eRDFGraph-\u003e[Integer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfFindPredInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind values of given predicate for a given subject\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfFindPredVal",
          "package": "swish",
          "signature": "RDFLabel-\u003e RDFLabel-\u003e RDFGraph-\u003e [RDFLabel]",
          "type": "function"
        },
        "index": {
          "description": "Find values of given predicate for given subject",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfFindPredVal",
          "normalized": "RDFLabel-\u003eRDFLabel-\u003eRDFGraph-\u003e[RDFLabel]",
          "package": "swish",
          "partial": "Find Pred Val",
          "signature": "RDFLabel-\u003eRDFLabel-\u003eRDFGraph-\u003e[RDFLabel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfFindPredVal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind all subjects that match (subject, predicate, object) in the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfFindValSubj",
          "package": "swish",
          "signature": "RDFLabel-\u003e RDFLabel-\u003e RDFGraph-\u003e [RDFLabel]",
          "type": "function"
        },
        "index": {
          "description": "Find all subjects that match subject predicate object in the graph",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfFindValSubj",
          "normalized": "RDFLabel-\u003eRDFLabel-\u003eRDFGraph-\u003e[RDFLabel]",
          "package": "swish",
          "partial": "Find Val Subj",
          "signature": "RDFLabel-\u003eRDFLabel-\u003eRDFGraph-\u003e[RDFLabel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfFindValSubj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if statement has given object\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfObjEq",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFTriple -\u003e Bool",
          "source": "src/Swish-RDF-Query.html#rdfObjEq",
          "type": "function"
        },
        "index": {
          "description": "Test if statement has given object",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfObjEq",
          "normalized": "RDFLabel-\u003eRDFTriple-\u003eBool",
          "package": "swish",
          "partial": "Obj Eq",
          "signature": "RDFLabel-\u003eRDFTriple-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfObjEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if statement has given predicate\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfPredEq",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFTriple -\u003e Bool",
          "source": "src/Swish-RDF-Query.html#rdfPredEq",
          "type": "function"
        },
        "index": {
          "description": "Test if statement has given predicate",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfPredEq",
          "normalized": "RDFLabel-\u003eRDFTriple-\u003eBool",
          "package": "swish",
          "partial": "Pred Eq",
          "signature": "RDFLabel-\u003eRDFTriple-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfPredEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse graph-query function.\n\u003c/p\u003e\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003erdfQueryFind\u003c/a\u003e\u003c/code\u003e, but with different success criteria.\n  The query graph is matched against the supplied graph,\n  but not every triple of the query is required to be matched.\n  Rather, every triple of the target graph must be matched,\n  and substitutions for just the variables thus bound are\n  returned.  In effect, these are subsitutions in the query\n  that entail the target graph (where \u003ccode\u003erdfQueryFind\u003c/code\u003e returns\n  substitutions that are entailed by the target graph).\n\u003c/p\u003e\u003cp\u003eMultiple substitutions may be used together, so the result\n  returned is a list of lists of query bindings.  Each inner\n  list contains several variable bindings that must all be applied\n  separately to the closure antecendents to obtain a collection of\n  expressions that together are antecedent to the supplied\n  conclusion.  A null list of bindings returned means the\n  conclusion can be inferred without any antecedents.\n\u003c/p\u003e\u003cp\u003eNote:  in back-chaining, the conditions required to prove each\n  target triple are derived independently, using the inference rule\n  for each such triple, so there are no requirements to check\n  consistency with previously determined variable bindings, as\n  there are when doing forward chaining.  A result of this is that\n  there may be redundant triples generated by the back-chaining\n  process.  Any process using back-chaining should deal with the\n  results returned accordingly.\n\u003c/p\u003e\u003cp\u003eAn empty outer list is returned if no combination of\n  substitutions can infer the supplied target.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBack",
          "package": "swish",
          "signature": "RDFGraph-\u003e RDFGraph-\u003e [[RDFVarBinding]]",
          "type": "function"
        },
        "index": {
          "description": "Reverse graph-query function Similar to rdfQueryFind but with different success criteria The query graph is matched against the supplied graph but not every triple of the query is required to be matched Rather every triple of the target graph must be matched and substitutions for just the variables thus bound are returned In effect these are subsitutions in the query that entail the target graph where rdfQueryFind returns substitutions that are entailed by the target graph Multiple substitutions may be used together so the result returned is list of lists of query bindings Each inner list contains several variable bindings that must all be applied separately to the closure antecendents to obtain collection of expressions that together are antecedent to the supplied conclusion null list of bindings returned means the conclusion can be inferred without any antecedents Note in back-chaining the conditions required to prove each target triple are derived independently using the inference rule for each such triple so there are no requirements to check consistency with previously determined variable bindings as there are when doing forward chaining result of this is that there may be redundant triples generated by the back-chaining process Any process using back-chaining should deal with the results returned accordingly An empty outer list is returned if no combination of substitutions can infer the supplied target",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBack",
          "normalized": "RDFGraph-\u003eRDFGraph-\u003e[[RDFVarBinding]]",
          "package": "swish",
          "partial": "Query Back",
          "signature": "RDFGraph-\u003eRDFGraph-\u003e[[RDFVarBinding]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryBack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF back-chaining query filter.  This function applies a supplied\n  query binding filter to the result from a call of \u003ccode\u003e\u003ca\u003erdfQueryBack\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEach inner list contains bindings that must all be used to satisfy\n  the backchain query, so if any query binding does not satisfy the\n  filter, the entire corresponding row is removed\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackFilter",
          "package": "swish",
          "signature": "RDFVarBindingFilter -\u003e [[RDFVarBinding]] -\u003e [[RDFVarBinding]]",
          "source": "src/Swish-RDF-Query.html#rdfQueryBackFilter",
          "type": "function"
        },
        "index": {
          "description": "RDF back-chaining query filter This function applies supplied query binding filter to the result from call of rdfQueryBack Each inner list contains bindings that must all be used to satisfy the backchain query so if any query binding does not satisfy the filter the entire corresponding row is removed",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackFilter",
          "normalized": "RDFVarBindingFilter-\u003e[[RDFVarBinding]]-\u003e[[RDFVarBinding]]",
          "package": "swish",
          "partial": "Query Back Filter",
          "signature": "RDFVarBindingFilter-\u003e[[RDFVarBinding]]-\u003e[[RDFVarBinding]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryBackFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF back-chaining query modifier.  This function applies a supplied\n  query binding modifier to the result from a call of \u003ccode\u003e\u003ca\u003erdfQueryBack\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEach inner list contains bindings that must all be used to satisfy\n  a backchaining query, so if any query binding does not satisfy the\n  filter, the entire corresponding row is removed\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackModify",
          "package": "swish",
          "signature": "VarBindingModify a b -\u003e [[VarBinding a b]] -\u003e [[VarBinding a b]]",
          "source": "src/Swish-RDF-Query.html#rdfQueryBackModify",
          "type": "function"
        },
        "index": {
          "description": "RDF back-chaining query modifier This function applies supplied query binding modifier to the result from call of rdfQueryBack Each inner list contains bindings that must all be used to satisfy backchaining query so if any query binding does not satisfy the filter the entire corresponding row is removed",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackModify",
          "normalized": "VarBindingModify a b-\u003e[[VarBinding a b]]-\u003e[[VarBinding a b]]",
          "package": "swish",
          "partial": "Query Back Modify",
          "signature": "VarBindingModify a b-\u003e[[VarBinding a b]]-\u003e[[VarBinding a b]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryBackModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph back-substitution function.\n\u003c/p\u003e\u003cp\u003eUses the supplied variable bindings from \u003ccode\u003e\u003ca\u003erdfQueryBack\u003c/a\u003e\u003c/code\u003e to perform\n  a series of variable substitutions in a supplied graph, returning\n  a list of lists of result graphs corresponding to each set of variable\n  bindings applied to the input graphs.\n\u003c/p\u003e\u003cp\u003eThe outer list of the result contains alternative antecedent lists\n  that satisfy the query goal.  Each inner list contains graphs that\n  must all be inferred to satisfy the query goal.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackSubs",
          "package": "swish",
          "signature": "[[RDFVarBinding]] -\u003e RDFGraph -\u003e [[(RDFGraph, [RDFLabel])]]",
          "source": "src/Swish-RDF-Query.html#rdfQueryBackSubs",
          "type": "function"
        },
        "index": {
          "description": "Graph back-substitution function Uses the supplied variable bindings from rdfQueryBack to perform series of variable substitutions in supplied graph returning list of lists of result graphs corresponding to each set of variable bindings applied to the input graphs The outer list of the result contains alternative antecedent lists that satisfy the query goal Each inner list contains graphs that must all be inferred to satisfy the query goal",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackSubs",
          "normalized": "[[RDFVarBinding]]-\u003eRDFGraph-\u003e[[(RDFGraph,[RDFLabel])]]",
          "package": "swish",
          "partial": "Query Back Subs",
          "signature": "[[RDFVarBinding]]-\u003eRDFGraph-\u003e[[(RDFGraph,[RDFLabel])]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryBackSubs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph back-substitution function, replacing variables with bnodes.\n\u003c/p\u003e\u003cp\u003eUses the supplied variable bindings from \u003ccode\u003e\u003ca\u003erdfQueryBack\u003c/a\u003e\u003c/code\u003e to perform\n  a series of variable substitutions in a supplied graph, returning\n  a list of lists of result graphs corresponding to each set of variable\n  bindings applied to the input graphs.\n\u003c/p\u003e\u003cp\u003eThe outer list of the result contains alternative antecedent lists\n  that satisfy the query goal.  Each inner list contains graphs that\n  must all be inferred to satisfy the query goal.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackSubsBlank",
          "package": "swish",
          "signature": "[[RDFVarBinding]] -\u003e RDFGraph -\u003e [[RDFGraph]]",
          "source": "src/Swish-RDF-Query.html#rdfQueryBackSubsBlank",
          "type": "function"
        },
        "index": {
          "description": "Graph back-substitution function replacing variables with bnodes Uses the supplied variable bindings from rdfQueryBack to perform series of variable substitutions in supplied graph returning list of lists of result graphs corresponding to each set of variable bindings applied to the input graphs The outer list of the result contains alternative antecedent lists that satisfy the query goal Each inner list contains graphs that must all be inferred to satisfy the query goal",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryBackSubsBlank",
          "normalized": "[[RDFVarBinding]]-\u003eRDFGraph-\u003e[[RDFGraph]]",
          "package": "swish",
          "partial": "Query Back Subs Blank",
          "signature": "[[RDFVarBinding]]-\u003eRDFGraph-\u003e[[RDFGraph]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryBackSubsBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRDF query filter.\n\u003c/p\u003e\u003cp\u003eThis function applies a supplied query binding\n  filter to the result from a call of \u003ccode\u003e\u003ca\u003erdfQueryFind\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf none of the query bindings found satisfy the filter, a null\n  list is returned (which is what \u003ccode\u003e\u003ca\u003erdfQueryFind\u003c/a\u003e\u003c/code\u003e returns if the\n  query cannot be satisfied).\n\u003c/p\u003e\u003cp\u003e(Because of lazy evaluation, this should be as efficient as\n  applying the filter as the search proceeds.  I started to build\n  the filter logic into the query function itself, with consequent\n  increase in complexity, until I remembered lazy evaluation lets\n  me keep things separate.)\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryFilter",
          "package": "swish",
          "signature": "RDFVarBindingFilter -\u003e [RDFVarBinding] -\u003e [RDFVarBinding]",
          "source": "src/Swish-RDF-Query.html#rdfQueryFilter",
          "type": "function"
        },
        "index": {
          "description": "RDF query filter This function applies supplied query binding filter to the result from call of rdfQueryFind If none of the query bindings found satisfy the filter null list is returned which is what rdfQueryFind returns if the query cannot be satisfied Because of lazy evaluation this should be as efficient as applying the filter as the search proceeds started to build the filter logic into the query function itself with consequent increase in complexity until remembered lazy evaluation lets me keep things separate",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryFilter",
          "normalized": "RDFVarBindingFilter-\u003e[RDFVarBinding]-\u003e[RDFVarBinding]",
          "package": "swish",
          "partial": "Query Filter",
          "signature": "RDFVarBindingFilter-\u003e[RDFVarBinding]-\u003e[RDFVarBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic graph-query function.\n\u003c/p\u003e\u003cp\u003eThe triples of the query graph are matched sequentially\n  against the target graph, each taking account of any\n  variable bindings that have already been determined,\n  and adding new variable bindings as triples containing\n  query variables are matched against the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryFind",
          "package": "swish",
          "signature": "RDFGraph-\u003e RDFGraph-\u003e [RDFVarBinding]",
          "type": "function"
        },
        "index": {
          "description": "Basic graph-query function The triples of the query graph are matched sequentially against the target graph each taking account of any variable bindings that have already been determined and adding new variable bindings as triples containing query variables are matched against the graph",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryFind",
          "normalized": "RDFGraph-\u003eRDFGraph-\u003e[RDFVarBinding]",
          "package": "swish",
          "partial": "Query Find",
          "signature": "RDFGraph-\u003eRDFGraph-\u003e[RDFVarBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryFind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimple entailment (instance) graph query.\n\u003c/p\u003e\u003cp\u003eThis function queries a graph to find instances of the\n  query graph in the target graph.  It is very similar\n  to the normal forward chaining query \u003ccode\u003e\u003ca\u003erdfQueryFind\u003c/a\u003e\u003c/code\u003e,\n  except that blank nodes rather than query variable nodes\n  in the query graph are matched against nodes in the target\n  graph.  Neither graph should contain query variables.\n\u003c/p\u003e\u003cp\u003eAn instance is defined by the RDF semantics specification,\n  per \u003ca\u003ehttp://www.w3.org/TR/rdf-mt/\u003c/a\u003e, and is obtained by replacing\n  blank nodes with URIs, literals or other blank nodes.  RDF\n  simple entailment can be determined in terms of instances.\n  This function looks for a subgraph of the target graph that\n  is an instance of the query graph, which is a necessary and\n  sufficient condition for RDF entailment (see the Interpolation\n  Lemma in RDF Semantics, section 1.2).\n\u003c/p\u003e\u003cp\u003eIt is anticipated that this query function can be used in\n  conjunction with backward chaining to determine when the\n  search for sufficient antecendents to determine some goal\n  has been concluded.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryInstance",
          "package": "swish",
          "signature": "RDFGraph -\u003e RDFGraph -\u003e [RDFVarBinding]",
          "source": "src/Swish-RDF-Query.html#rdfQueryInstance",
          "type": "function"
        },
        "index": {
          "description": "Simple entailment instance graph query This function queries graph to find instances of the query graph in the target graph It is very similar to the normal forward chaining query rdfQueryFind except that blank nodes rather than query variable nodes in the query graph are matched against nodes in the target graph Neither graph should contain query variables An instance is defined by the RDF semantics specification per http www.w3.org TR rdf-mt and is obtained by replacing blank nodes with URIs literals or other blank nodes RDF simple entailment can be determined in terms of instances This function looks for subgraph of the target graph that is an instance of the query graph which is necessary and sufficient condition for RDF entailment see the Interpolation Lemma in RDF Semantics section It is anticipated that this query function can be used in conjunction with backward chaining to determine when the search for sufficient antecendents to determine some goal has been concluded",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQueryInstance",
          "normalized": "RDFGraph-\u003eRDFGraph-\u003e[RDFVarBinding]",
          "package": "swish",
          "partial": "Query Instance",
          "signature": "RDFGraph-\u003eRDFGraph-\u003e[RDFVarBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQueryInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph substitution function.\n\u003c/p\u003e\u003cp\u003eUses the supplied variable bindings to substitute variables in\n  a supplied graph, returning a list of result graphs corresponding\n  to each set of variable bindings applied to the input graph.\n  This function is used for formward chaining substitutions, and\n  returns only those result graphs for which all query variables\n  are bound.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubs",
          "package": "swish",
          "signature": "[RDFVarBinding] -\u003e RDFGraph -\u003e [RDFGraph]",
          "source": "src/Swish-RDF-Query.html#rdfQuerySubs",
          "type": "function"
        },
        "index": {
          "description": "Graph substitution function Uses the supplied variable bindings to substitute variables in supplied graph returning list of result graphs corresponding to each set of variable bindings applied to the input graph This function is used for formward chaining substitutions and returns only those result graphs for which all query variables are bound",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubs",
          "normalized": "[RDFVarBinding]-\u003eRDFGraph-\u003e[RDFGraph]",
          "package": "swish",
          "partial": "Query Subs",
          "signature": "[RDFVarBinding]-\u003eRDFGraph-\u003e[RDFGraph]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQuerySubs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function applies a substitution for a single set of variable\n  bindings, returning the result and a list of unbound variables.\n  It uses a state transformer monad to collect the list of\n  unbound variables.\n\u003c/p\u003e\u003cp\u003eAdding an empty graph forces elimination of duplicate arcs.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubs2",
          "package": "swish",
          "signature": "RDFVarBinding -\u003e RDFGraph -\u003e (RDFGraph, [RDFLabel])",
          "source": "src/Swish-RDF-Query.html#rdfQuerySubs2",
          "type": "function"
        },
        "index": {
          "description": "This function applies substitution for single set of variable bindings returning the result and list of unbound variables It uses state transformer monad to collect the list of unbound variables Adding an empty graph forces elimination of duplicate arcs",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubs2",
          "normalized": "RDFVarBinding-\u003eRDFGraph-\u003e(RDFGraph,[RDFLabel])",
          "package": "swish",
          "partial": "Query Subs",
          "signature": "RDFVarBinding-\u003eRDFGraph-\u003e(RDFGraph,[RDFLabel])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQuerySubs2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph substitution function.\n\u003c/p\u003e\u003cp\u003eThis function performs the substitutions and returns a list of\n  result graphs each paired with a list unbound variables in each.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubsAll",
          "package": "swish",
          "signature": "[RDFVarBinding] -\u003e RDFGraph -\u003e [(RDFGraph, [RDFLabel])]",
          "source": "src/Swish-RDF-Query.html#rdfQuerySubsAll",
          "type": "function"
        },
        "index": {
          "description": "Graph substitution function This function performs the substitutions and returns list of result graphs each paired with list unbound variables in each",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubsAll",
          "normalized": "[RDFVarBinding]-\u003eRDFGraph-\u003e[(RDFGraph,[RDFLabel])]",
          "package": "swish",
          "partial": "Query Subs All",
          "signature": "[RDFVarBinding]-\u003eRDFGraph-\u003e[(RDFGraph,[RDFLabel])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQuerySubsAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraph substitution function.\n\u003c/p\u003e\u003cp\u003eThis function performs each of the substitutions in \u003ccode\u003evars\u003c/code\u003e, and\n  replaces any nodes corresponding to unbound query variables\n  with new blank nodes.\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubsBlank",
          "package": "swish",
          "signature": "[RDFVarBinding] -\u003e RDFGraph -\u003e [RDFGraph]",
          "source": "src/Swish-RDF-Query.html#rdfQuerySubsBlank",
          "type": "function"
        },
        "index": {
          "description": "Graph substitution function This function performs each of the substitutions in vars and replaces any nodes corresponding to unbound query variables with new blank nodes",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfQuerySubsBlank",
          "normalized": "[RDFVarBinding]-\u003eRDFGraph-\u003e[RDFGraph]",
          "package": "swish",
          "partial": "Query Subs Blank",
          "signature": "[RDFVarBinding]-\u003eRDFGraph-\u003e[RDFGraph]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfQuerySubsBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if statement has given subject\n\u003c/p\u003e",
          "module": "Swish.RDF.Query",
          "name": "rdfSubjEq",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFTriple -\u003e Bool",
          "source": "src/Swish-RDF-Query.html#rdfSubjEq",
          "type": "function"
        },
        "index": {
          "description": "Test if statement has given subject",
          "hierarchy": "Swish RDF Query",
          "module": "Swish.RDF.Query",
          "name": "rdfSubjEq",
          "normalized": "RDFLabel-\u003eRDFTriple-\u003eBool",
          "package": "swish",
          "partial": "Subj Eq",
          "signature": "RDFLabel-\u003eRDFTriple-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Query.html#v:rdfSubjEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some datatypes and functions that are\n  used to define rules and rulesets over RDF graphs.\n\u003c/p\u003e\u003cp\u003eFor the routines that accept a graph in N3 format, the following\n  namespaces are pre-defined for use by the graph:\n     \u003ccode\u003erdf:\u003c/code\u003e and \u003ccode\u003erdfs:\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some datatypes and functions that are used to define rules and rulesets over RDF graphs For the routines that accept graph in N3 format the following namespaces are pre-defined for use by the graph rdf and rdfs",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "partial": "Ruleset",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDatatype for constructing a graph closure rule\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "GraphClosure",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html#GraphClosure",
          "type": "data"
        },
        "index": {
          "description": "Datatype for constructing graph closure rule",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "GraphClosure",
          "package": "swish",
          "partial": "Graph Closure",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#t:GraphClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eGraphClosure\u003c/a\u003e\u003c/code\u003e for RDF statements.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFClosure",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html#RDFClosure",
          "type": "type"
        },
        "index": {
          "description": "GraphClosure for RDF statements",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFClosure",
          "package": "swish",
          "partial": "RDFClosure",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#t:RDFClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA named formula expressed as a RDF Graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFFormula",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html#RDFFormula",
          "type": "type"
        },
        "index": {
          "description": "named formula expressed as RDF Graph",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFFormula",
          "package": "swish",
          "partial": "RDFFormula",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#t:RDFFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA named inference rule expressed in RDF.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRule",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html#RDFRule",
          "type": "type"
        },
        "index": {
          "description": "named inference rule expressed in RDF",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRule",
          "package": "swish",
          "partial": "RDFRule",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#t:RDFRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA map for \u003ccode\u003e\u003ca\u003eRDFRule\u003c/a\u003e\u003c/code\u003e rules.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRuleMap",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html#RDFRuleMap",
          "type": "type"
        },
        "index": {
          "description": "map for RDFRule rules",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRuleMap",
          "package": "swish",
          "partial": "RDFRule Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#t:RDFRuleMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eRuleset\u003c/a\u003e\u003c/code\u003e for RDF.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRuleset",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html#RDFRuleset",
          "type": "type"
        },
        "index": {
          "description": "Ruleset for RDF",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRuleset",
          "package": "swish",
          "partial": "RDFRuleset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#t:RDFRuleset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA map for \u003ccode\u003e\u003ca\u003eRDFRuleset\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRulesetMap",
          "package": "swish",
          "source": "src/Swish-RDF-Ruleset.html#RDFRulesetMap",
          "type": "type"
        },
        "index": {
          "description": "map for RDFRuleset",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "RDFRulesetMap",
          "package": "swish",
          "partial": "RDFRuleset Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#t:RDFRulesetMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.RDF.Ruleset",
          "name": "GraphClosure",
          "package": "swish",
          "signature": "GraphClosure",
          "source": "src/Swish-RDF-Ruleset.html#GraphClosure",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "GraphClosure",
          "package": "swish",
          "partial": "Graph Closure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:GraphClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBackward chaining function based on RDF graph closure description\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "graphClosureBwdApply",
          "package": "swish",
          "signature": "GraphClosure RDFLabel -\u003e RDFGraph -\u003e [[RDFGraph]]",
          "source": "src/Swish-RDF-Ruleset.html#graphClosureBwdApply",
          "type": "function"
        },
        "index": {
          "description": "Backward chaining function based on RDF graph closure description",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "graphClosureBwdApply",
          "normalized": "GraphClosure RDFLabel-\u003eRDFGraph-\u003e[[RDFGraph]]",
          "package": "swish",
          "partial": "Closure Bwd Apply",
          "signature": "GraphClosure RDFLabel-\u003eRDFGraph-\u003e[[RDFGraph]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:graphClosureBwdApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForward chaining function based on RDF graph closure description\n\u003c/p\u003e\u003cp\u003eNote:  antecedents here are presumed to share bnodes.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "graphClosureFwdApply",
          "package": "swish",
          "signature": "GraphClosure RDFLabel -\u003e [RDFGraph] -\u003e [RDFGraph]",
          "source": "src/Swish-RDF-Ruleset.html#graphClosureFwdApply",
          "type": "function"
        },
        "index": {
          "description": "Forward chaining function based on RDF graph closure description Note antecedents here are presumed to share bnodes",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "graphClosureFwdApply",
          "normalized": "GraphClosure RDFLabel-\u003e[RDFGraph]-\u003e[RDFGraph]",
          "package": "swish",
          "partial": "Closure Fwd Apply",
          "signature": "GraphClosure RDFLabel-\u003e[RDFGraph]-\u003e[RDFGraph]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:graphClosureFwdApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine a value of type Rule based on an RDFClosure value.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeGraphClosureRule",
          "package": "swish",
          "signature": "GraphClosure RDFLabel -\u003e Rule RDFGraph",
          "source": "src/Swish-RDF-Ruleset.html#makeGraphClosureRule",
          "type": "function"
        },
        "index": {
          "description": "Define value of type Rule based on an RDFClosure value",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeGraphClosureRule",
          "normalized": "GraphClosure RDFLabel-\u003eRule RDFGraph",
          "package": "swish",
          "partial": "Graph Closure Rule",
          "signature": "GraphClosure RDFLabel-\u003eRule RDFGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeGraphClosureRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an RDF graph closure rule with a bnode allocator.\n\u003c/p\u003e\u003cp\u003eThis function is rather like \u003ccode\u003e\u003ca\u003emakeN3ClosureModifyRule\u003c/a\u003e\u003c/code\u003e, except that\n  the variable binding modifier is a function from the variables in\n  the variables and bnodes contained in the antecedent graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureAllocatorRule",
          "package": "swish",
          "signature": "Namespace-\u003e LName-\u003e Builder-\u003e Builder-\u003e RDFVarBindingModify-\u003e ([RDFLabel] -\u003e RDFVarBindingModify)-\u003e RDFRule",
          "type": "function"
        },
        "index": {
          "description": "Construct an RDF graph closure rule with bnode allocator This function is rather like makeN3ClosureModifyRule except that the variable binding modifier is function from the variables in the variables and bnodes contained in the antecedent graph",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureAllocatorRule",
          "normalized": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFVarBindingModify-\u003e([RDFLabel]-\u003eRDFVarBindingModify)-\u003eRDFRule",
          "package": "swish",
          "partial": "Closure Allocator Rule",
          "signature": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFVarBindingModify-\u003e([RDFLabel]-\u003eRDFVarBindingModify)-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeN3ClosureAllocatorRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an RDF graph closure rule that incorporates\n  a variable binding filter and a variable binding modifier.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureModifyRule",
          "package": "swish",
          "signature": "Namespace-\u003e LName-\u003e Builder-\u003e Builder-\u003e RDFVarBindingModify-\u003e RDFVarBindingModify-\u003e RDFRule",
          "type": "function"
        },
        "index": {
          "description": "Constructs an RDF graph closure rule that incorporates variable binding filter and variable binding modifier",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureModifyRule",
          "normalized": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFVarBindingModify-\u003eRDFVarBindingModify-\u003eRDFRule",
          "package": "swish",
          "partial": "Closure Modify Rule",
          "signature": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFVarBindingModify-\u003eRDFVarBindingModify-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeN3ClosureModifyRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an RDF graph closure rule.  That is, a rule that\n  given some set of antecedent statements returns new statements\n  that may be added to the graph.  This is the basis for\n  implementation of most of the inference rules given in the\n  RDF formal semantics document.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureRule",
          "package": "swish",
          "signature": "Namespace-\u003e LName-\u003e Builder-\u003e Builder-\u003e RDFVarBindingModify-\u003e RDFRule",
          "type": "function"
        },
        "index": {
          "description": "Constructs an RDF graph closure rule That is rule that given some set of antecedent statements returns new statements that may be added to the graph This is the basis for implementation of most of the inference rules given in the RDF formal semantics document",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureRule",
          "normalized": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFVarBindingModify-\u003eRDFRule",
          "package": "swish",
          "partial": "Closure Rule",
          "signature": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFVarBindingModify-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeN3ClosureRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a simple RDF graph closure rule without\n  additional node allocations or variable binding constraints.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureSimpleRule",
          "package": "swish",
          "signature": "Namespace-\u003e LName-\u003e Builder-\u003e Builder-\u003e RDFRule",
          "type": "function"
        },
        "index": {
          "description": "Construct simple RDF graph closure rule without additional node allocations or variable binding constraints",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeN3ClosureSimpleRule",
          "normalized": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFRule",
          "package": "swish",
          "partial": "Closure Simple Rule",
          "signature": "Namespace-\u003eLName-\u003eBuilder-\u003eBuilder-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeN3ClosureSimpleRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function defines a variable binding modifier that\n  allocates a new blank node for each value bound to\n  a query variable, and binds it to another variable\n  in each query binding.\n\u003c/p\u003e\u003cp\u003eThis provides a single binding for query variables that would\n  otherwise be unbound by a query.  For example, consider the\n  inference pattern:\n\u003c/p\u003e\u003cpre\u003e  ?a hasUncle ?c =\u003e ?a hasFather ?b . ?b hasBrother ?c .\n\u003c/pre\u003e\u003cp\u003eFor a given \u003ccode\u003e?a\u003c/code\u003e and \u003ccode\u003e?c\u003c/code\u003e, there is insufficient information\n  here to instantiate a value for variable \u003ccode\u003e?b\u003c/code\u003e.  Using this\n  function as part of a graph instance closure rule allows\n  forward chaining to allocate a single bnode for each\n  occurrence of \u003ccode\u003e?a\u003c/code\u003e, so that given:\n\u003c/p\u003e\u003cpre\u003e  Jimmy hasUncle Fred .\n  Jimmy hasUncle Bob .\n\u003c/pre\u003e\u003cp\u003eleads to exactly one bnode inference of:\n\u003c/p\u003e\u003cpre\u003e  Jimmy hasFather _:f .\n\u003c/pre\u003e\u003cp\u003egiving:\n\u003c/p\u003e\u003cpre\u003e  Jimmy hasFather _:f .\n  _:f   hasBrother Fred .\n  _:f   hasBrother Bob .\n\u003c/pre\u003e\u003cp\u003erather than:\n\u003c/p\u003e\u003cpre\u003e  Jimmy hasFather _:f1 .\n  _:f1  hasBrother Fred .\n  Jimmy hasFather _:f2 .\n  _:f2  hasBrother Bob .\n\u003c/pre\u003e\u003cp\u003eThis form of constrained allocation of bnodes is also required for\n  some of the inference patterns described by the RDF formal semantics,\n  particularly those where bnodes are substituted for URIs or literals.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeNodeAllocTo",
          "package": "swish",
          "signature": "RDFLabel-\u003e RDFLabel-\u003e [RDFLabel]-\u003e RDFVarBindingModify",
          "type": "function"
        },
        "index": {
          "description": "This function defines variable binding modifier that allocates new blank node for each value bound to query variable and binds it to another variable in each query binding This provides single binding for query variables that would otherwise be unbound by query For example consider the inference pattern hasUncle hasFather hasBrother For given and there is insufficient information here to instantiate value for variable Using this function as part of graph instance closure rule allows forward chaining to allocate single bnode for each occurrence of so that given Jimmy hasUncle Fred Jimmy hasUncle Bob leads to exactly one bnode inference of Jimmy hasFather giving Jimmy hasFather hasBrother Fred hasBrother Bob rather than Jimmy hasFather f1 f1 hasBrother Fred Jimmy hasFather f2 f2 hasBrother Bob This form of constrained allocation of bnodes is also required for some of the inference patterns described by the RDF formal semantics particularly those where bnodes are substituted for URIs or literals",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeNodeAllocTo",
          "normalized": "RDFLabel-\u003eRDFLabel-\u003e[RDFLabel]-\u003eRDFVarBindingModify",
          "package": "swish",
          "partial": "Node Alloc To",
          "signature": "RDFLabel-\u003eRDFLabel-\u003e[RDFLabel]-\u003eRDFVarBindingModify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeNodeAllocTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructs an RDF graph closure rule.  That is, a rule that\n  given some set of antecedent statements returns new statements\n  that may be added to the graph.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeRDFClosureRule",
          "package": "swish",
          "signature": "ScopedName-\u003e [RDFGraph]-\u003e RDFGraph-\u003e RDFVarBindingModify-\u003e RDFRule",
          "type": "function"
        },
        "index": {
          "description": "Constructs an RDF graph closure rule That is rule that given some set of antecedent statements returns new statements that may be added to the graph",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeRDFClosureRule",
          "normalized": "ScopedName-\u003e[RDFGraph]-\u003eRDFGraph-\u003eRDFVarBindingModify-\u003eRDFRule",
          "package": "swish",
          "partial": "RDFClosure Rule",
          "signature": "ScopedName-\u003e[RDFGraph]-\u003eRDFGraph-\u003eRDFVarBindingModify-\u003eRDFRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeRDFClosureRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an RDF formula.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeRDFFormula",
          "package": "swish",
          "signature": "Namespace-\u003e LName-\u003e Builder-\u003e RDFFormula",
          "type": "function"
        },
        "index": {
          "description": "Create an RDF formula",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeRDFFormula",
          "normalized": "Namespace-\u003eLName-\u003eBuilder-\u003eRDFFormula",
          "package": "swish",
          "partial": "RDFFormula",
          "signature": "Namespace-\u003eLName-\u003eBuilder-\u003eRDFFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeRDFFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper function to parse a string containing Notation3\n  and return the corresponding RDFGraph value.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "makeRDFGraphFromN3Builder",
          "package": "swish",
          "signature": "Builder -\u003e RDFGraph",
          "source": "src/Swish-RDF-Ruleset.html#makeRDFGraphFromN3Builder",
          "type": "function"
        },
        "index": {
          "description": "Helper function to parse string containing Notation3 and return the corresponding RDFGraph value",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "makeRDFGraphFromN3Builder",
          "normalized": "Builder-\u003eRDFGraph",
          "package": "swish",
          "partial": "RDFGraph From Builder",
          "signature": "Builder-\u003eRDFGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:makeRDFGraphFromN3Builder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of rule for proof display\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "nameGraphRule",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Ruleset.html#GraphClosure",
          "type": "function"
        },
        "index": {
          "description": "Name of rule for proof display",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "nameGraphRule",
          "package": "swish",
          "partial": "Graph Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:nameGraphRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe null RDF formula.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "nullRDFFormula",
          "package": "swish",
          "signature": "Formula RDFGraph",
          "source": "src/Swish-RDF-Ruleset.html#nullRDFFormula",
          "type": "function"
        },
        "index": {
          "description": "The null RDF formula",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "nullRDFFormula",
          "package": "swish",
          "partial": "RDFFormula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:nullRDFFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAntecedent triples pattern\n   (may include variable nodes)\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "ruleAnt",
          "package": "swish",
          "signature": "ArcSet lb",
          "source": "src/Swish-RDF-Ruleset.html#GraphClosure",
          "type": "function"
        },
        "index": {
          "description": "Antecedent triples pattern may include variable nodes",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "ruleAnt",
          "package": "swish",
          "partial": "Ant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:ruleAnt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConsequent triples pattern\n   (may include variable nodes)\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "ruleCon",
          "package": "swish",
          "signature": "ArcSet lb",
          "source": "src/Swish-RDF-Ruleset.html#GraphClosure",
          "type": "function"
        },
        "index": {
          "description": "Consequent triples pattern may include variable nodes",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "ruleCon",
          "package": "swish",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:ruleCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStructure that defines additional\n   constraints and/or variable\n   bindings based on other matched\n   query variables.  Matching the\n   antecedents.  Use \u003ccode\u003e\u003ca\u003evarBindingId\u003c/a\u003e\u003c/code\u003e if\n   no additional variable constraints\n   or bindings are added beyond those\n   arising from graph queries.\n\u003c/p\u003e",
          "module": "Swish.RDF.Ruleset",
          "name": "ruleModify",
          "package": "swish",
          "signature": "VarBindingModify lb lb",
          "source": "src/Swish-RDF-Ruleset.html#GraphClosure",
          "type": "function"
        },
        "index": {
          "description": "Structure that defines additional constraints and or variable bindings based on other matched query variables Matching the antecedents Use varBindingId if no additional variable constraints or bindings are added beyond those arising from graph queries",
          "hierarchy": "Swish RDF Ruleset",
          "module": "Swish.RDF.Ruleset",
          "name": "ruleModify",
          "package": "swish",
          "partial": "Modify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Ruleset.html#v:ruleModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module instantiates the \u003ccode\u003e\u003ca\u003eVarBinding\u003c/a\u003e\u003c/code\u003e types and methods for use\n  with RDF graph labels.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "source": "src/Swish-RDF-VarBinding.html",
          "type": "module"
        },
        "index": {
          "description": "This module instantiates the VarBinding types and methods for use with RDF graph labels",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "partial": "Var Binding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen variable binding modifier that operates on RDFLabel values\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFOpenVarBindingModify",
          "package": "swish",
          "source": "src/Swish-RDF-VarBinding.html#RDFOpenVarBindingModify",
          "type": "type"
        },
        "index": {
          "description": "Open variable binding modifier that operates on RDFLabel values",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFOpenVarBindingModify",
          "package": "swish",
          "partial": "RDFOpen Var Binding Modify",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#t:RDFOpenVarBindingModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine type for lookup map of open query binding modifiers\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFOpenVarBindingModifyMap",
          "package": "swish",
          "source": "src/Swish-RDF-VarBinding.html#RDFOpenVarBindingModifyMap",
          "type": "type"
        },
        "index": {
          "description": "Define type for lookup map of open query binding modifiers",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFOpenVarBindingModifyMap",
          "package": "swish",
          "partial": "RDFOpen Var Binding Modify Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#t:RDFOpenVarBindingModifyMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRDFVarBinding\u003c/code\u003e is the specific type type of a variable\n  binding value used with RDF graph queries. \n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFVarBinding",
          "package": "swish",
          "source": "src/Swish-RDF-VarBinding.html#RDFVarBinding",
          "type": "type"
        },
        "index": {
          "description": "RDFVarBinding is the specific type type of variable binding value used with RDF graph queries",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFVarBinding",
          "package": "swish",
          "partial": "RDFVar Binding",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#t:RDFVarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eRDFVarBindingFilter\u003c/code\u003e is a function type that tests to see if\n  a query binding satisfies some criterion, and is used to\n  create a variable binding modifier that simply filers\n  given variable bindings.\n\u003c/p\u003e\u003cp\u003eQueries often want to apply some kind of filter or condition\n  to the variable bindings that are processed.  In inference rules,\n  it sometimes seems desirable to stipulate additional conditions on\n  the things that are matched.\n\u003c/p\u003e\u003cp\u003eThis function type is used to perform such tests.\n  A number of simple implementations are included.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFVarBindingFilter",
          "package": "swish",
          "source": "src/Swish-RDF-VarBinding.html#RDFVarBindingFilter",
          "type": "type"
        },
        "index": {
          "description": "RDFVarBindingFilter is function type that tests to see if query binding satisfies some criterion and is used to create variable binding modifier that simply filers given variable bindings Queries often want to apply some kind of filter or condition to the variable bindings that are processed In inference rules it sometimes seems desirable to stipulate additional conditions on the things that are matched This function type is used to perform such tests number of simple implementations are included",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFVarBindingFilter",
          "package": "swish",
          "partial": "RDFVar Binding Filter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#t:RDFVarBindingFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine type of query binding modifier for RDF graph inference\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFVarBindingModify",
          "package": "swish",
          "source": "src/Swish-RDF-VarBinding.html#RDFVarBindingModify",
          "type": "type"
        },
        "index": {
          "description": "Define type of query binding modifier for RDF graph inference",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "RDFVarBindingModify",
          "package": "swish",
          "partial": "RDFVar Binding Modify",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#t:RDFVarBindingModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaps no query variables.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "nullRDFVarBinding",
          "package": "swish",
          "signature": "RDFVarBinding",
          "source": "src/Swish-RDF-VarBinding.html#nullRDFVarBinding",
          "type": "function"
        },
        "index": {
          "description": "maps no query variables",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "nullRDFVarBinding",
          "package": "swish",
          "partial": "RDFVar Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:nullRDFVarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to a blank node.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingBlank",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFVarBindingFilter",
          "source": "src/Swish-RDF-VarBinding.html#rdfVarBindingBlank",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to blank node",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingBlank",
          "normalized": "RDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Blank",
          "signature": "RDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to a literal value with a\n  datatype whose URI is bound to another node\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingDatatyped",
          "package": "swish",
          "signature": "RDFLabel-\u003e RDFLabel-\u003e RDFVarBindingFilter",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to literal value with datatype whose URI is bound to another node",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingDatatyped",
          "normalized": "RDFLabel-\u003eRDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Datatyped",
          "signature": "RDFLabel-\u003eRDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingDatatyped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to a literal value.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFVarBindingFilter",
          "source": "src/Swish-RDF-VarBinding.html#rdfVarBindingLiteral",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to literal value",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingLiteral",
          "normalized": "RDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Literal",
          "signature": "RDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to container membership property.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingMemberProp",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFVarBindingFilter",
          "source": "src/Swish-RDF-VarBinding.html#rdfVarBindingMemberProp",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to container membership property",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingMemberProp",
          "normalized": "RDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Member Prop",
          "signature": "RDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingMemberProp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to a typed literal value.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingTypedLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFVarBindingFilter",
          "source": "src/Swish-RDF-VarBinding.html#rdfVarBindingTypedLiteral",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to typed literal value",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingTypedLiteral",
          "normalized": "RDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Typed Literal",
          "signature": "RDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingTypedLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to an untyped literal value.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingUntypedLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFVarBindingFilter",
          "source": "src/Swish-RDF-VarBinding.html#rdfVarBindingUntypedLiteral",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to an untyped literal value",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingUntypedLiteral",
          "normalized": "RDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Untyped Literal",
          "signature": "RDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingUntypedLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to a URI reference.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingUriRef",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFVarBindingFilter",
          "source": "src/Swish-RDF-VarBinding.html#rdfVarBindingUriRef",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to URI reference",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingUriRef",
          "normalized": "RDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Uri Ref",
          "signature": "RDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingUriRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures\n  an indicated variable is bound to an XML literal value.\n\u003c/p\u003e",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingXMLLiteral",
          "package": "swish",
          "signature": "RDFLabel -\u003e RDFVarBindingFilter",
          "source": "src/Swish-RDF-VarBinding.html#rdfVarBindingXMLLiteral",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures an indicated variable is bound to an XML literal value",
          "hierarchy": "Swish RDF VarBinding",
          "module": "Swish.RDF.VarBinding",
          "name": "rdfVarBindingXMLLiteral",
          "normalized": "RDFLabel-\u003eRDFVarBindingFilter",
          "package": "swish",
          "partial": "Var Binding XMLLiteral",
          "signature": "RDFLabel-\u003eRDFVarBindingFilter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-VarBinding.html#v:rdfVarBindingXMLLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some commonly used vocabulary terms from the Dublin Core\n  vocabularies (\u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "DublinCore",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some commonly used vocabulary terms from the Dublin Core vocabularies http dublincore.org documents dcmi-terms",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "DublinCore",
          "package": "swish",
          "partial": "Dublin Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcam:memberOf\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcam-memberOf\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcamVocabularyEncodingScheme",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcamVocabularyEncodingScheme",
          "type": "function"
        },
        "index": {
          "description": "dcam memberOf from http dublincore.org documents dcmi-terms dcam-memberOf",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcamVocabularyEncodingScheme",
          "package": "swish",
          "partial": "Vocabulary Encoding Scheme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcamVocabularyEncodingScheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcam:memberOf\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcam-memberOf\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcammemberOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcammemberOf",
          "type": "function"
        },
        "index": {
          "description": "dcam memberOf from http dublincore.org documents dcmi-terms dcam-memberOf",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcammemberOf",
          "package": "swish",
          "partial": "Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcammemberOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:contributor\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-contributor\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemcontributor",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemcontributor",
          "type": "function"
        },
        "index": {
          "description": "dcelem contributor from http dublincore.org documents dcmi-terms elements-contributor",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemcontributor",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemcontributor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:coverage\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-coverage\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemcoverage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemcoverage",
          "type": "function"
        },
        "index": {
          "description": "dcelem coverage from http dublincore.org documents dcmi-terms elements-coverage",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemcoverage",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemcoverage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:creator\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-creator\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemcreator",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemcreator",
          "type": "function"
        },
        "index": {
          "description": "dcelem creator from http dublincore.org documents dcmi-terms elements-creator",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemcreator",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemcreator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:date\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-date\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemdate",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemdate",
          "type": "function"
        },
        "index": {
          "description": "dcelem date from http dublincore.org documents dcmi-terms elements-date",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemdate",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:description\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-description\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemdescription",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemdescription",
          "type": "function"
        },
        "index": {
          "description": "dcelem description from http dublincore.org documents dcmi-terms elements-description",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemdescription",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemdescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:format\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-format\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemformat",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemformat",
          "type": "function"
        },
        "index": {
          "description": "dcelem format from http dublincore.org documents dcmi-terms elements-format",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemformat",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemformat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:identifier\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-identifier\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemidentifier",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemidentifier",
          "type": "function"
        },
        "index": {
          "description": "dcelem identifier from http dublincore.org documents dcmi-terms elements-identifier",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemidentifier",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemidentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:language\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-language\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemlanguage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemlanguage",
          "type": "function"
        },
        "index": {
          "description": "dcelem language from http dublincore.org documents dcmi-terms elements-language",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemlanguage",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemlanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:publisher\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-publisher\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelempublisher",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelempublisher",
          "type": "function"
        },
        "index": {
          "description": "dcelem publisher from http dublincore.org documents dcmi-terms elements-publisher",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelempublisher",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelempublisher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:relation\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-relation\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemrelation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemrelation",
          "type": "function"
        },
        "index": {
          "description": "dcelem relation from http dublincore.org documents dcmi-terms elements-relation",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemrelation",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemrelation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:rights\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-rights\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemrights",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemrights",
          "type": "function"
        },
        "index": {
          "description": "dcelem rights from http dublincore.org documents dcmi-terms elements-rights",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemrights",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemrights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:source\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-source\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemsource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemsource",
          "type": "function"
        },
        "index": {
          "description": "dcelem source from http dublincore.org documents dcmi-terms elements-source",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemsource",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemsource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:subject\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-subject\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemsubject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemsubject",
          "type": "function"
        },
        "index": {
          "description": "dcelem subject from http dublincore.org documents dcmi-terms elements-subject",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemsubject",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemsubject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:title\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-title\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemtitle",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemtitle",
          "type": "function"
        },
        "index": {
          "description": "dcelem title from http dublincore.org documents dcmi-terms elements-title",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemtitle",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemtitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcelem:type\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#elements-type\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemtype",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcelemtype",
          "type": "function"
        },
        "index": {
          "description": "dcelem type from http dublincore.org documents dcmi-terms elements-type",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcelemtype",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcelemtype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Agent\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-Agent\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctAgent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctAgent",
          "type": "function"
        },
        "index": {
          "description": "dcterms Agent from http dublincore.org documents dcmi-terms classes-Agent",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctAgent",
          "package": "swish",
          "partial": "Agent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctAgent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:AgentClass\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-AgentClass\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctAgentClass",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctAgentClass",
          "type": "function"
        },
        "index": {
          "description": "dcterms AgentClass from http dublincore.org documents dcmi-terms classes-AgentClass",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctAgentClass",
          "package": "swish",
          "partial": "Agent Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctAgentClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:BibliographicResource\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-BibliographicResource\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctBibliographicResource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctBibliographicResource",
          "type": "function"
        },
        "index": {
          "description": "dcterms BibliographicResource from http dublincore.org documents dcmi-terms classes-BibliographicResource",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctBibliographicResource",
          "package": "swish",
          "partial": "Bibliographic Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctBibliographicResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Box\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-Box\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctBox",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctBox",
          "type": "function"
        },
        "index": {
          "description": "dcterms Box from http dublincore.org documents dcmi-terms ses-Box",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctBox",
          "package": "swish",
          "partial": "Box",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctBox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:DCMIType\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-DCMIType\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctDCMIType",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctDCMIType",
          "type": "function"
        },
        "index": {
          "description": "dcterms DCMIType from http dublincore.org documents dcmi-terms ves-DCMIType",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctDCMIType",
          "package": "swish",
          "partial": "DCMIType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctDCMIType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:DDC\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-DDC\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctDDC",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctDDC",
          "type": "function"
        },
        "index": {
          "description": "dcterms DDC from http dublincore.org documents dcmi-terms ves-DDC",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctDDC",
          "package": "swish",
          "partial": "DDC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctDDC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:FileFormat\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-FileFormat\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctFileFormat",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctFileFormat",
          "type": "function"
        },
        "index": {
          "description": "dcterms FileFormat from http dublincore.org documents dcmi-terms classes-FileFormat",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctFileFormat",
          "package": "swish",
          "partial": "File Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctFileFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Frequency\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-Frequency\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctFrequency",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctFrequency",
          "type": "function"
        },
        "index": {
          "description": "dcterms Frequency from http dublincore.org documents dcmi-terms classes-Frequency",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctFrequency",
          "package": "swish",
          "partial": "Frequency",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctFrequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:IMT\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-IMT\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctIMT",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctIMT",
          "type": "function"
        },
        "index": {
          "description": "dcterms IMT from http dublincore.org documents dcmi-terms ves-IMT",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctIMT",
          "package": "swish",
          "partial": "IMT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctIMT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:ISO3166\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-ISO3166\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctISO3166",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctISO3166",
          "type": "function"
        },
        "index": {
          "description": "dcterms ISO3166 from http dublincore.org documents dcmi-terms ses-ISO3166",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctISO3166",
          "package": "swish",
          "partial": "ISO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctISO3166"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:ISO639-2\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-ISO639-2\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctISO639_2",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctISO639_2",
          "type": "function"
        },
        "index": {
          "description": "dcterms ISO639-2 from http dublincore.org documents dcmi-terms ses-ISO639-2",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctISO639_2",
          "package": "swish",
          "partial": "ISO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctISO639_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:ISO639-3\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-ISO639-3\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctISO639_3",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctISO639_3",
          "type": "function"
        },
        "index": {
          "description": "dcterms ISO639-3 from http dublincore.org documents dcmi-terms ses-ISO639-3",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctISO639_3",
          "package": "swish",
          "partial": "ISO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctISO639_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Jurisdiction\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-Jurisdiction\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctJurisdiction",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctJurisdiction",
          "type": "function"
        },
        "index": {
          "description": "dcterms Jurisdiction from http dublincore.org documents dcmi-terms classes-Jurisdiction",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctJurisdiction",
          "package": "swish",
          "partial": "Jurisdiction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctJurisdiction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:LCC\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-LCC\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLCC",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctLCC",
          "type": "function"
        },
        "index": {
          "description": "dcterms LCC from http dublincore.org documents dcmi-terms ves-LCC",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLCC",
          "package": "swish",
          "partial": "LCC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctLCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:LCSH\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-LCSH\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLCSH",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctLCSH",
          "type": "function"
        },
        "index": {
          "description": "dcterms LCSH from http dublincore.org documents dcmi-terms ves-LCSH",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLCSH",
          "package": "swish",
          "partial": "LCSH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctLCSH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:LicenseDocument\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-LicenseDocument\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLicenseDocument",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctLicenseDocument",
          "type": "function"
        },
        "index": {
          "description": "dcterms LicenseDocument from http dublincore.org documents dcmi-terms classes-LicenseDocument",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLicenseDocument",
          "package": "swish",
          "partial": "License Document",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctLicenseDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:LinguisticSystem\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-LinguisticSystem\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLinguisticSystem",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctLinguisticSystem",
          "type": "function"
        },
        "index": {
          "description": "dcterms LinguisticSystem from http dublincore.org documents dcmi-terms classes-LinguisticSystem",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLinguisticSystem",
          "package": "swish",
          "partial": "Linguistic System",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctLinguisticSystem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Location\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-Location\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLocation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctLocation",
          "type": "function"
        },
        "index": {
          "description": "dcterms Location from http dublincore.org documents dcmi-terms classes-Location",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLocation",
          "package": "swish",
          "partial": "Location",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:LocationPeriodOrJurisdiction\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-LocationPeriodOrJurisdiction\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLocationPeriodOrJurisdiction",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctLocationPeriodOrJurisdiction",
          "type": "function"
        },
        "index": {
          "description": "dcterms LocationPeriodOrJurisdiction from http dublincore.org documents dcmi-terms classes-LocationPeriodOrJurisdiction",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctLocationPeriodOrJurisdiction",
          "package": "swish",
          "partial": "Location Period Or Jurisdiction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctLocationPeriodOrJurisdiction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:MESH\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-MESH\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMESH",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctMESH",
          "type": "function"
        },
        "index": {
          "description": "dcterms MESH from http dublincore.org documents dcmi-terms ves-MESH",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMESH",
          "package": "swish",
          "partial": "MESH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctMESH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:MediaType\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-MediaType\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMediaType",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctMediaType",
          "type": "function"
        },
        "index": {
          "description": "dcterms MediaType from http dublincore.org documents dcmi-terms classes-MediaType",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMediaType",
          "package": "swish",
          "partial": "Media Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctMediaType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:MediaTypeOrExtent\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-MediaTypeOrExtent\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMediaTypeOrExtent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctMediaTypeOrExtent",
          "type": "function"
        },
        "index": {
          "description": "dcterms MediaTypeOrExtent from http dublincore.org documents dcmi-terms classes-MediaTypeOrExtent",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMediaTypeOrExtent",
          "package": "swish",
          "partial": "Media Type Or Extent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctMediaTypeOrExtent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:MethodOfAccrual\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-MethodOfAccrual\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMethodOfAccrual",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctMethodOfAccrual",
          "type": "function"
        },
        "index": {
          "description": "dcterms MethodOfAccrual from http dublincore.org documents dcmi-terms classes-MethodOfAccrual",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMethodOfAccrual",
          "package": "swish",
          "partial": "Method Of Accrual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctMethodOfAccrual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:MethodOfInstruction\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-MethodOfInstruction\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMethodOfInstruction",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctMethodOfInstruction",
          "type": "function"
        },
        "index": {
          "description": "dcterms MethodOfInstruction from http dublincore.org documents dcmi-terms classes-MethodOfInstruction",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctMethodOfInstruction",
          "package": "swish",
          "partial": "Method Of Instruction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctMethodOfInstruction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:NLM\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-NLM\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctNLM",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctNLM",
          "type": "function"
        },
        "index": {
          "description": "dcterms NLM from http dublincore.org documents dcmi-terms ves-NLM",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctNLM",
          "package": "swish",
          "partial": "NLM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctNLM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Period\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-Period\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPeriod",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctPeriod",
          "type": "function"
        },
        "index": {
          "description": "dcterms Period from http dublincore.org documents dcmi-terms ses-Period",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPeriod",
          "package": "swish",
          "partial": "Period",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctPeriod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:PeriodOfTime\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-PeriodOfTime\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPeriodOfTime",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctPeriodOfTime",
          "type": "function"
        },
        "index": {
          "description": "dcterms PeriodOfTime from http dublincore.org documents dcmi-terms classes-PeriodOfTime",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPeriodOfTime",
          "package": "swish",
          "partial": "Period Of Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctPeriodOfTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:PhysicalMedium\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-PhysicalMedium\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPhysicalMedium",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctPhysicalMedium",
          "type": "function"
        },
        "index": {
          "description": "dcterms PhysicalMedium from http dublincore.org documents dcmi-terms classes-PhysicalMedium",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPhysicalMedium",
          "package": "swish",
          "partial": "Physical Medium",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctPhysicalMedium"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:PhysicalResource\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-PhysicalResource\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPhysicalResource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctPhysicalResource",
          "type": "function"
        },
        "index": {
          "description": "dcterms PhysicalResource from http dublincore.org documents dcmi-terms classes-PhysicalResource",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPhysicalResource",
          "package": "swish",
          "partial": "Physical Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctPhysicalResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Point\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-Point\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPoint",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctPoint",
          "type": "function"
        },
        "index": {
          "description": "dcterms Point from http dublincore.org documents dcmi-terms ses-Point",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPoint",
          "package": "swish",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Policy\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-Policy\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPolicy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctPolicy",
          "type": "function"
        },
        "index": {
          "description": "dcterms Policy from http dublincore.org documents dcmi-terms classes-Policy",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctPolicy",
          "package": "swish",
          "partial": "Policy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctPolicy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:ProvenanceStatement\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-ProvenanceStatement\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctProvenanceStatement",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctProvenanceStatement",
          "type": "function"
        },
        "index": {
          "description": "dcterms ProvenanceStatement from http dublincore.org documents dcmi-terms classes-ProvenanceStatement",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctProvenanceStatement",
          "package": "swish",
          "partial": "Provenance Statement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctProvenanceStatement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:RFC1766\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-RFC1766\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC1766",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctRFC1766",
          "type": "function"
        },
        "index": {
          "description": "dcterms RFC1766 from http dublincore.org documents dcmi-terms ses-RFC1766",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC1766",
          "package": "swish",
          "partial": "RFC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctRFC1766"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:RFC3066\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-RFC3066\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC3066",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctRFC3066",
          "type": "function"
        },
        "index": {
          "description": "dcterms RFC3066 from http dublincore.org documents dcmi-terms ses-RFC3066",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC3066",
          "package": "swish",
          "partial": "RFC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctRFC3066"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:RFC4646\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-RFC4646\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC4646",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctRFC4646",
          "type": "function"
        },
        "index": {
          "description": "dcterms RFC4646 from http dublincore.org documents dcmi-terms ses-RFC4646",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC4646",
          "package": "swish",
          "partial": "RFC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctRFC4646"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:RFC5646\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-RFC5646\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC5646",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctRFC5646",
          "type": "function"
        },
        "index": {
          "description": "dcterms RFC5646 from http dublincore.org documents dcmi-terms ses-RFC5646",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRFC5646",
          "package": "swish",
          "partial": "RFC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctRFC5646"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:RightsStatement\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-RightsStatement\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRightsStatement",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctRightsStatement",
          "type": "function"
        },
        "index": {
          "description": "dcterms RightsStatement from http dublincore.org documents dcmi-terms classes-RightsStatement",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctRightsStatement",
          "package": "swish",
          "partial": "Rights Statement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctRightsStatement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:SizeOrDuration\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-SizeOrDuration\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctSizeOrDuration",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctSizeOrDuration",
          "type": "function"
        },
        "index": {
          "description": "dcterms SizeOrDuration from http dublincore.org documents dcmi-terms classes-SizeOrDuration",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctSizeOrDuration",
          "package": "swish",
          "partial": "Size Or Duration",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctSizeOrDuration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:Standard\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#classes-Standard\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctStandard",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctStandard",
          "type": "function"
        },
        "index": {
          "description": "dcterms Standard from http dublincore.org documents dcmi-terms classes-Standard",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctStandard",
          "package": "swish",
          "partial": "Standard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctStandard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:TGN\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-TGN\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctTGN",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctTGN",
          "type": "function"
        },
        "index": {
          "description": "dcterms TGN from http dublincore.org documents dcmi-terms ves-TGN",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctTGN",
          "package": "swish",
          "partial": "TGN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctTGN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:UDC\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ves-UDC\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctUDC",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctUDC",
          "type": "function"
        },
        "index": {
          "description": "dcterms UDC from http dublincore.org documents dcmi-terms ves-UDC",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctUDC",
          "package": "swish",
          "partial": "UDC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctUDC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:URI\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-URI\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctURI",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctURI",
          "type": "function"
        },
        "index": {
          "description": "dcterms URI from http dublincore.org documents dcmi-terms ses-URI",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctURI",
          "package": "swish",
          "partial": "URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:W3CDTF\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#ses-W3CDTF\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctW3CDTF",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctW3CDTF",
          "type": "function"
        },
        "index": {
          "description": "dcterms W3CDTF from http dublincore.org documents dcmi-terms ses-W3CDTF",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctW3CDTF",
          "package": "swish",
          "partial": "CDTF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctW3CDTF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:abstract\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-abstract\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctabstract",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctabstract",
          "type": "function"
        },
        "index": {
          "description": "dcterms abstract from http dublincore.org documents dcmi-terms terms-abstract",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctabstract",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctabstract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:accessRights\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-accessRights\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccessRights",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctaccessRights",
          "type": "function"
        },
        "index": {
          "description": "dcterms accessRights from http dublincore.org documents dcmi-terms terms-accessRights",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccessRights",
          "package": "swish",
          "partial": "Rights",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctaccessRights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:accrualMethod\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-accrualMethod\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccrualMethod",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctaccrualMethod",
          "type": "function"
        },
        "index": {
          "description": "dcterms accrualMethod from http dublincore.org documents dcmi-terms terms-accrualMethod",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccrualMethod",
          "package": "swish",
          "partial": "Method",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctaccrualMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:accrualPeriodicity\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-accrualPeriodicity\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccrualPeriodicity",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctaccrualPeriodicity",
          "type": "function"
        },
        "index": {
          "description": "dcterms accrualPeriodicity from http dublincore.org documents dcmi-terms terms-accrualPeriodicity",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccrualPeriodicity",
          "package": "swish",
          "partial": "Periodicity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctaccrualPeriodicity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:accrualPolicy\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-accrualPolicy\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccrualPolicy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctaccrualPolicy",
          "type": "function"
        },
        "index": {
          "description": "dcterms accrualPolicy from http dublincore.org documents dcmi-terms terms-accrualPolicy",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaccrualPolicy",
          "package": "swish",
          "partial": "Policy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctaccrualPolicy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:alternative\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-alternative\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctalternative",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctalternative",
          "type": "function"
        },
        "index": {
          "description": "dcterms alternative from http dublincore.org documents dcmi-terms terms-alternative",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctalternative",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctalternative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:audience\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-audience\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaudience",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctaudience",
          "type": "function"
        },
        "index": {
          "description": "dcterms audience from http dublincore.org documents dcmi-terms terms-audience",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctaudience",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctaudience"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:available\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-available\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctavailable",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctavailable",
          "type": "function"
        },
        "index": {
          "description": "dcterms available from http dublincore.org documents dcmi-terms terms-available",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctavailable",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctavailable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:bibliographicCitation\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-bibliographicCitation\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctbibliographicCitation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctbibliographicCitation",
          "type": "function"
        },
        "index": {
          "description": "dcterms bibliographicCitation from http dublincore.org documents dcmi-terms terms-bibliographicCitation",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctbibliographicCitation",
          "package": "swish",
          "partial": "Citation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctbibliographicCitation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:conformsTo\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-conformsTo\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctconformsTo",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctconformsTo",
          "type": "function"
        },
        "index": {
          "description": "dcterms conformsTo from http dublincore.org documents dcmi-terms terms-conformsTo",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctconformsTo",
          "package": "swish",
          "partial": "To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctconformsTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:contributor\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-contributor\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcontributor",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctcontributor",
          "type": "function"
        },
        "index": {
          "description": "dcterms contributor from http dublincore.org documents dcmi-terms terms-contributor",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcontributor",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctcontributor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:coverage\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-coverage\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcoverage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctcoverage",
          "type": "function"
        },
        "index": {
          "description": "dcterms coverage from http dublincore.org documents dcmi-terms terms-coverage",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcoverage",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctcoverage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:created\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-created\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcreated",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctcreated",
          "type": "function"
        },
        "index": {
          "description": "dcterms created from http dublincore.org documents dcmi-terms terms-created",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcreated",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctcreated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:creator\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-creator\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcreator",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctcreator",
          "type": "function"
        },
        "index": {
          "description": "dcterms creator from http dublincore.org documents dcmi-terms terms-creator",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctcreator",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctcreator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:date\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-date\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdate",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctdate",
          "type": "function"
        },
        "index": {
          "description": "dcterms date from http dublincore.org documents dcmi-terms terms-date",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdate",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:dateAccepted\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-dateAccepted\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdateAccepted",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctdateAccepted",
          "type": "function"
        },
        "index": {
          "description": "dcterms dateAccepted from http dublincore.org documents dcmi-terms terms-dateAccepted",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdateAccepted",
          "package": "swish",
          "partial": "Accepted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctdateAccepted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:dateCopyrighted\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-dateCopyrighted\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdateCopyrighted",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctdateCopyrighted",
          "type": "function"
        },
        "index": {
          "description": "dcterms dateCopyrighted from http dublincore.org documents dcmi-terms terms-dateCopyrighted",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdateCopyrighted",
          "package": "swish",
          "partial": "Copyrighted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctdateCopyrighted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:dateSubmitted\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-dateSubmitted\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdateSubmitted",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctdateSubmitted",
          "type": "function"
        },
        "index": {
          "description": "dcterms dateSubmitted from http dublincore.org documents dcmi-terms terms-dateSubmitted",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdateSubmitted",
          "package": "swish",
          "partial": "Submitted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctdateSubmitted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:description\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-description\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdescription",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctdescription",
          "type": "function"
        },
        "index": {
          "description": "dcterms description from http dublincore.org documents dcmi-terms terms-description",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctdescription",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctdescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:educationLevel\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-educationLevel\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcteducationLevel",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcteducationLevel",
          "type": "function"
        },
        "index": {
          "description": "dcterms educationLevel from http dublincore.org documents dcmi-terms terms-educationLevel",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcteducationLevel",
          "package": "swish",
          "partial": "Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcteducationLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:extent\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-extent\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctextent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctextent",
          "type": "function"
        },
        "index": {
          "description": "dcterms extent from http dublincore.org documents dcmi-terms terms-extent",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctextent",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctextent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:format\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-format\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctformat",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctformat",
          "type": "function"
        },
        "index": {
          "description": "dcterms format from http dublincore.org documents dcmi-terms terms-format",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctformat",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctformat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:hasFormat\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-hasFormat\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcthasFormat",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcthasFormat",
          "type": "function"
        },
        "index": {
          "description": "dcterms hasFormat from http dublincore.org documents dcmi-terms terms-hasFormat",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcthasFormat",
          "package": "swish",
          "partial": "Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcthasFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:hasPart\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-hasPart\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcthasPart",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcthasPart",
          "type": "function"
        },
        "index": {
          "description": "dcterms hasPart from http dublincore.org documents dcmi-terms terms-hasPart",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcthasPart",
          "package": "swish",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcthasPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:hasVersion\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-hasVersion\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcthasVersion",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcthasVersion",
          "type": "function"
        },
        "index": {
          "description": "dcterms hasVersion from http dublincore.org documents dcmi-terms terms-hasVersion",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcthasVersion",
          "package": "swish",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcthasVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:identifier\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-identifier\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctidentifier",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctidentifier",
          "type": "function"
        },
        "index": {
          "description": "dcterms identifier from http dublincore.org documents dcmi-terms terms-identifier",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctidentifier",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctidentifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:instructionalMethod\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-instructionalMethod\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctinstructionalMethod",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctinstructionalMethod",
          "type": "function"
        },
        "index": {
          "description": "dcterms instructionalMethod from http dublincore.org documents dcmi-terms terms-instructionalMethod",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctinstructionalMethod",
          "package": "swish",
          "partial": "Method",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctinstructionalMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:isFormatOf\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-isFormatOf\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisFormatOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctisFormatOf",
          "type": "function"
        },
        "index": {
          "description": "dcterms isFormatOf from http dublincore.org documents dcmi-terms terms-isFormatOf",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisFormatOf",
          "package": "swish",
          "partial": "Format Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctisFormatOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:isPartOf\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-isPartOf\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisPartOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctisPartOf",
          "type": "function"
        },
        "index": {
          "description": "dcterms isPartOf from http dublincore.org documents dcmi-terms terms-isPartOf",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisPartOf",
          "package": "swish",
          "partial": "Part Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctisPartOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:isReferencedBy\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-isReferencedBy\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisReferencedBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctisReferencedBy",
          "type": "function"
        },
        "index": {
          "description": "dcterms isReferencedBy from http dublincore.org documents dcmi-terms terms-isReferencedBy",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisReferencedBy",
          "package": "swish",
          "partial": "Referenced By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctisReferencedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:isReplacedBy\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-isReplacedBy\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisReplacedBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctisReplacedBy",
          "type": "function"
        },
        "index": {
          "description": "dcterms isReplacedBy from http dublincore.org documents dcmi-terms terms-isReplacedBy",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisReplacedBy",
          "package": "swish",
          "partial": "Replaced By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctisReplacedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:isRequiredBy\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-isRequiredBy\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisRequiredBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctisRequiredBy",
          "type": "function"
        },
        "index": {
          "description": "dcterms isRequiredBy from http dublincore.org documents dcmi-terms terms-isRequiredBy",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisRequiredBy",
          "package": "swish",
          "partial": "Required By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctisRequiredBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:isVersionOf\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-isVersionOf\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisVersionOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctisVersionOf",
          "type": "function"
        },
        "index": {
          "description": "dcterms isVersionOf from http dublincore.org documents dcmi-terms terms-isVersionOf",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctisVersionOf",
          "package": "swish",
          "partial": "Version Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctisVersionOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:issued\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-issued\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctissued",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctissued",
          "type": "function"
        },
        "index": {
          "description": "dcterms issued from http dublincore.org documents dcmi-terms terms-issued",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctissued",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctissued"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:language\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-language\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctlanguage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctlanguage",
          "type": "function"
        },
        "index": {
          "description": "dcterms language from http dublincore.org documents dcmi-terms terms-language",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctlanguage",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctlanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:license\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-license\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctlicense",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctlicense",
          "type": "function"
        },
        "index": {
          "description": "dcterms license from http dublincore.org documents dcmi-terms terms-license",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctlicense",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctlicense"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:mediator\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-mediator\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctmediator",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctmediator",
          "type": "function"
        },
        "index": {
          "description": "dcterms mediator from http dublincore.org documents dcmi-terms terms-mediator",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctmediator",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctmediator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:medium\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-medium\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctmedium",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctmedium",
          "type": "function"
        },
        "index": {
          "description": "dcterms medium from http dublincore.org documents dcmi-terms terms-medium",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctmedium",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctmedium"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:modified\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-modified\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctmodified",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctmodified",
          "type": "function"
        },
        "index": {
          "description": "dcterms modified from http dublincore.org documents dcmi-terms terms-modified",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctmodified",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctmodified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:provenance\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-provenance\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctprovenance",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctprovenance",
          "type": "function"
        },
        "index": {
          "description": "dcterms provenance from http dublincore.org documents dcmi-terms terms-provenance",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctprovenance",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctprovenance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:publisher\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-publisher\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctpublisher",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctpublisher",
          "type": "function"
        },
        "index": {
          "description": "dcterms publisher from http dublincore.org documents dcmi-terms terms-publisher",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctpublisher",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctpublisher"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:references\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-references\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctreferences",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctreferences",
          "type": "function"
        },
        "index": {
          "description": "dcterms references from http dublincore.org documents dcmi-terms terms-references",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctreferences",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctreferences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:relation\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-relation\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrelation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctrelation",
          "type": "function"
        },
        "index": {
          "description": "dcterms relation from http dublincore.org documents dcmi-terms terms-relation",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrelation",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctrelation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:replaces\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-replaces\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctreplaces",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctreplaces",
          "type": "function"
        },
        "index": {
          "description": "dcterms replaces from http dublincore.org documents dcmi-terms terms-replaces",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctreplaces",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctreplaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:requires\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-requires\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrequires",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctrequires",
          "type": "function"
        },
        "index": {
          "description": "dcterms requires from http dublincore.org documents dcmi-terms terms-requires",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrequires",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctrequires"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:rights\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-rights\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrights",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctrights",
          "type": "function"
        },
        "index": {
          "description": "dcterms rights from http dublincore.org documents dcmi-terms terms-rights",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrights",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctrights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:rightsHolder\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-rightsHolder\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrightsHolder",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctrightsHolder",
          "type": "function"
        },
        "index": {
          "description": "dcterms rightsHolder from http dublincore.org documents dcmi-terms terms-rightsHolder",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctrightsHolder",
          "package": "swish",
          "partial": "Holder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctrightsHolder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:source\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-source\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctsource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctsource",
          "type": "function"
        },
        "index": {
          "description": "dcterms source from http dublincore.org documents dcmi-terms terms-source",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctsource",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctsource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:spatial\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-spatial\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctspatial",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctspatial",
          "type": "function"
        },
        "index": {
          "description": "dcterms spatial from http dublincore.org documents dcmi-terms terms-spatial",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctspatial",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctspatial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:subject\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-subject\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctsubject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctsubject",
          "type": "function"
        },
        "index": {
          "description": "dcterms subject from http dublincore.org documents dcmi-terms terms-subject",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctsubject",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctsubject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:tableOfContents\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-tableOfContents\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttableOfContents",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcttableOfContents",
          "type": "function"
        },
        "index": {
          "description": "dcterms tableOfContents from http dublincore.org documents dcmi-terms terms-tableOfContents",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttableOfContents",
          "package": "swish",
          "partial": "Of Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcttableOfContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:temporal\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-temporal\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttemporal",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcttemporal",
          "type": "function"
        },
        "index": {
          "description": "dcterms temporal from http dublincore.org documents dcmi-terms terms-temporal",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttemporal",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcttemporal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:title\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-title\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttitle",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcttitle",
          "type": "function"
        },
        "index": {
          "description": "dcterms title from http dublincore.org documents dcmi-terms terms-title",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttitle",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcttitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:type\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-type\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttype",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dcttype",
          "type": "function"
        },
        "index": {
          "description": "dcterms type from http dublincore.org documents dcmi-terms terms-type",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dcttype",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dcttype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edcterms:valid\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#terms-valid\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctvalid",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctvalid",
          "type": "function"
        },
        "index": {
          "description": "dcterms valid from http dublincore.org documents dcmi-terms terms-valid",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctvalid",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctvalid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Collection\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Collection\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeCollection",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeCollection",
          "type": "function"
        },
        "index": {
          "description": "dctype Collection from http dublincore.org documents dcmi-terms dcmitype-Collection",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeCollection",
          "package": "swish",
          "partial": "Collection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeCollection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Dataset\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Dataset\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeDataset",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeDataset",
          "type": "function"
        },
        "index": {
          "description": "dctype Dataset from http dublincore.org documents dcmi-terms dcmitype-Dataset",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeDataset",
          "package": "swish",
          "partial": "Dataset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeDataset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Event\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Event\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeEvent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeEvent",
          "type": "function"
        },
        "index": {
          "description": "dctype Event from http dublincore.org documents dcmi-terms dcmitype-Event",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeEvent",
          "package": "swish",
          "partial": "Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Image\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Image\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeImage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeImage",
          "type": "function"
        },
        "index": {
          "description": "dctype Image from http dublincore.org documents dcmi-terms dcmitype-Image",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeImage",
          "package": "swish",
          "partial": "Image",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:InteractiveResource\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-InteractiveResource\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeInteractiveResource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeInteractiveResource",
          "type": "function"
        },
        "index": {
          "description": "dctype InteractiveResource from http dublincore.org documents dcmi-terms dcmitype-InteractiveResource",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeInteractiveResource",
          "package": "swish",
          "partial": "Interactive Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeInteractiveResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:MovingImage\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-MovingImage\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeMovingImage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeMovingImage",
          "type": "function"
        },
        "index": {
          "description": "dctype MovingImage from http dublincore.org documents dcmi-terms dcmitype-MovingImage",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeMovingImage",
          "package": "swish",
          "partial": "Moving Image",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeMovingImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:PhysicalObject\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-PhysicalObject\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypePhysicalObject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypePhysicalObject",
          "type": "function"
        },
        "index": {
          "description": "dctype PhysicalObject from http dublincore.org documents dcmi-terms dcmitype-PhysicalObject",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypePhysicalObject",
          "package": "swish",
          "partial": "Physical Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypePhysicalObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Service\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Service\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeService",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeService",
          "type": "function"
        },
        "index": {
          "description": "dctype Service from http dublincore.org documents dcmi-terms dcmitype-Service",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeService",
          "package": "swish",
          "partial": "Service",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeService"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Software\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Software\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeSoftware",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeSoftware",
          "type": "function"
        },
        "index": {
          "description": "dctype Software from http dublincore.org documents dcmi-terms dcmitype-Software",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeSoftware",
          "package": "swish",
          "partial": "Software",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeSoftware"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Sound\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Sound\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeSound",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeSound",
          "type": "function"
        },
        "index": {
          "description": "dctype Sound from http dublincore.org documents dcmi-terms dcmitype-Sound",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeSound",
          "package": "swish",
          "partial": "Sound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeSound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:StillImage\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-StillImage\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeStillImage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeStillImage",
          "type": "function"
        },
        "index": {
          "description": "dctype StillImage from http dublincore.org documents dcmi-terms dcmitype-StillImage",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeStillImage",
          "package": "swish",
          "partial": "Still Image",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeStillImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edctype:Text\u003c/code\u003e from \u003ca\u003ehttp://dublincore.org/documents/dcmi-terms/#dcmitype-Text\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeText",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#dctypeText",
          "type": "function"
        },
        "index": {
          "description": "dctype Text from http dublincore.org documents dcmi-terms dcmitype-Text",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "dctypeText",
          "package": "swish",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:dctypeText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003edcam\u003c/code\u003e to \u003ca\u003ehttp://purl.org/dc/dcam/\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCAM",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#namespaceDCAM",
          "type": "function"
        },
        "index": {
          "description": "Maps dcam to http purl.org dc dcam",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCAM",
          "package": "swish",
          "partial": "DCAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:namespaceDCAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003edcelem\u003c/code\u003e to the legacy namespace \u003ca\u003ehttp://purl.org/dc/elements/1.1/\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCELEM",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#namespaceDCELEM",
          "type": "function"
        },
        "index": {
          "description": "Maps dcelem to the legacy namespace http purl.org dc elements",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCELEM",
          "package": "swish",
          "partial": "DCELEM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:namespaceDCELEM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003edcterms\u003c/code\u003e to \u003ca\u003ehttp://purl.org/dc/terms/\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCTERMS",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#namespaceDCTERMS",
          "type": "function"
        },
        "index": {
          "description": "Maps dcterms to http purl.org dc terms",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCTERMS",
          "package": "swish",
          "partial": "DCTERMS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:namespaceDCTERMS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003edctype\u003c/code\u003e to \u003ca\u003ehttp://purl.org/dc/dcmitype/\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCTYPE",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-DublinCore.html#namespaceDCTYPE",
          "type": "function"
        },
        "index": {
          "description": "Maps dctype to http purl.org dc dcmitype",
          "hierarchy": "Swish RDF Vocabulary DublinCore",
          "module": "Swish.RDF.Vocabulary.DublinCore",
          "name": "namespaceDCTYPE",
          "package": "swish",
          "partial": "DCTYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-DublinCore.html#v:namespaceDCTYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some commonly used vocabulary terms from the FOAF\n  vocabulary (\u003ca\u003ehttp://xmlns.com/foaf/spec/\u003c/a\u003e).\n\u003c/p\u003e\u003cp\u003eNote that unlike some of the existing vocabularies in Swish, the FOAF\n  one matches the case and spelling of the RDF terms; so we\n  use \u003ccode\u003e\u003ca\u003efoafbased_near\u003c/a\u003e\u003c/code\u003e\n  rather than \u003ccode\u003efoafBasedNear\u003c/code\u003e. This is partly because some terms would\n  end up with the same Haskell label if a conversion to camel-case wer\n  used.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "FOAF",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some commonly used vocabulary terms from the FOAF vocabulary http xmlns.com foaf spec Note that unlike some of the existing vocabularies in Swish the FOAF one matches the case and spelling of the RDF terms so we use foafbased near rather than foafBasedNear This is partly because some terms would end up with the same Haskell label if conversion to camel-case wer used",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "FOAF",
          "package": "swish",
          "partial": "FOAF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:Agent\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_Agent\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafAgent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafAgent",
          "type": "function"
        },
        "index": {
          "description": "foaf Agent from http xmlns.com foaf spec term Agent",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafAgent",
          "package": "swish",
          "partial": "Agent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafAgent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:Document\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_Document\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafDocument",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafDocument",
          "type": "function"
        },
        "index": {
          "description": "foaf Document from http xmlns.com foaf spec term Document",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafDocument",
          "package": "swish",
          "partial": "Document",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:Group\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_Group\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafGroup",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafGroup",
          "type": "function"
        },
        "index": {
          "description": "foaf Group from http xmlns.com foaf spec term Group",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafGroup",
          "package": "swish",
          "partial": "Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafGroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:Image\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_Image\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafImage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafImage",
          "type": "function"
        },
        "index": {
          "description": "foaf Image from http xmlns.com foaf spec term Image",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafImage",
          "package": "swish",
          "partial": "Image",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:LabelProperty\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_LabelProperty\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafLabelProperty",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafLabelProperty",
          "type": "function"
        },
        "index": {
          "description": "foaf LabelProperty from http xmlns.com foaf spec term LabelProperty",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafLabelProperty",
          "package": "swish",
          "partial": "Label Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafLabelProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:OnlineAccount\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_OnlineAccount\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineAccount",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafOnlineAccount",
          "type": "function"
        },
        "index": {
          "description": "foaf OnlineAccount from http xmlns.com foaf spec term OnlineAccount",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineAccount",
          "package": "swish",
          "partial": "Online Account",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafOnlineAccount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:OnlineChatAccount\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_OnlineChatAccount\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineChatAccount",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafOnlineChatAccount",
          "type": "function"
        },
        "index": {
          "description": "foaf OnlineChatAccount from http xmlns.com foaf spec term OnlineChatAccount",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineChatAccount",
          "package": "swish",
          "partial": "Online Chat Account",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafOnlineChatAccount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:OnlineEcommerceAccount\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_OnlineEcommerceAccount\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineEcommerceAccount",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafOnlineEcommerceAccount",
          "type": "function"
        },
        "index": {
          "description": "foaf OnlineEcommerceAccount from http xmlns.com foaf spec term OnlineEcommerceAccount",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineEcommerceAccount",
          "package": "swish",
          "partial": "Online Ecommerce Account",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafOnlineEcommerceAccount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:OnlineGamingAccount\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_OnlineGamingAccount\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineGamingAccount",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafOnlineGamingAccount",
          "type": "function"
        },
        "index": {
          "description": "foaf OnlineGamingAccount from http xmlns.com foaf spec term OnlineGamingAccount",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOnlineGamingAccount",
          "package": "swish",
          "partial": "Online Gaming Account",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafOnlineGamingAccount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:Organization\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_Organization\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOrganization",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafOrganization",
          "type": "function"
        },
        "index": {
          "description": "foaf Organization from http xmlns.com foaf spec term Organization",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafOrganization",
          "package": "swish",
          "partial": "Organization",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafOrganization"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:Person\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_Person\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafPerson",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafPerson",
          "type": "function"
        },
        "index": {
          "description": "foaf Person from http xmlns.com foaf spec term Person",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafPerson",
          "package": "swish",
          "partial": "Person",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafPerson"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:PersonalProfileDocument\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_PersonalProfileDocument\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafPersonalProfileDocument",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafPersonalProfileDocument",
          "type": "function"
        },
        "index": {
          "description": "foaf PersonalProfileDocument from http xmlns.com foaf spec term PersonalProfileDocument",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafPersonalProfileDocument",
          "package": "swish",
          "partial": "Personal Profile Document",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafPersonalProfileDocument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:Project\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_Project\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafProject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafProject",
          "type": "function"
        },
        "index": {
          "description": "foaf Project from http xmlns.com foaf spec term Project",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafProject",
          "package": "swish",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:account\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_account\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaccount",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafaccount",
          "type": "function"
        },
        "index": {
          "description": "foaf account from http xmlns.com foaf spec term account",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaccount",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafaccount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:accountName\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_accountName\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaccountName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafaccountName",
          "type": "function"
        },
        "index": {
          "description": "foaf accountName from http xmlns.com foaf spec term accountName",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaccountName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafaccountName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:accountServiceHomepage\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_accountServiceHomepage\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaccountServiceHomepage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafaccountServiceHomepage",
          "type": "function"
        },
        "index": {
          "description": "foaf accountServiceHomepage from http xmlns.com foaf spec term accountServiceHomepage",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaccountServiceHomepage",
          "package": "swish",
          "partial": "Service Homepage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafaccountServiceHomepage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:age\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_age\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafage",
          "type": "function"
        },
        "index": {
          "description": "foaf age from http xmlns.com foaf spec term age",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafage",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:aimChatID\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_aimChatID\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaimChatID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafaimChatID",
          "type": "function"
        },
        "index": {
          "description": "foaf aimChatID from http xmlns.com foaf spec term aimChatID",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafaimChatID",
          "package": "swish",
          "partial": "Chat ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafaimChatID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:based_near\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_based_near\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafbased_near",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafbased_near",
          "type": "function"
        },
        "index": {
          "description": "foaf based near from http xmlns.com foaf spec term based near",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafbased_near",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafbased_near"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:birthday\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_birthday\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafbirthday",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafbirthday",
          "type": "function"
        },
        "index": {
          "description": "foaf birthday from http xmlns.com foaf spec term birthday",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafbirthday",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafbirthday"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:currentProject\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_currentProject\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafcurrentProject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafcurrentProject",
          "type": "function"
        },
        "index": {
          "description": "foaf currentProject from http xmlns.com foaf spec term currentProject",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafcurrentProject",
          "package": "swish",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafcurrentProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:depiction\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_depiction\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafdepiction",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafdepiction",
          "type": "function"
        },
        "index": {
          "description": "foaf depiction from http xmlns.com foaf spec term depiction",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafdepiction",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafdepiction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:depicts\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_depicts\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafdepicts",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafdepicts",
          "type": "function"
        },
        "index": {
          "description": "foaf depicts from http xmlns.com foaf spec term depicts",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafdepicts",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafdepicts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:dnaChecksum\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_dnaChecksum\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafdnaChecksum",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafdnaChecksum",
          "type": "function"
        },
        "index": {
          "description": "foaf dnaChecksum from http xmlns.com foaf spec term dnaChecksum",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafdnaChecksum",
          "package": "swish",
          "partial": "Checksum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafdnaChecksum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:familyName\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_familyName\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffamilyName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaffamilyName",
          "type": "function"
        },
        "index": {
          "description": "foaf familyName from http xmlns.com foaf spec term familyName",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffamilyName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaffamilyName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:family_name\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_family_name\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffamily_name",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaffamily_name",
          "type": "function"
        },
        "index": {
          "description": "foaf family name from http xmlns.com foaf spec term family name",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffamily_name",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaffamily_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:firstName\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_firstName\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffirstName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaffirstName",
          "type": "function"
        },
        "index": {
          "description": "foaf firstName from http xmlns.com foaf spec term firstName",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffirstName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaffirstName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:focus\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_focus\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffocus",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaffocus",
          "type": "function"
        },
        "index": {
          "description": "foaf focus from http xmlns.com foaf spec term focus",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffocus",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaffocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:fundedBy\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_fundedBy\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffundedBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaffundedBy",
          "type": "function"
        },
        "index": {
          "description": "foaf fundedBy from http xmlns.com foaf spec term fundedBy",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaffundedBy",
          "package": "swish",
          "partial": "By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaffundedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:geekcode\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_geekcode\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgeekcode",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafgeekcode",
          "type": "function"
        },
        "index": {
          "description": "foaf geekcode from http xmlns.com foaf spec term geekcode",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgeekcode",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafgeekcode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:gender\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_gender\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgender",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafgender",
          "type": "function"
        },
        "index": {
          "description": "foaf gender from http xmlns.com foaf spec term gender",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgender",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafgender"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:givenName\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_givenName\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgivenName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafgivenName",
          "type": "function"
        },
        "index": {
          "description": "foaf givenName from http xmlns.com foaf spec term givenName",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgivenName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafgivenName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:givenname\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_givenname\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgivenname",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafgivenname",
          "type": "function"
        },
        "index": {
          "description": "foaf givenname from http xmlns.com foaf spec term givenname",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafgivenname",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafgivenname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:holdsAccount\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_holdsAccount\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafholdsAccount",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafholdsAccount",
          "type": "function"
        },
        "index": {
          "description": "foaf holdsAccount from http xmlns.com foaf spec term holdsAccount",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafholdsAccount",
          "package": "swish",
          "partial": "Account",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafholdsAccount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:homepage\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_homepage\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafhomepage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafhomepage",
          "type": "function"
        },
        "index": {
          "description": "foaf homepage from http xmlns.com foaf spec term homepage",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafhomepage",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafhomepage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:icqChatID\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_icqChatID\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaficqChatID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaficqChatID",
          "type": "function"
        },
        "index": {
          "description": "foaf icqChatID from http xmlns.com foaf spec term icqChatID",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaficqChatID",
          "package": "swish",
          "partial": "Chat ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaficqChatID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:img\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_img\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafimg",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafimg",
          "type": "function"
        },
        "index": {
          "description": "foaf img from http xmlns.com foaf spec term img",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafimg",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafimg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:interest\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_interest\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafinterest",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafinterest",
          "type": "function"
        },
        "index": {
          "description": "foaf interest from http xmlns.com foaf spec term interest",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafinterest",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafinterest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:isPrimaryTopicOf\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_isPrimaryTopicOf\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafisPrimaryTopicOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafisPrimaryTopicOf",
          "type": "function"
        },
        "index": {
          "description": "foaf isPrimaryTopicOf from http xmlns.com foaf spec term isPrimaryTopicOf",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafisPrimaryTopicOf",
          "package": "swish",
          "partial": "Primary Topic Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafisPrimaryTopicOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:jabberID\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_jabberID\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafjabberID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafjabberID",
          "type": "function"
        },
        "index": {
          "description": "foaf jabberID from http xmlns.com foaf spec term jabberID",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafjabberID",
          "package": "swish",
          "partial": "ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafjabberID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:knows\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_knows\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafknows",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafknows",
          "type": "function"
        },
        "index": {
          "description": "foaf knows from http xmlns.com foaf spec term knows",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafknows",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafknows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:lastName\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_lastName\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaflastName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaflastName",
          "type": "function"
        },
        "index": {
          "description": "foaf lastName from http xmlns.com foaf spec term lastName",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaflastName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaflastName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:logo\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_logo\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaflogo",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaflogo",
          "type": "function"
        },
        "index": {
          "description": "foaf logo from http xmlns.com foaf spec term logo",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaflogo",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaflogo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:made\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_made\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmade",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmade",
          "type": "function"
        },
        "index": {
          "description": "foaf made from http xmlns.com foaf spec term made",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmade",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmade"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:maker\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_maker\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmaker",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmaker",
          "type": "function"
        },
        "index": {
          "description": "foaf maker from http xmlns.com foaf spec term maker",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmaker",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmaker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:mbox\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_mbox\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmbox",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmbox",
          "type": "function"
        },
        "index": {
          "description": "foaf mbox from http xmlns.com foaf spec term mbox",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmbox",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmbox"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:mbox_sha1sum\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_mbox_sha1sum\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmbox_sha1sum",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmbox_sha1sum",
          "type": "function"
        },
        "index": {
          "description": "foaf mbox sha1sum from http xmlns.com foaf spec term mbox sha1sum",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmbox_sha1sum",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmbox_sha1sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:member\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_member\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmember",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmember",
          "type": "function"
        },
        "index": {
          "description": "foaf member from http xmlns.com foaf spec term member",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmember",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:membershipClass\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_membershipClass\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmembershipClass",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmembershipClass",
          "type": "function"
        },
        "index": {
          "description": "foaf membershipClass from http xmlns.com foaf spec term membershipClass",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmembershipClass",
          "package": "swish",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmembershipClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:msnChatID\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_msnChatID\u003c/a\u003e.  \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmsnChatID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmsnChatID",
          "type": "function"
        },
        "index": {
          "description": "foaf msnChatID from http xmlns.com foaf spec term msnChatID",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmsnChatID",
          "package": "swish",
          "partial": "Chat ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmsnChatID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:myersBriggs\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_myersBriggs\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmyersBriggs",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafmyersBriggs",
          "type": "function"
        },
        "index": {
          "description": "foaf myersBriggs from http xmlns.com foaf spec term myersBriggs",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafmyersBriggs",
          "package": "swish",
          "partial": "Briggs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafmyersBriggs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:name\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_name\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafname",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafname",
          "type": "function"
        },
        "index": {
          "description": "foaf name from http xmlns.com foaf spec term name",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafname",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:nick\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_nick\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafnick",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafnick",
          "type": "function"
        },
        "index": {
          "description": "foaf nick from http xmlns.com foaf spec term nick",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafnick",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafnick"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:openid\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_openid\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafopenid",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafopenid",
          "type": "function"
        },
        "index": {
          "description": "foaf openid from http xmlns.com foaf spec term openid",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafopenid",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafopenid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:page\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_page\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafpage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafpage",
          "type": "function"
        },
        "index": {
          "description": "foaf page from http xmlns.com foaf spec term page",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafpage",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafpage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:pastProject\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_pastProject\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafpastProject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafpastProject",
          "type": "function"
        },
        "index": {
          "description": "foaf pastProject from http xmlns.com foaf spec term pastProject",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafpastProject",
          "package": "swish",
          "partial": "Project",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafpastProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:phone\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_phone\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafphone",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafphone",
          "type": "function"
        },
        "index": {
          "description": "foaf phone from http xmlns.com foaf spec term phone",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafphone",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafphone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:plan\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_plan\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafplan",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafplan",
          "type": "function"
        },
        "index": {
          "description": "foaf plan from http xmlns.com foaf spec term plan",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafplan",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafplan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:primaryTopic\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_primaryTopic\u003c/a\u003e.  \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafprimaryTopic",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafprimaryTopic",
          "type": "function"
        },
        "index": {
          "description": "foaf primaryTopic from http xmlns.com foaf spec term primaryTopic",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafprimaryTopic",
          "package": "swish",
          "partial": "Topic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafprimaryTopic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:publications\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_publications\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafpublications",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafpublications",
          "type": "function"
        },
        "index": {
          "description": "foaf publications from http xmlns.com foaf spec term publications",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafpublications",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafpublications"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:schoolHomepage\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_schoolHomepage\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafschoolHomepage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafschoolHomepage",
          "type": "function"
        },
        "index": {
          "description": "foaf schoolHomepage from http xmlns.com foaf spec term schoolHomepage",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafschoolHomepage",
          "package": "swish",
          "partial": "Homepage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafschoolHomepage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:sha1\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_sha1\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafsha1",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafsha1",
          "type": "function"
        },
        "index": {
          "description": "foaf sha1 from http xmlns.com foaf spec term sha1",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafsha1",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafsha1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:skypeID\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_skypeID\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafskypeID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafskypeID",
          "type": "function"
        },
        "index": {
          "description": "foaf skypeID from http xmlns.com foaf spec term skypeID",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafskypeID",
          "package": "swish",
          "partial": "ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafskypeID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:status\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_status\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafstatus",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafstatus",
          "type": "function"
        },
        "index": {
          "description": "foaf status from http xmlns.com foaf spec term status",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafstatus",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafstatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:surname\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_surname\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafsurname",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafsurname",
          "type": "function"
        },
        "index": {
          "description": "foaf surname from http xmlns.com foaf spec term surname",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafsurname",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafsurname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:theme\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_theme\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftheme",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaftheme",
          "type": "function"
        },
        "index": {
          "description": "foaf theme from http xmlns.com foaf spec term theme",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftheme",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaftheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:thumbnail\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_thumbnail\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafthumbnail",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafthumbnail",
          "type": "function"
        },
        "index": {
          "description": "foaf thumbnail from http xmlns.com foaf spec term thumbnail",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafthumbnail",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafthumbnail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:tipjar\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_tipjar\u003c/a\u003e.  \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftipjar",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaftipjar",
          "type": "function"
        },
        "index": {
          "description": "foaf tipjar from http xmlns.com foaf spec term tipjar",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftipjar",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaftipjar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:title\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_title\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftitle",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaftitle",
          "type": "function"
        },
        "index": {
          "description": "foaf title from http xmlns.com foaf spec term title",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftitle",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaftitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:topic\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_topic\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftopic",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaftopic",
          "type": "function"
        },
        "index": {
          "description": "foaf topic from http xmlns.com foaf spec term topic",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftopic",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaftopic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:topic_interest\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_topic_interest\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftopic_interest",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foaftopic_interest",
          "type": "function"
        },
        "index": {
          "description": "foaf topic interest from http xmlns.com foaf spec term topic interest",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foaftopic_interest",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foaftopic_interest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:weblog\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_weblog\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafweblog",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafweblog",
          "type": "function"
        },
        "index": {
          "description": "foaf weblog from http xmlns.com foaf spec term weblog",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafweblog",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafweblog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:workInfoHomepage\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_workInfoHomepage\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafworkInfoHomepage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafworkInfoHomepage",
          "type": "function"
        },
        "index": {
          "description": "foaf workInfoHomepage from http xmlns.com foaf spec term workInfoHomepage",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafworkInfoHomepage",
          "package": "swish",
          "partial": "Info Homepage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafworkInfoHomepage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:workplaceHomepage\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_workplaceHomepage\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafworkplaceHomepage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafworkplaceHomepage",
          "type": "function"
        },
        "index": {
          "description": "foaf workplaceHomepage from http xmlns.com foaf spec term workplaceHomepage",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafworkplaceHomepage",
          "package": "swish",
          "partial": "Homepage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafworkplaceHomepage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003efoaf:yahooChatID\u003c/code\u003e from \u003ca\u003ehttp://xmlns.com/foaf/spec/#term_yahooChatID\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafyahooChatID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#foafyahooChatID",
          "type": "function"
        },
        "index": {
          "description": "foaf yahooChatID from http xmlns.com foaf spec term yahooChatID",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "foafyahooChatID",
          "package": "swish",
          "partial": "Chat ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:foafyahooChatID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003efoaf\u003c/code\u003e to \u003ca\u003ehttp://xmlns.com/foaf/0.1/\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "namespaceFOAF",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-FOAF.html#namespaceFOAF",
          "type": "function"
        },
        "index": {
          "description": "Maps foaf to http xmlns.com foaf",
          "hierarchy": "Swish RDF Vocabulary FOAF",
          "module": "Swish.RDF.Vocabulary.FOAF",
          "name": "namespaceFOAF",
          "package": "swish",
          "partial": "FOAF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-FOAF.html#v:namespaceFOAF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some commonly used vocabulary terms from the Geo\n  vocabulary (\u003ca\u003ehttp://www.w3.org/2003/01/geo/\u003c/a\u003e, WGS84 Geo Positioning: an RDF vocabulary).\n\u003c/p\u003e\u003cp\u003eNote that unlike some of the existing vocabularies in Swish, the Geo\n  one matches the case and spelling of the RDF terms; so we\n  use \u003ccode\u003e\u003ca\u003egeolat\u003c/a\u003e\u003c/code\u003e rather than \u003ccode\u003egeoLat\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "Geo",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-Geo.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some commonly used vocabulary terms from the Geo vocabulary http www.w3.org geo WGS84 Geo Positioning an RDF vocabulary Note that unlike some of the existing vocabularies in Swish the Geo one matches the case and spelling of the RDF terms so we use geolat rather than geoLat",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "Geo",
          "package": "swish",
          "partial": "Geo",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeo:Point\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geoPoint",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Geo.html#geoPoint",
          "type": "function"
        },
        "index": {
          "description": "geo Point",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geoPoint",
          "package": "swish",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#v:geoPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeo:SpatialThing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geoSpatialThing",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Geo.html#geoSpatialThing",
          "type": "function"
        },
        "index": {
          "description": "geo SpatialThing",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geoSpatialThing",
          "package": "swish",
          "partial": "Spatial Thing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#v:geoSpatialThing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeo:lat\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolat",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Geo.html#geolat",
          "type": "function"
        },
        "index": {
          "description": "geo lat",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolat",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#v:geolat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeo:lat_long\u003c/code\u003e (it is suggested that this not be used when generating RDF statements).\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolat_long",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Geo.html#geolat_long",
          "type": "function"
        },
        "index": {
          "description": "geo lat long it is suggested that this not be used when generating RDF statements",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolat_long",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#v:geolat_long"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeo:location\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolocation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Geo.html#geolocation",
          "type": "function"
        },
        "index": {
          "description": "geo location",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolocation",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#v:geolocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egeo:long\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolong",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Geo.html#geolong",
          "type": "function"
        },
        "index": {
          "description": "geo long",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "geolong",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#v:geolong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003egeo\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/2003/01/geo/wgs84_pos#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "namespaceGEO",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-Geo.html#namespaceGEO",
          "type": "function"
        },
        "index": {
          "description": "Maps geo to http www.w3.org geo wgs84 pos",
          "hierarchy": "Swish RDF Vocabulary Geo",
          "module": "Swish.RDF.Vocabulary.Geo",
          "name": "namespaceGEO",
          "package": "swish",
          "partial": "GEO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Geo.html#v:namespaceGEO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines vocabulary terms from the OWL vocabulary. Note that there\n  is an unfortunate mixture of styles for property names - e.g. \u003ccode\u003e\u003ca\u003eowlSameAs\u003c/a\u003e\u003c/code\u003e\n  and \u003ccode\u003e\u003ca\u003eowlequivalentClass\u003c/a\u003e\u003c/code\u003e. At present there is no systematic attempt to\n  include terms from the vocabulary.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "OWL",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-OWL.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines vocabulary terms from the OWL vocabulary Note that there is an unfortunate mixture of styles for property names e.g owlSameAs and owlequivalentClass At present there is no systematic attempt to include terms from the vocabulary",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "OWL",
          "package": "swish",
          "partial": "OWL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003eowl\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/2002/07/owl#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "namespaceOWL",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#namespaceOWL",
          "type": "function"
        },
        "index": {
          "description": "Maps owl to http www.w3.org owl",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "namespaceOWL",
          "package": "swish",
          "partial": "OWL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:namespaceOWL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:AnnotationProperty\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlAnnotationProperty",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlAnnotationProperty",
          "type": "function"
        },
        "index": {
          "description": "owl AnnotationProperty",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlAnnotationProperty",
          "package": "swish",
          "partial": "Annotation Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlAnnotationProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:Class\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlClass",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlClass",
          "type": "function"
        },
        "index": {
          "description": "owl Class",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlClass",
          "package": "swish",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:DatatypeProperty\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlDatatypeProperty",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlDatatypeProperty",
          "type": "function"
        },
        "index": {
          "description": "owl DatatypeProperty",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlDatatypeProperty",
          "package": "swish",
          "partial": "Datatype Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlDatatypeProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:NamedIndividual\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlNamedIndividual",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlNamedIndividual",
          "type": "function"
        },
        "index": {
          "description": "owl NamedIndividual",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlNamedIndividual",
          "package": "swish",
          "partial": "Named Individual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlNamedIndividual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:Thing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlNothing",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlNothing",
          "type": "function"
        },
        "index": {
          "description": "owl Thing",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlNothing",
          "package": "swish",
          "partial": "Nothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlNothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:ObjectProperty\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlObjectProperty",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlObjectProperty",
          "type": "function"
        },
        "index": {
          "description": "owl ObjectProperty",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlObjectProperty",
          "package": "swish",
          "partial": "Object Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlObjectProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:Ontology\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlOntology",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlOntology",
          "type": "function"
        },
        "index": {
          "description": "owl Ontology",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlOntology",
          "package": "swish",
          "partial": "Ontology",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlOntology"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:sameAs\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlSameAs",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlSameAs",
          "type": "function"
        },
        "index": {
          "description": "owl sameAs",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlSameAs",
          "package": "swish",
          "partial": "Same As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlSameAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:Thing\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlThing",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlThing",
          "type": "function"
        },
        "index": {
          "description": "owl Thing",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlThing",
          "package": "swish",
          "partial": "Thing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlThing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:backwartCompatibleWith\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlbackwardCompatibleWith",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlbackwardCompatibleWith",
          "type": "function"
        },
        "index": {
          "description": "owl backwartCompatibleWith",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlbackwardCompatibleWith",
          "package": "swish",
          "partial": "Compatible With",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlbackwardCompatibleWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:deprecated\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owldeprecated",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owldeprecated",
          "type": "function"
        },
        "index": {
          "description": "owl deprecated",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owldeprecated",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owldeprecated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:equivalentClass\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlequivalentClass",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlequivalentClass",
          "type": "function"
        },
        "index": {
          "description": "owl equivalentClass",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlequivalentClass",
          "package": "swish",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlequivalentClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:equivalentProperty\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlequivalentProperty",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlequivalentProperty",
          "type": "function"
        },
        "index": {
          "description": "owl equivalentProperty",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlequivalentProperty",
          "package": "swish",
          "partial": "Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlequivalentProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:imports\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlimports",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlimports",
          "type": "function"
        },
        "index": {
          "description": "owl imports",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlimports",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlimports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:incompatibleWith\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlincompatibleWith",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlincompatibleWith",
          "type": "function"
        },
        "index": {
          "description": "owl incompatibleWith",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlincompatibleWith",
          "package": "swish",
          "partial": "With",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlincompatibleWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:priorVersion\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlpriorVersion",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlpriorVersion",
          "type": "function"
        },
        "index": {
          "description": "owl priorVersion",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlpriorVersion",
          "package": "swish",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlpriorVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:rational\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlrational",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlrational",
          "type": "function"
        },
        "index": {
          "description": "owl rational",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlrational",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlrational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:real\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlreal",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlreal",
          "type": "function"
        },
        "index": {
          "description": "owl real",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlreal",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlreal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eowl:versionInfo\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlversionInfo",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-OWL.html#owlversionInfo",
          "type": "function"
        },
        "index": {
          "description": "owl versionInfo",
          "hierarchy": "Swish RDF Vocabulary OWL",
          "module": "Swish.RDF.Vocabulary.OWL",
          "name": "owlversionInfo",
          "package": "swish",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-OWL.html#v:owlversionInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some vocabulary terms from the Provenance Ontology\n  \u003ca\u003ehttp://www.w3.org/TR/prov-o/\u003c/a\u003e by the W3C Provenance Working Group\n  (\u003ca\u003ehttp://www.w3.org/2011/prov/wiki/Main_Page/\u003c/a\u003e).\n  This is \u003cem\u003eexperimental\u003c/em\u003e since the Ontology is still a Working Draft.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "Provenance",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some vocabulary terms from the Provenance Ontology http www.w3.org TR prov-o by the W3C Provenance Working Group http www.w3.org prov wiki Main Page This is experimental since the Ontology is still Working Draft",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "Provenance",
          "package": "swish",
          "partial": "Provenance",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003eprov\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/ns/prov-o/\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "namespacePROV",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#namespacePROV",
          "type": "function"
        },
        "index": {
          "description": "Maps prov to http www.w3.org ns prov-o",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "namespacePROV",
          "package": "swish",
          "partial": "PROV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:namespacePROV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Activity\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#activity\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provActivity",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provActivity",
          "type": "function"
        },
        "index": {
          "description": "prov Activity from http www.w3.org TR prov-o activity",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provActivity",
          "package": "swish",
          "partial": "Activity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provActivity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Agent\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#agent\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provAgent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provAgent",
          "type": "function"
        },
        "index": {
          "description": "prov Agent from http www.w3.org TR prov-o agent",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provAgent",
          "package": "swish",
          "partial": "Agent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provAgent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Control\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#control\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provControl",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provControl",
          "type": "function"
        },
        "index": {
          "description": "prov Control from http www.w3.org TR prov-o control",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provControl",
          "package": "swish",
          "partial": "Control",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provControl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Entity\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#entity\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provEntity",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provEntity",
          "type": "function"
        },
        "index": {
          "description": "prov Entity from http www.w3.org TR prov-o entity",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provEntity",
          "package": "swish",
          "partial": "Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Generation\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#generation\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provGeneration",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provGeneration",
          "type": "function"
        },
        "index": {
          "description": "prov Generation from http www.w3.org TR prov-o generation",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provGeneration",
          "package": "swish",
          "partial": "Generation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provGeneration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Location\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#location\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provLocation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provLocation",
          "type": "function"
        },
        "index": {
          "description": "prov Location from http www.w3.org TR prov-o location",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provLocation",
          "package": "swish",
          "partial": "Location",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Participation\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#participation\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provParticipation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provParticipation",
          "type": "function"
        },
        "index": {
          "description": "prov Participation from http www.w3.org TR prov-o participation",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provParticipation",
          "package": "swish",
          "partial": "Participation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provParticipation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:ProvenanceContainer\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#provenancecontainer\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provProvenanceContainer",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provProvenanceContainer",
          "type": "function"
        },
        "index": {
          "description": "prov ProvenanceContainer from http www.w3.org TR prov-o provenancecontainer",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provProvenanceContainer",
          "package": "swish",
          "partial": "Provenance Container",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provProvenanceContainer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:QualifiedInvolvement\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#qualifiedinvolvement\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provQualifiedInvolvement",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provQualifiedInvolvement",
          "type": "function"
        },
        "index": {
          "description": "prov QualifiedInvolvement from http www.w3.org TR prov-o qualifiedinvolvement",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provQualifiedInvolvement",
          "package": "swish",
          "partial": "Qualified Involvement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provQualifiedInvolvement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Recipe\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#recipe\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provRecipe",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provRecipe",
          "type": "function"
        },
        "index": {
          "description": "prov Recipe from http www.w3.org TR prov-o recipe",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provRecipe",
          "package": "swish",
          "partial": "Recipe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provRecipe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Role\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#role\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provRole",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provRole",
          "type": "function"
        },
        "index": {
          "description": "prov Role from http www.w3.org TR prov-o role",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provRole",
          "package": "swish",
          "partial": "Role",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provRole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:Usage\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#usage\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provUsage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provUsage",
          "type": "function"
        },
        "index": {
          "description": "prov Usage from http www.w3.org TR prov-o usage",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provUsage",
          "package": "swish",
          "partial": "Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:dependedOn\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#dependedon\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provdependedOn",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provdependedOn",
          "type": "function"
        },
        "index": {
          "description": "prov dependedOn from http www.w3.org TR prov-o dependedon",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provdependedOn",
          "package": "swish",
          "partial": "On",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provdependedOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:endedAt\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#endedat\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provendedAt",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provendedAt",
          "type": "function"
        },
        "index": {
          "description": "prov endedAt from http www.w3.org TR prov-o endedat",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provendedAt",
          "package": "swish",
          "partial": "At",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provendedAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadLocation\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadlocation\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadLocation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadLocation",
          "type": "function"
        },
        "index": {
          "description": "prov hadLocation from http www.w3.org TR prov-o hadlocation",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadLocation",
          "package": "swish",
          "partial": "Location",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadLocation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadOriginalSource\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadoriginalsource\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadOriginalSource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadOriginalSource",
          "type": "function"
        },
        "index": {
          "description": "prov hadOriginalSource from http www.w3.org TR prov-o hadoriginalsource",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadOriginalSource",
          "package": "swish",
          "partial": "Original Source",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadOriginalSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadParticipant\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadparticipant\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadParticipant",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadParticipant",
          "type": "function"
        },
        "index": {
          "description": "prov hadParticipant from http www.w3.org TR prov-o hadparticipant",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadParticipant",
          "package": "swish",
          "partial": "Participant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadParticipant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadQualifiedControl\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadqualifiedcontrol\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedControl",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadQualifiedControl",
          "type": "function"
        },
        "index": {
          "description": "prov hadQualifiedControl from http www.w3.org TR prov-o hadqualifiedcontrol",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedControl",
          "package": "swish",
          "partial": "Qualified Control",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadQualifiedControl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadQualifiedEntity\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadqualifiedentity\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedEntity",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadQualifiedEntity",
          "type": "function"
        },
        "index": {
          "description": "prov hadQualifiedEntity from http www.w3.org TR prov-o hadqualifiedentity",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedEntity",
          "package": "swish",
          "partial": "Qualified Entity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadQualifiedEntity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadQualifiedGeneration\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadqualifiedgeneration\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedGeneration",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadQualifiedGeneration",
          "type": "function"
        },
        "index": {
          "description": "prov hadQualifiedGeneration from http www.w3.org TR prov-o hadqualifiedgeneration",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedGeneration",
          "package": "swish",
          "partial": "Qualified Generation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadQualifiedGeneration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadQualifiedParticipation\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadqualifiedparticipation\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedParticipation",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadQualifiedParticipation",
          "type": "function"
        },
        "index": {
          "description": "prov hadQualifiedParticipation from http www.w3.org TR prov-o hadqualifiedparticipation",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedParticipation",
          "package": "swish",
          "partial": "Qualified Participation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadQualifiedParticipation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadQualifiedUsage\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadqualifiedusage\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedUsage",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadQualifiedUsage",
          "type": "function"
        },
        "index": {
          "description": "prov hadQualifiedUsage from http www.w3.org TR prov-o hadqualifiedusage",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadQualifiedUsage",
          "package": "swish",
          "partial": "Qualified Usage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadQualifiedUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadRecipe\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadrecipe\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadRecipe",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadRecipe",
          "type": "function"
        },
        "index": {
          "description": "prov hadRecipe from http www.w3.org TR prov-o hadrecipe",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadRecipe",
          "package": "swish",
          "partial": "Recipe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadRecipe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadRole\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadrole\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadRole",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadRole",
          "type": "function"
        },
        "index": {
          "description": "prov hadRole from http www.w3.org TR prov-o hadrole",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadRole",
          "package": "swish",
          "partial": "Role",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadRole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:hadTemporalValue\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#hadtemporalvalue\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadTemporalValue",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provhadTemporalValue",
          "type": "function"
        },
        "index": {
          "description": "prov hadTemporalValue from http www.w3.org TR prov-o hadtemporalvalue",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provhadTemporalValue",
          "package": "swish",
          "partial": "Temporal Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provhadTemporalValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:startedAt\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#startedat\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provstartedAt",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provstartedAt",
          "type": "function"
        },
        "index": {
          "description": "prov startedAt from http www.w3.org TR prov-o startedat",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provstartedAt",
          "package": "swish",
          "partial": "At",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provstartedAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:used\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#used\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provused",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provused",
          "type": "function"
        },
        "index": {
          "description": "prov used from http www.w3.org TR prov-o used",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provused",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provused"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasAttributedTo\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasattributedto\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasAttributedTo",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasAttributedTo",
          "type": "function"
        },
        "index": {
          "description": "prov wasAttributedTo from http www.w3.org TR prov-o wasattributedto",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasAttributedTo",
          "package": "swish",
          "partial": "Attributed To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasAttributedTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasComplementOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wascomplementof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasComplementOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasComplementOf",
          "type": "function"
        },
        "index": {
          "description": "prov wasComplementOf from http www.w3.org TR prov-o wascomplementof",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasComplementOf",
          "package": "swish",
          "partial": "Complement Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasComplementOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasControlledBy\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wascontrolledby\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasControlledBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasControlledBy",
          "type": "function"
        },
        "index": {
          "description": "prov wasControlledBy from http www.w3.org TR prov-o wascontrolledby",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasControlledBy",
          "package": "swish",
          "partial": "Controlled By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasControlledBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasDerivedFrom\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasderivedfrom\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasDerivedFrom",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasDerivedFrom",
          "type": "function"
        },
        "index": {
          "description": "prov wasDerivedFrom from http www.w3.org TR prov-o wasderivedfrom",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasDerivedFrom",
          "package": "swish",
          "partial": "Derived From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasDerivedFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasEventuallyDerivedFrom\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#waseventuallyderivedfrom\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasEventuallyDerivedFrom",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasEventuallyDerivedFrom",
          "type": "function"
        },
        "index": {
          "description": "prov wasEventuallyDerivedFrom from http www.w3.org TR prov-o waseventuallyderivedfrom",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasEventuallyDerivedFrom",
          "package": "swish",
          "partial": "Eventually Derived From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasEventuallyDerivedFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasGeneratedAt\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasgeneratedat\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasGeneratedAt",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasGeneratedAt",
          "type": "function"
        },
        "index": {
          "description": "prov wasGeneratedAt from http www.w3.org TR prov-o wasgeneratedat",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasGeneratedAt",
          "package": "swish",
          "partial": "Generated At",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasGeneratedAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasGeneratedBy\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasgeneratedby\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasGeneratedBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasGeneratedBy",
          "type": "function"
        },
        "index": {
          "description": "prov wasGeneratedBy from http www.w3.org TR prov-o wasgeneratedby",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasGeneratedBy",
          "package": "swish",
          "partial": "Generated By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasGeneratedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasInformedBy\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasinformedby\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasInformedBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasInformedBy",
          "type": "function"
        },
        "index": {
          "description": "prov wasInformedBy from http www.w3.org TR prov-o wasinformedby",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasInformedBy",
          "package": "swish",
          "partial": "Informed By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasInformedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasQuoteOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasquoteof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasQuoteOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasQuoteOf",
          "type": "function"
        },
        "index": {
          "description": "prov wasQuoteOf from http www.w3.org TR prov-o wasquoteof",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasQuoteOf",
          "package": "swish",
          "partial": "Quote Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasQuoteOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasRevisionOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasrevisionof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasRevisionOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasRevisionOf",
          "type": "function"
        },
        "index": {
          "description": "prov wasRevisionOf from http www.w3.org TR prov-o wasrevisionof",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasRevisionOf",
          "package": "swish",
          "partial": "Revision Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasRevisionOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasScheduledAfter\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wasscheduledafter\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasScheduledAfter",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasScheduledAfter",
          "type": "function"
        },
        "index": {
          "description": "prov wasScheduledAfter from http www.w3.org TR prov-o wasscheduledafter",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasScheduledAfter",
          "package": "swish",
          "partial": "Scheduled After",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasScheduledAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eprov:wasSummaryOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/prov-o/#wassummaryof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasSummaryOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-Provenance.html#provwasSummaryOf",
          "type": "function"
        },
        "index": {
          "description": "prov wasSummaryOf from http www.w3.org TR prov-o wassummaryof",
          "hierarchy": "Swish RDF Vocabulary Provenance",
          "module": "Swish.RDF.Vocabulary.Provenance",
          "name": "provwasSummaryOf",
          "package": "swish",
          "partial": "Summary Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-Provenance.html#v:provwasSummaryOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some commonly used vocabulary terms from the\n  RDF (\u003ca\u003ehttp://www.w3.org/TR/rdf-syntax-grammar/\u003c/a\u003e) and\n  RDF Schema (\u003ca\u003ehttp://www.w3.org/TR/rdf-schema/\u003c/a\u003e) documents.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "RDF",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-RDF.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some commonly used vocabulary terms from the RDF http www.w3.org TR rdf-syntax-grammar and RDF Schema http www.w3.org TR rdf-schema documents",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "RDF",
          "package": "swish",
          "partial": "RDF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003erdf\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/1999/02/22-rdf-syntax-ns#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "namespaceRDF",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#namespaceRDF",
          "type": "function"
        },
        "index": {
          "description": "Maps rdf to http www.w3.org rdf-syntax-ns",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "namespaceRDF",
          "package": "swish",
          "partial": "RDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:namespaceRDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003erdfs\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/2000/01/rdf-schema#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "namespaceRDFS",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#namespaceRDFS",
          "type": "function"
        },
        "index": {
          "description": "Maps rdfs to http www.w3.org rdf-schema",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "namespaceRDFS",
          "package": "swish",
          "partial": "RDFS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:namespaceRDFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:_1\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdf1",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdf1",
          "type": "function"
        },
        "index": {
          "description": "rdf",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdf1",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdf1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:_2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdf2",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdf2",
          "type": "function"
        },
        "index": {
          "description": "rdf",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdf2",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdf2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:about\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfAbout",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfAbout",
          "type": "function"
        },
        "index": {
          "description": "rdf about",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfAbout",
          "package": "swish",
          "partial": "About",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfAbout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Alt\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_alt\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfAlt",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfAlt",
          "type": "function"
        },
        "index": {
          "description": "rdf Alt from http www.w3.org TR rdf-schema ch alt",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfAlt",
          "package": "swish",
          "partial": "Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Bag\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_bag\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfBag",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfBag",
          "type": "function"
        },
        "index": {
          "description": "rdf Bag from http www.w3.org TR rdf-schema ch bag",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfBag",
          "package": "swish",
          "partial": "Bag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfBag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:datatype\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfDatatype",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfDatatype",
          "type": "function"
        },
        "index": {
          "description": "rdf datatype",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfDatatype",
          "package": "swish",
          "partial": "Datatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Description\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfDescription",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfDescription",
          "type": "function"
        },
        "index": {
          "description": "rdf Description",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfDescription",
          "package": "swish",
          "partial": "Description",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:first\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_first\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfFirst",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfFirst",
          "type": "function"
        },
        "index": {
          "description": "rdf first from http www.w3.org TR rdf-schema ch first",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfFirst",
          "package": "swish",
          "partial": "First",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:ID\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfID",
          "type": "function"
        },
        "index": {
          "description": "rdf ID",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfID",
          "package": "swish",
          "partial": "ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:li\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfLi",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfLi",
          "type": "function"
        },
        "index": {
          "description": "rdf li",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfLi",
          "package": "swish",
          "partial": "Li",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfLi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:List\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_list\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfList",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfList",
          "type": "function"
        },
        "index": {
          "description": "rdf List from http www.w3.org TR rdf-schema ch list",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfList",
          "package": "swish",
          "partial": "List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:nil\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_nil\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfNil",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfNil",
          "type": "function"
        },
        "index": {
          "description": "rdf nil from http www.w3.org TR rdf-schema ch nil",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfNil",
          "package": "swish",
          "partial": "Nil",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfNil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:nodeID\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfNodeID",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfNodeID",
          "type": "function"
        },
        "index": {
          "description": "rdf nodeID",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfNodeID",
          "package": "swish",
          "partial": "Node ID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfNodeID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:object\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_object\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfObject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfObject",
          "type": "function"
        },
        "index": {
          "description": "rdf object from http www.w3.org TR rdf-schema ch object",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfObject",
          "package": "swish",
          "partial": "Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:parseType\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfParseType",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfParseType",
          "type": "function"
        },
        "index": {
          "description": "rdf parseType",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfParseType",
          "package": "swish",
          "partial": "Parse Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfParseType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:predicate\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_predicate\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfPredicate",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfPredicate",
          "type": "function"
        },
        "index": {
          "description": "rdf predicate from http www.w3.org TR rdf-schema ch predicate",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfPredicate",
          "package": "swish",
          "partial": "Predicate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfPredicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Property\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_property\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfProperty",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfProperty",
          "type": "function"
        },
        "index": {
          "description": "rdf Property from http www.w3.org TR rdf-schema ch property",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfProperty",
          "package": "swish",
          "partial": "Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:RDF\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfRDF",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfRDF",
          "type": "function"
        },
        "index": {
          "description": "rdf RDF",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfRDF",
          "package": "swish",
          "partial": "RDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfRDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:resource\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfResource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfResource",
          "type": "function"
        },
        "index": {
          "description": "rdf resource",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfResource",
          "package": "swish",
          "partial": "Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:rest\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_rest\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfRest",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfRest",
          "type": "function"
        },
        "index": {
          "description": "rdf rest from http www.w3.org TR rdf-schema ch rest",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfRest",
          "package": "swish",
          "partial": "Rest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfRest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Seq\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_seq\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfSeq",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfSeq",
          "type": "function"
        },
        "index": {
          "description": "rdf Seq from http www.w3.org TR rdf-schema ch seq",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfSeq",
          "package": "swish",
          "partial": "Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:Statement\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_statement\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfStatement",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfStatement",
          "type": "function"
        },
        "index": {
          "description": "rdf Statement from http www.w3.org TR rdf-schema ch statement",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfStatement",
          "package": "swish",
          "partial": "Statement",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfStatement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:subject\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_subject\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfSubject",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfSubject",
          "type": "function"
        },
        "index": {
          "description": "rdf subject from http www.w3.org TR rdf-schema ch subject",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfSubject",
          "package": "swish",
          "partial": "Subject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfSubject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:type\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_type\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfType",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfType",
          "type": "function"
        },
        "index": {
          "description": "rdf type from http www.w3.org TR rdf-schema ch type",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfType",
          "package": "swish",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:value\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_value\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfValue",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfValue",
          "type": "function"
        },
        "index": {
          "description": "rdf value from http www.w3.org TR rdf-schema ch value",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfValue",
          "package": "swish",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdf:XMLLiteral\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_xmlliteral\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfXMLLiteral",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfXMLLiteral",
          "type": "function"
        },
        "index": {
          "description": "rdf XMLLiteral from http www.w3.org TR rdf-schema ch xmlliteral",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfXMLLiteral",
          "package": "swish",
          "partial": "XMLLiteral",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfXMLLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003erdf:_n\u003c/code\u003e entity.\n\u003c/p\u003e\u003cp\u003eThere is no check that the argument is not 0, so it is\n possible to create the un-defined label \u003ccode\u003erdf:_0\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfn",
          "package": "swish",
          "signature": "Word32 -\u003e ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfn",
          "type": "function"
        },
        "index": {
          "description": "Create rdf entity There is no check that the argument is not so it is possible to create the un-defined label rdf",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfn",
          "normalized": "Word-\u003eScopedName",
          "package": "swish",
          "signature": "Word-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Class\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_class\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsClass",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsClass",
          "type": "function"
        },
        "index": {
          "description": "rdfs Class from http www.w3.org TR rdf-schema ch class",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsClass",
          "package": "swish",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:comment\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_comment\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsComment",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsComment",
          "type": "function"
        },
        "index": {
          "description": "rdfs comment from http www.w3.org TR rdf-schema ch comment",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsComment",
          "package": "swish",
          "partial": "Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Container\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_container\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsContainer",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsContainer",
          "type": "function"
        },
        "index": {
          "description": "rdfs Container from http www.w3.org TR rdf-schema ch container",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsContainer",
          "package": "swish",
          "partial": "Container",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsContainer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:ContainerMembershipProperty\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_containermembershipproperty\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsContainerMembershipProperty",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsContainerMembershipProperty",
          "type": "function"
        },
        "index": {
          "description": "rdfs ContainerMembershipProperty from http www.w3.org TR rdf-schema ch containermembershipproperty",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsContainerMembershipProperty",
          "package": "swish",
          "partial": "Container Membership Property",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsContainerMembershipProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Datatype\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_datatype\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsDatatype",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsDatatype",
          "type": "function"
        },
        "index": {
          "description": "rdfs Datatype from http www.w3.org TR rdf-schema ch datatype",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsDatatype",
          "package": "swish",
          "partial": "Datatype",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsDatatype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:domain\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_domain\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsDomain",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsDomain",
          "type": "function"
        },
        "index": {
          "description": "rdfs domain from http www.w3.org TR rdf-schema ch domain",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsDomain",
          "package": "swish",
          "partial": "Domain",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsDomain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:isDefinedBy\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_isdefinedby\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsIsDefinedBy",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsIsDefinedBy",
          "type": "function"
        },
        "index": {
          "description": "rdfs isDefinedBy from http www.w3.org TR rdf-schema ch isdefinedby",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsIsDefinedBy",
          "package": "swish",
          "partial": "Is Defined By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsIsDefinedBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:label\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_label\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsLabel",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsLabel",
          "type": "function"
        },
        "index": {
          "description": "rdfs label from http www.w3.org TR rdf-schema ch label",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsLabel",
          "package": "swish",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Literal\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_literal\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsLiteral",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsLiteral",
          "type": "function"
        },
        "index": {
          "description": "rdfs Literal from http www.w3.org TR rdf-schema ch literal",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsLiteral",
          "package": "swish",
          "partial": "Literal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:member\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_member\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsMember",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsMember",
          "type": "function"
        },
        "index": {
          "description": "rdfs member from http www.w3.org TR rdf-schema ch member",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsMember",
          "package": "swish",
          "partial": "Member",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:range\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_range\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsRange",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsRange",
          "type": "function"
        },
        "index": {
          "description": "rdfs range from http www.w3.org TR rdf-schema ch range",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsRange",
          "package": "swish",
          "partial": "Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:Resource\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_resource\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsResource",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsResource",
          "type": "function"
        },
        "index": {
          "description": "rdfs Resource from http www.w3.org TR rdf-schema ch resource",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsResource",
          "package": "swish",
          "partial": "Resource",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:seeAlso\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_seealso\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsSeeAlso",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsSeeAlso",
          "type": "function"
        },
        "index": {
          "description": "rdfs seeAlso from http www.w3.org TR rdf-schema ch seealso",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsSeeAlso",
          "package": "swish",
          "partial": "See Also",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsSeeAlso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:subClassOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_subclassof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsSubClassOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsSubClassOf",
          "type": "function"
        },
        "index": {
          "description": "rdfs subClassOf from http www.w3.org TR rdf-schema ch subclassof",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsSubClassOf",
          "package": "swish",
          "partial": "Sub Class Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsSubClassOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfs:subPropertyOf\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/rdf-schema/#ch_subpropertyof\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsSubPropertyOf",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-RDF.html#rdfsSubPropertyOf",
          "type": "function"
        },
        "index": {
          "description": "rdfs subPropertyOf from http www.w3.org TR rdf-schema ch subpropertyof",
          "hierarchy": "Swish RDF Vocabulary RDF",
          "module": "Swish.RDF.Vocabulary.RDF",
          "name": "rdfsSubPropertyOf",
          "package": "swish",
          "partial": "Sub Property Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-RDF.html#v:rdfsSubPropertyOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some commonly used vocabulary terms from the SIOC\n  project (\u003ca\u003ehttp://sioc-project.org/\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "SIOC",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some commonly used vocabulary terms from the SIOC project http sioc-project.org",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "SIOC",
          "package": "swish",
          "partial": "SIOC",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003esioc\u003c/code\u003e to \u003ca\u003ehttp://rdfs.org/sioc/ns#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "namespaceSIOC",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#namespaceSIOC",
          "type": "function"
        },
        "index": {
          "description": "Maps sioc to http rdfs.org sioc ns",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "namespaceSIOC",
          "package": "swish",
          "partial": "SIOC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:namespaceSIOC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Community\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Community\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocCommunity",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocCommunity",
          "type": "function"
        },
        "index": {
          "description": "sioc Community from http rdfs.org sioc spec term Community",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocCommunity",
          "package": "swish",
          "partial": "Community",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocCommunity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Container\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Container\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocContainer",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocContainer",
          "type": "function"
        },
        "index": {
          "description": "sioc Container from http rdfs.org sioc spec term Container",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocContainer",
          "package": "swish",
          "partial": "Container",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocContainer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Forum\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Forum\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocForum",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocForum",
          "type": "function"
        },
        "index": {
          "description": "sioc Forum from http rdfs.org sioc spec term Forum",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocForum",
          "package": "swish",
          "partial": "Forum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocForum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Item\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Item\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocItem",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocItem",
          "type": "function"
        },
        "index": {
          "description": "sioc Item from http rdfs.org sioc spec term Item",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocItem",
          "package": "swish",
          "partial": "Item",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Post\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Post\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocPost",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocPost",
          "type": "function"
        },
        "index": {
          "description": "sioc Post from http rdfs.org sioc spec term Post",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocPost",
          "package": "swish",
          "partial": "Post",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocPost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Role\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Role\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocRole",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocRole",
          "type": "function"
        },
        "index": {
          "description": "sioc Role from http rdfs.org sioc spec term Role",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocRole",
          "package": "swish",
          "partial": "Role",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocRole"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Site\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Site\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocSite",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocSite",
          "type": "function"
        },
        "index": {
          "description": "sioc Site from http rdfs.org sioc spec term Site",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocSite",
          "package": "swish",
          "partial": "Site",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocSite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Space\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Space\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocSpace",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocSpace",
          "type": "function"
        },
        "index": {
          "description": "sioc Space from http rdfs.org sioc spec term Space",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocSpace",
          "package": "swish",
          "partial": "Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Thread\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Thread\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocThread",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocThread",
          "type": "function"
        },
        "index": {
          "description": "sioc Thread from http rdfs.org sioc spec term Thread",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocThread",
          "package": "swish",
          "partial": "Thread",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocThread"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:UserAccount\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_UserAccount\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocUserAccount",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocUserAccount",
          "type": "function"
        },
        "index": {
          "description": "sioc UserAccount from http rdfs.org sioc spec term UserAccount",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocUserAccount",
          "package": "swish",
          "partial": "User Account",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocUserAccount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:Usergroup\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_Usergroup\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocUsergroup",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocUsergroup",
          "type": "function"
        },
        "index": {
          "description": "sioc Usergroup from http rdfs.org sioc spec term Usergroup",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocUsergroup",
          "package": "swish",
          "partial": "Usergroup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocUsergroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:about\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_about\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocabout",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocabout",
          "type": "function"
        },
        "index": {
          "description": "sioc about from http rdfs.org sioc spec term about",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocabout",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocabout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:account_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_account_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocaccount_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocaccount_of",
          "type": "function"
        },
        "index": {
          "description": "sioc account of from http rdfs.org sioc spec term account of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocaccount_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocaccount_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:addressed_to\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_addressed_to\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocaddressed_to",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocaddressed_to",
          "type": "function"
        },
        "index": {
          "description": "sioc addressed to from http rdfs.org sioc spec term addressed to",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocaddressed_to",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocaddressed_to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:administrator_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_administrator_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocadministrator_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocadministrator_of",
          "type": "function"
        },
        "index": {
          "description": "sioc administrator of from http rdfs.org sioc spec term administrator of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocadministrator_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocadministrator_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:attachment\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_attachment\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocattachment",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocattachment",
          "type": "function"
        },
        "index": {
          "description": "sioc attachment from http rdfs.org sioc spec term attachment",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocattachment",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocattachment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:avatar\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_avatar\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocavatar",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocavatar",
          "type": "function"
        },
        "index": {
          "description": "sioc avatar from http rdfs.org sioc spec term avatar",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocavatar",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocavatar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:container_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_container_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioccontainer_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioccontainer_of",
          "type": "function"
        },
        "index": {
          "description": "sioc container of from http rdfs.org sioc spec term container of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioccontainer_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioccontainer_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:content\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_content\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioccontent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioccontent",
          "type": "function"
        },
        "index": {
          "description": "sioc content from http rdfs.org sioc spec term content",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioccontent",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioccontent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:creator_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_creator_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioccreator_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioccreator_of",
          "type": "function"
        },
        "index": {
          "description": "sioc creator of from http rdfs.org sioc spec term creator of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioccreator_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioccreator_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:earlier_version\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_earlier_version\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocearlier_version",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocearlier_version",
          "type": "function"
        },
        "index": {
          "description": "sioc earlier version from http rdfs.org sioc spec term earlier version",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocearlier_version",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocearlier_version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:email\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_email\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocemail",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocemail",
          "type": "function"
        },
        "index": {
          "description": "sioc email from http rdfs.org sioc spec term email",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocemail",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocemail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:email_sha1\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_email_sha1\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocemail_sha1",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocemail_sha1",
          "type": "function"
        },
        "index": {
          "description": "sioc email sha1 from http rdfs.org sioc spec term email sha1",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocemail_sha1",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocemail_sha1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:embeds_knowledge\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_embeds_knowledge\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocembeds_knowledge",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocembeds_knowledge",
          "type": "function"
        },
        "index": {
          "description": "sioc embeds knowledge from http rdfs.org sioc spec term embeds knowledge",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocembeds_knowledge",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocembeds_knowledge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:feed\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_feed\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocfeed",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocfeed",
          "type": "function"
        },
        "index": {
          "description": "sioc feed from http rdfs.org sioc spec term feed",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocfeed",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocfeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:follows\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_follows\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocfollows",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocfollows",
          "type": "function"
        },
        "index": {
          "description": "sioc follows from http rdfs.org sioc spec term follows",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocfollows",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocfollows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:function_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_function_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocfunction_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocfunction_of",
          "type": "function"
        },
        "index": {
          "description": "sioc function of from http rdfs.org sioc spec term function of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocfunction_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocfunction_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_administrator\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_administrator\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_administrator",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_administrator",
          "type": "function"
        },
        "index": {
          "description": "sioc has administrator from http rdfs.org sioc spec term has administrator",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_administrator",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_administrator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_container\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_container\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_container",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_container",
          "type": "function"
        },
        "index": {
          "description": "sioc has container from http rdfs.org sioc spec term has container",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_container",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_container"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_creator\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_creator\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_creator",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_creator",
          "type": "function"
        },
        "index": {
          "description": "sioc has creator from http rdfs.org sioc spec term has creator",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_creator",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_creator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_discussion\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_discussion\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_discussion",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_discussion",
          "type": "function"
        },
        "index": {
          "description": "sioc has discussion from http rdfs.org sioc spec term has discussion",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_discussion",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_discussion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_function\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_function\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_function",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_function",
          "type": "function"
        },
        "index": {
          "description": "sioc has function from http rdfs.org sioc spec term has function",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_function",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_host\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_host\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_host",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_host",
          "type": "function"
        },
        "index": {
          "description": "sioc has host from http rdfs.org sioc spec term has host",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_host",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_host"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_member\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_member\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_member",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_member",
          "type": "function"
        },
        "index": {
          "description": "sioc has member from http rdfs.org sioc spec term has member",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_member",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_moderator\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_moderator\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_moderator",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_moderator",
          "type": "function"
        },
        "index": {
          "description": "sioc has moderator from http rdfs.org sioc spec term has moderator",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_moderator",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_moderator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_modifier\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_modifier\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_modifier",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_modifier",
          "type": "function"
        },
        "index": {
          "description": "sioc has modifier from http rdfs.org sioc spec term has modifier",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_modifier",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_owner\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_owner\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_owner",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_owner",
          "type": "function"
        },
        "index": {
          "description": "sioc has owner from http rdfs.org sioc spec term has owner",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_owner",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_owner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_parent\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_parent\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_parent",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_parent",
          "type": "function"
        },
        "index": {
          "description": "sioc has parent from http rdfs.org sioc spec term has parent",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_parent",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_parent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_reply\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_reply\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_reply",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_reply",
          "type": "function"
        },
        "index": {
          "description": "sioc has reply from http rdfs.org sioc spec term has reply",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_reply",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_reply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_scope\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_scope\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_scope",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_scope",
          "type": "function"
        },
        "index": {
          "description": "sioc has scope from http rdfs.org sioc spec term has scope",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_scope",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_scope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_space\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_space\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_space",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_space",
          "type": "function"
        },
        "index": {
          "description": "sioc has space from http rdfs.org sioc spec term has space",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_space",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_subscriber\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_subscriber\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_subscriber",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_subscriber",
          "type": "function"
        },
        "index": {
          "description": "sioc has subscriber from http rdfs.org sioc spec term has subscriber",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_subscriber",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_subscriber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:has_usergroup\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_has_usergroup\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_usergroup",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochas_usergroup",
          "type": "function"
        },
        "index": {
          "description": "sioc has usergroup from http rdfs.org sioc spec term has usergroup",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochas_usergroup",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochas_usergroup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:host_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_host_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochost_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siochost_of",
          "type": "function"
        },
        "index": {
          "description": "sioc host of from http rdfs.org sioc spec term host of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siochost_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siochost_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:id\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_id\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocid",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocid",
          "type": "function"
        },
        "index": {
          "description": "sioc id from http rdfs.org sioc spec term id",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocid",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:ip_address\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_ip_address\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocip_address",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocip_address",
          "type": "function"
        },
        "index": {
          "description": "sioc ip address from http rdfs.org sioc spec term ip address",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocip_address",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocip_address"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:last_activity_date\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_last_activity_date\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclast_activity_date",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioclast_activity_date",
          "type": "function"
        },
        "index": {
          "description": "sioc last activity date from http rdfs.org sioc spec term last activity date",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclast_activity_date",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioclast_activity_date"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:last_item_date\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_last_item_date\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclast_item_date",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioclast_item_date",
          "type": "function"
        },
        "index": {
          "description": "sioc last item date from http rdfs.org sioc spec term last item date",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclast_item_date",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioclast_item_date"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:last_reply_date\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_last_reply_date\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclast_reply_date",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioclast_reply_date",
          "type": "function"
        },
        "index": {
          "description": "sioc last reply date from http rdfs.org sioc spec term last reply date",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclast_reply_date",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioclast_reply_date"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:later_version\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_later_version\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclater_version",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioclater_version",
          "type": "function"
        },
        "index": {
          "description": "sioc later version from http rdfs.org sioc spec term later version",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclater_version",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioclater_version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:latest_version\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_latest_version\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclatest_version",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioclatest_version",
          "type": "function"
        },
        "index": {
          "description": "sioc latest version from http rdfs.org sioc spec term latest version",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclatest_version",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioclatest_version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:link\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_link\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclink",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioclink",
          "type": "function"
        },
        "index": {
          "description": "sioc link from http rdfs.org sioc spec term link",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclink",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioclink"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:links_to\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_links_to\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclinks_to",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioclinks_to",
          "type": "function"
        },
        "index": {
          "description": "sioc links to from http rdfs.org sioc spec term links to",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioclinks_to",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioclinks_to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:member_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_member_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocmember_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocmember_of",
          "type": "function"
        },
        "index": {
          "description": "sioc member of from http rdfs.org sioc spec term member of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocmember_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocmember_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:moderator_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_moderator_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocmoderator_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocmoderator_of",
          "type": "function"
        },
        "index": {
          "description": "sioc moderator of from http rdfs.org sioc spec term moderator of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocmoderator_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocmoderator_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:modifier_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_modifier_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocmodifier_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocmodifier_of",
          "type": "function"
        },
        "index": {
          "description": "sioc modifier of from http rdfs.org sioc spec term modifier of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocmodifier_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocmodifier_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:name\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_name\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocname",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocname",
          "type": "function"
        },
        "index": {
          "description": "sioc name from http rdfs.org sioc spec term name",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocname",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocname"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:next_by_date\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_next_by_date\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnext_by_date",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnext_by_date",
          "type": "function"
        },
        "index": {
          "description": "sioc next by date from http rdfs.org sioc spec term next by date",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnext_by_date",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnext_by_date"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:next_version\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_next_version\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnext_version",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnext_version",
          "type": "function"
        },
        "index": {
          "description": "sioc next version from http rdfs.org sioc spec term next version",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnext_version",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnext_version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:note\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_note\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnote",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnote",
          "type": "function"
        },
        "index": {
          "description": "sioc note from http rdfs.org sioc spec term note",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnote",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:num_authors\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_num_authors\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_authors",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnum_authors",
          "type": "function"
        },
        "index": {
          "description": "sioc num authors from http rdfs.org sioc spec term num authors",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_authors",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnum_authors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:num_items\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_num_items\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_items",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnum_items",
          "type": "function"
        },
        "index": {
          "description": "sioc num items from http rdfs.org sioc spec term num items",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_items",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnum_items"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:num_replies\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_num_replies\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_replies",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnum_replies",
          "type": "function"
        },
        "index": {
          "description": "sioc num replies from http rdfs.org sioc spec term num replies",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_replies",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnum_replies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:num_threads\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_num_threads\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_threads",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnum_threads",
          "type": "function"
        },
        "index": {
          "description": "sioc num threads from http rdfs.org sioc spec term num threads",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_threads",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnum_threads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:num_views\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_num_views\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_views",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocnum_views",
          "type": "function"
        },
        "index": {
          "description": "sioc num views from http rdfs.org sioc spec term num views",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocnum_views",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocnum_views"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:owner_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_owner_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocowner_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocowner_of",
          "type": "function"
        },
        "index": {
          "description": "sioc owner of from http rdfs.org sioc spec term owner of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocowner_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocowner_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:parent_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_parent_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocparent_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocparent_of",
          "type": "function"
        },
        "index": {
          "description": "sioc parent of from http rdfs.org sioc spec term parent of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocparent_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocparent_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:previous_by_date\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_previous_by_date\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocprevious_by_date",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocprevious_by_date",
          "type": "function"
        },
        "index": {
          "description": "sioc previous by date from http rdfs.org sioc spec term previous by date",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocprevious_by_date",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocprevious_by_date"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:previous_version\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_previous_version\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocprevious_version",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocprevious_version",
          "type": "function"
        },
        "index": {
          "description": "sioc previous version from http rdfs.org sioc spec term previous version",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocprevious_version",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocprevious_version"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:related_to\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_related_to\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocrelated_to",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocrelated_to",
          "type": "function"
        },
        "index": {
          "description": "sioc related to from http rdfs.org sioc spec term related to",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocrelated_to",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocrelated_to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:reply_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_reply_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocreply_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocreply_of",
          "type": "function"
        },
        "index": {
          "description": "sioc reply of from http rdfs.org sioc spec term reply of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocreply_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocreply_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:scope_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_scope_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocscope_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocscope_of",
          "type": "function"
        },
        "index": {
          "description": "sioc scope of from http rdfs.org sioc spec term scope of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocscope_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocscope_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:sibling\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_sibling\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocsibling",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocsibling",
          "type": "function"
        },
        "index": {
          "description": "sioc sibling from http rdfs.org sioc spec term sibling",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocsibling",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocsibling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:space_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_space_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocspace_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocspace_of",
          "type": "function"
        },
        "index": {
          "description": "sioc space of from http rdfs.org sioc spec term space of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocspace_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocspace_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:subscriber_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_subscriber_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocsubscriber_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocsubscriber_of",
          "type": "function"
        },
        "index": {
          "description": "sioc subscriber of from http rdfs.org sioc spec term subscriber of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocsubscriber_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocsubscriber_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:topic\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_topic\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioctopic",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#sioctopic",
          "type": "function"
        },
        "index": {
          "description": "sioc topic from http rdfs.org sioc spec term topic",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "sioctopic",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:sioctopic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esioc:usergroup_of\u003c/code\u003e from \u003ca\u003ehttp://rdfs.org/sioc/spec/#term_usergroup_of\u003c/a\u003e. \n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocusergroup_of",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-SIOC.html#siocusergroup_of",
          "type": "function"
        },
        "index": {
          "description": "sioc usergroup of from http rdfs.org sioc spec term usergroup of",
          "hierarchy": "Swish RDF Vocabulary SIOC",
          "module": "Swish.RDF.Vocabulary.SIOC",
          "name": "siocusergroup_of",
          "package": "swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-SIOC.html#v:siocusergroup_of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines vocabulary terms from the XSD document.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "XSD",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary-XSD.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines vocabulary terms from the XSD document",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "XSD",
          "package": "swish",
          "partial": "XSD",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003exsd\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/2001/XMLSchema#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "namespaceXSD",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#namespaceXSD",
          "type": "function"
        },
        "index": {
          "description": "Maps xsd to http www.w3.org XMLSchema",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "namespaceXSD",
          "package": "swish",
          "partial": "XSD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:namespaceXSD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:anyURI\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#anyURI\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdAnyURI",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdAnyURI",
          "type": "function"
        },
        "index": {
          "description": "xsd anyURI from http www.w3.org TR xmlschema-2 anyURI",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdAnyURI",
          "package": "swish",
          "partial": "Any URI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdAnyURI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:boolean\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#boolean\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdBoolean",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdBoolean",
          "type": "function"
        },
        "index": {
          "description": "xsd boolean from http www.w3.org TR xmlschema-2 boolean",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdBoolean",
          "package": "swish",
          "partial": "Boolean",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdBoolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:byte\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#byte\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdByte",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdByte",
          "type": "function"
        },
        "index": {
          "description": "xsd byte from http www.w3.org TR xmlschema-2 byte",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdByte",
          "package": "swish",
          "partial": "Byte",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:date\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#date\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDate",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdDate",
          "type": "function"
        },
        "index": {
          "description": "xsd date from http www.w3.org TR xmlschema-2 date",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDate",
          "package": "swish",
          "partial": "Date",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdDate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:dateTime\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#dateTime\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDateTime",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdDateTime",
          "type": "function"
        },
        "index": {
          "description": "xsd dateTime from http www.w3.org TR xmlschema-2 dateTime",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDateTime",
          "package": "swish",
          "partial": "Date Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdDateTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:decimal\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#decimal\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDecimal",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdDecimal",
          "type": "function"
        },
        "index": {
          "description": "xsd decimal from http www.w3.org TR xmlschema-2 decimal",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDecimal",
          "package": "swish",
          "partial": "Decimal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdDecimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:double\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#double\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDouble",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdDouble",
          "type": "function"
        },
        "index": {
          "description": "xsd double from http www.w3.org TR xmlschema-2 double",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdDouble",
          "package": "swish",
          "partial": "Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:float\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#float\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdFloat",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdFloat",
          "type": "function"
        },
        "index": {
          "description": "xsd float from http www.w3.org TR xmlschema-2 float",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdFloat",
          "package": "swish",
          "partial": "Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:int\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#int\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdInt",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdInt",
          "type": "function"
        },
        "index": {
          "description": "xsd int from http www.w3.org TR xmlschema-2 int",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdInt",
          "package": "swish",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:integer\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#integer\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdInteger",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdInteger",
          "type": "function"
        },
        "index": {
          "description": "xsd integer from http www.w3.org TR xmlschema-2 integer",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdInteger",
          "package": "swish",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:long\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#long\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdLong",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdLong",
          "type": "function"
        },
        "index": {
          "description": "xsd long from http www.w3.org TR xmlschema-2 long",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdLong",
          "package": "swish",
          "partial": "Long",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:negativeInteger\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#negativeInteger\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdNegInteger",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdNegInteger",
          "type": "function"
        },
        "index": {
          "description": "xsd negativeInteger from http www.w3.org TR xmlschema-2 negativeInteger",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdNegInteger",
          "package": "swish",
          "partial": "Neg Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdNegInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:nonNegativeInteger\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#nonNegativeInteger\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdNonNegInteger",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdNonNegInteger",
          "type": "function"
        },
        "index": {
          "description": "xsd nonNegativeInteger from http www.w3.org TR xmlschema-2 nonNegativeInteger",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdNonNegInteger",
          "package": "swish",
          "partial": "Non Neg Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdNonNegInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:nonPositiveInteger\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#nonPositiveInteger\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdNonPosInteger",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdNonPosInteger",
          "type": "function"
        },
        "index": {
          "description": "xsd nonPositiveInteger from http www.w3.org TR xmlschema-2 nonPositiveInteger",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdNonPosInteger",
          "package": "swish",
          "partial": "Non Pos Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdNonPosInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:positiveInteger\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#positiveInteger\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdPosInteger",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdPosInteger",
          "type": "function"
        },
        "index": {
          "description": "xsd positiveInteger from http www.w3.org TR xmlschema-2 positiveInteger",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdPosInteger",
          "package": "swish",
          "partial": "Pos Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdPosInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:short\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#short\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdShort",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdShort",
          "type": "function"
        },
        "index": {
          "description": "xsd short from http www.w3.org TR xmlschema-2 short",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdShort",
          "package": "swish",
          "partial": "Short",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:string\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#string\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdString",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdString",
          "type": "function"
        },
        "index": {
          "description": "xsd string from http www.w3.org TR xmlschema-2 string",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdString",
          "package": "swish",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:time\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#time\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdTime",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdTime",
          "type": "function"
        },
        "index": {
          "description": "xsd time from http www.w3.org TR xmlschema-2 time",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdTime",
          "package": "swish",
          "partial": "Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdTime"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a scoped name for an XSD datatype with the given name.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdType",
          "package": "swish",
          "signature": "LName -\u003e ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdType",
          "type": "function"
        },
        "index": {
          "description": "Create scoped name for an XSD datatype with the given name",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdType",
          "normalized": "LName-\u003eScopedName",
          "package": "swish",
          "partial": "Type",
          "signature": "LName-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:unsignedByte\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#unsignedByte\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedByte",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdUnsignedByte",
          "type": "function"
        },
        "index": {
          "description": "xsd unsignedByte from http www.w3.org TR xmlschema-2 unsignedByte",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedByte",
          "package": "swish",
          "partial": "Unsigned Byte",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdUnsignedByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:unsignedInt\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#unsignedInt\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedInt",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdUnsignedInt",
          "type": "function"
        },
        "index": {
          "description": "xsd unsignedInt from http www.w3.org TR xmlschema-2 unsignedInt",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedInt",
          "package": "swish",
          "partial": "Unsigned Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdUnsignedInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:unsignedLong\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#unsignedLong\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedLong",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdUnsignedLong",
          "type": "function"
        },
        "index": {
          "description": "xsd unsignedLong from http www.w3.org TR xmlschema-2 unsignedLong",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedLong",
          "package": "swish",
          "partial": "Unsigned Long",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdUnsignedLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003exsd:unsignedShort\u003c/code\u003e from \u003ca\u003ehttp://www.w3.org/TR/xmlschema-2/#unsignedShort\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedShort",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary-XSD.html#xsdUnsignedShort",
          "type": "function"
        },
        "index": {
          "description": "xsd unsignedShort from http www.w3.org TR xmlschema-2 unsignedShort",
          "hierarchy": "Swish RDF Vocabulary XSD",
          "module": "Swish.RDF.Vocabulary.XSD",
          "name": "xsdUnsignedShort",
          "package": "swish",
          "partial": "Unsigned Short",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary-XSD.html#v:xsdUnsignedShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines some commonly used vocabulary terms,\n  using the \u003ccode\u003e\u003ca\u003eNamespace\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eScopedName\u003c/a\u003e\u003c/code\u003e data types. Additional vocabularies\n  are available in the set of \u003ccode\u003eSwish.RDF.Vocabulary.*\u003c/code\u003e modules, parts of\n  which are re-exported by this module\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "Vocabulary",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines some commonly used vocabulary terms using the Namespace and ScopedName data types Additional vocabularies are available in the set of Swish.RDF.Vocabulary modules parts of which are re-exported by this module",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "Vocabulary",
          "package": "swish",
          "partial": "Vocabulary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresent the language tag for a literal string, following\n RFC 3066 \u003ca\u003ehttp://www.ietf.org/rfc/rfc3066.txt\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eUse \u003ccode\u003e\u003ca\u003etoLangTag\u003c/a\u003e\u003c/code\u003e to create a tag and \u003ccode\u003e\u003ca\u003efromLangTag\u003c/a\u003e\u003c/code\u003e to\n convert back. The case is preserved for the tag, although\n comparison (both the \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e instance and \u003ccode\u003ecompareLangTag\u003c/code\u003e)\n is done using the lower-case form of the tags.\n\u003c/p\u003e\u003cp\u003eAs an example:\n\u003c/p\u003e\u003cpre\u003e Prelude\u003e :set prompt \"swish\u003e \"\n swish\u003e :set -XOverloadedStrings\n swish\u003e :m + Swish.RDF.Vocabulary\n swish\u003e let en = \"en\" :: LanguageTag\n swish\u003e let us = \"en-us\" :: LanguageTag\n swish\u003e let gb = \"en-GB\" :: LanguageTag\n swish\u003e gb\n en-GB\n swish\u003e gb == \"en-gb\"\n True\n swish\u003e en == us\n False\n swish\u003e en `isBaseLang` us\n True\n swish\u003e us `isBaseLang` en\n False\n swish\u003e us `isBaseLang` gb\n False\n\u003c/pre\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "LanguageTag",
          "package": "swish",
          "source": "src/Swish-RDF-Vocabulary.html#LanguageTag",
          "type": "data"
        },
        "index": {
          "description": "Represent the language tag for literal string following RFC http www.ietf.org rfc rfc3066.txt Use toLangTag to create tag and fromLangTag to convert back The case is preserved for the tag although comparison both the Eq instance and compareLangTag is done using the lower-case form of the tags As an example Prelude set prompt swish swish set XOverloadedStrings swish Swish.RDF.Vocabulary swish let en en LanguageTag swish let us en-us LanguageTag swish let gb en-GB LanguageTag swish gb en-GB swish gb en-gb True swish en us False swish en isBaseLang us True swish us isBaseLang en False swish us isBaseLang gb False",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "LanguageTag",
          "package": "swish",
          "partial": "Language Tag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#t:LanguageTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edefault:base\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "defaultBase",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary.html#defaultBase",
          "type": "function"
        },
        "index": {
          "description": "default base",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "defaultBase",
          "package": "swish",
          "partial": "Base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:defaultBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a language tag back into text form.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "fromLangTag",
          "package": "swish",
          "signature": "LanguageTag -\u003e Text",
          "source": "src/Swish-RDF-Vocabulary.html#fromLangTag",
          "type": "function"
        },
        "index": {
          "description": "Convert language tag back into text form",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "fromLangTag",
          "normalized": "LanguageTag-\u003eText",
          "package": "swish",
          "partial": "Lang Tag",
          "signature": "LanguageTag-\u003eText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:fromLangTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare language tags using the Language-range specification\n in section 2.5 of RFC 3066.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e is returned if the comparison tag is the same as, or\n matches a prefix of, the base tag (where the match must be\n over complete sub tags).\n\u003c/p\u003e\u003cp\u003eNote that \n\u003c/p\u003e\u003cpre\u003e l1 `isBaseLang` l2 == l2 `isBaseLang` l1\n\u003c/pre\u003e\u003cp\u003eonly when\n\u003c/p\u003e\u003cpre\u003e l1 == l2\n\u003c/pre\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "isBaseLang",
          "package": "swish",
          "signature": "LanguageTag-\u003e LanguageTag-\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Compare language tags using the Language-range specification in section of RFC True is returned if the comparison tag is the same as or matches prefix of the base tag where the match must be over complete sub tags Note that l1 isBaseLang l2 l2 isBaseLang l1 only when l1 l2",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "isBaseLang",
          "normalized": "LanguageTag-\u003eLanguageTag-\u003eBool",
          "package": "swish",
          "partial": "Base Lang",
          "signature": "LanguageTag-\u003eLanguageTag-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:isBaseLang"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elog:implies\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "logImplies",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary.html#logImplies",
          "type": "function"
        },
        "index": {
          "description": "log implies",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "logImplies",
          "package": "swish",
          "partial": "Implies",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:logImplies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003edaml\u003c/code\u003e to \u003ca\u003ehttp://www.daml.org/2000/10/daml-ont#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceDAML",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#namespaceDAML",
          "type": "function"
        },
        "index": {
          "description": "Maps daml to http www.daml.org daml-ont",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceDAML",
          "package": "swish",
          "partial": "DAML",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:namespaceDAML"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003edefault\u003c/code\u003e to \u003ccode\u003ehttp://id.ninebynine.org/default/\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceDefault",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#namespaceDefault",
          "type": "function"
        },
        "index": {
          "description": "Maps default to http id.ninebynine.org default",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceDefault",
          "package": "swish",
          "partial": "Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:namespaceDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003elog\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/2000/10/swap/log#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceLOG",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#namespaceLOG",
          "type": "function"
        },
        "index": {
          "description": "Maps log to http www.w3.org swap log",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceLOG",
          "package": "swish",
          "partial": "LOG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:namespaceLOG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003emath\u003c/code\u003e to \u003ca\u003ehttp://www.w3.org/2000/10/swap/math#\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceMATH",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#namespaceMATH",
          "type": "function"
        },
        "index": {
          "description": "Maps math to http www.w3.org swap math",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceMATH",
          "package": "swish",
          "partial": "MATH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:namespaceMATH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003erdfd\u003c/code\u003e to \u003ccode\u003ehttp://id.ninebynine.org/2003/rdfext/rdfd#\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceRDFD",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#namespaceRDFD",
          "type": "function"
        },
        "index": {
          "description": "Maps rdfd to http id.ninebynine.org rdfext rdfd",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceRDFD",
          "package": "swish",
          "partial": "RDFD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:namespaceRDFD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003eswish\u003c/code\u003e to \u003ccode\u003ehttp://id.ninebynine.org/2003/Swish/\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceSwish",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#namespaceSwish",
          "type": "function"
        },
        "index": {
          "description": "Maps swish to http id.ninebynine.org Swish",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceSwish",
          "package": "swish",
          "partial": "Swish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:namespaceSwish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a namespace for the datatype family schema used by Swish.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceXsdType",
          "package": "swish",
          "signature": "LName-\u003e Namespace",
          "type": "function"
        },
        "index": {
          "description": "Create namespace for the datatype family schema used by Swish",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "namespaceXsdType",
          "normalized": "LName-\u003eNamespace",
          "package": "swish",
          "partial": "Xsd Type",
          "signature": "LName-\u003eNamespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:namespaceXsdType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:constraint\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdConstraint",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary.html#rdfdConstraint",
          "type": "function"
        },
        "index": {
          "description": "rdfd constraint",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdConstraint",
          "package": "swish",
          "partial": "Constraint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:rdfdConstraint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:GeneralRestriction\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdGeneralRestriction",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary.html#rdfdGeneralRestriction",
          "type": "function"
        },
        "index": {
          "description": "rdfd GeneralRestriction",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdGeneralRestriction",
          "package": "swish",
          "partial": "General Restriction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:rdfdGeneralRestriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:maxCardinality\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdMaxCardinality",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary.html#rdfdMaxCardinality",
          "type": "function"
        },
        "index": {
          "description": "rdfd maxCardinality",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdMaxCardinality",
          "package": "swish",
          "partial": "Max Cardinality",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:rdfdMaxCardinality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003erdfd:onProperties\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdOnProperties",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-RDF-Vocabulary.html#rdfdOnProperties",
          "type": "function"
        },
        "index": {
          "description": "rdfd onProperties",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "rdfdOnProperties",
          "package": "swish",
          "partial": "On Properties",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:rdfdOnProperties"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003ers_rdf\u003c/code\u003e to \u003ccode\u003ehttp://id.ninebynine.org/2003/Ruleset/rdf#\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "scopeRDF",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#scopeRDF",
          "type": "function"
        },
        "index": {
          "description": "Maps rs rdf to http id.ninebynine.org Ruleset rdf",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "scopeRDF",
          "package": "swish",
          "partial": "RDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:scopeRDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003ers_rdfd\u003c/code\u003e to \u003ccode\u003ehttp://id.ninebynine.org/2003/Ruleset/rdfd#\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "scopeRDFD",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#scopeRDFD",
          "type": "function"
        },
        "index": {
          "description": "Maps rs rdfd to http id.ninebynine.org Ruleset rdfd",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "scopeRDFD",
          "package": "swish",
          "partial": "RDFD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:scopeRDFD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaps \u003ccode\u003ers_rdfs\u003c/code\u003e to \u003ccode\u003ehttp://id.ninebynine.org/2003/Ruleset/rdfs#\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "scopeRDFS",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-RDF-Vocabulary.html#scopeRDFS",
          "type": "function"
        },
        "index": {
          "description": "Maps rs rdfs to http id.ninebynine.org Ruleset rdfs",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "scopeRDFS",
          "package": "swish",
          "partial": "RDFS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:scopeRDFS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a local name to a scoped name in the \u003ccode\u003eswish\u003c/code\u003e namespace (\u003ccode\u003e\u003ca\u003enamespaceSwish\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "swishName",
          "package": "swish",
          "signature": "LName -\u003e ScopedName",
          "source": "src/Swish-RDF-Vocabulary.html#swishName",
          "type": "function"
        },
        "index": {
          "description": "Convert local name to scoped name in the swish namespace namespaceSwish",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "swishName",
          "normalized": "LName-\u003eScopedName",
          "package": "swish",
          "partial": "Name",
          "signature": "LName-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:swishName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eLanguageTag\u003c/a\u003e\u003c/code\u003e element from the label.\n\u003c/p\u003e\u003cp\u003eValid tags follow the ABNF from RCF 3066, which is\n\u003c/p\u003e\u003cpre\u003e   Language-Tag = Primary-subtag *( \"-\" Subtag )\n   Primary-subtag = 1*8ALPHA\n   Subtag = 1*8(ALPHA / DIGIT)\n\u003c/pre\u003e\u003cp\u003eThere are no checks that the primary or secondary sub tag\n values are defined in any standard, such as ISO 639,\n or obey any other syntactical restriction than given above.\n\u003c/p\u003e",
          "module": "Swish.RDF.Vocabulary",
          "name": "toLangTag",
          "package": "swish",
          "signature": "Text -\u003e Maybe LanguageTag",
          "source": "src/Swish-RDF-Vocabulary.html#toLangTag",
          "type": "function"
        },
        "index": {
          "description": "Create LanguageTag element from the label Valid tags follow the ABNF from RCF which is Language-Tag Primary-subtag Subtag Primary-subtag ALPHA Subtag ALPHA DIGIT There are no checks that the primary or secondary sub tag values are defined in any standard such as ISO or obey any other syntactical restriction than given above",
          "hierarchy": "Swish RDF Vocabulary",
          "module": "Swish.RDF.Vocabulary",
          "name": "toLangTag",
          "normalized": "Text-\u003eMaybe LanguageTag",
          "package": "swish",
          "partial": "Lang Tag",
          "signature": "Text-\u003eMaybe LanguageTag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF-Vocabulary.html#v:toLangTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides an in-memory RDF Graph (it re-exports\n  \u003ca\u003eSwish.RDF.Graph\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.RDF",
          "name": "RDF",
          "package": "swish",
          "source": "src/Swish-RDF.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides an in-memory RDF Graph it re-exports Swish.RDF.Graph",
          "hierarchy": "Swish RDF",
          "module": "Swish.RDF",
          "name": "RDF",
          "package": "swish",
          "partial": "RDF",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-RDF.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a framework for defining inference rules\n  over some expression form.  It is intended to be used with\n  RDF graphs, but the structures aim to be quite generic with\n  respect to the expression forms allowed.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Rule",
          "name": "Rule",
          "package": "swish",
          "source": "src/Swish-Rule.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines framework for defining inference rules over some expression form It is intended to be used with RDF graphs but the structures aim to be quite generic with respect to the expression forms allowed",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "Rule",
          "package": "swish",
          "partial": "Rule",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpression is a type class for values over which proofs\n  may be constructed.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "Expression",
          "package": "swish",
          "source": "src/Swish-Rule.html#Expression",
          "type": "class"
        },
        "index": {
          "description": "Expression is type class for values over which proofs may be constructed",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "Expression",
          "package": "swish",
          "partial": "Expression",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#t:Expression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Formula is a named expression.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "Formula",
          "package": "swish",
          "source": "src/Swish-Rule.html#Formula",
          "type": "data"
        },
        "index": {
          "description": "Formula is named expression",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "Formula",
          "package": "swish",
          "partial": "Formula",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#t:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRule is a data type for inference rules that can be used\n  to construct a step in a proof.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "Rule",
          "package": "swish",
          "source": "src/Swish-Rule.html#Rule",
          "type": "data"
        },
        "index": {
          "description": "Rule is data type for inference rules that can be used to construct step in proof",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "Rule",
          "package": "swish",
          "partial": "Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#t:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of rules labelled with their name.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "RuleMap",
          "package": "swish",
          "source": "src/Swish-Rule.html#RuleMap",
          "type": "type"
        },
        "index": {
          "description": "set of rules labelled with their name",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "RuleMap",
          "package": "swish",
          "partial": "Rule Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#t:RuleMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Rule",
          "name": "Formula",
          "package": "swish",
          "signature": "Formula",
          "source": "src/Swish-Rule.html#Formula",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "Formula",
          "package": "swish",
          "partial": "Formula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:Formula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Rule",
          "name": "Rule",
          "package": "swish",
          "signature": "Rule",
          "source": "src/Swish-Rule.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "Rule",
          "package": "swish",
          "partial": "Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBackward application of a rule, takes an expression\n  and returns a list of alternative antecedents, each of\n  which is a list of expressions that jointly yield the\n  given consequence through application of the inference\n  rule.  An empty list is returned if no antecedents\n  will allow the consequence to be inferred.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "bwdApply",
          "package": "swish",
          "signature": "ex -\u003e [[ex]]",
          "source": "src/Swish-Rule.html#Rule",
          "type": "function"
        },
        "index": {
          "description": "Backward application of rule takes an expression and returns list of alternative antecedents each of which is list of expressions that jointly yield the given consequence through application of the inference rule An empty list is returned if no antecedents will allow the consequence to be inferred",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "bwdApply",
          "normalized": "a-\u003e[[a]]",
          "package": "swish",
          "partial": "Apply",
          "signature": "ex-\u003e[[ex]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:bwdApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks that the antecedants are all required\n to create the consequence using the given rule.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "bwdCheckInference",
          "package": "swish",
          "signature": "Rule ex-\u003e [ex]-\u003e ex-\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Checks that the antecedants are all required to create the consequence using the given rule",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "bwdCheckInference",
          "normalized": "Rule a-\u003e[a]-\u003ea-\u003eBool",
          "package": "swish",
          "partial": "Check Inference",
          "signature": "Rule ex-\u003e[ex]-\u003eex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:bwdCheckInference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInference check.  Takes a list of antecedent expressions\n  and a consequent expression, returning True if the\n  consequence can be obtained from the antecedents by\n  application of the rule.  When the antecedents and\n  consequent are both given, this is generally more efficient\n  that using either forward or backward chaining.\n  Also, a particular rule may not fully support either\n  forward or backward chaining, but all rules are required\n  to fully support this function.\n\u003c/p\u003e\u003cp\u003eA default implementation based on forward chaining is\n  given below.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "checkInference",
          "package": "swish",
          "signature": "[ex] -\u003e ex -\u003e Bool",
          "source": "src/Swish-Rule.html#Rule",
          "type": "function"
        },
        "index": {
          "description": "Inference check Takes list of antecedent expressions and consequent expression returning True if the consequence can be obtained from the antecedents by application of the rule When the antecedents and consequent are both given this is generally more efficient that using either forward or backward chaining Also particular rule may not fully support either forward or backward chaining but all rules are required to fully support this function default implementation based on forward chaining is given below",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "checkInference",
          "normalized": "[a]-\u003ea-\u003eBool",
          "package": "swish",
          "partial": "Inference",
          "signature": "[ex]-\u003eex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:checkInference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamed formula value\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "formExpr",
          "package": "swish",
          "signature": "ex",
          "source": "src/Swish-Rule.html#Formula",
          "type": "function"
        },
        "index": {
          "description": "Named formula value",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "formExpr",
          "package": "swish",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:formExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName used for formula in proof chain\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "formName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-Rule.html#Formula",
          "type": "function"
        },
        "index": {
          "description": "Name used for formula in proof chain",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "formName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:formName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForward application of a rule, takes a list of\n  expressions and returns a list (possibly empty)\n  of forward applications of the rule to combinations\n  of the antecedent expressions.\n  Note that all of the results returned can be assumed to\n  be (simultaneously) true, given the antecedents provided.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "fwdApply",
          "package": "swish",
          "signature": "[ex] -\u003e [ex]",
          "source": "src/Swish-Rule.html#Rule",
          "type": "function"
        },
        "index": {
          "description": "Forward application of rule takes list of expressions and returns list possibly empty of forward applications of the rule to combinations of the antecedent expressions Note that all of the results returned can be assumed to be simultaneously true given the antecedents provided",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "fwdApply",
          "normalized": "[a]-\u003e[a]",
          "package": "swish",
          "partial": "Apply",
          "signature": "[ex]-\u003e[ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:fwdApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChecks that consequence is a result of\n applying the rule to the antecedants.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "fwdCheckInference",
          "package": "swish",
          "signature": "Rule ex-\u003e [ex]-\u003e ex-\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Checks that consequence is result of applying the rule to the antecedants",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "fwdCheckInference",
          "normalized": "Rule a-\u003e[a]-\u003ea-\u003eBool",
          "package": "swish",
          "partial": "Check Inference",
          "signature": "Rule ex-\u003e[ex]-\u003eex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:fwdCheckInference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs expression true in all interpretations?\n  If so, then its truth is assumed without justification.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "isValid",
          "package": "swish",
          "signature": "ex -\u003e Bool",
          "source": "src/Swish-Rule.html#isValid",
          "type": "method"
        },
        "index": {
          "description": "Is expression true in all interpretations If so then its truth is assumed without justification",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "isValid",
          "normalized": "a-\u003eBool",
          "package": "swish",
          "partial": "Valid",
          "signature": "ex-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:isValid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe null formula.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "nullFormula",
          "package": "swish",
          "signature": "Formula ex",
          "source": "src/Swish-Rule.html#nullFormula",
          "type": "function"
        },
        "index": {
          "description": "The null formula",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "nullFormula",
          "package": "swish",
          "partial": "Formula",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:nullFormula"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe null rule.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "nullRule",
          "package": "swish",
          "signature": "Rule ex",
          "source": "src/Swish-Rule.html#nullRule",
          "type": "function"
        },
        "index": {
          "description": "The null rule",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "nullRule",
          "package": "swish",
          "partial": "Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:nullRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a scoped name with the null namespace.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "nullSN",
          "package": "swish",
          "signature": "LName-\u003e ScopedName",
          "type": "function"
        },
        "index": {
          "description": "Create scoped name with the null namespace",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "nullSN",
          "normalized": "LName-\u003eScopedName",
          "package": "swish",
          "partial": "SN",
          "signature": "LName-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:nullSN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe namespace \u003ccode\u003ehttp://id.ninebynine.org/2003/Ruleset/null\u003c/code\u003e with the prefix \u003ccode\u003enull:\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "nullScope",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-Rule.html#nullScope",
          "type": "function"
        },
        "index": {
          "description": "The namespace http id.ninebynine.org Ruleset null with the prefix null",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "nullScope",
          "package": "swish",
          "partial": "Scope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:nullScope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName of rule, for use when displaying a proof\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "ruleName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-Rule.html#Rule",
          "type": "function"
        },
        "index": {
          "description": "Name of rule for use when displaying proof",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "ruleName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:ruleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a displayable form of a list of labelled formulae\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "showsFormulae",
          "package": "swish",
          "signature": "String-\u003e [Formula ex]-\u003e String-\u003e ShowS",
          "type": "function"
        },
        "index": {
          "description": "Return displayable form of list of labelled formulae",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "showsFormulae",
          "normalized": "String-\u003e[Formula a]-\u003eString-\u003eShowS",
          "package": "swish",
          "partial": "Formulae",
          "signature": "String-\u003e[Formula ex]-\u003eString-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:showsFormulae"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a string left justified in a field of at least the specified\n  number of characters width.\n\u003c/p\u003e",
          "module": "Swish.Rule",
          "name": "showsWidth",
          "package": "swish",
          "signature": "Int -\u003e String -\u003e ShowS",
          "source": "src/Swish-Rule.html#showsWidth",
          "type": "function"
        },
        "index": {
          "description": "Show string left justified in field of at least the specified number of characters width",
          "hierarchy": "Swish Rule",
          "module": "Swish.Rule",
          "name": "showsWidth",
          "normalized": "Int-\u003eString-\u003eShowS",
          "package": "swish",
          "partial": "Width",
          "signature": "Int-\u003eString-\u003eShowS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Rule.html#v:showsWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a ruleset data type, used to collect information\n  about a ruleset that may contribute torwards inferences in RDF;\n  e.g. RDF and RDFS are rulesets.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eRuleset\u003c/a\u003e\u003c/code\u003e consists of a namespace, a collection of axioms, and\n  a collection of rules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "source": "src/Swish-Ruleset.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines ruleset data type used to collect information about ruleset that may contribute torwards inferences in RDF e.g RDF and RDFS are rulesets Ruleset consists of namespace collection of axioms and collection of rules",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "partial": "Ruleset",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Rule set.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "source": "src/Swish-Ruleset.html#Ruleset",
          "type": "data"
        },
        "index": {
          "description": "Rule set",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "partial": "Ruleset",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#t:Ruleset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of Rulesets labelled by their Namespace.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "RulesetMap",
          "package": "swish",
          "source": "src/Swish-Ruleset.html#RulesetMap",
          "type": "type"
        },
        "index": {
          "description": "set of Rulesets labelled by their Namespace",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "RulesetMap",
          "package": "swish",
          "partial": "Ruleset Map",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#t:RulesetMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "signature": "Ruleset",
          "source": "src/Swish-Ruleset.html#Ruleset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "Ruleset",
          "package": "swish",
          "partial": "Ruleset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:Ruleset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named axiom in a proof context.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getContextAxiom",
          "package": "swish",
          "signature": "ScopedName-\u003e Formula ex-\u003e [Ruleset ex]-\u003e Formula ex",
          "type": "function"
        },
        "index": {
          "description": "Find named axiom in proof context",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getContextAxiom",
          "normalized": "ScopedName-\u003eFormula a-\u003e[Ruleset a]-\u003eFormula a",
          "package": "swish",
          "partial": "Context Axiom",
          "signature": "ScopedName-\u003eFormula ex-\u003e[Ruleset ex]-\u003eFormula ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getContextAxiom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named rule in a proof context.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getContextRule",
          "package": "swish",
          "signature": "ScopedName-\u003e Rule ex-\u003e [Ruleset ex]-\u003e Rule ex",
          "type": "function"
        },
        "index": {
          "description": "Find named rule in proof context",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getContextRule",
          "normalized": "ScopedName-\u003eRule a-\u003e[Ruleset a]-\u003eRule a",
          "package": "swish",
          "partial": "Context Rule",
          "signature": "ScopedName-\u003eRule ex-\u003e[Ruleset ex]-\u003eRule ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getContextRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named axiom in a proof context.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getMaybeContextAxiom",
          "package": "swish",
          "signature": "ScopedName-\u003e [Ruleset ex]-\u003e Maybe (Formula ex)",
          "type": "function"
        },
        "index": {
          "description": "Find named axiom in proof context",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getMaybeContextAxiom",
          "normalized": "ScopedName-\u003e[Ruleset a]-\u003eMaybe(Formula a)",
          "package": "swish",
          "partial": "Maybe Context Axiom",
          "signature": "ScopedName-\u003e[Ruleset ex]-\u003eMaybe(Formula ex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getMaybeContextAxiom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named rule in a proof context.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getMaybeContextRule",
          "package": "swish",
          "signature": "ScopedName-\u003e [Ruleset ex]-\u003e Maybe (Rule ex)",
          "type": "function"
        },
        "index": {
          "description": "Find named rule in proof context",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getMaybeContextRule",
          "normalized": "ScopedName-\u003e[Ruleset a]-\u003eMaybe(Rule a)",
          "package": "swish",
          "partial": "Maybe Context Rule",
          "signature": "ScopedName-\u003e[Ruleset ex]-\u003eMaybe(Rule ex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getMaybeContextRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named axiom in a ruleset.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getRulesetAxiom",
          "package": "swish",
          "signature": "ScopedName -\u003e Ruleset ex -\u003e Maybe (Formula ex)",
          "source": "src/Swish-Ruleset.html#getRulesetAxiom",
          "type": "function"
        },
        "index": {
          "description": "Find named axiom in ruleset",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getRulesetAxiom",
          "normalized": "ScopedName-\u003eRuleset a-\u003eMaybe(Formula a)",
          "package": "swish",
          "partial": "Ruleset Axiom",
          "signature": "ScopedName-\u003eRuleset ex-\u003eMaybe(Formula ex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getRulesetAxiom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the axioms from a ruleset.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getRulesetAxioms",
          "package": "swish",
          "signature": "Ruleset ex -\u003e [Formula ex]",
          "source": "src/Swish-Ruleset.html#getRulesetAxioms",
          "type": "function"
        },
        "index": {
          "description": "Extract the axioms from ruleset",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getRulesetAxioms",
          "normalized": "Ruleset a-\u003e[Formula a]",
          "package": "swish",
          "partial": "Ruleset Axioms",
          "signature": "Ruleset ex-\u003e[Formula ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getRulesetAxioms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the namespace of a ruleset.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getRulesetNamespace",
          "package": "swish",
          "signature": "Ruleset ex -\u003e Namespace",
          "source": "src/Swish-Ruleset.html#getRulesetNamespace",
          "type": "function"
        },
        "index": {
          "description": "Extract the namespace of ruleset",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getRulesetNamespace",
          "normalized": "Ruleset a-\u003eNamespace",
          "package": "swish",
          "partial": "Ruleset Namespace",
          "signature": "Ruleset ex-\u003eNamespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getRulesetNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind a named rule in a ruleset. \n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getRulesetRule",
          "package": "swish",
          "signature": "ScopedName -\u003e Ruleset ex -\u003e Maybe (Rule ex)",
          "source": "src/Swish-Ruleset.html#getRulesetRule",
          "type": "function"
        },
        "index": {
          "description": "Find named rule in ruleset",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getRulesetRule",
          "normalized": "ScopedName-\u003eRuleset a-\u003eMaybe(Rule a)",
          "package": "swish",
          "partial": "Ruleset Rule",
          "signature": "ScopedName-\u003eRuleset ex-\u003eMaybe(Rule ex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getRulesetRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the rules from a ruleset.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "getRulesetRules",
          "package": "swish",
          "signature": "Ruleset ex -\u003e [Rule ex]",
          "source": "src/Swish-Ruleset.html#getRulesetRules",
          "type": "function"
        },
        "index": {
          "description": "Extract the rules from ruleset",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "getRulesetRules",
          "normalized": "Ruleset a-\u003e[Rule a]",
          "package": "swish",
          "partial": "Ruleset Rules",
          "signature": "Ruleset ex-\u003e[Rule ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:getRulesetRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a ruleset.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "makeRuleset",
          "package": "swish",
          "signature": "Namespace -\u003e [Formula ex] -\u003e [Rule ex] -\u003e Ruleset ex",
          "source": "src/Swish-Ruleset.html#makeRuleset",
          "type": "function"
        },
        "index": {
          "description": "Create ruleset",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "makeRuleset",
          "normalized": "Namespace-\u003e[Formula a]-\u003e[Rule a]-\u003eRuleset a",
          "package": "swish",
          "partial": "Ruleset",
          "signature": "Namespace-\u003e[Formula ex]-\u003e[Rule ex]-\u003eRuleset ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:makeRuleset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAxioms.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "rsAxioms",
          "package": "swish",
          "signature": "[Formula ex]",
          "source": "src/Swish-Ruleset.html#Ruleset",
          "type": "function"
        },
        "index": {
          "description": "Axioms",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "rsAxioms",
          "normalized": "[Formula a]",
          "package": "swish",
          "partial": "Axioms",
          "signature": "[Formula ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:rsAxioms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNamespace.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "rsNamespace",
          "package": "swish",
          "signature": "Namespace",
          "source": "src/Swish-Ruleset.html#Ruleset",
          "type": "function"
        },
        "index": {
          "description": "Namespace",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "rsNamespace",
          "package": "swish",
          "partial": "Namespace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:rsNamespace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRules.\n\u003c/p\u003e",
          "module": "Swish.Ruleset",
          "name": "rsRules",
          "package": "swish",
          "signature": "[Rule ex]",
          "source": "src/Swish-Ruleset.html#Ruleset",
          "type": "function"
        },
        "index": {
          "description": "Rules",
          "hierarchy": "Swish Ruleset",
          "module": "Swish.Ruleset",
          "name": "rsRules",
          "normalized": "[Rule a]",
          "package": "swish",
          "partial": "Rules",
          "signature": "[Rule ex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Ruleset.html#v:rsRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements the Swish script processor:  it parses a script\nfrom a supplied string, and returns a list of Swish state transformer\nfunctions whose effect, when applied to a state value, is to implement\nthe supplied script.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.Script",
          "name": "Script",
          "package": "swish",
          "source": "src/Swish-Script.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements the Swish script processor it parses script from supplied string and returns list of Swish state transformer functions whose effect when applied to state value is to implement the supplied script",
          "hierarchy": "Swish Script",
          "module": "Swish.Script",
          "name": "Script",
          "package": "swish",
          "partial": "Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Script.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for Swish script processor\n\u003c/p\u003e",
          "module": "Swish.Script",
          "name": "parseScriptFromText",
          "package": "swish",
          "signature": "Maybe QName-\u003e Text-\u003e Either String [SwishStateIO ()]",
          "type": "function"
        },
        "index": {
          "description": "Parser for Swish script processor",
          "hierarchy": "Swish Script",
          "module": "Swish.Script",
          "name": "parseScriptFromText",
          "normalized": "Maybe QName-\u003eText-\u003eEither String[SwishStateIO()]",
          "package": "swish",
          "partial": "Script From Text",
          "signature": "Maybe QName-\u003eText-\u003eEither String[SwishStateIO()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Script.html#v:parseScriptFromText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.Utils.ListHelpers",
          "name": "ListHelpers",
          "package": "swish",
          "source": "src/Swish-Utils-ListHelpers.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Swish Utils ListHelpers",
          "module": "Swish.Utils.ListHelpers",
          "name": "ListHelpers",
          "package": "swish",
          "partial": "List Helpers",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Utils-ListHelpers.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply list of functions to some value, returning list of results.\n  It's kind of like an converse map.\n\u003c/p\u003e\u003cp\u003eThis is similar to the \u003ccode\u003eap\u003c/code\u003e function in the Monad library.\n\u003c/p\u003e",
          "module": "Swish.Utils.ListHelpers",
          "name": "flist",
          "package": "swish",
          "signature": "[a -\u003e b] -\u003e a -\u003e [b]",
          "source": "src/Swish-Utils-ListHelpers.html#flist",
          "type": "function"
        },
        "index": {
          "description": "Apply list of functions to some value returning list of results It kind of like an converse map This is similar to the ap function in the Monad library",
          "hierarchy": "Swish Utils ListHelpers",
          "module": "Swish.Utils.ListHelpers",
          "name": "flist",
          "normalized": "[a-\u003eb]-\u003ea-\u003e[b]",
          "package": "swish",
          "signature": "[a-\u003eb]-\u003ea-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-Utils-ListHelpers.html#v:flist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines functions for representing and manipulating query\n  binding variable sets.  This is the key data that mediates between\n  query and back substitution when performing inferences.  A framework\n  of query variable modifiers is provided that can be used to\n  implement richer inferences, such as filtering of  query results,\n  or replacing values based on known relationships.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Swish.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "source": "src/Swish-VarBinding.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines functions for representing and manipulating query binding variable sets This is the key data that mediates between query and back substitution when performing inferences framework of query variable modifiers is provided that can be used to implement richer inferences such as filtering of query results or replacing values based on known relationships",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "partial": "Var Binding",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType for variable binding modifier that has yet to be instantiated\n  with respect to the variables that it operates upon.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "OpenVarBindingModify",
          "package": "swish",
          "source": "src/Swish-VarBinding.html#OpenVarBindingModify",
          "type": "type"
        },
        "index": {
          "description": "Type for variable binding modifier that has yet to be instantiated with respect to the variables that it operates upon",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "OpenVarBindingModify",
          "package": "swish",
          "partial": "Open Var Binding Modify",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#t:OpenVarBindingModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVarBinding is the type of an arbitrary variable bindings\n  value, where the type of the bound values is not specified.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "source": "src/Swish-VarBinding.html#VarBinding",
          "type": "data"
        },
        "index": {
          "description": "VarBinding is the type of an arbitrary variable bindings value where the type of the bound values is not specified",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "partial": "Var Binding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#t:VarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVarBindingFilter is a function type that tests to see if\n  a query binding satisfies some criterion.\n\u003c/p\u003e\u003cp\u003eQueries often want to apply some kind of filter or condition\n  to the variable bindings that are processed.  In inference rules,\n  it sometimes seems desirable to stipulate additional conditions on\n  the things that are matched.\n\u003c/p\u003e\u003cp\u003eThis function type is used to perform such tests.\n  A number of simple implementations are included below.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "VarBindingFilter",
          "package": "swish",
          "source": "src/Swish-VarBinding.html#VarBindingFilter",
          "type": "data"
        },
        "index": {
          "description": "VarBindingFilter is function type that tests to see if query binding satisfies some criterion Queries often want to apply some kind of filter or condition to the variable bindings that are processed In inference rules it sometimes seems desirable to stipulate additional conditions on the things that are matched This function type is used to perform such tests number of simple implementations are included below",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "VarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Filter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#t:VarBindingFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefine the type of a function to modify variable bindings in\n  forward chaining based on rule antecedent matches.  This\n  function is used to implement the \"allocated to\" logic described\n  in Appendix B of the RDF semantics document, in which a specific\n  blank node is associated with all matches of some specific value\n  by applications of the rule on a given graph.\n  Use \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e if no modification of the variable bindings is required.\n\u003c/p\u003e\u003cp\u003eThis datatype consists of the modifier function itself, which\n  operates on a list of variable bindings rather than a single\n  variable binding (because some modifications share context across\n  a set of bindings), and some additional descriptive information\n  that allows possible usage patterns to be analyzed.\n\u003c/p\u003e\u003cp\u003eSome usage patterns (see \u003ccode\u003e\u003ca\u003evbmUsage\u003c/a\u003e\u003c/code\u003e for more details):\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003efilter\u003c/dt\u003e\u003cdd\u003e  all variables are input variables, and the effect\n      of the modifier function is to drop variable bindings that\n      don't satisfy some criterion.\n      Identifiable by an empty element in \u003ccode\u003evbmUsage\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003esource\u003c/dt\u003e\u003cdd\u003e  all variables are output variables:  a raw query\n      could be viewed as a source of variable bindings.\n      Identifiable by an element of \u003ccode\u003evbmUsage\u003c/code\u003e equal to \u003ccode\u003evbmVocab\u003c/code\u003e.\n\u003c/dd\u003e\u003cdt\u003emodifier\u003c/dt\u003e\u003cdd\u003e  for each supplied variable binding, one or more\n      new variable bindings may be created that contain the\n      input variables bound as supplied plus some additional variables.\n      Identifiable by an element of \u003ccode\u003evbmUsage\u003c/code\u003e some subset of \u003ccode\u003evbmVocab\u003c/code\u003e.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eA variety of variable usage patterns may be supported by a given\n  modifier:  a modifier may be used to define new variable bindings\n  from existing bindings in a number of ways, or simply to check that\n  some required relationship between bindings is satisfied.\n  (Example, for \u003ccode\u003ea + b = c\u003c/code\u003e, any one variable can be deduced from the\n  other two, or all three may be supplied to check that the relationship\n  does indeed hold.)\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "VarBindingModify",
          "package": "swish",
          "source": "src/Swish-VarBinding.html#VarBindingModify",
          "type": "data"
        },
        "index": {
          "description": "Define the type of function to modify variable bindings in forward chaining based on rule antecedent matches This function is used to implement the allocated to logic described in Appendix of the RDF semantics document in which specific blank node is associated with all matches of some specific value by applications of the rule on given graph Use id if no modification of the variable bindings is required This datatype consists of the modifier function itself which operates on list of variable bindings rather than single variable binding because some modifications share context across set of bindings and some additional descriptive information that allows possible usage patterns to be analyzed Some usage patterns see vbmUsage for more details filter all variables are input variables and the effect of the modifier function is to drop variable bindings that don satisfy some criterion Identifiable by an empty element in vbmUsage source all variables are output variables raw query could be viewed as source of variable bindings Identifiable by an element of vbmUsage equal to vbmVocab modifier for each supplied variable binding one or more new variable bindings may be created that contain the input variables bound as supplied plus some additional variables Identifiable by an element of vbmUsage some subset of vbmVocab variety of variable usage patterns may be supported by given modifier modifier may be used to define new variable bindings from existing bindings in number of ways or simply to check that some required relationship between bindings is satisfied Example for any one variable can be deduced from the other two or all three may be supplied to check that the relationship does indeed hold",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "VarBindingModify",
          "package": "swish",
          "partial": "Var Binding Modify",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#t:VarBindingModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "signature": "VarBinding",
          "source": "src/Swish-VarBinding.html#VarBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "VarBinding",
          "package": "swish",
          "partial": "Var Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:VarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "VarBindingFilter",
          "package": "swish",
          "signature": "VarBindingFilter",
          "source": "src/Swish-VarBinding.html#VarBindingFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "VarBindingFilter",
          "package": "swish",
          "partial": "Var Binding Filter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:VarBindingFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "VarBindingModify",
          "package": "swish",
          "signature": "VarBindingModify",
          "source": "src/Swish-VarBinding.html#VarBindingModify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "VarBindingModify",
          "package": "swish",
          "partial": "Var Binding Modify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:VarBindingModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a single new value to a variable binding and return the resulting\n  new variable binding.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "addVarBinding",
          "package": "swish",
          "signature": "a -\u003e b -\u003e VarBinding a b -\u003e VarBinding a b",
          "source": "src/Swish-VarBinding.html#addVarBinding",
          "type": "function"
        },
        "index": {
          "description": "Add single new value to variable binding and return the resulting new variable binding",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "addVarBinding",
          "normalized": "a-\u003eb-\u003eVarBinding a b-\u003eVarBinding a b",
          "package": "swish",
          "partial": "Var Binding",
          "signature": "a-\u003eb-\u003eVarBinding a b-\u003eVarBinding a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:addVarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply query binding to a supplied value, returning the value\n  unchanged if no binding is defined\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "applyVarBinding",
          "package": "swish",
          "signature": "VarBinding a a -\u003e a -\u003e a",
          "source": "src/Swish-VarBinding.html#applyVarBinding",
          "type": "function"
        },
        "index": {
          "description": "Apply query binding to supplied value returning the value unchanged if no binding is defined",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "applyVarBinding",
          "normalized": "VarBinding a a-\u003ea-\u003ea",
          "package": "swish",
          "partial": "Var Binding",
          "signature": "VarBinding a a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:applyVarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of the variables bound by a supplied variable binding\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "boundVars",
          "package": "swish",
          "signature": "VarBinding a b -\u003e Set a",
          "source": "src/Swish-VarBinding.html#boundVars",
          "type": "function"
        },
        "index": {
          "description": "Return list of the variables bound by supplied variable binding",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "boundVars",
          "normalized": "VarBinding a b-\u003eSet a",
          "package": "swish",
          "partial": "Vars",
          "signature": "VarBinding a b-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:boundVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose sequence of variable binding modifiers.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "composeSequence",
          "package": "swish",
          "signature": "[VarBindingModify a b] -\u003e Maybe (VarBindingModify a b)",
          "source": "src/Swish-VarBinding.html#composeSequence",
          "type": "function"
        },
        "index": {
          "description": "Compose sequence of variable binding modifiers",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "composeSequence",
          "normalized": "[VarBindingModify a b]-\u003eMaybe(VarBindingModify a b)",
          "package": "swish",
          "partial": "Sequence",
          "signature": "[VarBindingModify a b]-\u003eMaybe(VarBindingModify a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:composeSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003eJust a\u003c/code\u003e compatible composition of variable binding modifiers\n  for a given set of supplied bound variables, or \u003ccode\u003eNothing\u003c/code\u003e if there\n  is no compatible composition\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "findComposition",
          "package": "swish",
          "signature": "[VarBindingModify a b] -\u003e [a] -\u003e Maybe (VarBindingModify a b)",
          "source": "src/Swish-VarBinding.html#findComposition",
          "type": "function"
        },
        "index": {
          "description": "Return Just compatible composition of variable binding modifiers for given set of supplied bound variables or Nothing if there is no compatible composition",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "findComposition",
          "normalized": "[VarBindingModify a b]-\u003e[a]-\u003eMaybe(VarBindingModify a b)",
          "package": "swish",
          "partial": "Composition",
          "signature": "[VarBindingModify a b]-\u003e[a]-\u003eMaybe(VarBindingModify a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:findComposition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind all compatible compositions of a list of variable binding\n  modifiers for a given set of supplied bound variables.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "findCompositions",
          "package": "swish",
          "signature": "[VarBindingModify a b] -\u003e [a] -\u003e [VarBindingModify a b]",
          "source": "src/Swish-VarBinding.html#findCompositions",
          "type": "function"
        },
        "index": {
          "description": "Find all compatible compositions of list of variable binding modifiers for given set of supplied bound variables",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "findCompositions",
          "normalized": "[VarBindingModify a b]-\u003e[a]-\u003e[VarBindingModify a b]",
          "package": "swish",
          "partial": "Compositions",
          "signature": "[VarBindingModify a b]-\u003e[a]-\u003e[VarBindingModify a b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:findCompositions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin a pair of query bindings, returning a new binding that\n  maps all variables recognized by either of the input bindings.\n  If the bindings should overlap, such overlap is not detected and\n  the value from the first binding provided is used.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "joinVarBindings",
          "package": "swish",
          "signature": "VarBinding a b -\u003e VarBinding a b -\u003e VarBinding a b",
          "source": "src/Swish-VarBinding.html#joinVarBindings",
          "type": "function"
        },
        "index": {
          "description": "Join pair of query bindings returning new binding that maps all variables recognized by either of the input bindings If the bindings should overlap such overlap is not detected and the value from the first binding provided is used",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "joinVarBindings",
          "normalized": "VarBinding a b-\u003eVarBinding a b-\u003eVarBinding a b",
          "package": "swish",
          "partial": "Var Bindings",
          "signature": "VarBinding a b-\u003eVarBinding a b-\u003eVarBinding a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:joinVarBindings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunction to make a variable binding from a list of\n  pairs of variable and corresponding assigned value.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "makeVarBinding",
          "package": "swish",
          "signature": "[(a, b)] -\u003e VarBinding a b",
          "source": "src/Swish-VarBinding.html#makeVarBinding",
          "type": "function"
        },
        "index": {
          "description": "Function to make variable binding from list of pairs of variable and corresponding assigned value",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "makeVarBinding",
          "normalized": "[(a,b)]-\u003eVarBinding a b",
          "package": "swish",
          "partial": "Var Binding",
          "signature": "[(a,b)]-\u003eVarBinding a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:makeVarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a variable comparison filter for named variables using\n  a supplied value comparison function.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "makeVarCompareFilter",
          "package": "swish",
          "signature": "ScopedName -\u003e (b -\u003e b -\u003e Bool) -\u003e a -\u003e a -\u003e VarBindingFilter a b",
          "source": "src/Swish-VarBinding.html#makeVarCompareFilter",
          "type": "function"
        },
        "index": {
          "description": "Make variable comparison filter for named variables using supplied value comparison function",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "makeVarCompareFilter",
          "normalized": "ScopedName-\u003e(a-\u003ea-\u003eBool)-\u003eb-\u003eb-\u003eVarBindingFilter b a",
          "package": "swish",
          "partial": "Var Compare Filter",
          "signature": "ScopedName-\u003e(b-\u003eb-\u003eBool)-\u003ea-\u003ea-\u003eVarBindingFilter a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:makeVarCompareFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a variable binding modifier from a variable binding filter value.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "makeVarFilterModify",
          "package": "swish",
          "signature": "VarBindingFilter a b -\u003e VarBindingModify a b",
          "source": "src/Swish-VarBinding.html#makeVarFilterModify",
          "type": "function"
        },
        "index": {
          "description": "Make variable binding modifier from variable binding filter value",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "makeVarFilterModify",
          "normalized": "VarBindingFilter a b-\u003eVarBindingModify a b",
          "package": "swish",
          "partial": "Var Filter Modify",
          "signature": "VarBindingFilter a b-\u003eVarBindingModify a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:makeVarFilterModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a variable test filter for a named variable using a\n  supplied value testing function.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "makeVarTestFilter",
          "package": "swish",
          "signature": "ScopedName -\u003e (b -\u003e Bool) -\u003e a -\u003e VarBindingFilter a b",
          "source": "src/Swish-VarBinding.html#makeVarTestFilter",
          "type": "function"
        },
        "index": {
          "description": "Make variable test filter for named variable using supplied value testing function",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "makeVarTestFilter",
          "normalized": "ScopedName-\u003e(a-\u003eBool)-\u003eb-\u003eVarBindingFilter b a",
          "package": "swish",
          "partial": "Var Test Filter",
          "signature": "ScopedName-\u003e(b-\u003eBool)-\u003ea-\u003eVarBindingFilter a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:makeVarTestFilter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe null, or empry, binding maps no query variables.\n   This is the \u003ccode\u003e\u003ca\u003emempty\u003c/a\u003e\u003c/code\u003e instance of the Monoid.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "nullVarBinding",
          "package": "swish",
          "signature": "VarBinding a b",
          "source": "src/Swish-VarBinding.html#nullVarBinding",
          "type": "function"
        },
        "index": {
          "description": "The null or empry binding maps no query variables This is the mempty instance of the Monoid",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "nullVarBinding",
          "package": "swish",
          "partial": "Var Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:nullVarBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNull variable binding modifier\n\u003c/p\u003e\u003cp\u003eThis is like \u003ccode\u003e\u003ca\u003evarBindingId\u003c/a\u003e\u003c/code\u003e except parameterized by some labels.\n  I think this is redundant, and should be eliminated.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "nullVarBindingModify",
          "package": "swish",
          "signature": "OpenVarBindingModify a b",
          "source": "src/Swish-VarBinding.html#nullVarBindingModify",
          "type": "function"
        },
        "index": {
          "description": "Null variable binding modifier This is like varBindingId except parameterized by some labels think this is redundant and should be eliminated",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "nullVarBindingModify",
          "package": "swish",
          "partial": "Var Binding Modify",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:nullVarBindingModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract variable binding name from \u003ccode\u003eOpenVarBindingModify\u003c/code\u003e value\n\u003c/p\u003e\u003cp\u003e(Because only the name is required, the application to an undefined\n  list of variable labels should never be evaluated, as long as the\n  name is not dependent on the variable names in any way.)\n\u003c/p\u003e\u003cp\u003eNOT QUITE... some of the functions that create \u003ccode\u003eOpenVarBindingModify\u003c/code\u003e\n  instances also pattern-match the number of labels provided, forcing\n  evaluation of the labels parameter, even though it's not used.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "openVbmName",
          "package": "swish",
          "signature": "OpenVarBindingModify lb vn -\u003e ScopedName",
          "source": "src/Swish-VarBinding.html#openVbmName",
          "type": "function"
        },
        "index": {
          "description": "Extract variable binding name from OpenVarBindingModify value Because only the name is required the application to an undefined list of variable labels should never be evaluated as long as the name is not dependent on the variable names in any way NOT QUITE some of the functions that create OpenVarBindingModify instances also pattern-match the number of labels provided forcing evaluation of the labels parameter even though it not used",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "openVbmName",
          "normalized": "OpenVarBindingModify a b-\u003eScopedName",
          "package": "swish",
          "partial": "Vbm Name",
          "signature": "OpenVarBindingModify lb vn-\u003eScopedName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:openVbmName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVarBinding subset function, tests to see if one query binding\n  is a subset of another;  i.e. every query variable mapping defined\n  by one is also defined by the other.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "subBinding",
          "package": "swish",
          "signature": "VarBinding a b -\u003e VarBinding a b -\u003e Bool",
          "source": "src/Swish-VarBinding.html#subBinding",
          "type": "function"
        },
        "index": {
          "description": "VarBinding subset function tests to see if one query binding is subset of another i.e every query variable mapping defined by one is also defined by the other",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "subBinding",
          "normalized": "VarBinding a b-\u003eVarBinding a b-\u003eBool",
          "package": "swish",
          "partial": "Binding",
          "signature": "VarBinding a b-\u003eVarBinding a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:subBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable binding modifier that returns exactly those\n  variable bindings presented.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "varBindingId",
          "package": "swish",
          "signature": "VarBindingModify a b",
          "source": "src/Swish-VarBinding.html#varBindingId",
          "type": "function"
        },
        "index": {
          "description": "Variable binding modifier that returns exactly those variable bindings presented",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "varBindingId",
          "package": "swish",
          "partial": "Binding Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:varBindingId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a number of query binding filters\n  into a composite filter that accepts any query binding that\n  satisfies all of the component values.\n\u003c/p\u003e\u003cp\u003eThe same function could be achieved by composing the component\n  filter-based modifiers, but this function is more convenient\n  as it avoids the need to check for modifier compatibility.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "varFilterConjunction",
          "package": "swish",
          "signature": "[VarBindingFilter a b] -\u003e VarBindingFilter a b",
          "source": "src/Swish-VarBinding.html#varFilterConjunction",
          "type": "function"
        },
        "index": {
          "description": "This function composes number of query binding filters into composite filter that accepts any query binding that satisfies all of the component values The same function could be achieved by composing the component filter-based modifiers but this function is more convenient as it avoids the need to check for modifier compatibility",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "varFilterConjunction",
          "normalized": "[VarBindingFilter a b]-\u003eVarBindingFilter a b",
          "package": "swish",
          "partial": "Filter Conjunction",
          "signature": "[VarBindingFilter a b]-\u003eVarBindingFilter a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:varFilterConjunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function composes a number of query binding filters\n  into a composite filter that accepts any query binding that\n  satisfies at least one of the component values.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "varFilterDisjunction",
          "package": "swish",
          "signature": "[VarBindingFilter a b] -\u003e VarBindingFilter a b",
          "source": "src/Swish-VarBinding.html#varFilterDisjunction",
          "type": "function"
        },
        "index": {
          "description": "This function composes number of query binding filters into composite filter that accepts any query binding that satisfies at least one of the component values",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "varFilterDisjunction",
          "normalized": "[VarBindingFilter a b]-\u003eVarBindingFilter a b",
          "package": "swish",
          "partial": "Filter Disjunction",
          "signature": "[VarBindingFilter a b]-\u003eVarBindingFilter a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:varFilterDisjunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures that\n  two indicated query variables are mapped to the same value.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "varFilterEQ",
          "package": "swish",
          "signature": "a -\u003e a -\u003e VarBindingFilter a b",
          "source": "src/Swish-VarBinding.html#varFilterEQ",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures that two indicated query variables are mapped to the same value",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "varFilterEQ",
          "normalized": "a-\u003ea-\u003eVarBindingFilter a b",
          "package": "swish",
          "partial": "Filter EQ",
          "signature": "a-\u003ea-\u003eVarBindingFilter a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:varFilterEQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function generates a query binding filter that ensures that\n  two indicated query variables are mapped to different values.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "varFilterNE",
          "package": "swish",
          "signature": "a -\u003e a -\u003e VarBindingFilter a b",
          "source": "src/Swish-VarBinding.html#varFilterNE",
          "type": "function"
        },
        "index": {
          "description": "This function generates query binding filter that ensures that two indicated query variables are mapped to different values",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "varFilterNE",
          "normalized": "a-\u003ea-\u003eVarBindingFilter a b",
          "package": "swish",
          "partial": "Filter NE",
          "signature": "a-\u003ea-\u003eVarBindingFilter a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:varFilterNE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "vbEnum",
          "package": "swish",
          "signature": "Set (a, b)",
          "source": "src/Swish-VarBinding.html#VarBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbEnum",
          "normalized": "Set(a,b)",
          "package": "swish",
          "partial": "Enum",
          "signature": "Set(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "vbMap",
          "package": "swish",
          "signature": "a -\u003e Maybe b",
          "source": "src/Swish-VarBinding.html#VarBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbMap",
          "normalized": "a-\u003eMaybe b",
          "package": "swish",
          "partial": "Map",
          "signature": "a-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "vbNull",
          "package": "swish",
          "signature": "Bool",
          "source": "src/Swish-VarBinding.html#VarBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbNull",
          "package": "swish",
          "partial": "Null",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "vbfName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-VarBinding.html#VarBindingFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbfName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbfName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "vbfTest",
          "package": "swish",
          "signature": "VarBinding a b -\u003e Bool",
          "source": "src/Swish-VarBinding.html#VarBindingFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbfTest",
          "normalized": "VarBinding a b-\u003eBool",
          "package": "swish",
          "partial": "Test",
          "signature": "VarBinding a b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbfTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Swish.VarBinding",
          "name": "vbfVocab",
          "package": "swish",
          "signature": "[a]",
          "source": "src/Swish-VarBinding.html#VarBindingFilter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbfVocab",
          "normalized": "[a]",
          "package": "swish",
          "partial": "Vocab",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbfVocab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply variable binding modifier to a\n  list of variable bindings, returning a\n  new list.  The result list is not\n  necessarily the same length as the\n  supplied list.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "vbmApply",
          "package": "swish",
          "signature": "[VarBinding a b] -\u003e [VarBinding a b]",
          "source": "src/Swish-VarBinding.html#VarBindingModify",
          "type": "function"
        },
        "index": {
          "description": "Apply variable binding modifier to list of variable bindings returning new list The result list is not necessarily the same length as the supplied list",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbmApply",
          "normalized": "[VarBinding a b]-\u003e[VarBinding a b]",
          "package": "swish",
          "partial": "Apply",
          "signature": "[VarBinding a b]-\u003e[VarBinding a b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbmApply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariable binding modifier compatibility test.\n\u003c/p\u003e\u003cp\u003eGiven a list of bound variables and a variable binding modifier, return\n  a list of new variables that may be bound, or \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote:  if the usage pattern component is well-formed (i.e. all\n  elements different) then at most one element can be compatible with\n  a given input variable set.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "vbmCompatibility",
          "package": "swish",
          "signature": "VarBindingModify a b -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Swish-VarBinding.html#vbmCompatibility",
          "type": "function"
        },
        "index": {
          "description": "Variable binding modifier compatibility test Given list of bound variables and variable binding modifier return list of new variables that may be bound or Nothing Note if the usage pattern component is well-formed i.e all elements different then at most one element can be compatible with given input variable set",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbmCompatibility",
          "normalized": "VarBindingModify a b-\u003e[a]-\u003eMaybe[a]",
          "package": "swish",
          "partial": "Compatibility",
          "signature": "VarBindingModify a b-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbmCompatibility"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose variable binding modifiers.\n\u003c/p\u003e\u003cp\u003eReturns \u003ccode\u003eJust a\u003c/code\u003e new variable binding modifier that corresponds to\n  applying the first supplied modifier and then applying the second\n  one, or \u003ccode\u003eNothing\u003c/code\u003e if the two modifiers cannot be compatibly composed.\n\u003c/p\u003e\u003cp\u003eNOTE:  this function does not, in general, commute.\n\u003c/p\u003e\u003cp\u003eNOTE:  if there are different ways to achieve the same usage, that\n  usage is currently repeated in the result returned.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "vbmCompose",
          "package": "swish",
          "signature": "VarBindingModify a b -\u003e VarBindingModify a b -\u003e Maybe (VarBindingModify a b)",
          "source": "src/Swish-VarBinding.html#vbmCompose",
          "type": "function"
        },
        "index": {
          "description": "Compose variable binding modifiers Returns Just new variable binding modifier that corresponds to applying the first supplied modifier and then applying the second one or Nothing if the two modifiers cannot be compatibly composed NOTE this function does not in general commute NOTE if there are different ways to achieve the same usage that usage is currently repeated in the result returned",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbmCompose",
          "normalized": "VarBindingModify a b-\u003eVarBindingModify a b-\u003eMaybe(VarBindingModify a b)",
          "package": "swish",
          "partial": "Compose",
          "signature": "VarBindingModify a b-\u003eVarBindingModify a b-\u003eMaybe(VarBindingModify a b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbmCompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eName used to identify this variable binding\n  modifier when building inference rules.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "vbmName",
          "package": "swish",
          "signature": "ScopedName",
          "source": "src/Swish-VarBinding.html#VarBindingModify",
          "type": "function"
        },
        "index": {
          "description": "Name used to identify this variable binding modifier when building inference rules",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbmName",
          "package": "swish",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbmName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of binding modifier usage patterns\n  supported.  Each pattern is characterized as\n  a list of variables for which new bindings\n  may be created by some application of this\n  modifier, assuming that bindings for all other\n  variables in \u003ccode\u003evbmVocab\u003c/code\u003e are supplied.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "vbmUsage",
          "package": "swish",
          "signature": "[[a]]",
          "source": "src/Swish-VarBinding.html#VarBindingModify",
          "type": "function"
        },
        "index": {
          "description": "List of binding modifier usage patterns supported Each pattern is characterized as list of variables for which new bindings may be created by some application of this modifier assuming that bindings for all other variables in vbmVocab are supplied",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbmUsage",
          "normalized": "[[a]]",
          "package": "swish",
          "partial": "Usage",
          "signature": "[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbmUsage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of variables used by this modifier.\n  All results of applying this modifier contain\n  bindings for these variables.\n\u003c/p\u003e",
          "module": "Swish.VarBinding",
          "name": "vbmVocab",
          "package": "swish",
          "signature": "[a]",
          "source": "src/Swish-VarBinding.html#VarBindingModify",
          "type": "function"
        },
        "index": {
          "description": "List of variables used by this modifier All results of applying this modifier contain bindings for these variables",
          "hierarchy": "Swish VarBinding",
          "module": "Swish.VarBinding",
          "name": "vbmVocab",
          "normalized": "[a]",
          "package": "swish",
          "partial": "Vocab",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish-VarBinding.html#v:vbmVocab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSwish:  Semantic Web Inference Scripting in Haskell\n\u003c/p\u003e\u003cp\u003eThis program is a simple skeleton for constructing Semantic Web [1]\n  inference tools in Haskell, using the RDF graph and several RDF\n  parsers (at present Notation 3 and NTriples).\n\u003c/p\u003e\u003cp\u003eIt might be viewed as a kind of embroyonic CWM [2] in Haskell,\n  except that the intent is that Haskell will be used as a primary\n  language for defining inferences.  As such, Swish is an open-ended\n  toolkit for constructing new special-purpose Semantic Web\n  applications rather than a closed, self-contained general-purpose\n  SW application.  As such, it is part of another experiment along\n  the lines described in [3].\n\u003c/p\u003e\u003cp\u003eThe script format used by Swish is described in\n  \u003ca\u003eSwish.Script\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eUsers wishing to process RDF data directly may prefer to look at\n  the following modules; \u003ca\u003eSwish.RDF\u003c/a\u003e, \u003ca\u003eSwish.RDF.Parser.Turtle\u003c/a\u003e,\n  \u003ca\u003eSwish.RDF.Parser.N3\u003c/a\u003e, \u003ca\u003eSwish.RDF.Parser.NTriples\u003c/a\u003e,\n  \u003ca\u003eSwish.RDF.Formatter.Turtle\u003c/a\u003e, \u003ca\u003eSwish.RDF.Formatter.N3\u003c/a\u003e\n  and \u003ca\u003eSwish.RDF.Formatter.NTriples\u003c/a\u003e.\n\u003c/p\u003e\u003col\u003e\u003cli\u003e Semantic web: \u003ca\u003ehttp://www.w3.org/2001/sw/\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e CWM:          \u003ca\u003ehttp://www.w3.org/2000/10/swap/doc/cwm.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Motivation:   \u003ca\u003ehttp://www.w3.org/2000/10/swap/doc/Motivation.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Notation 3:   \u003ca\u003ehttp://www.w3.org/TeamSubmission/2008/SUBM-n3-20080114/\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e Turtle:       \u003ca\u003ehttp://www.w3.org/TR/turtle/\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e RDF:          \u003ca\u003ehttp://www.w3.org/RDF/\u003c/a\u003e\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eNotes\n\u003c/p\u003e\u003cp\u003eI anticipate that this module may be used as a starting point for\n  creating new programs rather then as a complete program in its own\n  right.  The functionality built into this code is selected with a\n  view to testing the Haskell modules for handling RDF rather than\n  for performing any particular application processing (though\n  development as a tool with some broader utility is not ruled out).\n\u003c/p\u003e\u003cp\u003eWith the following in ghci:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e:m + Swish\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e:set prompt \"swish\u003e \"\n\u003c/code\u003e\u003c/strong\u003e\u003c/pre\u003e\u003cp\u003ethen we can run a Swish script (format described in \u003ca\u003eSwish.Script\u003c/a\u003e)\n by saying:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erunSwish \"-s=script.ss\"\n\u003c/code\u003e\u003c/strong\u003eExitSuccess\n\u003c/pre\u003e\u003cp\u003eor convert a file from Turtle to NTriples format with:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erunSwish \"-ttl -i=foo.ttl -nt -o=foo.nt\"\n\u003c/code\u003e\u003c/strong\u003eExitSuccess\n\u003c/pre\u003e\u003cp\u003eYou can also use \u003ccode\u003e\u003ca\u003evalidateCommands\u003c/a\u003e\u003c/code\u003e by giving it the individual commands,\n such as\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet Right cs = validateCommands [\"-ttl\", \"-i=file1.ttl\", \"-c=file2.ttl\"]\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecs\n\u003c/code\u003e\u003c/strong\u003e[SwishAction: -ttl,SwishAction: -i=file1.ttl,SwishAction: -c=file2.ttl]\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003est \u003c- runSwishActions cs\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003est\n\u003c/code\u003e\u003c/strong\u003eThe graphs do not compare as equal.\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Swish",
          "name": "Swish",
          "package": "swish",
          "source": "src/Swish.html",
          "type": "module"
        },
        "index": {
          "description": "Swish Semantic Web Inference Scripting in Haskell This program is simple skeleton for constructing Semantic Web inference tools in Haskell using the RDF graph and several RDF parsers at present Notation and NTriples It might be viewed as kind of embroyonic CWM in Haskell except that the intent is that Haskell will be used as primary language for defining inferences As such Swish is an open-ended toolkit for constructing new special-purpose Semantic Web applications rather than closed self-contained general-purpose SW application As such it is part of another experiment along the lines described in The script format used by Swish is described in Swish.Script Users wishing to process RDF data directly may prefer to look at the following modules Swish.RDF Swish.RDF.Parser.Turtle Swish.RDF.Parser.N3 Swish.RDF.Parser.NTriples Swish.RDF.Formatter.Turtle Swish.RDF.Formatter.N3 and Swish.RDF.Formatter.NTriples Semantic web http www.w3.org sw CWM http www.w3.org swap doc cwm.html Motivation http www.w3.org swap doc Motivation.html Notation http www.w3.org TeamSubmission SUBM-n3-20080114 Turtle http www.w3.org TR turtle RDF http www.w3.org RDF Notes anticipate that this module may be used as starting point for creating new programs rather then as complete program in its own right The functionality built into this code is selected with view to testing the Haskell modules for handling RDF rather than for performing any particular application processing though development as tool with some broader utility is not ruled out With the following in ghci Swish set prompt swish then we can run Swish script format described in Swish.Script by saying runSwish script.ss ExitSuccess or convert file from Turtle to NTriples format with runSwish ttl foo.ttl nt foo.nt ExitSuccess You can also use validateCommands by giving it the individual commands such as let Right cs validateCommands ttl file1.ttl file2.ttl cs SwishAction ttl SwishAction file1.ttl SwishAction file2.ttl st runSwishActions cs st The graphs do not compare as equal",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "Swish",
          "package": "swish",
          "partial": "Swish",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresent a Swish action. At present there is no way to create these\n actions other than \u003ccode\u003e\u003ca\u003evalidateCommands\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Swish",
          "name": "SwishAction",
          "package": "swish",
          "source": "src/Swish.html#SwishAction",
          "type": "data"
        },
        "index": {
          "description": "Represent Swish action At present there is no way to create these actions other than validateCommands",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "SwishAction",
          "package": "swish",
          "partial": "Swish Action",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#t:SwishAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatus of the processor\n\u003c/p\u003e",
          "module": "Swish",
          "name": "SwishStatus",
          "package": "swish",
          "source": "src/Swish-Monad.html#SwishStatus",
          "type": "data"
        },
        "index": {
          "description": "Status of the processor",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "SwishStatus",
          "package": "swish",
          "partial": "Swish Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#t:SwishStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite out the help for Swish\n\u003c/p\u003e",
          "module": "Swish",
          "name": "displaySwishHelp",
          "package": "swish",
          "signature": "IO ()",
          "source": "src/Swish.html#displaySwishHelp",
          "type": "function"
        },
        "index": {
          "description": "Write out the help for Swish",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "displaySwishHelp",
          "normalized": "IO()",
          "package": "swish",
          "partial": "Swish Help",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#v:displaySwishHelp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse and run the given string as if given at the command\n line. The \"quiet\", \"version\" and \"help\" options are\n ignored.\n\u003c/p\u003e",
          "module": "Swish",
          "name": "runSwish",
          "package": "swish",
          "signature": "String -\u003e IO ExitCode",
          "source": "src/Swish.html#runSwish",
          "type": "function"
        },
        "index": {
          "description": "Parse and run the given string as if given at the command line The quiet version and help options are ignored",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "runSwish",
          "normalized": "String-\u003eIO ExitCode",
          "package": "swish",
          "partial": "Swish",
          "signature": "String-\u003eIO ExitCode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#v:runSwish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute the given set of actions.\n\u003c/p\u003e",
          "module": "Swish",
          "name": "runSwishActions",
          "package": "swish",
          "signature": "[SwishAction] -\u003e IO SwishStatus",
          "source": "src/Swish.html#runSwishActions",
          "type": "function"
        },
        "index": {
          "description": "Execute the given set of actions",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "runSwishActions",
          "normalized": "[SwishAction]-\u003eIO SwishStatus",
          "package": "swish",
          "partial": "Swish Actions",
          "signature": "[SwishAction]-\u003eIO SwishStatus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#v:runSwishActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn any arguments that need processing immediately, namely                     \n the \"help\", \"quiet\" and \"version\" options.\n\u003c/p\u003e",
          "module": "Swish",
          "name": "splitArguments",
          "package": "swish",
          "signature": "[String] -\u003e ([String], [String])",
          "source": "src/Swish.html#splitArguments",
          "type": "function"
        },
        "index": {
          "description": "Return any arguments that need processing immediately namely the help quiet and version options",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "splitArguments",
          "normalized": "[String]-\u003e([String],[String])",
          "package": "swish",
          "partial": "Arguments",
          "signature": "[String]-\u003e([String],[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#v:splitArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of command-line arguments create the list of actions\n to perform or a string and status value indicating an input error.\n\u003c/p\u003e",
          "module": "Swish",
          "name": "validateCommands",
          "package": "swish",
          "signature": "[String] -\u003e Either (String, SwishStatus) [SwishAction]",
          "source": "src/Swish.html#validateCommands",
          "type": "function"
        },
        "index": {
          "description": "Given list of command-line arguments create the list of actions to perform or string and status value indicating an input error",
          "hierarchy": "Swish",
          "module": "Swish",
          "name": "validateCommands",
          "normalized": "[String]-\u003eEither(String,SwishStatus)[SwishAction]",
          "package": "swish",
          "partial": "Commands",
          "signature": "[String]-\u003eEither(String,SwishStatus)[SwishAction]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/swish/docs/Swish.html#v:validateCommands"
      }
    }
  ]
]